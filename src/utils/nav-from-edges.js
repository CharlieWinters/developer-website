/**
 * Convert an object used for generating the tree into an object
 * to be used in the UI.
 *
 * @param {Object} link - A link object that includes directories.
 * @param {string} link.url - The local path to the page.
 * @param {string} link.displayName - The title for the page.
 * @return {Object} A link object with just a url and displayName.
 */
const linkWithoutDirs = (link) => ({
  url: link.url,
  displayName: link.displayName,
});

/**
 * Creates a link object (including a list of directories) from an
 * edge (generated by GraphQL).
 *
 * @param {Object} edge - A markdown edge.
 * @return {Object} A link object that includes directories.
 */
const linkFromEdge = (edge) => {
  const { path, title } = edge?.node?.frontmatter;
  return {
    url: path,
    displayName: title,
    dirs: path.split('/').slice(1),
  };
};

/**
 * Converts a slug into a displayName.
 *
 * @param {string} str - A slug-like string.
 * @return {string} A displayName for use in the UI.
 */
const makeDisplayName = (str) =>
  str
    .split('-')
    .map((word) => word.replace(/\b\w/g, (l) => l.toUpperCase()))
    .join(' ');

/**
 * Function that compares two link objects and sorts by their displayNames.
 */
const sortByDisplayName = (a, b) => (a.displayName > b.displayName ? 1 : -1);

/**
 * Generates an array of links for the UI. Each link can have an
 * array of links below that. This function can call itself.
 *
 * @param {Object[]} links - An array of links that are >= this level.
 * @param {number} [level=0] The nested level.
 */
const genTree = (links, level = 0) => {
  const linksAtLevel = links.filter((link) => level === link.dirs.length - 1);

  // if we have nothing below this, just return a flat list of links
  if (linksAtLevel.length === links.length) {
    return linksAtLevel.map(linkWithoutDirs);
  }

  // get all the directories at this level (sorted alphabetically for now)
  const linksBelowLevel = links.filter((link) => level < link.dirs.length - 1);
  const dirsAtLevel = linksBelowLevel.map((link) => link.dirs[level]);
  const uniqueDirsAtLevel = [...new Set(dirsAtLevel)].sort();

  return uniqueDirsAtLevel.reduce((acc, dir) => {
    const linksUnderDir = links.filter((link) => link.dirs[level] === dir);

    // find the index page
    const index = linksAtLevel.find(
      (link) => link.dirs.length === level + 1 && link.dirs[level] === dir
    );

    // get the children for this node and sort them
    const childLinks = linksUnderDir
      .filter((link) => link !== index)
      .sort(sortByDisplayName);

    return [
      ...acc,
      {
        // add the index page, if it exists, or a placeholder title
        ...(index
          ? linkWithoutDirs(index)
          : { displayName: makeDisplayName(dir) }),
        // add the child links by calling this function again
        children: genTree(childLinks, level + 1),
      },
    ];
  }, []);
};

/**
 * Given a list of edges, generates the navigation to be used in the UI.
 *
 * @param {Object[]} edges - An array of edge objects.
 * @return {Object[]} An array of link objects.
 */
const getNavFromEdges = (edges) => {
  const links = edges.map(linkFromEdge);
  return genTree(links);
};

export default getNavFromEdges;
