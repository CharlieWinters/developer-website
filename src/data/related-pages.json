{
  "/build-apps/add-time-picker-guide": [
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-09-29T01:40:52Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-27T01:38:35Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 16 Days : 22 Hours : 10 Minutes : 8 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 20 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.01004,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add a <em>time</em> <em>picker</em> to your <em>app</em>",
        "body": " source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an <em>app</em> to show page view data on a map 20 min Add a <em>time</em> <em>picker</em> to your <em>app</em> Add a <em>time</em> <em>picker</em> to a sample application   Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps"
      ],
      "title": "Add tables to your New Relic One application",
      "type": "developer",
      "tags": [
        "table in app",
        "Table component",
        "TableHeaderc omponent",
        "TableHeaderCell component",
        "TableRow component",
        "TableRowCell component"
      ],
      "external_id": "7ff7a8426eb1758a08ec360835d9085fae829936",
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/",
      "published_at": "2020-09-29T01:47:51Z",
      "updated_at": "2020-09-17T01:48:42Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a table to your New Relic One app.",
      "body": "Add tables to your New Relic One application 30 min Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. git clone https://github.com/newrelic/nr1-how-to.git` cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet` Copy Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. nr1 nerdpack:uuid -gf # Update the app unique ID npm install # Install dependencies nr1 nerdpack:serve # Serve the demo app locally Copy Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the nerdlets/create-a-table-nerdlet subdirectory and open the index.js file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside of the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.35532,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add tables to your New Relic One <em>application</em>",
        "sections": "Add tables to your New Relic One <em>application</em>",
        "info": "Add a table to your New Relic One <em>app</em>.",
        "tags": "table in <em>app</em>",
        "body": " as shown in the example. export default class Nr1HowtoAdd<em>TimePicker</em> extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application Change the directory back to nr1-how-to&#x2F;create-a-table. Before you can load the demo"
      },
      "id": "5efa989ee7b9d2ad567bab51"
    },
    {
      "sections": [
        "Intro to New Relic One API components",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One API components",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2020-09-29T01:52:56Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One API components",
      "body": "Intro to New Relic One API components To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.399506,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic One <em>apps</em>",
        "body": ". They can be divided into these categories: <em>PlatformStateContext</em>: provides read access to the platform URL state variables. Example: <em>time</em>Range in the <em>time</em> <em>picker</em>. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Create a \"Hello, World!\" application",
        "Permissions for managing applications",
        "Set up your development environment",
        "Add, query, and mutate data using NerdStorage",
        "Add the NerdGraphQuery component to an application",
        "Add a time picker to your app",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps"
      ],
      "published_at": "2020-09-29T01:47:50Z",
      "title": "Build apps",
      "updated_at": "2020-09-25T01:49:59Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One   Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 20 min Add a time picker to your app Add a time picker to a sample application 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.63689,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add a <em>time</em> <em>picker</em> to your <em>app</em>",
        "body": " <em>app</em> Add a <em>time</em> <em>picker</em> to a sample application 30 min Add a table to your <em>app</em> Add a table to your New Relic One <em>app</em> 30 min Create a custom map view Build an <em>app</em> to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "category_2": "Explore data",
      "nodeid": 38956,
      "sections": [
        "Explore and query data",
        "Explore data",
        "Query builder",
        "Use charts",
        "Dashboards",
        "New Relic Query Language",
        "Introduction to the data explorer",
        "Why it matters",
        "Query your data",
        "Use the data explorer",
        "Visualize and refine your exploration",
        "Use cases",
        "For more help"
      ],
      "title": "Introduction to the data explorer",
      "category_0": "Query your data",
      "type": "docs",
      "category_1": "Explore and query data",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/query-your-data/explore-query-data/data-explorer/introduction-data-explorer",
      "external_id": "40ecc67e45ae77a881411e1e4210266345566d70",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/data_explorer_new.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/data-explorer/introduction-data-explorer",
      "published_at": "2020-09-29T01:46:59Z",
      "updated_at": "2020-09-29T01:46:59Z",
      "breadcrumb": "Contents / Query your data / Explore and query data / Explore data",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to New Relic One's data explorer, which lets you run custom queries of your data, build charts and other visualizations, and share with others.",
      "body": "With the data explorer you can navigate all your data visually, without any​​​ NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Want to switch to New Relic One from Insights? See our transition guide. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Query your data To access the data explorer, go to one.newrelic.com and at the top of the page, click the Query your data icon. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces apps to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count(*), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Need to do more advanced searches or customize your charts? From data explorer you can access query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data - by clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.51538,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " or event) you want to browse. Select the <em>time</em> range using the <em>time</em> <em>picker</em>. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available"
      },
      "id": "5f2308db196a674fb6b53cce"
    }
  ],
  "/build-apps/add-query-mutate-data-nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Create a \"Hello, World!\" application",
        "Permissions for managing applications",
        "Set up your development environment",
        "Add, query, and mutate data using NerdStorage",
        "Add the NerdGraphQuery component to an application",
        "Add a time picker to your app",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps"
      ],
      "published_at": "2020-09-29T01:47:50Z",
      "title": "Build apps",
      "updated_at": "2020-09-25T01:49:59Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One   Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 20 min Add a time picker to your app Add a time picker to a sample application 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 327.50458,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em>",
        "body": "   Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 45 min <em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em> <em>NerdStorage</em> is a document database accessible within New Relic One"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-09-08T01:50:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users's configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { 'YourNerdpackUuid': { 'collection-1': { 'document-1-of-collection-1': '{\"lastNumber\": 42, \"another\": [1]}', 'document-2-of-collection-1': '\"userToken\"', // ... }, 'another-collection': { 'fruits': '[\"pear\", \"apple\"]', // ... }, // ... }, } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.08655,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>NerdStorage</em>",
        "sections": "Intro to <em>NerdStorage</em>",
        "info": "Intro to <em>NerdStorage</em> on New Relic One",
        "tags": "<em>nerdstorage</em>",
        "body": " document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of <em>data</em> associated with it. <em>Data</em> associated with a document: <em>NerdStorage</em> accepts any sort of <em>data</em> associated to a documentId. <em>Query</em> and mutation components that are provided work by serializing"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-09-29T01:52:56Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Copy Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.33788,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching <em>data</em> from your laptop while troubleshooting an issue, or adding New Relic into your CI&#x2F;CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "Query and store data",
        "Components overview",
        "Query components",
        "Mutation components",
        "Static methods",
        "NrqlQuery"
      ],
      "title": "Query and store data",
      "type": "developer",
      "tags": [
        "nerdgraph query components",
        "mutation components",
        "static methods"
      ],
      "external_id": "cbbf363393edeefbc4c08f9754b43d38fd911026",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/query-and-store-data/",
      "published_at": "2020-09-29T01:52:56Z",
      "updated_at": "2020-08-01T01:42:02Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Reference guide for SDK query components using NerdGraph",
      "body": "Query and store data 10 min To help you build a New Relic One application, we provide you with the New Relic One SDK. Here you can learn how to use the SDK query components, which allow you to make queries and mutations via NerdGraph, our GraphQL endpoint. Query-related React components can be identified by the Query suffix. Mutation-related components can be identified by the Mutation prefix. Components overview Our data components are based on React Apollo. The most basic component is NerdGraphQuery, which accepts any GraphQL (or GraphQL AST generated by the graphql-tag library as the query parameter, and a set of query variables passed as variables. Over this query, we have created an additional set of queries, which can be divided into four groups: User queries: These allow you to query the current user and its associated accounts. Components in this category: UserStorageQuery and AccountsQuery. Entities queries: Because New Relic One is entity-centric, we use queries to make access to your entities easier. You can count, search, list, query, and favorite them. Components in this category: EntityCountQuery, EntitySearchQuery, EntitiesByDomainTypeQuery, EntitiesByGuidsQuery, EntityByGuidQuery, EntityByNameQuery. Storage queries: New Relic One provides a simple storage mechanism that we call NerdStorage. This can be used by Nerdpack creators to store application configuration setting data, user-specific data, and other small pieces of data. Components in this category: UserStorageQuery, AccountStorageQuery, EntityStorageQuery, UserStorageMutation, AccountStorageMutation, and EntityStorageMutation. For details, see NerdStorage. NRQL queries: To be able to query your New Relic data via NRQL (New Relic Query Language), we provide a NrqlQuery component. This component can return data in different formats, so that you can use it for charting and not only for querying. Query components All query components accept a function as a children prop where the different statuses can be passed. This callback receives an object with the following properties: loading: Boolean that is set to true when data fetching is happening. Our components use the cache-and-network strategy, meaning that after the data has loaded, subsequent data reloads might be triggered first with stale data, then refreshed when the most recent data has arrived. data: Root property where the data requested is retrieved. The structure matches a root structure based on the NerdGraph schema. This is true even for highly nested data structures, which means you’ll have to traverse down to find the desired data. error: Contains an Error instance when the query fails. Set to undefined when data is loading or the fetch was successful. fetchMore: Callback function that can be called when the query is being loaded in chunks. The function will only be present when it’s feasible to do so, more data is available, and no fetchMore has already been triggered. Data is loaded in batches of 200 by default. Other components provided by the platform (like the Dropdown or the List) are capable of accepting fetchMore, meaning you can combine them easily. Mutation components Mutation components also accept a children as a function, like the query ones. The mutation can be preconfigured at the component level, and a function is passed back that you can use in your component. This is the standard React Apollo approach for performing mutations, but you might find it easier to use our static mutation method added to the component. More on this topic below. Static methods All of the described components also expose a static method so that they can be used imperatively rather than declaratively. All Query components have a static Query method, and all Mutation components have a mutation method. These static methods accept the same props as their query component, but passed as an object. For example: // Declarative way (using components). function renderAccountList() { return ( <ul> <AccountsQuery> ({data, error}) => { if (error) { return <li>Failed to retrieve list: {error.message}</li>; } return data.map((account) => { <li key={account.id}>{account.name}</li> }); }} </AccountsQuery> </ul> ); } // Imperative way (using promises). async function getAccountList() { let data = {}; try { data = await AccountsQuery.query(); } catch (error) { console.log('Failed to retrieve list: ' + error.message); return; } return data.actor.accounts.map((account) => { return account.name; }); } Copy Similarly, a mutation can happen either way; either declaratively or imperatively. NrqlQuery NrqlQuery deserves additional explanation, because there are multiple formats in which you can return data from it. To provide maximum functionality, all three are exposed through a formatType property. You can find its different values under NrqlQuery.formatType: NERD_GRAPH: Returns the format in which it arrives from NerdGraph. RAW: The format exposed by default in Insights and dashboards when being plotted as JSON. This format is useful if you have a pre-existing script in this format that you're willing to migrate to or incorporate with. CHART: The format used by the charting engine that we also expose. You can find a more detailed explanation of how to manipulate this format in the guide to chart components, and some examples. If you are willing to push data, we currently do not expose NrqlMutation. To do that, see the Event API for how to add custom events.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.041245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> and store <em>data</em>",
        "sections": "<em>Query</em> and store <em>data</em>",
        "info": "Reference guide for SDK <em>query</em> components using NerdGraph",
        "tags": "nerdgraph <em>query</em> components",
        "body": ", EntityByGuid<em>Query</em>, EntityByName<em>Query</em>. Storage queries: New Relic One provides a simple storage mechanism that we call <em>NerdStorage</em>. This can be used by Nerdpack creators to store application configuration setting <em>data</em>, user-specific <em>data</em>, and other small pieces of <em>data</em>. Components in this category"
      },
      "id": "5efa989e28ccbc2f15307deb"
    },
    {
      "image": "https://opensource.newrelic.com/static/New_Relic_One_Catalog_Project-044e387f68b03896ff65f46edcffb1f3.png",
      "url": "https://opensource.newrelic.com/oss-category/",
      "sections": [
        "Categories",
        "Community Project",
        "Requirements",
        "Community Plus",
        "New Relic One Catalog",
        "Example Code",
        "New Relic Experimental",
        "Archived"
      ],
      "published_at": "2020-09-29T01:54:26Z",
      "title": "New Relic Open Source Categories",
      "updated_at": "2020-09-02T02:08:45Z",
      "type": "opensource",
      "external_id": "87c1876d27bdde7fb6636382fb5e659ae47c496a",
      "document_type": "page",
      "popularity": 1,
      "info": "",
      "body": "New Relic Open Source External Projects Highlighted Projects New Relic Projects Menu External Projects Highlighted Projects New Relic Projects Categories Community Project Community Plus New Relic One Catalog Example Code New Relic Experimental Archived For the code snippets that appear in the project's README file, see this documentation. Community Project This code is developed in the open with input from the community through issues and PRs. There is an active maintainer team within New Relic, troubleshooting support in the New Relic Explorers Hub, and the documentation is available in the project repository. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Has active maintainer / maintainers, including at least one Relic Troubleshooting support via the New Relic Explorers Hub Issues and PR’s managed in GitHub Documentation reviewed by the New Relic documentation team Linted code An automated release pipeline Community Plus This code is developed in the open with input from the community through issues and PRs. A New Relic engineering team serves as the maintainer. Troubleshooting support is available in the New Relic Explorers Hub, and documentation is available in the project repository and docs.newrelic.com. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Is maintained by a New Relic engineering team Troubleshooting support via the New Relic Explorers Hub Issues and PR’s managed in GitHub For additional details on support options, see the Open Source Support Policy Documentation reviewed by the New Relic documentation team Linted code An automated release pipeline New Relic One Catalog This code is a part of the New Relic One Catalog. It meets the criteria for a Community Project; but it also contains UI workflows for configuration. Most Catalog projects seek to maintain a public roadmap, often expressed in a GitHub Project board and Issues within the repository. Requirements All the requirements of a Community Project An empty state application workflow that guides users through the setup of configuration data that is stored in NerdStorage Architectural review (including UX) by New Relic (Optional) maintains a public roadmap (recommended via a GitHub project in the repo) Example Code This code demonstrates an aspect of building on the New Relic One platform. Find the complete description of its usage and other relevant docs in the README. There is no long-term maintainer for this code nor is support provided, but the author(s) may address future updates / needs as platform features change. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file (optional) Issues are available at the project author's discretion Documentation reviewed by the New Relic documentation team Linted code New Relic Experimental This code solves an interesting problem but does not yet have an active maintainer(s). The project is being developed in the open for the purpose of feedback on a new feature or function. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Typically hosted in the New Relic Experimental GitHub org (Optional) Issues at the project owner's discertion Archived This code is read-only. There is neither a maintainer team nor support. Requirements Complies with New Relic's legal requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Previous references to Support should be modified or removed from the README Project is read-only and available for cloning only New Relic Open Source Standards External Projects Highlighted Projects New Relic Projects Create an issue Copyright © 2020 New Relic Inc.Version 1.9.2",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.55703,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " a public roadmap, often expressed in a GitHub Project board and Issues within the repository. Requirements All the requirements of a Community Project An empty state application workflow that guides users through the setup of configuration <em>data</em> that is stored in <em>NerdStorage</em> Architectural review (including"
      },
      "id": "5f31822228ccbc916988dff8"
    }
  ],
  "/terms": [
    {
      "category_2": "Data privacy",
      "nodeid": 1591,
      "sections": [
        "Security and Privacy",
        "Data privacy",
        "Compliance",
        "Information security",
        "Security bulletins",
        "Security controls for privacy",
        "Secured content",
        "Analytics",
        "Data transmission and firewalls",
        "Hosting and data storage",
        "Data access",
        "HTTP parameters disabled by default",
        "For more help"
      ],
      "title": "Security controls for privacy",
      "category_0": "New Relic Security and Privacy",
      "type": "docs",
      "category_1": "Security and Privacy",
      "external_id": "bc8220cf6b971d3e72dbcd38b006d799a1041cd3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/data-privacy/security-controls-privacy",
      "published_at": "2020-09-28T02:13:37Z",
      "updated_at": "2020-09-24T07:44:02Z",
      "breadcrumb": "Contents / New Relic Security and Privacy / Security and Privacy / Data privacy",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic data security: content, analytics, transmission, hosting and storage, data access, etc. For complete details, see https://newrelic.com/security",
      "body": "This document describes how New Relic protects the security of your data. For more information about our security measures, see our data privacy documentation and the New Relic Security website. Secured content Data for New Relic accounts are isolated so that users can only see the data for accounts they own (or have been given permission to see). New Relic also has certain rights regarding customers' data, described in the Terms and Conditions page on the New Relic website. Analytics In order to help us improve our product and user experience, New Relic uses third-party analytics services to better understand the behavior of users on our site. The user data that New Relic collects is used solely by New Relic and is not shared, sold, or rented to any third parties for their own use. For more information, see our Services data privacy notice. Data transmission and firewalls The New Relic agent communicates with two hosts: collector.newrelic.com collector-nnn.newrelic.com, where nnn is a numerical value Typically the numbered host is fixed for your account, and it appears in log/newrelic.agent.log. For required changes when you want to create firewall rules to allow the agent to communicate, see Networks. For more information about security measures for your data in transit to New Relic or at rest in our storage, see Data encryption. Hosting and data storage New Relic is self-hosted with co-location services called Server Central in a Tier 3 data center in Chicago, Illinois and an IBM-hosted data center near Frankfurt, Germany, as well as cloud storage through Amazon AWS. We use standard best practices to maintain a firewall for our servers and to protect our servers from unauthorized login. All data is stored in a cluster of MySQL databases. New Relic data is backed up nightly, and an archive is stored at a secondary data center. Data access Access to account data by New Relic employees is limited to a necessary set of users consistent with their assigned New Relic responsibilities. Except to the extent necessary to provide subscribed services and as documented in our Services data privacy notice, customer account data is not shared with any third parties. All customer account data access is logged and regularly audited. HTTP parameters disabled by default By default, New Relic agents disable collection of HTTP request parameters, such as the query string of a URL. This is an automatic safeguard to protect potentially sensitive data. New Relic collects and displays HTTP parameters only when you explicitly enable them in your agent configuration file. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 390.9984,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Security <em>and</em> Privacy",
        "info": "New Relic data security: content, analytics, transmission, hosting <em>and</em> storage, data access, etc. For complete details, see https:&#x2F;&#x2F;newrelic.com&#x2F;security",
        "category_0": "New Relic Security <em>and</em> Privacy",
        "category_1": "Security <em>and</em> Privacy",
        "body": " for accounts they own (or have been given permission to see). New Relic also has certain rights regarding customers&#x27; data, described in the <em>Terms</em> and <em>Conditions</em> page on the New Relic website. Analytics In order to help us improve our product and user experience, New Relic uses third-party analytics services"
      },
      "id": "5e30b8a864441f47ebd05cb0"
    },
    {
      "category_2": "Product definitions",
      "nodeid": 39646,
      "sections": [
        "License information",
        "General usage licenses",
        "Special services licenses",
        "Distributed licenses",
        "Referenced policies",
        "Product definitions",
        "Usage plans",
        "FAQ",
        "New Relic One pricing: Definitions",
        "For more help"
      ],
      "title": "New Relic One pricing: Definitions",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "License information",
      "external_id": "097fc095ef18942f3af1845237742340e36416b8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/license-information/product-definitions/new-relic-one-pricing-definitions",
      "published_at": "2020-09-27T19:07:42Z",
      "updated_at": "2020-09-10T14:58:10Z",
      "breadcrumb": "Contents / Licenses / License information / Product definitions",
      "document_type": "page",
      "popularity": 1,
      "info": "This document provides definitions of terminology you may see in New Relic contracts.",
      "body": "This document provides definitions of terminology you may see in the Terms or this site for New Relic One pricing and billing: Account Account refers to the online account or subaccounts that New Relic provides for customers to manage their use of the Products. Commitment Term Commitment Term means the non-cancelable, committed Subscription Term for the Products. Customer Data Customer Data means the data, information, or content that Customer and its users send to an Account from the Software, the Customer Properties, or Third-Party Services. Customer Properties Customer Properties means Customer’s websites, infrastructure, networks, mobile applications, or other systems, as well as Customer accounts on Third-Party Services. Documentation Documentation means the New Relic technical guides and documentation made available from the dedicated ‘Documentation’ page of the New Relic website. GB Ingested A GB Ingested is a measurement of the volume of metrics, events, logs, traces, or other telemetry data sent to or generated by the Products for the benefit of the Customer, including from the Software, the Customer Properties, or Third-Party Services. In this context, a GB is defined as 1 billion bytes. Login Credentials Login Credentials means the username, email address, password, or other personal information that is provided by a Customer user in order to manage an Account. Monthly Provisioned User A Monthly Provisioned User is any user who can log into Customer’s Account(s) and access the New Relic One Product functionality as specified in an Order and the Documentation. Order Order means the purchasing order for access to the Service or related services that: (1) is either executed by the Parties or entered into by you via self-service, and references this Agreement, or (2) is entered into by you and a Channel Partner. Paid Terms of Service Paid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/paid. Product(s) Product(s) mean the purchase of the New Relic subscription products described in the applicable Order and any updates, corrections, bug fixes, modifications, improvements, related services, new features, and functionality (made generally available to New Relic’s customer base) thereto. Software Software means the distributed software, APIs, scripts, or other code proprietary to New Relic provided with the Products. Terms Terms means the underlying Customer-New Relic agreement and the Order. Third-Party Services Third-Party Services means any third party platform, add-on, service, or product not provided by New Relic and that a user integrates or enables for use with the Products, including third-party applications and plug-ins. Unpaid Terms of Service Unpaid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/unpaid. Usage Plan Usage Plan refers to the Service or Product pricing, invoicing related information, and product-specific terms (e.g. concurrent user account sessions) contained within the Documentation. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 374.86066,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "This document provides definitions of <em>terminology</em> you may see in New Relic contracts.",
        "body": "This document provides definitions of terminology you may see in the <em>Terms</em> or this site for New Relic One pricing and billing: Account Account refers to the online account or subaccounts that New Relic provides for customers to manage their use of the Products. Commitment <em>Term</em> Commitment <em>Term</em> means"
      },
      "id": "5f23b039196a67030b94f5c4"
    },
    {
      "image": "",
      "url": "https://opensource.newrelic.com/cla/",
      "sections": [
        "NEW RELIC, INC.",
        "INDIVIDUAL CONTRIBUTOR LICENSE AGREEMENT",
        "Definitions."
      ],
      "published_at": "2020-09-29T01:54:26Z",
      "title": "New Relic Open Source Contributor License Agreement",
      "updated_at": "2020-09-02T02:08:45Z",
      "type": "opensource",
      "external_id": "478151b2a97835e82c3cd1eaa49610793dc56783",
      "document_type": "page",
      "popularity": 1,
      "info": "",
      "body": "New Relic Open Source External Projects Highlighted Projects New Relic Projects Menu External Projects Highlighted Projects New Relic Projects NEW RELIC, INC. INDIVIDUAL CONTRIBUTOR LICENSE AGREEMENT Thank you for your interest in contributing to the open source projects of New Relic, Inc. (“New Relic”). In order to clarify the intellectual property license granted with Contributions from any person or entity, New Relic must have a Contributor License Agreement (\"Agreement\") on file that has been signed by each Contributor, indicating agreement to the license terms below. This Agreement is for your protection as a Contributor as well as the protection of New Relic; it does not change your rights to use your own Contributions for any other purpose. You accept and agree to the following terms and conditions for Your present and future Contributions submitted to New Relic. Except for the licenses granted herein to New Relic and recipients of software distributed by New Relic, You reserve all right, title, and interest in and to Your Contributions. Definitions. \"You\" (or \"Your\") shall mean the copyright owner or legal entity authorized by the copyright owner that is entering into this Agreement with New Relic. For legal entities, the entity making a Contribution and all other entities that control, are controlled by, or are under common control with that entity are considered to be a single Contributor. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"Contribution\" shall mean any original work of authorship, including any modifications or additions to an existing work, that is intentionally submitted by You to New Relic for inclusion in, or documentation of, any of the products managed or maintained by New Relic (the \"Work\"). For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to New Relic or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, New Relic for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by You as \"Not a Contribution.\" Grant of Copyright License. Subject to the terms and conditions of this Agreement, You hereby grant to New Relic and to recipients of software distributed by New Relic a perpetual, worldwide, non-exclusive, no-charge, royalty-free, transferable, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense, and distribute Your Contributions and such derivative works. Grant of Patent License. Subject to the terms and conditions of this Agreement, You hereby grant to New Relic and to recipients of software distributed by New Relic a perpetual, worldwide, non-exclusive, no-charge, royalty-free, transferable, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by You that are necessarily infringed by Your Contributions alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that Your Contribution, or the Work to which You have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the date such litigation is filed. You represent that You are legally entitled to grant the above licenses. If Your employer(s) has rights to intellectual property that You create that includes Your Contributions, You represent that You have received permission to make Contributions on behalf of that employer, that Your employer has waived such rights for Your Contributions to New Relic, or that Your employer has executed a separate Agreement with New Relic. You represent that each of Your Contributions is Your original creation (see section 7 for submissions on behalf of others). You represent that Your Contribution submissions include complete details of any third-party license or other restriction (including, but not limited to, related patents and trademarks) of which You are personally aware and which are associated with any part of Your Contributions. You are not expected to provide support for Your Contributions, except to the extent You desire to provide support. You may provide support for free, for a fee, or not at all. Unless required by applicable law or agreed to in writing, You provide Your Contributions on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON- INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. Should You wish to submit work that is not Your original creation, You may submit it to New Relic separately from any Contribution, identifying the complete details of its source and of any license or other restriction (including, but not limited to, related patents, trademarks, and license agreements) of which You are personally aware, and conspicuously marking the work as \"Submitted on behalf of a third-party: [named here] \". You agree to notify New Relic of any facts or circumstances of which You become aware that would make these representations inaccurate in any respect. New Relic Open Source Standards External Projects Highlighted Projects New Relic Projects Edit this page Create an issue Copyright © 2020 New Relic Inc.Version 1.9.2",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.9119,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is for your protection as a Contributor as well as the protection of New Relic; it does not change your rights to use your own Contributions for any other purpose. You accept and agree to the following <em>terms</em> and <em>conditions</em> for Your present and future Contributions submitted to New Relic. Except"
      },
      "id": "5f31822264441fcbe056a984"
    },
    {
      "category_2": "Developer Edition",
      "nodeid": 39641,
      "sections": [
        "Product or service licenses",
        "New Relic One",
        "APM",
        "Browser",
        "Developer Edition",
        "Infrastructure",
        "Insights",
        "Logs",
        "Mobile",
        "Synthetics",
        "Mobile apps",
        "Plugins",
        "Miscellaneous",
        "Developer Program Resources",
        "For more help"
      ],
      "title": "Developer Program Resources",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "Product or service licenses",
      "external_id": "98308cfffa652e4c25967e1be5b848b9c28ca410",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-developer-edition/developer-program-resources",
      "published_at": "2020-09-27T19:06:32Z",
      "updated_at": "2020-08-08T19:17:02Z",
      "breadcrumb": "Contents / Licenses / Product or service licenses / Developer Edition",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic Developer edition policy",
      "body": "As a customer, you are eligible to participate in New Relic’s Developer Program. Additional information and resources are available at New Relic’s Developer Program site. By downloading, accessing, or using the developer resources (including the CLI), you agree that usage of the developer resources is pursuant to the New Relic Developers Terms and Conditions and that you have the authority to bind your organization. Such terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not use these developer resources. If your use of the New Relic developer resources are covered under a separate agreement, the above does not apply to you. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 349.9709,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is pursuant to the New Relic Developers <em>Terms</em> and <em>Conditions</em> and that you have the authority to bind your organization. Such <em>terms</em> do not have to be signed in order to be binding. If you do not agree to these <em>terms</em> and <em>conditions</em>, your sole remedy is to not use these developer resources. If your"
      },
      "id": "5f338507e7b9d2f670c9de83"
    },
    {
      "category_2": "New Relic One",
      "nodeid": 39366,
      "sections": [
        "Product or service licenses",
        "New Relic One",
        "APM",
        "Browser",
        "Developer Edition",
        "Infrastructure",
        "Insights",
        "Logs",
        "Mobile",
        "Synthetics",
        "Mobile apps",
        "Plugins",
        "Miscellaneous",
        "Preview access for New Relic One",
        "For more help"
      ],
      "title": "Preview access for New Relic One",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "Product or service licenses",
      "external_id": "eae3865081d3bd8ad2dd8b6eaf0fe0147355360c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-one/preview-access-new-relic-one",
      "published_at": "2020-09-27T18:56:05Z",
      "updated_at": "2020-07-31T04:41:27Z",
      "breadcrumb": "Contents / Licenses / Product or service licenses / New Relic One",
      "document_type": "page",
      "popularity": 1,
      "body": "As a customer with a paid subscription to New Relic products, you are eligible to participate in preview access of the New Relic One platform (e.g. Telemetry Data Platform, Full Stack Observability, and Applied Intelligence products) for the period beginning July 31, 2020 and ending December 31, 2020 (“Preview Access”). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE TERMS AND CONDITIONS IN LIEU OF ANY OTHER TERMS. These terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not participate in Preview Access. New Relic reserves the right to terminate or restrict Preview Access, in whole or in part, at any time. Notwithstanding the foregoing and any other materials provided by New Relic, select customers are ineligible for the Preview Access. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 340.4483,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", 2020 (“Preview Access”). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE <em>TERMS</em> AND <em>CONDITIONS</em> IN LIEU OF ANY OTHER <em>TERMS</em>. These <em>terms</em> do not have to be signed in order to be binding"
      },
      "id": "5f23a0f7e7b9d29da9c82305"
    }
  ],
  "/explore-docs/nr1-common": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 223.65668,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " extension to build your apps. <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em> This table provides descriptions for the <em>New</em> <em>Relic</em> <em>One</em> <em>commands</em>. For more context, including usage and option details, click any individual <em>command</em> or the <em>command</em> category. For details on user permissions, see Authentication and permissions"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-09-29T01:52:56Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Copy Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.06044,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-09-29T01:40:52Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-27T01:38:35Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 16 Days : 22 Hours : 10 Minutes : 8 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 20 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.25656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " source APIs, agents, OS emitters - get any data 20 min Automate <em>common</em> tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Set up New Relic using Helm charts",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Set up New Relic using Terraform"
      ],
      "published_at": "2020-09-29T01:47:50Z",
      "title": "Automate workflows",
      "updated_at": "2020-09-25T01:49:59Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 20 min Set up New Relic using Terraform Learn how to provision New Relic resources using Terraform",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.45544,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using Helm charts",
        "body": " CloudFormation, and a <em>command</em>-line interface. These tools enable you to integrate <em>New</em> <em>Relic</em> into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and <em>CLI</em> guides below, find more automation"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-09-29T01:48:49Z",
      "updated_at": "2020-08-26T01:47:20Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.541695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": "Set up your development environment 20 min If you&#x27;ve decided to build a custom app or modify <em>one</em> of our open source apps, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> <em>command</em> line interface (<em>CLI</em>) An API key, which you get when you download the <em>CLI</em> Depending on what you want to do with your app"
      },
      "id": "5efa9973e7b9d242237bab39"
    }
  ],
  "/automate-workflows/automated-tagging": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Set up New Relic using Helm charts",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Set up New Relic using Terraform"
      ],
      "published_at": "2020-09-29T01:47:50Z",
      "title": "Automate workflows",
      "updated_at": "2020-09-25T01:49:59Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 20 min Set up New Relic using Terraform Learn how to provision New Relic resources using Terraform",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.38364,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Automate</em> workflows",
        "sections": "<em>Automatically</em> <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em>",
        "body": " solutions in our Developer Toolkit. Guides to <em>automate</em> workflows 5 min Quickly <em>tag</em> resources Add tags to apps for easy filtering 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 30 min Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em> See how easy"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Measure DevOps success",
      "nodeid": 34966,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "2. Take advantage of integrations and existing tools",
        "3. Leverage the power of APIs",
        "For more help"
      ],
      "title": "Automate instrumentation",
      "category_0": "New Relic solutions",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "91b25e8572d235c7f95963650848fc6ab6cf4b39",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/NRCLItool.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation",
      "published_at": "2020-09-28T01:04:03Z",
      "updated_at": "2020-09-28T01:04:02Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "Capture tangible, measurable metrics from before and after deployments to optimize your DevOps team. ",
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Read this Best Practices post for more information about automating instrumentation in your pipeline 2. Take advantage of integrations and existing tools It’s always worth taking a little extra time to look for time-saving integrations and tools that can help to achieve your automation goals. For example, you can use IBM’s open-sourced New Relic CLI (command line interface) tool to automate a variety of tasks, such as managing New Relic Synthetics monitors; creating, editing, and deleting New Relic Alerts policies and conditions; and managing user accounts. Use IBM's New Relic CLI tool to manage your Synthetics monitors, alert policies, and user accounts. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.29369,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Automate</em> instrumentation",
        "sections": "<em>Automate</em> instrumentation",
        "info": "Capture tangible, measurable metrics from before and after deployments to optimize <em>your</em> DevOps team. ",
        "body": " It’s always worth taking a little extra time to look for time-saving integrations and tools that can help to achieve <em>your</em> automation goals. For example, you can use IBM’s open-sourced New Relic CLI (command line interface) tool to <em>automate</em> a variety of tasks, such as managing New Relic Synthetics"
      },
      "id": "5f5e0c14196a67e25fce6a8a"
    },
    {
      "category_2": "Optimize your cloud native environment",
      "nodeid": 32781,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Adopt cloud services",
        "1. Identify services and technologies",
        "2. Deploy New Relic Infrastructure",
        "3. Configure cloud integrations",
        "4. Track data on your dashboards",
        "5. Add alerts for cloud-based metrics",
        "6. Set up additional monitoring",
        "7. CI/CD pipeline integration",
        "8. AWS Lambda Monitoring",
        "For more help"
      ],
      "title": "Adopt cloud services",
      "category_0": "New Relic solutions",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "182e7d7d0302bc861c09bb94e5a0773bef131e6c",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/adopt_cloud.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/adopt-cloud-services",
      "published_at": "2020-09-27T20:33:59Z",
      "updated_at": "2020-09-27T20:33:59Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Optimize your cloud native environment",
      "document_type": "page",
      "popularity": 1,
      "info": "Use the New Relic Platform to monitor your modern technologies and cloud services.",
      "body": "Whether you've recently completed your cloud migration, have been using cloud-based services for a while, or have always been in the cloud, you may find yourself deploying modern, cutting-edge technologies and services. It's important to develop the ability to adopt new services easily and with confidence; innovation never stops for companies operating in the cloud, and a company's willingness to embrace new technology can give it a major competitive differentiator. These modern technologies could be container solutions such as Docker, Kubernetes, and Amazon AWS ECS or Fargate, for example. Or they could be serverless services such as AWS Lambda, Microsoft Azure, or Google Cloud Platform Functions. They may be cloud-based databases, or any number of cloud services that abstract the service away from an operations-maintained infrastructure. In these situations, you want to monitor, query, and alert on the performance and usage metrics for both modern technologies and cloud-based services. This allows your team to deploy faster, to adopt new services with confidence, to make better business decisions, and in general to expand its technology horizons. Here are the steps to using the New Relic Platform to monitor your modern technologies and cloud services: 1. Identify services and technologies Determine the components you need to monitor by answering the following questions: What cloud-based applications do I have? What are the underlying cloud-based services, technologies, and infrastructure supporting those applications? When you have a full understanding of your architecture, you reduce the possibility of missing dependencies and new services that might impact your organization's application environment. 2. Deploy New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, install the Infrastructure agent on the hosts you identified in Step One so that you can monitor your cloud services. If you use Ansible, Chef, or Puppet for automation, you can use those tools to deploy Infrastructure agents to your hosts. 3. Configure cloud integrations As you integrate new cloud services, you can use New Relic to monitor and report data about these services; giving you a single, comprehensive overview of your entire architecture. To configure cloud service integrations, link your Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) service provider account with New Relic. 4. Track data on your dashboards New Relic Infrastructure integrations auto-populate dashboards with metrics from cloud providers like AWS, Azure, and GCP so you can track the data that is critical to your cloud adoption success. If you adopt a hybrid cloud of multiple cloud providers, New Relic can provide a holistic perspective that is agnostic to cloud providers. AWS EC2 monitoring integration dashboard In this default dashboard for the AWS EC2 monitoring integration, New Relic captures metrics for EC2 instances per region, instance state, and instance type. The dashboard also shows inventory for different software packages and configurations that are installed on those instances. infrastructure.newrelic.com > Integrations > Amazon Web Services: View AWS EC2 data on the default dashboard for the AWS EC2 monitoring integration. Azure VMs monitoring integration dashboard The default Azure virtual machine integration dashboard shows data for VM sizes, VMs per region, and VMs per resource group. infrastructure.newrelic.com > Integrations > Microsoft Azure: View Azure virtual machine data on the default dashboard for the Azure VMs monitoring integration. GCP Compute Engine monitoring integration dashboard In this default dashboard for the Google Cloud Platform, New Relic captures metrics for instances per zone, instance status, firewall dropped packets, reserved cores, and disk throttled operations. The dashboard also shows inventory for different software packages and configurations that are installed on those instances. infrastructure.newrelic.com > Integrations > Google Cloud Platform: View GCP Compute Engine data on the default dashboard for the GCP Compute Engine monitoring integration. Example modern and cloud services dashboard In this example dashboard, three different cloud vendors, modern technologies, cloud services, infrastructure instance locations, and DevOps widgets are combined for an overall view. one.newrelic.com > Dashboards: Here is an example of an Insights dashboard with data about vendors, technologies, services, instances, and other important details for DevOps teams. 5. Add alerts for cloud-based metrics When monitoring cloud-based services, it is essential to keep track of all changes to a system by alerting on them. Integrations with New Relic Infrastructure allow you to create alerts on the metrics that are the most important to you. Here is an example of a baseline alert that will notify you based on the number of requests received on all AWS Elastic Load Balancing (ALB) systems for the ALB monitoring integration: alerts.newrelic.com > Alert policies > (selected policy) > Alert conditions: Create a NRQL baseline alert to monitor the number of requests received your ALB systems. 6. Set up additional monitoring In addition to monitoring cloud services, you can deploy New Relic APM, Browser, Mobile, and Synthetics to gain full-stack visibility into all of the components of your applications: Use New Relic APM to report application-tier performance metrics. Use New Relic Browser to report front-end web metrics. Use New Relic Mobile to report front-end mobile app metrics. Use New Relic Synthetics to monitor websites, critical business transactions, and API endpoints. 7. CI/CD pipeline integration It's important to track deployments and the impact that code and infrastructure changes have on your end-user experience. New Relic APM deployment markers allow you to record deployments for each application. A deployment marker is an event indicating that a deployment happened. You can pair markers with metadata from your source code management (SCM) system ( including user IDs, revisions, and change logs.). APM displays a vertical line, or marker, on charts and graphs at the deployment event's timestamp. When you hover over the line, APM displays the associated metadata for that deployment. Tracking deployments is an invaluable way to determine the root causes of immediate, long-term, or gradual degradations in your applications. Recommendation: Make POST requests to the New Relic REST API as the final step of a successful CI/CD deployment, as described in the API documentation. The following tools have integrations or plugins available to help automate CI/CD deployments: Chef (see newrelic_deployment) Jenkins Ansible Puppet 8. AWS Lambda Monitoring New Relic One features an updated APM agent that is highly optimized from a cost and time perspective for ephemeral Lambda functions. Enable New Relic monitoring of AWS Lambda to to assess invocations, error rate, function duration, cold starts, and more. You can also take advantage of New Relic's Infrastructure integration with Lambda for additional reporting capabilities. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.98825,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Optimize <em>your</em> cloud native environment",
        "info": "Use the New Relic Platform to monitor <em>your</em> modern technologies and cloud services.",
        "category_2": "Optimize <em>your</em> cloud native environment",
        "body": " integrations As you integrate new cloud services, you can use New Relic to monitor and report data about these services; giving you a single, comprehensive overview of <em>your</em> <em>entire</em> architecture. To configure cloud service integrations, link <em>your</em> Amazon Web Services (AWS), Microsoft Azure, or Google Cloud",
        "breadcrumb": "Contents &#x2F; New Relic solutions &#x2F; New Relic solutions &#x2F; Optimize <em>your</em> cloud native environment"
      },
      "id": "5f58360d196a673b60ce6aa3"
    },
    {
      "category_2": "Cloud adoption",
      "nodeid": 16276,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Modern and cloud services",
        "1. Identify applications, cloud services, infrastructure, and technologies",
        "2. Deploy Infrastructure",
        "3. Configure cloud integrations",
        "4. Track data on your dashboards",
        "5. Add alerts for cloud-based metrics",
        "6. Set up additional monitoring",
        "7. CI/CD Pipeline integration",
        "For more help"
      ],
      "title": "Modern and cloud services ",
      "category_0": "New Relic solutions",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "b9d879c0bea5c876edd35f384cf569e41fddad2a",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/GCPComputeEngineDashboard.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/cloud-adoption/modern-cloud-services",
      "published_at": "2020-09-27T16:10:56Z",
      "updated_at": "2020-09-27T06:28:32Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Cloud adoption",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic to monitor your cloud services for any usage issues or errors that might occur in your new architecture after your cloud migration.",
      "body": "Whether you've just completed your cloud migration, have been using cloud based services for awhile, or have always been in the cloud, you may find yourself deploying or running technologies and services that are new and modern. These modern technologies could be container solutions such as Docker, Kubernetes, and Amazon AWS ECS or Fargate for example. Or they could be serverless services such as AWS Lambda, Microsoft Azure, or Google Cloud Platform Functions, cloud based databases, or any number of cloud services that abstract the service away from an operations-maintained infrastructure. In these situations you still want to monitor, query, and alert on the performance and usage metrics for both modern technologies and cloud-based services, allowing for faster deployments, the ability to adopt new services, better business decisions, and to expand horizons. This doc demonstrates how to use the New Relic Platform to monitor your modern technologies and cloud services. 1. Identify applications, cloud services, infrastructure, and technologies Determine the components you need to monitor by answering the following the questions: What cloud-based applications do I have? What are the underlying cloud-based services, technologies, and infrastructure supporting those applications? When you have a full understanding of your architecture, you reduce the possibility of missing dependencies during your migration. 2. Deploy Infrastructure After reviewing the requirements for New Relic Infrastructure, install the Infrastructure agent on the hosts you identified so you can start to monitor your cloud services. If you use Ansible, Chef, or Puppet for automation, you can use those tools to deploy Infrastructure agents to your hosts. 3. Configure cloud integrations Once your applications are migrated to the cloud and you start to integrate new cloud services, you can use New Relic to monitor and report data about your cloud services, offering you a comprehensive view of your entire architecture in one place. To get started configuring cloud service integrations, link your cloud service provider account with New Relic, depending on whether you use Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP). 4. Track data on your dashboards New Relic Infrastructure integrations auto-populate dashboards with metrics from cloud providers like AWS, Azure, and GCP so you can track the data that is critical to your cloud adoption success. If you adopt a hybrid cloud of multiple cloud providers, New Relic can provide a holistic perspective that is agnostic to cloud providers. AWS EC2 monitoring integration dashboard In this default dashboard for the AWS EC2 monitoring integration, New Relic captures metrics for EC2 instances per region, instance state, and instance type. The dashboard also shows inventory for different software packages and configurations that are installed on those instances. infrastructure.newrelic.com > Integrations > Amazon Web Services: View AWS EC2 data on the default dashboard for the AWS EC2 monitoring integration. Azure VMs monitoring integration dashboard The default Azure virtual machine integration dashboard shows data for VM sizes, VMs per region, and VMs per resource group. infrastructure.newrelic.com > Integrations > Microsoft Azure: View Azure virtual machine data on the default dashboard for the Azure VMs monitoring integration. GCP Compute Engine monitoring integration dashboard In this default dashboard for the Google Cloud Platform, New Relic captures metrics for instances per zone, instance status, firewall dropped packets, reserved cores, and disk throttled operations. The dashboard also shows inventory for different software packages and configurations that are installed on those instances. infrastructure.newrelic.com > Integrations > Google Cloud Platform: View GCP Compute Engine data on the default dashboard for the GCP Compute Engine monitoring integration. Example modern and cloud services dashboard In this example dashboard, three different cloud vendors, modern technologies, cloud services, infrastructure instance locations, and DevOps widgets are combined for an overall view. one.newrelic.com > Dashboards: Here is an example of a dashboard with data about vendors, technologies, services, instances, and other important details. 5. Add alerts for cloud-based metrics When monitoring cloud-based services, it is essential to keep track of all the changes happening with the system by alerting on them. Integrations with New Relic Infrastructure allow you to create alerts on the metrics that are the most important to you. Here is an example of a baseline alert that will notify you based on the number of requests received on all ALB systems for the AWS Elastic Load Balancing (ALB) monitoring integration: alerts.newrelic.com > Alert policies > (selected policy) > Alert conditions: Create a NRQL baseline alert to monitor the number of requests received your ALB systems. 6. Set up additional monitoring In addition to monitoring cloud services, you can deploy New Relic APM, Browser, Mobile, and Synthetics to gain full-stack visibility into all of the components of your applications: Use New Relic APM to report application-tier performance metrics. Use New Relic Browser to report front-end web metrics. Use New Relic Mobile to report front-end mobile app metrics. Use New Relic Synthetics to monitor websites, critical business transactions, and API endpoints. 7. CI/CD Pipeline integration It's important to track deployments and how the impact of the code and infrastructure changes you make affect customer experience. New Relic APM's deployment markers feature allows you to record deployments for each application. A deployment marker is an event indicating that a deployment happened, and it's paired with metadata available from your SCM system (such metadata typically includes the user, revision, change log, etc.). APM displays a vertical line, or marker, on charts and graphs at the deployment event's timestamp. When you hover over the line, APM displays the associated metadata for that deployment. Tracking deployments is an invaluable way to determine the root cause of immediate, long-term, or gradual degradations in your application. Recommendation: Make POST requests to the New Relic REST API as the final step of a successful CI/CD deployment as described in the API documentation. The following tools have integrations or plugins available to help automate CI/CD deployments: Chef (see newrelic_deployment) Jenkins Ansible For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.37358,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Optimize <em>your</em> cloud native environment",
        "info": "Use New Relic to monitor <em>your</em> cloud services for any usage issues or errors that might occur in <em>your</em> new architecture after <em>your</em> cloud migration.",
        "body": " applications are migrated to the cloud and you start to integrate new cloud services, you can use New Relic to monitor and report data about <em>your</em> cloud services, offering you a comprehensive view of <em>your</em> <em>entire</em> architecture in one place. To get started configuring cloud service integrations, link <em>your</em> cloud"
      },
      "id": "5bac5da60cc37f1f5e3ad7bb"
    },
    {
      "category_2": "Examples",
      "nodeid": 34236,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "NerdGraph tagging API tutorial",
        "Read tags for an entity",
        "Add tags for an entity",
        "Remove a tag from an entity",
        "Delete specific tag values for an entity",
        "Replace all tag values for an entity",
        "For more help"
      ],
      "title": "NerdGraph tagging API tutorial",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "c4b8fbf4f75b862f2b6e3caad723935febb89815",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-tagging-api-tutorial",
      "published_at": "2020-09-27T22:31:13Z",
      "updated_at": "2020-07-26T05:41:24Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic's NerdGraph (our GraphQL API) to manage tags attached to your entities.  ",
      "body": "New Relic One provides unified access to all the entities you monitor with New Relic. Tags are used to organize and group all your entities in a way that's useful for troubleshooting and understanding your environment. To add, delete, or modify your tags, use the NerdGraph GraphiQL explorer. NerdGraph allows you to tag your entities with a key and an associated list of values. You can also use NerdGraph to query entities. Read tags for an entity To construct these queries and see responses: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to find the entity and then fetch its tags. Use NerdGraph's tag API to read the existing tags and their values. In this example, our entity is a browser app called Cookie Checkout: { actor { entitySearch (query: \"name like 'Cookie Checkout'\") { results { entities { tags { key values } } } } } } The actual values vary depending on your data. Use the New Relic GraphiQL explorer to experiment with queries. Add tags for an entity To add new tags for an entity: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity you want to tag. Use the taggingAddTagsToEntity mutation to add a tag with a value to the entity. In this example, we have a browser application called Cookie Checkout owned by a UI team. We want to add a team tag with a ui value to this instance. Once the tag is added, we can filter by the tag team:ui and find the Cookie Checkout app in the New Relic One UI. mutation { taggingAddTagsToEntity ( guid: \"ENTITY_GUID\", tags: { key: \"team\", values: [\"ui\"]}) { errors { message } } } Remove a tag from an entity To delete a tag and all of its associated values from an entity: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagFromEntity mutation. The following example mutation removes the team tag from an entity: mutation { taggingDeleteTagFromEntity ( guid: \"ENTITY_GUID\", tagKeys: [\"team\"]) { errors { message } } } Delete specific tag values for an entity Instead of deleting an entire tag and all of its values, you can delete a single tag value. Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagValuesFromEntity mutation. The following example mutation deletes the ui value from the tag key: mutation { taggingDeleteTagValuesFromEntity ( guid: \"ENTITY_GUID\", tagValues : [{key: \"team\" value: \"ui\"}]) { errors { message } } } Because tagValues is an array, you can delete multiple specific values from a single entity in one mutation. Replace all tag values for an entity To replace all the existing values for a tag with new ones: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingReplaceTagsOnEntity mutation. In this example, the Cookie Checkout browser application was transferred from the ui team to the cookie-dev team. You can replace the tag values for team with the following mutation: mutation { taggingReplaceTagsOnEntity ( guid: \"ENTITY_GUID\", tags: {key: \"team\" values: [\"cookie-dev\"]}) { errors { message } } } For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.472824,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NerdGraph <em>tagging</em> API tutorial",
        "sections": "NerdGraph <em>tagging</em> API tutorial",
        "info": "Use New Relic&#x27;s NerdGraph (our GraphQL API) to manage <em>tags</em> attached to <em>your</em> entities.  ",
        "body": ". NerdGraph allows you to <em>tag</em> <em>your</em> entities with a key and an associated list of values. You can also use NerdGraph to query entities. Read tags for an entity To construct these queries and see responses: Go to the NerdGraph GraphiQL explorer at https:&#x2F;&#x2F;api.newrelic.com&#x2F;graphiql. Use entitySearch() to find"
      },
      "id": "5d8024fc28ccbcc5e9499cf1"
    }
  ],
  "/explore-docs/nr1-config": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.69382,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " extension to build your apps. <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em> This table provides descriptions for the <em>New</em> <em>Relic</em> <em>One</em> <em>commands</em>. For more context, including usage and option details, click any individual <em>command</em> or the <em>command</em> category. For details on user permissions, see Authentication and permissions"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-09-29T01:52:56Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Copy Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.22809,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2020-09-29T01:52:56Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.83377,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em> Here&#x27;s a list of common <em>commands</em> to get you started with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-09-29T01:48:49Z",
      "updated_at": "2020-08-26T01:47:20Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.42933,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": "Set up your development environment 20 min If you&#x27;ve decided to build a custom app or modify <em>one</em> of our open source apps, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> <em>command</em> line interface (<em>CLI</em>) An API key, which you get when you download the <em>CLI</em> Depending on what you want to do with your app"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-nerdpack/",
      "sections": [
        "New Relic One CLI Nerdpack commands",
        "Command details",
        "nr1 nerdpack:build",
        "Builds a Nerdpack",
        "Usage",
        "Options",
        "nr1 nerdpack:clone",
        "Clone an existing Nerdpack",
        "nr1 nerdpack:serve",
        "Serve your Nerdpack locally",
        "nr1 nerdpack:uuid",
        "Get your Nerdpack's UUID",
        "nr1 nerdpack:publish",
        "Publish your Nerdpack",
        "nr1 nerdpack:deploy",
        "Deploy your Nerdpack to a channel",
        "nr1 nerdpack:undeploy",
        "Undeploy your Nerdpack",
        "nr1 nerdpack:clean",
        "Removes all built artifacts",
        "nr1 nerdpack:validate",
        "Validates artifacts inside your Nerdpack",
        "nr1 nerdpack:Info",
        "Shows the state of your Nerdpack in the New Relic's registry"
      ],
      "published_at": "2020-09-29T01:54:07Z",
      "title": "New Relic One CLI Nerdpack commands",
      "updated_at": "2020-09-17T01:49:55Z",
      "type": "developer",
      "external_id": "7c1050a6a8624664b90c15111f7c72e96b2fbe17",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI commands you can use to set up your New Relic One Nerdpacks.",
      "body": "New Relic One CLI Nerdpack commands To set up your Nerdpacks, use the commands below. You can click any command to see its usage options and additional details about the command. Command Description nr1 nerdpack:build Assembles your Nerdpack into bundles nr1 nerdpack:clone Clones a Nerdpack from a git repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your development folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Command details nr1 nerdpack:build Builds a Nerdpack Runs a webpack process to assemble your Nerdpack into javascript and CSS bundles. As many other CLI commands, it should be run at the package.json level of your Nerdpack. Usage $ nr1 nerdpack:build OPTION Options --extra-metadata-path=extra-metadata-path Specify a json file path with extra metadata. [default: extra-metadata.json] --prerelease=prerelease If specififed, the value will be appended to the current version of generated files. ie: --prerelease=abc. Then the version will be \"1.2.3-abc\". --profile=profile The authencation profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:clone Clone an existing Nerdpack Duplicates an existing Nerdpack onto your local computer. You can clone an open source Nerdpack from our Open Source GitHub repositories. After choosing a git repository, this command performs the following actions so that you can start using the Nerdpack: Clones the repository. Sets the repository as remote upstream. Installs all of its dependencies (using npm). Generates a new UUID using your profile, and commits it. Usage $ nr1 nerdpack:clone OPTION Options -r, --repo=REPO Repository location (either an HTTPS or SSH path). (Required) -p, --path=PATH Determines the directory to clone to (defaults to the repository name). -f, --force Replaces destination folder if it exists. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:serve Serve your Nerdpack locally Launches a server with your Nerdpack locally on the New Relic One platform, where it can be tested live. To learn more about working with apps locally, see our guide on how to serve, publish, and deploy documentation. Usage $ nr1 nerdpack:serve Options --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:uuid Get your Nerdpack's UUID Prints the UUID (Universal Unique ID) of your Nerdpack, by default. The UUID determines what data the Nerdpack can access and who can subscribe to the Nerdpack. To deploy a Nerdpack you didn't make, you'll have to assign it a new UUID by using the -g or --generate option. For more details, see our GitHub workshop on GitHub. Usage $ nr1 nerdpack:uuid Options --profile=PROFILE The authentication profile you want to use. -f, --force If present, it will override the existing UUID without asking. -g, --generate Generates a new UUID if not available. --verbose Adds extra information to the output. nr1 nerdpack:publish Publish your Nerdpack Publishes your Nerdpack to New Relic. Please note: If no additional parameters are passed in, this command will automatically deploy the Nerdpack onto the DEV channel. If you want to specify your own list of deploy channels, add the --channel option. For example, $ nr1 nerdpack:publish --channel BETA --channel STABLE. If you want to disable this behavior, add -D or --skip-deploy to the command. Then, you can use nr1 nerdpack:deploy to perform a deploy manually. For more on publishing and deploying, see Deploy to New Relic One. Usage $ nr1 nerdpack:publish Options -B, --skip-build Skips the previous build process. -D, --skip-deploy Skips the following deploy process. -c, --channel=DEV/BETA/STABLE Specifies the channel to deploys to. [default: STABLE] -f, --force Forces the publish, overriding any existing version in the registry. --dry-run Undergoes publishing process without actually publishing anything. --extra-metadata-path=extra-metadata-path Specifies a json file .path with extra metadata. [default: extra-metadata.json] --prerelease=STRING The value you enter will be appended to the current version of generated files. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:deploy Deploy your Nerdpack to a channel Deploys a Nerdpack version to a specific channel (DEV, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. For more on publishing and deploying, see Deploy to New Relic One. Usage $ nr1 nerdpack:deploy OPTION Options -c, --channel=DEV/BETA/STABLE Specifies the channel to deploy to. (required) -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to deploy. By default, the command will use the one in package.json. --from-version=VERSION Specifies which version to deploy. By default, the command will use the one in package.json. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:undeploy Undeploy your Nerdpack Undeploys a Nerdpack version from a specific channel (for example, DEV, BETA, or STABLE). Usage $ nr1 nerdpack:undeploy OPTION Options -c, --channel=DEV/BETA/STABLE Specifies the channel to undeploy from. (required) -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to deploy. By default, the command will use the one in package.json. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:clean Removes all built artifacts Cleans and removes the content and the developtment folders (dist/, tmp/). Usage $ nr1 nerdpack:clean OPTION Options --profile=profile The authentication profile you want to use --verbose Adds extra information to the output. nr1 nerdpack:validate Validates artifacts inside your Nerdpack Validates artifacts inside your Nerdpack. Usage $ nr1 nerdpack:validate OPTION Options -l, --force-local The authentication profile you want to use. -r, --force-remote Force download of new schema files. --profile=profile The authentication profile you want to uset. --verbose Adds extra information to the output. nr1 nerdpack:Info Shows the state of your Nerdpack in the New Relic's registry Shows the state of your Nerdpack in the New Relic's registry. The default amount of versions shown is 10 but all versions can be shown if the --all (or -a) flag is used Usage $ nr1 nerdpack:info OPTION Options -a, --all Show all versions. -i, --nerdpack-id=nerdpack-id Get info from the specified Nerdpack instead of local one. --profile=profile The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.14273,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> Nerdpack <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> Nerdpack <em>commands</em>",
        "info": "An overview of the <em>CLI</em> <em>commands</em> you can use to set up your <em>New</em> <em>Relic</em> <em>One</em> Nerdpacks.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> Nerdpack <em>commands</em> To set up your Nerdpacks, use the <em>commands</em> below. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 nerdpack:build Assembles your Nerdpack into bundles nr1 nerdpack:clone Clones a Nerdpack from"
      },
      "id": "5f28bd6a64441f9817b11a38"
    }
  ],
  "/explore-docs/newrelic-cli": [
    {
      "category_2": "Measure DevOps success",
      "nodeid": 34966,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "2. Take advantage of integrations and existing tools",
        "3. Leverage the power of APIs",
        "For more help"
      ],
      "title": "Automate instrumentation",
      "category_0": "New Relic solutions",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "91b25e8572d235c7f95963650848fc6ab6cf4b39",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/NRCLItool.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation",
      "published_at": "2020-09-28T01:04:03Z",
      "updated_at": "2020-09-28T01:04:02Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "Capture tangible, measurable metrics from before and after deployments to optimize your DevOps team. ",
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Read this Best Practices post for more information about automating instrumentation in your pipeline 2. Take advantage of integrations and existing tools It’s always worth taking a little extra time to look for time-saving integrations and tools that can help to achieve your automation goals. For example, you can use IBM’s open-sourced New Relic CLI (command line interface) tool to automate a variety of tasks, such as managing New Relic Synthetics monitors; creating, editing, and deleting New Relic Alerts policies and conditions; and managing user accounts. Use IBM's New Relic CLI tool to manage your Synthetics monitors, alert policies, and user accounts. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 933.4342,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> solutions",
        "category_0": "<em>New</em> <em>Relic</em> solutions",
        "category_1": "<em>New</em> <em>Relic</em> solutions",
        "body": " It’s always worth taking a little extra time to look for time-saving integrations and tools that can help to achieve your automation goals. For example, you can use IBM’s open-sourced <em>New</em> <em>Relic</em> <em>CLI</em> (command line interface) tool to automate a variety of tasks, such as managing <em>New</em> <em>Relic</em> Synthetics",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; Measure DevOps success"
      },
      "id": "5f5e0c14196a67e25fce6a8a"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-09-29T01:40:52Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-27T01:38:35Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 16 Days : 22 Hours : 10 Minutes : 8 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 20 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 726.6968,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Set up New Relic using Helm charts",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Set up New Relic using Terraform"
      ],
      "published_at": "2020-09-29T01:47:50Z",
      "title": "Automate workflows",
      "updated_at": "2020-09-25T01:49:59Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 20 min Set up New Relic using Terraform Learn how to provision New Relic resources using Terraform",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 654.17816,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using Helm charts",
        "body": " CloudFormation, and a command-line interface. These tools enable you to integrate <em>New</em> <em>Relic</em> into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and <em>CLI</em> guides below, find more automation"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 645.25745,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> One <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> One <em>CLI</em> reference",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> One app",
        "body": "<em>New</em> <em>Relic</em> One <em>CLI</em> reference To build a <em>New</em> <em>Relic</em> One app, you must install the <em>New</em> <em>Relic</em> One <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> One <em>CLI</em> (command line interface). This page explains how to use"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/nerd-days/",
      "sections": [
        "Nerd Days is a free 1-day event focused on building more perfect software",
        "Register for Nerd Days 1.0",
        "Save the date & join us online",
        "Additional Nerd Days Events",
        "REGISTER FOR NERD DAYS | AMERICAS",
        "Tracks",
        "Observability",
        "Cloud migration",
        "Open source",
        "Devops journey",
        "Fundamentals",
        "Nerd Days AMER Agenda",
        "DevOps journey",
        "Keynote",
        "Instrumenting your service using agents",
        "Increased Maturity with Full Stack Observability",
        "Deploying an app on Kubernetes",
        "Delivering SRE as a Service",
        "Building applications on New Relic One",
        "Exploring your data using NRQL",
        "New Relic AI",
        "Going Serverless: Chipping at the monolith",
        "Logging for Modern Organizations",
        "Grafana and Prometheus with TDP",
        "Lunch Break",
        "Custom Instrumentation",
        "Exploring Data with NerdGraph",
        "Tool Consolidation",
        "Flex Integration - Build Your First Linux Configuration",
        "Open Source powers the New Relic One Catalog",
        "Alerts Best Practices",
        "The Art & Science of Deciphering Perceived Performance: A look at how user behavior affects your data",
        "Kubernetes Observability",
        "Measuring code pipelines",
        "New Relic CLI Wizardry/ Reducing toil with Terraform",
        "True availability using Synthetics",
        "How Observability-Driven Development accelerates DevOps transformations",
        "CFP Customer Session: Cloud fundamentals",
        "Testing in Production",
        "NerdStorageVault: ThirdParty Secrets",
        "Closing + Swag",
        "Engage with the developer community"
      ],
      "published_at": "2020-09-29T01:55:32Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-27T01:39:41Z",
      "type": "developer",
      "external_id": "0b8374051901a77e242ce296c00eeb3c760439d1",
      "document_type": "page",
      "popularity": 1,
      "body": "Nerd Days is a free 1-day event focused on building more perfect software Register for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region) Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. Save the date & join us online Choose the sessions you're interested in add Nerd Days to your calendar. You’ll hear from fellow engineers who built New Relic solutions and New Relic users from various industries. Whether you’re new or a data nerd, there’s an interactive session for you. Date: October 13, 2020 Time: 9AM PST - 3PM PST We look forward to building with you during Nerd Days! If you have any questions about Nerd Days please emails deco@newrelic.com. Additional Nerd Days Events EMEA RegistrationNov 10, 2020 APJ RegistrationOct 22, 2020 REGISTER FOR NERD DAYS | AMERICAS Tracks Tracks will vary by region. All sessions will be recorded and distributed after the event. Observability Cloud migration Open source Devops journey Fundamentals Nerd Days AMER Agenda We’ve got a packed schedule with thought-leaders of their respective industries Fundamentals Observability Cloud migration DevOps journey Open source 9:00 AM Keynote Lew Cirne 10:00 AM Instrumenting your service using agents Increased Maturity with Full Stack Observability Deploying an app on Kubernetes Delivering SRE as a Service Building applications on New Relic One 11:00 AM Exploring your data using NRQL New Relic AI Going Serverless: Chipping at the monolith Logging for Modern Organizations Grafana and Prometheus with TDP 12:00 PM Lunch Break Distant Disco 1:00 PM Custom Instrumentation Exploring Data with NerdGraph Tool Consolidation Flex Integration - Build Your First Linux Configuration Open Source powers the New Relic One Catalog 2:00 PM Alerts Best Practices The Art & Science of Deciphering Perceived Performance: A look at how user behavior affects your data Kubernetes Observability Measuring code pipelines New Relic CLI Wizardry/ Reducing toil with Terraform 3:00 PM True availability using Synthetics How Observability-Driven Development accelerates DevOps transformations CFP Customer Session: Cloud fundamentals Testing in Production NerdStorageVault: ThirdParty Secrets 4:00 PM Closing + Swag Jemiah Sius and Team Engage with the developer community @newrelic New Relic Forum Developers Hopin logo Event powered by Hopin",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 611.8309,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> Wizardry&#x2F; Reducing toil with Terraform",
        "body": " pipelines <em>New</em> <em>Relic</em> <em>CLI</em> Wizardry&#x2F; Reducing toil with Terraform 3:00 PM True availability using Synthetics How Observability-Driven Development accelerates DevOps transformations CFP Customer Session: Cloud fundamentals Testing in Production NerdStorageVault: ThirdParty Secrets 4:00 PM Closing + Swag Jemiah Sius and Team Engage with the developer community @newrelic <em>New</em> <em>Relic</em> Forum Developers Hopin logo Event powered by Hopin"
      },
      "id": "5f3dd5bf28ccbc2349f56e4e"
    }
  ],
  "/automate-workflows/5-mins-tag-resources": [
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-09-29T01:40:52Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-27T01:38:35Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 16 Days : 22 Hours : 10 Minutes : 8 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 20 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.45285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Set up New Relic using Helm charts",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Set up New Relic using Terraform"
      ],
      "published_at": "2020-09-29T01:47:50Z",
      "title": "Automate workflows",
      "updated_at": "2020-09-25T01:49:59Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 20 min Set up New Relic using Terraform Learn how to provision New Relic resources using Terraform",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.271576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using Helm charts",
        "body": " solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly <em>tag</em> resources Add <em>tags</em> to apps for easy filtering 20 min Set up <em>New</em> <em>Relic</em> using Helm charts Learn how to set up <em>New</em> <em>Relic</em> using Helm charts 30 min Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the entire stack See how easy"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Alerts release notes",
      "nodeid": 40771,
      "sections": [
        "New Relic Platform release notes",
        "Alerts release notes",
        "APM release notes",
        "Cloud Integrations release notes",
        "Diagnostics release notes",
        "Mobile release notes",
        "Kubernetes integration release notes",
        "09-25-2020 : Entity Tags on Violations for Cloud Integrations",
        "Component: Violation Tags",
        "Update:"
      ],
      "title": "09-25-2020 : Entity Tags on Violations for Cloud Integrations",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "New Relic Platform release notes",
      "external_id": "a298fdb1da8f5f032a0655ecb9b91fdb418a25c8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/platform-release-notes/alerts-release-notes/09-25-2020-entity-tags-violations-cloud-integrations",
      "published_at": "2020-09-29T22:49:23Z",
      "updated_at": "2020-09-29T16:10:16Z",
      "breadcrumb": "Contents / New Relic Platform Release Notes / Alerts release notes",
      "document_type": "release_notes_platform",
      "popularity": 1,
      "body": "[RSS] Released on:  September 25, 2020 Component: Violation Tags Update: We are now adding entity tag data to the violations from cloud integrations. We are now enriching violations with entity tags for the following alert conditions and entity types NRQL Conditions - ONLY when adding \"facet entity.guid\" to your NRQL query APM Conditions Synthetic Conditions Infrastructure : Cloud Integrations Infrastructure On-Host Integrations: only for the following types: HOST KafkaBroker KafkaTopic OracleDbInstance MssqlInstance ElasticsearchNode RabbitMqCluster RabbitMqExchange RabbitMqQueue RabbitMqNode KubernetesCluster AwsEcsCluster VarnishInstance MemcachedInstance CouchbaseBucket CouchbaseNode CouchbaseCluster CouchbaseQueryEngine PostgreSQLInstance F5System F5VirtualServer F5PoolMember F5Pool F5Node ConsulAgent CassandraNode RedisInstance ApacheServer NGINXServer MySQLNode VSphereHost VSphereVm VSphereResourcePool VSphereDatastore VSphereCluster VSphereDatacenter WindowsService",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.9725,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "09-25-2020 : Entity <em>Tags</em> on Violations for Cloud Integrations",
        "sections": "<em>New</em> <em>Relic</em> Platform release notes",
        "category_1": "<em>New</em> <em>Relic</em> Platform release notes",
        "body": "[RSS] Released on:  September 25, 2020 Component: Violation <em>Tags</em> Update: We are now adding entity <em>tag</em> data to the violations from cloud integrations. We are now enriching violations with entity <em>tags</em> for the following alert conditions and entity types NRQL Conditions - ONLY when adding &quot;facet",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> Platform Release Notes &#x2F; Alerts release notes"
      },
      "id": "5f735c6928ccbc5f5d337dbb"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Get your application details",
        "Add a simple tag to your application",
        "Bonus step: Create a deployment marker",
        "Next steps"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2020-09-29T01:47:54Z",
      "updated_at": "2020-08-08T01:41:47Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Get started with the New Relic CLI 20 min Access the New Relic platform from the comfort of your terminal: you can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. Our CLI has been designed for automating common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic personal API Key, which you can create from the Account settings of your New Relic account An instrumented application in your New Relic account Step 1 of 10 Install the New Relic CLI The New Relic CLI can be downloaded via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile Now that you've installed the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. To create your first CLI profile, run the profiles add command. Note that you need to set the region of your New Relic account: use -r to set either us or eu (this is required). # Create the tutorial account for the US region newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_API_KEY -r YOUR_REGION # Set the profile as defaults newrelic profiles default -n tutorial Copy Step 3 of 10 Get your application details In this example, you are going to add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 The New Relic CLI can retrieve your application details as a JSON object. To search for your APM application use the apm application search command. If you get an error, check that the account ID and application name you provided are correct. newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Copy Step 5 of 10 If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example. When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. [ { accountId: YOUR_ACCOUNT_ID, applicationId: YOUR_APP_ID, domain: 'APM', entityType: 'APM_APPLICATION_ENTITY', guid: 'A_LONG_GUID', name: 'NAME_OF_YOUR_APP', permalink: 'https://one.newrelic.com/redirect/entity/A_LONG_GUID', reporting: true, type: 'APPLICATION', }, ]; Copy Step 6 of 10 Add a simple tag to your application Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Let's suppose that you want to add an environment tag to your application. Go ahead and add the dev:testing tag⁠ (or any other key-value pair) to your application using the entities tags create command. newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Copy Step 7 of 10 What if you want to add multiple tags? Tag sets come to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags at once to your application, modify and run the following snippet. newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Copy Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 You've created and added some tags to your application, but how do you know they're there? You need to retrieve your application's tags. To retrieve your application's tags, use the entity tags get command. newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Step 9 of 10 Bonus step: Create a deployment marker Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same Application ID from your earlier search. newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Copy Step 10 of 10 Notice that the JSON response includes the revision and timestamp of the deployment. This workflow could be built into a continuous integration or continuous deployment (CI/CD) system to help indicate changes in your application's behavior after deployments. Here is an example. { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands. For example, you could create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.74144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " Now that you have the GUID, you can point the <em>New</em> <em>Relic</em> <em>CLI</em> directly at your application. Adding a <em>tag</em> is the simplest way to try out the <em>CLI</em> capabilities (don&#x27;t worry, <em>tags</em> can be deleted by using entity <em>tags</em> delete). Let&#x27;s suppose that you want to add an environment <em>tag</em> to your application. Go ahead"
      },
      "id": "5efa999c196a67c4e1766461"
    },
    {
      "category_2": "Measure DevOps success",
      "nodeid": 34966,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "2. Take advantage of integrations and existing tools",
        "3. Leverage the power of APIs",
        "For more help"
      ],
      "title": "Automate instrumentation",
      "category_0": "New Relic solutions",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "91b25e8572d235c7f95963650848fc6ab6cf4b39",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/NRCLItool.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation",
      "published_at": "2020-09-28T01:04:03Z",
      "updated_at": "2020-09-28T01:04:02Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "Capture tangible, measurable metrics from before and after deployments to optimize your DevOps team. ",
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Read this Best Practices post for more information about automating instrumentation in your pipeline 2. Take advantage of integrations and existing tools It’s always worth taking a little extra time to look for time-saving integrations and tools that can help to achieve your automation goals. For example, you can use IBM’s open-sourced New Relic CLI (command line interface) tool to automate a variety of tasks, such as managing New Relic Synthetics monitors; creating, editing, and deleting New Relic Alerts policies and conditions; and managing user accounts. Use IBM's New Relic CLI tool to manage your Synthetics monitors, alert policies, and user accounts. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.34343,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> solutions",
        "category_0": "<em>New</em> <em>Relic</em> solutions",
        "category_1": "<em>New</em> <em>Relic</em> solutions",
        "body": " It’s always worth taking a little extra time to look for time-saving integrations and tools that can help to achieve your automation goals. For example, you can use IBM’s open-sourced <em>New</em> <em>Relic</em> <em>CLI</em> (command line interface) tool to automate a variety of tasks, such as managing <em>New</em> <em>Relic</em> Synthetics",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; Measure DevOps success"
      },
      "id": "5f5e0c14196a67e25fce6a8a"
    }
  ],
  "/build-apps/publish-deploy": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Create a \"Hello, World!\" application",
        "Permissions for managing applications",
        "Set up your development environment",
        "Add, query, and mutate data using NerdStorage",
        "Add the NerdGraphQuery component to an application",
        "Add a time picker to your app",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps"
      ],
      "published_at": "2020-09-29T01:47:50Z",
      "title": "Build apps",
      "updated_at": "2020-09-25T01:49:59Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One   Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 20 min Add a time picker to your app Add a time picker to a sample application 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.73505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "<em>Publish</em> and <em>deploy</em> <em>apps</em>",
        "body": " <em>app</em> <em>Add</em> a time picker to a sample application 30 min <em>Add</em> a table to your <em>app</em> <em>Add</em> a table to your New Relic One <em>app</em> 30 min Create a custom map view Build an <em>app</em> to show page view data on a map 30 min <em>Publish</em> and <em>deploy</em> <em>apps</em> Start sharing the <em>apps</em> you build"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Permissions for managing applications",
        "New Relic One pricing plan",
        "Original product-based pricing"
      ],
      "title": "Permissions for managing applications",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2020-09-29T01:48:49Z",
      "updated_at": "2020-09-02T02:04:41Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for subscribing to apps",
      "body": "Permissions for managing applications When you create an app, you'll likely want to share it. From New Relic One's Apps page, you can subscribe to apps you create, publish, and deploy, and to other publicly available apps. You must have the Nerdpack manager role to subcribe accounts to apps. Read on to learn about permissions and versions. Permissions for managing applications The Nerdpack manager role is a New Relic add-on role. When you create a Nerdpack, you have the Nerdpack manager role for handling that Nerdpack. New Relic account administrators have the Nerdpack manager role automatically, and can subscribe their accounts to available Nerdpacks. User permissions vary depending on which pricing plan you are on. New Relic One pricing plan For accounts with New Relic One pricing, there are permissions differences for basic users and full users: Full users have the Nerdpack manager role and have full capabilities for creating and managing New Relic One applications, as well as accessing all types of applications in the New Relic One catalog. A basic user can develop and view their own local New Relic One apps, but they cannot: Subscribe other users to apps they’ve created. Access or manage apps in the New Relic One catalog. Access apps in the entity explorer sidebar. Original product-based pricing For accounts on our original product-based pricing, here are access details: Subscribe to publicly available applications To subscribe to publicly available applications, you must have the Nerdpack manager role. Nerdpack manager permissions are automatically assigned to New Relic account owners and admins and can be assigned to individual users. If you aren’t an owner or admin, you can request Nerdpack manager permission, or ask your New Relic admin or owner to subscribe the apps to your account for you. You can add any of the publicly available applications to master accounts or separate sub-accounts on which you have the Nerdpack manager role, or to separate sub-accounts under a master account you own or administer. If you add the application to a master account, the access flows to all of its sub-accounts as well. Subscribe to applications that you create You also must have the Nerdpack manager role to subscribe the applications you create to accounts. Applications that you publish and deploy can only be subscribed to the master account that was used to publish them, or to its sub-accounts. This means you might want a New Relic admin to deploy your applications for you if they need to be available across the organization.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 63.054848,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Permissions for managing <em>applications</em>",
        "sections": "Permissions for managing <em>applications</em>",
        "info": "Learn about permissions for <em>subscribing</em> to <em>apps</em>",
        "tags": "managing <em>apps</em>",
        "body": "Permissions for managing applications When you create an <em>app</em>, you&#x27;ll likely want to share it. From New Relic One&#x27;s <em>Apps</em> page, you can <em>subscribe</em> to <em>apps</em> you create, <em>publish</em>, and <em>deploy</em>, and to other publicly available <em>apps</em>. You must have the Nerdpack manager role to subcribe accounts to <em>apps</em>. Read"
      },
      "id": "5f45bf2864441ffb4dfdcdbb"
    },
    {
      "category_2": "Hosting services",
      "nodeid": 13151,
      "sections": [
        "Node.js agent",
        "Getting started",
        "Installation and configuration",
        "Supported features",
        "Attributes",
        "API guides",
        "Hosting services",
        "Troubleshooting",
        "Install New Relic Node.js agent in GAE flexible environment",
        "Use native deploy",
        "Build a custom runtime",
        "Optional: Disable health checks",
        "Get New Relic agent troubleshooting logs from GAE",
        "For more help"
      ],
      "title": "Install New Relic Node.js agent in GAE flexible environment",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Node.js agent",
      "external_id": "92a838b215a23bd47fcc8b45abdf347c56f720db",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/hosting-services/install-new-relic-nodejs-agent-gae-flexible-environment",
      "published_at": "2020-09-27T15:48:41Z",
      "updated_at": "2020-08-18T06:29:37Z",
      "breadcrumb": "Contents / APM agents / Node.js agent / Hosting services",
      "document_type": "page",
      "popularity": 1,
      "info": "How to install your APM's Node.js app in the Google App Engine (GAE) flexible environment. ",
      "body": "With New Relic's Node.js agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. This document explains how to add New Relic to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Use native deploy To use Google App Engine's \"native mode\" installation with your Node.js app: Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. Optional: Set environment variables to configure the Node.js agent's GAE app.yaml file. Use the Google Cloud SDK's gcloud command line tool to deploy GAE apps. To deploy your Node.js app to your initialized GAE flexible environment, run the following command: gcloud --project new-relic-apm-nodejs app deploy Google App Engine automatically includes your Node.js app's newrelic.js configuration file in the deployed package. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by building a custom runtime for Docker. You can deploy the app without any special configuration. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Google App Engine's documentation for Node.js Google App Engine's tutorial to deploy a Node.js app 1. Set up the GAE project and install dependencies Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Optional: Set environment variables. 3. Configure and deploy The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. To create the Dockerfile, build the container, and deploy your app, follow the GAE procedures for Node.js. Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Optional: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in New Relic APM. If you notice performance issues, disable GAE health checks. In your app.yaml, add: health_check: enable_health_check: False Get New Relic agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect New Relic Node.js agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.js configuration file to: log_file_name: STDOUT To view the logs, use the Cloud Platform Console's Log Viewer. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 32.644806,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use native <em>deploy</em>",
        "info": "How to install your APM&#x27;s Node.js <em>app</em> in the Google <em>App</em> Engine (GAE) flexible environment. ",
        "body": ". This document explains how to <em>add</em> New Relic to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime Use native <em>deploy</em> To use Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with your"
      },
      "id": "5972fea707552313d3f9ba8d"
    },
    {
      "category_2": "Hosting services",
      "nodeid": 13866,
      "sections": [
        "Python agent",
        "Getting started",
        "Installation",
        "Configuration",
        "Supported features",
        "Back-end services",
        "Custom instrumentation",
        "API guides",
        "Python agent API",
        "Web frameworks and servers",
        "Hosting services",
        "Attributes",
        "Troubleshooting",
        "Install the Python agent in GAE flexible environment",
        "Deploy using GAE's native support",
        "Build a custom runtime using Docker",
        "Recommendation: Disable health checks",
        "Get agent troubleshooting logs from GAE",
        "For more help"
      ],
      "title": "Install the Python agent in GAE flexible environment",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Python agent",
      "external_id": "c1ce9a74f2eccba9cf0cd509a6f15f2d02fabb16",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/hosting-services/install-python-agent-gae-flexible-environment",
      "published_at": "2020-09-27T21:42:46Z",
      "updated_at": "2020-08-30T17:24:26Z",
      "breadcrumb": "Contents / APM agents / Python agent / Hosting services",
      "document_type": "page",
      "popularity": 1,
      "info": "How to install your Python app in the Google App Engine (GAE) flexible environment. ",
      "body": "With the Python agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding agent data to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in New Relic One. This document explains how to add agent data to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Deploy using GAE's native support When using Google App Engine \"native mode\" installation, you provide your app code and an app.yaml file. Google App Engine then deploys to a standard prebuilt Docker image. For example, to deploy with native support for a Flask/Django app: Follow standard procedures to install the Python agent, including your license key. Set the NEW_RELIC_CONFIG_FILE as an environment variable pointing to newrelic.ini. Once the agent and configuration file have been installed, the Python agent can automatically monitor applications that reside in the GAE flexible environment. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime using Docker See Google's documentation for building custom runtimes. This example describes how to add agent data to your GAE flex app by building a custom runtime for Docker. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Our GAE flex examples on Github for Python Google App Engine's documentation for Python Google App Engine's tutorials to deploy a Python app 1. Set up the GAE project and install dependencies When building a custom runtime using Docker, set the NEW_RELIC_CONFIG_FILE as an environment variable pointing to the Dockerfile instead of to your Python app's newrelic.ini. Follow standard procedures to install the Python agent, including your license key. Follow Google App Engine procedures Python to create a Google Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK also provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: env: flex runtime: custom 3. Configure a Dockerfile The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. The following Dockerfile example shows the Python agent installed for an application served with gunicorn. These procedures are similar to the Python quick start guide. The Dockerfile will contain customer-specific code, including Python version, installation requirements, etc). # [START dockerfile] FROM gcr.io/google_appengine/python # Install the fortunes binary from the debian repositories. RUN apt-get update && apt-get install -y fortunes # Optional: Change the -p argument to use Python 2.7. RUN virtualenv /env -p python3.5 # Set virtualenv environment variables. This is equivalent to running # source /env/bin/activate. ENV VIRTUAL_ENV /env ENV PATH /env/bin:$PATH ADD requirements.txt /app/ RUN pip install -r requirements.txt ADD . /app/ CMD NEW_RELIC_CONFIG_FILE=newrelic.ini newrelic-admin run-program gunicorn -b :$PORT main:app # [END dockerfile] 4. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud app deploy Wait until the deployment completes. To open the app in the browser, run the following command: gcloud app browse To view your GAE flex app data, go to the APM Summary page. Recommendation: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in APM. Recommendation: Configure your app.yaml to disable health checks by adding: health_check: enable_health_check: False Get agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect Python agent logs to Stackdriver in the Cloud Platform Console, add the following statement to the newrelic.ini configuration: log_file = stderr To view the logs, use the Cloud Platform Console's Log Viewer. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 22.413319,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Deploy</em> using GAE&#x27;s native support",
        "info": "How to install your Python <em>app</em> in the Google <em>App</em> Engine (GAE) flexible environment. ",
        "body": " explains how to <em>add</em> agent data to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime <em>Deploy</em> using GAE&#x27;s native support When using Google <em>App</em> Engine &quot;native mode&quot; installation, you provide"
      },
      "id": "5f3fb624196a672fda1cd4a3"
    },
    {
      "category_2": "Installation",
      "nodeid": 13121,
      "sections": [
        "Go agent",
        "Get started",
        "Installation",
        "Configuration",
        "Instrumentation",
        "API guides",
        "Features",
        "Troubleshooting",
        "Install the Go agent in GAE flexible environment",
        "Build a custom runtime using Docker",
        "Recommendation: Disable health checks",
        "Get agent troubleshooting logs from GAE",
        "For more help"
      ],
      "title": "Install the Go agent in GAE flexible environment",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Go agent",
      "external_id": "d6409627d1a1d951d544a84613ad1709456f4560",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/go-agent/installation/install-go-agent-gae-flexible-environment",
      "published_at": "2020-09-27T15:48:12Z",
      "updated_at": "2020-08-15T09:48:00Z",
      "breadcrumb": "Contents / APM agents / Go agent / Installation",
      "document_type": "page",
      "popularity": 1,
      "info": "How to install your New Relic's Go app in the Google App Engine (GAE) flexible environment. ",
      "body": "With our Go agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. Here we explain how to add New Relic to your GAE flex app by configuring a custom runtime, and give an example of deploying a Go app with Docker. The Go agent can run in a GAE flexible environment using a custom runtime. Due to limitations of other environments, do not use the GAE standard environment or Google App Engine's \"native mode\" installation. Build a custom runtime using Docker See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by installing the Go agent, building a custom Go runtime for Docker, and deploying a golang application. For more information about deploying and configuring your Go app in the GAE flexible environment, see: Google App Engine's documentation for Go Google App Engine's tutorials to deploy a Go app 1. Set up the GAE project and install dependencies Follow standard procedures to install the Go agent for your specific app server, including your license key. Follow Google App Engine procedures for Go to create a new Cloud Platform project, create an App Engine application, download and install git, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex 3. Configure a Dockerfile The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. The following Dockerfile example code defines the golang version used. FROM golang:1.8-onbuild CMD go run main.go 4. Build a Docker image To build the Docker image, run the following command. Be sure to include the period at the end of the code, to indicate the current directory contains the build files. docker build --rm -t Docker-image-name . 5. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud --project go-app-name app deploy Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Recommendation: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in APM. Recommendation: Configure your app.yaml to disable health checks by adding: health_check: enable_health_check: False Get agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see GAE's documentation for debugging an instance. To redirect New Relic Go agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.yml file to: log_file_name: STDOUT For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 20.43899,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "How to install your New Relic&#x27;s Go <em>app</em> in the Google <em>App</em> Engine (GAE) flexible environment. ",
        "body": " command line tool to manage and <em>deploy</em> GAE <em>apps</em>. 2. Configure your <em>app</em>.yaml The <em>app</em>.yaml configuration file is required for a GAE flexible environment <em>app</em> with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex 3. Configure a Dockerfile The Dockerfile defines the Docker"
      },
      "id": "5f37af50196a67d8f955e63e"
    }
  ],
  "/automate-workflows/get-started-new-relic-cli": [
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-09-29T01:40:52Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-27T01:38:35Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 16 Days : 22 Hours : 10 Minutes : 8 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 20 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.4864,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Set up New Relic using Helm charts",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Set up New Relic using Terraform"
      ],
      "published_at": "2020-09-29T01:47:50Z",
      "title": "Automate workflows",
      "updated_at": "2020-09-25T01:49:59Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 20 min Set up New Relic using Terraform Learn how to provision New Relic resources using Terraform",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.229,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using Helm charts",
        "body": " it is to leverage automation in your DevOps environment! 20 min Set up <em>New</em> <em>Relic</em> using the Kubernetes operator Learn how to provision <em>New</em> <em>Relic</em> resources using the Kubernetes operator 20 min Automate common tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> 20 min Set up <em>New</em> <em>Relic</em> using Terraform Learn how to provision <em>New</em> <em>Relic</em> resources using Terraform"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Alerts release notes",
      "nodeid": 40771,
      "sections": [
        "New Relic Platform release notes",
        "Alerts release notes",
        "APM release notes",
        "Cloud Integrations release notes",
        "Diagnostics release notes",
        "Mobile release notes",
        "Kubernetes integration release notes",
        "09-25-2020 : Entity Tags on Violations for Cloud Integrations",
        "Component: Violation Tags",
        "Update:"
      ],
      "title": "09-25-2020 : Entity Tags on Violations for Cloud Integrations",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "New Relic Platform release notes",
      "external_id": "a298fdb1da8f5f032a0655ecb9b91fdb418a25c8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/platform-release-notes/alerts-release-notes/09-25-2020-entity-tags-violations-cloud-integrations",
      "published_at": "2020-09-29T22:49:23Z",
      "updated_at": "2020-09-29T16:10:16Z",
      "breadcrumb": "Contents / New Relic Platform Release Notes / Alerts release notes",
      "document_type": "release_notes_platform",
      "popularity": 1,
      "body": "[RSS] Released on:  September 25, 2020 Component: Violation Tags Update: We are now adding entity tag data to the violations from cloud integrations. We are now enriching violations with entity tags for the following alert conditions and entity types NRQL Conditions - ONLY when adding \"facet entity.guid\" to your NRQL query APM Conditions Synthetic Conditions Infrastructure : Cloud Integrations Infrastructure On-Host Integrations: only for the following types: HOST KafkaBroker KafkaTopic OracleDbInstance MssqlInstance ElasticsearchNode RabbitMqCluster RabbitMqExchange RabbitMqQueue RabbitMqNode KubernetesCluster AwsEcsCluster VarnishInstance MemcachedInstance CouchbaseBucket CouchbaseNode CouchbaseCluster CouchbaseQueryEngine PostgreSQLInstance F5System F5VirtualServer F5PoolMember F5Pool F5Node ConsulAgent CassandraNode RedisInstance ApacheServer NGINXServer MySQLNode VSphereHost VSphereVm VSphereResourcePool VSphereDatastore VSphereCluster VSphereDatacenter WindowsService",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.40503,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "09-25-2020 : <em>Entity</em> <em>Tags</em> on Violations for Cloud Integrations",
        "sections": "09-25-2020 : <em>Entity</em> <em>Tags</em> on Violations for Cloud Integrations",
        "category_1": "<em>New</em> <em>Relic</em> Platform release notes",
        "body": "[RSS] Released on:  September 25, 2020 Component: Violation <em>Tags</em> Update: We are now adding <em>entity</em> <em>tag</em> data to the violations from cloud integrations. We are now enriching violations with <em>entity</em> <em>tags</em> for the following alert conditions and <em>entity</em> types NRQL Conditions - ONLY when adding &quot;facet",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> Platform Release Notes &#x2F; Alerts release notes"
      },
      "id": "5f735c6928ccbc5f5d337dbb"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Note",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-09-29T01:47:53Z",
      "updated_at": "2020-08-14T01:45:08Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). # Create the tutorial account for the US region newrelic profiles add -n tutorial --apiKey API_KEY -r us # Set the profile as default newrelic profiles default -n tutorial Copy Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. # Change the `name` to match any of your existing entities newrelic entity search --name \"test\" Copy Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Note Adding tags is an asynchronous operation: it could take a little while for the tags to get created. # Adding a single tag newrelic entity tags create --guid GUID --tag key:value # Adding multiple tags newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Copy Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.10667,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Quickly <em>tag</em> a set of resources",
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Add <em>tags</em> to applications you instrument for easier filtering and organization.",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " by invoking the <em>entity</em> <em>tags</em> delete command followed by the same arguments you used to create them. [ { <em>Key</em>: &#x27;<em>tag</em>1&#x27;, Values: [&#x27;true&#x27;], }, { <em>Key</em>: &#x27;<em>tag</em>2&#x27;, Values: [&#x27;test&#x27;], }, { <em>Key</em>: &#x27;<em>tag</em>3&#x27;, Values: [&#x27;testing&#x27;], }, &#x2F;&#x2F; ... ]; Copy Next steps Have a look at all the <em>New</em> <em>Relic</em> <em>CLI</em> commands. For example"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "category_2": "Logs in context for Ruby",
      "nodeid": 35726,
      "sections": [
        "Enable log management",
        "New Relic Logs",
        "Enable log monitoring",
        "Configure logs in context",
        "Logs in context for Go",
        "Logs in context for Java",
        "Logs in context for .NET",
        "Logs in context for Node.js",
        "Logs in context for PHP",
        "Logs in context for Python",
        "Logs in context for Ruby",
        "Logs in context with agent APIs",
        "Configure logs in context for Ruby",
        "Compatibility and requirements",
        "Configure logs in context with log management",
        "Install or update the Ruby agent",
        "Configure for Rails",
        "Rails advanced configuration",
        "Configure for Ruby without Rails",
        "Advanced configuration",
        "Custom logger configuration",
        "Lograge configuration",
        "Check for logging data",
        "Troubleshooting",
        "Incompatible gems",
        "What's next?",
        "For more help"
      ],
      "title": "Configure logs in context for Ruby",
      "category_0": "Log management",
      "type": "docs",
      "category_1": "Enable log management",
      "external_id": "39429728c3bc0c83479db2ebe30dee4a31efd2b3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/enable-log-management-new-relic/logs-context-ruby/configure-logs-context-ruby",
      "published_at": "2020-09-27T23:26:05Z",
      "updated_at": "2020-09-27T23:26:05Z",
      "breadcrumb": "Contents / Log management / Enable log management / Logs in context for Ruby",
      "document_type": "page",
      "popularity": 1,
      "info": "A description of the logs in context configuration process for the Ruby agent.",
      "body": "Logs in context for the Ruby agent connects your logs and APM data in New Relic, giving full context to high-level events and providing high value data to specific log lines. Read on to learn how to configure logs in context and enrich your log data. Compatibility and requirements To use log management with the Ruby agent, ensure your configuration meets the following requirements: Ruby agent 6.7.0 or higher: Install or update Supported Rails version (for Rails applications) Configure logs in context with log management To configure logs in context with Ruby: Enable log management with a compatible log forwarding plugin. Install or update the Ruby agent. Configure logs in context for Ruby. Optional: Advanced configuration. Check for logging data. Enable log management Confirm that you have log management enabled, with a compatible log forwarding plugin installed to send your application logs to New Relic. Install or update the Ruby agent Install or update to the most recent Ruby agent version, and enable distributed tracing. Configure logs in context for Ruby Configure for Rails Rails logging is controlled by two components: a logger (customizable by setting config.logger) and a log formatter (customizable by setting config.log_formatter). In most cases, logs in context should be configured by setting config.log_formatter to the DecoratingFormatter in your Rails application. For more guidance regarding Rails configuration, see Configuring Rails Applications. In your application's config, require 'newrelic_rpm', then add the following line: module ________ class Application < Rails::Application ... config.log_formatter = ::NewRelic::Agent::Logging::DecoratingFormatter.new end end This will use the New Relic formatter to format log messages, but the rest of the logging configuration will be provided by the other Rails config settings. Please note that Logs in Context for Ruby does not currently support tagged logging; if you are initializing your logger with a log_tags argument, your custom tags may not appear on the final version of your logs. Rails advanced configuration If setting the log_formatter option doesn't meet your needs, replace the entire Rails logger with an instance of the New Relic logger. Provide the parameters to the logger's constructor, like this: module ________ class Application < Rails::Application ... config.logger = ::NewRelic::Agent::Logging::DecoratingLogger.new( \"log/application.log\", #etc... ) end end Configure for Ruby without Rails For non-Rails applications, use the DecoratingLogger in place of the Ruby standard ::Logger, like this: logger = ::NewRelic::Agent::Logging::DecoratingLogger.new( 'log/application.log', #etc... ) ... logger.info(...) The DecoratingLogger is a drop-in replacement for the Ruby standard ::Logger. Their constructors accept the same parameters. Advanced configuration Custom logger configuration To use our logging extension with a different logging implementation, or your own custom logger, use the DecoratingFormatter. Example: module ________ class Application < Rails::Application ... config.logger = ::YourCustomLoggerImplementation.new( $stdout, formatter: ::NewRelic::Agent::Logging::DecoratingFormatter.new ) end end Lograge configuration To configure this extension with the lograge gem, there is no additional configuration required. Check for logging data If you have configured your logging in /config/application.rb, or in /config/environments/development.rb, run your application locally and check its logging output. You should see some output like this: {\"entity.name\":\"your_app_name\",\"entity.type\":\"SERVICE\",\"hostname\":\"79bcbf8d\",\"trace.id\":\"79bcbf8d\",\"span.id\":\"00fc7d46\",\"timestamp\":1567701375543,\"message\":\"example log message one\",\"log.level\":\"DEBUG\"} {\"entity.name\":\"your_app_name\",\"entity.type\":\"SERVICE\",\"hostname\":\"79bcbf8d\",\"trace.id\":\"79bcbf8d\",\"span.id\":\"6754870b\",\"timestamp\":1567702843604,\"message\":\"example log message two\",\"log.level\":\"DEBUG\"} If you have deployed this application to an environment with a log forwarder, your application's logs will appear in the New Relic Logs UI with metadata linking them to a trace and a span. You can find them using a query like this: entity.name:\"your_app_name\" has:trace.id If you see JSON logs in your application's output, but no logs returned by a query like the above, check your log forwarder. Troubleshooting If the logs from your application are not formatted in JSON with fields like trace.id and span.id, there may be a problem with the configuration of the New Relic Logging Extension. Check that: the application is using a supported logging framework. the configuration has been applied to all the environments where you would like to use the New Relic Logging Extension. there is not another logger configured later in the configuration of the application. Incompatible gems The New Relic decorating logger is known to be incompatible with the following gems: logging semantic logger rails_stdout_logger rails_12factor What's next? Now that you've set up APM logs in context, here are some potential next steps: Explore your data using the Logs UI. Troubleshoot errors with distributed tracing, stack traces, application logs, and more. Query your data and create custom dashboards or alerts. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.79953,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> Logs",
        "body": "Logs in context for the Ruby agent connects your logs and APM data in <em>New</em> <em>Relic</em>, giving full context to high-level events and providing high value data to specific log lines. Read on to learn how to configure logs in context and enrich your log data. Compatibility and requirements To use log"
      },
      "id": "5f37c37164441ffb9aa0a5f1"
    }
  ],
  "/explore-docs/nr1-cli": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-nerdpack/",
      "sections": [
        "New Relic One CLI Nerdpack commands",
        "Command details",
        "nr1 nerdpack:build",
        "Builds a Nerdpack",
        "Usage",
        "Options",
        "nr1 nerdpack:clone",
        "Clone an existing Nerdpack",
        "nr1 nerdpack:serve",
        "Serve your Nerdpack locally",
        "nr1 nerdpack:uuid",
        "Get your Nerdpack's UUID",
        "nr1 nerdpack:publish",
        "Publish your Nerdpack",
        "nr1 nerdpack:deploy",
        "Deploy your Nerdpack to a channel",
        "nr1 nerdpack:undeploy",
        "Undeploy your Nerdpack",
        "nr1 nerdpack:clean",
        "Removes all built artifacts",
        "nr1 nerdpack:validate",
        "Validates artifacts inside your Nerdpack",
        "nr1 nerdpack:Info",
        "Shows the state of your Nerdpack in the New Relic's registry"
      ],
      "published_at": "2020-09-29T01:54:07Z",
      "title": "New Relic One CLI Nerdpack commands",
      "updated_at": "2020-09-17T01:49:55Z",
      "type": "developer",
      "external_id": "7c1050a6a8624664b90c15111f7c72e96b2fbe17",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI commands you can use to set up your New Relic One Nerdpacks.",
      "body": "New Relic One CLI Nerdpack commands To set up your Nerdpacks, use the commands below. You can click any command to see its usage options and additional details about the command. Command Description nr1 nerdpack:build Assembles your Nerdpack into bundles nr1 nerdpack:clone Clones a Nerdpack from a git repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your development folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Command details nr1 nerdpack:build Builds a Nerdpack Runs a webpack process to assemble your Nerdpack into javascript and CSS bundles. As many other CLI commands, it should be run at the package.json level of your Nerdpack. Usage $ nr1 nerdpack:build OPTION Options --extra-metadata-path=extra-metadata-path Specify a json file path with extra metadata. [default: extra-metadata.json] --prerelease=prerelease If specififed, the value will be appended to the current version of generated files. ie: --prerelease=abc. Then the version will be \"1.2.3-abc\". --profile=profile The authencation profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:clone Clone an existing Nerdpack Duplicates an existing Nerdpack onto your local computer. You can clone an open source Nerdpack from our Open Source GitHub repositories. After choosing a git repository, this command performs the following actions so that you can start using the Nerdpack: Clones the repository. Sets the repository as remote upstream. Installs all of its dependencies (using npm). Generates a new UUID using your profile, and commits it. Usage $ nr1 nerdpack:clone OPTION Options -r, --repo=REPO Repository location (either an HTTPS or SSH path). (Required) -p, --path=PATH Determines the directory to clone to (defaults to the repository name). -f, --force Replaces destination folder if it exists. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:serve Serve your Nerdpack locally Launches a server with your Nerdpack locally on the New Relic One platform, where it can be tested live. To learn more about working with apps locally, see our guide on how to serve, publish, and deploy documentation. Usage $ nr1 nerdpack:serve Options --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:uuid Get your Nerdpack's UUID Prints the UUID (Universal Unique ID) of your Nerdpack, by default. The UUID determines what data the Nerdpack can access and who can subscribe to the Nerdpack. To deploy a Nerdpack you didn't make, you'll have to assign it a new UUID by using the -g or --generate option. For more details, see our GitHub workshop on GitHub. Usage $ nr1 nerdpack:uuid Options --profile=PROFILE The authentication profile you want to use. -f, --force If present, it will override the existing UUID without asking. -g, --generate Generates a new UUID if not available. --verbose Adds extra information to the output. nr1 nerdpack:publish Publish your Nerdpack Publishes your Nerdpack to New Relic. Please note: If no additional parameters are passed in, this command will automatically deploy the Nerdpack onto the DEV channel. If you want to specify your own list of deploy channels, add the --channel option. For example, $ nr1 nerdpack:publish --channel BETA --channel STABLE. If you want to disable this behavior, add -D or --skip-deploy to the command. Then, you can use nr1 nerdpack:deploy to perform a deploy manually. For more on publishing and deploying, see Deploy to New Relic One. Usage $ nr1 nerdpack:publish Options -B, --skip-build Skips the previous build process. -D, --skip-deploy Skips the following deploy process. -c, --channel=DEV/BETA/STABLE Specifies the channel to deploys to. [default: STABLE] -f, --force Forces the publish, overriding any existing version in the registry. --dry-run Undergoes publishing process without actually publishing anything. --extra-metadata-path=extra-metadata-path Specifies a json file .path with extra metadata. [default: extra-metadata.json] --prerelease=STRING The value you enter will be appended to the current version of generated files. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:deploy Deploy your Nerdpack to a channel Deploys a Nerdpack version to a specific channel (DEV, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. For more on publishing and deploying, see Deploy to New Relic One. Usage $ nr1 nerdpack:deploy OPTION Options -c, --channel=DEV/BETA/STABLE Specifies the channel to deploy to. (required) -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to deploy. By default, the command will use the one in package.json. --from-version=VERSION Specifies which version to deploy. By default, the command will use the one in package.json. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:undeploy Undeploy your Nerdpack Undeploys a Nerdpack version from a specific channel (for example, DEV, BETA, or STABLE). Usage $ nr1 nerdpack:undeploy OPTION Options -c, --channel=DEV/BETA/STABLE Specifies the channel to undeploy from. (required) -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to deploy. By default, the command will use the one in package.json. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:clean Removes all built artifacts Cleans and removes the content and the developtment folders (dist/, tmp/). Usage $ nr1 nerdpack:clean OPTION Options --profile=profile The authentication profile you want to use --verbose Adds extra information to the output. nr1 nerdpack:validate Validates artifacts inside your Nerdpack Validates artifacts inside your Nerdpack. Usage $ nr1 nerdpack:validate OPTION Options -l, --force-local The authentication profile you want to use. -r, --force-remote Force download of new schema files. --profile=profile The authentication profile you want to uset. --verbose Adds extra information to the output. nr1 nerdpack:Info Shows the state of your Nerdpack in the New Relic's registry Shows the state of your Nerdpack in the New Relic's registry. The default amount of versions shown is 10 but all versions can be shown if the --all (or -a) flag is used Usage $ nr1 nerdpack:info OPTION Options -a, --all Show all versions. -i, --nerdpack-id=nerdpack-id Get info from the specified Nerdpack instead of local one. --profile=profile The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.973175,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> CLI <em>Nerdpack</em> <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> CLI <em>Nerdpack</em> <em>commands</em>",
        "info": "An overview of the CLI <em>commands</em> you can use to set up your <em>New</em> <em>Relic</em> <em>One</em> <em>Nerdpacks</em>.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> CLI <em>Nerdpack</em> <em>commands</em> To set up your Nerdpacks, use the <em>commands</em> below. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 <em>nerdpack</em>:build Assembles your <em>Nerdpack</em> into bundles nr1 <em>nerdpack</em>:clone Clones a <em>Nerdpack</em> from"
      },
      "id": "5f28bd6a64441f9817b11a38"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-09-08T01:50:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users's configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { 'YourNerdpackUuid': { 'collection-1': { 'document-1-of-collection-1': '{\"lastNumber\": 42, \"another\": [1]}', 'document-2-of-collection-1': '\"userToken\"', // ... }, 'another-collection': { 'fruits': '[\"pear\", \"apple\"]', // ... }, // ... }, } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.02928,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use NerdStorage in your <em>apps</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "Intro to NerdStorage 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "Intro to New Relic One API components",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One API components",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2020-09-29T01:52:56Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One API components",
      "body": "Intro to New Relic One API components To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.373856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>New</em> <em>Relic</em> <em>One</em> API components",
        "sections": "Intro to <em>New</em> <em>Relic</em> <em>One</em> API components",
        "info": "Intro to <em>New</em> <em>Relic</em> <em>One</em> API components",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>",
        "body": "Intro to <em>New</em> <em>Relic</em> <em>One</em> API components To help you build <em>New</em> <em>Relic</em> <em>One</em> applications, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-09-29T01:48:49Z",
      "updated_at": "2020-08-26T01:47:20Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 52.97452,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Prepare to build or modify <em>apps</em>",
        "info": "Prepare to build <em>apps</em> and contribute to this site",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> CLI",
        "body": "Set up your development environment 20 min If you&#x27;ve decided to build a custom <em>app</em> or modify <em>one</em> of our open source apps, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> <em>command</em> line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your <em>app</em>"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-08-14T01:49:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Copy Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 48.42403,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> file structure",
        "sections": "<em>Nerdpack</em> file structure",
        "info": "An overview of the <em>Nerdpack</em> File Structure",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> CLI",
        "body": " components, see our <em>app</em> building guides and the <em>New</em> <em>Relic</em> <em>One</em> CLI <em>command</em> reference. <em>Nerdpack</em> file structure When you generate a <em>Nerdpack</em> template using the nr1 create <em>command</em>, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png"
      },
      "id": "5efa989e196a671300766404"
    }
  ],
  "/build-apps/howto-use-nrone-table-components": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/table-header-cell/",
      "sections": [
        "TableHeaderCell",
        "Usage",
        "Props"
      ],
      "published_at": "2020-09-29T01:51:51Z",
      "title": "TableHeaderCell",
      "updated_at": "2020-08-03T04:46:36Z",
      "type": "developer",
      "external_id": "2a4be1419d1a6e501a8eed915b8acf7c9798259d",
      "document_type": "page",
      "popularity": 1,
      "info": "A TableHeaderCell component!",
      "body": "TableHeaderCell Usage Copy Props There are no props for this component.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 529.6985,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>TableHeaderCell</em>",
        "sections": "<em>TableHeaderCell</em>",
        "info": "A <em>TableHeaderCell</em> <em>component</em>!",
        "body": "<em>TableHeaderCell</em> Usage Copy Props There are no props for this <em>component</em>."
      },
      "id": "5efa9906196a67523e76646e"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/table-row/",
      "sections": [
        "TableRow",
        "Usage",
        "Props"
      ],
      "published_at": "2020-09-29T01:52:56Z",
      "title": "TableRow",
      "updated_at": "2020-08-03T04:45:42Z",
      "type": "developer",
      "external_id": "b9ca0d4e07a506dd961eb2194c5344bfa9ab770d",
      "document_type": "page",
      "popularity": 1,
      "info": "A TableRow component!",
      "body": "TableRow Usage Copy Props There are no props for this component.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 433.51154,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>TableRow</em>",
        "sections": "<em>TableRow</em>",
        "info": "A <em>TableRow</em> <em>component</em>!",
        "body": "<em>TableRow</em> Usage Copy Props There are no props for this <em>component</em>."
      },
      "id": "5efa98d564441f93435f7e24"
    },
    {
      "category_2": "Cloud adoption",
      "nodeid": 16121,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Create application baselines",
        "1. Identify components",
        "2. Determine compatibility",
        "3. Deploy monitoring",
        "4. Gather metrics",
        "5. Set up Dashboards",
        "Expert tips",
        "For more help"
      ],
      "title": "Create application baselines",
      "category_0": "New Relic solutions",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "e971df6f5f6a6360b22e2929f33f9d7af6ff130f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/create-application-baselines",
      "published_at": "2020-09-27T20:07:57Z",
      "updated_at": "2020-09-27T20:07:57Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Cloud adoption",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic to establish a baseline to use for comparison during your cloud adoption process.",
      "body": "Cloud migrations can take many forms. Some companies choose to port their applications directly from their data center to the cloud (a “Lift and Shift” migration) while others focus on completely re-architecting their applications to take advantage of benefits available only in the cloud. No matter your approach, there are three primary questions you want to answer after your migration: Has my application gotten slower? Is my application less stable than before? Am I losing customers due to either of the previous questions? To answer these questions, start by performing some basic testing to establish a baseline for the performance and availability of your systems. A baseline is a measurement of the current performance and availability of your application, which you then use as a comparison after your migration to validate your business case. In some cases, you may change a baseline when you perform migration acceptance testing. You can also use a baseline as a comparison point during your migration to make sure that you are on track. 1. Identify components Before you begin a cloud migration, identify all the tiers of your entire application stack. List all of the components (applications, services, etc.) that you want to migrate. Segment the application stack as follows: Application (backend/microservices/cron jobs) Dependency services, such as the message queue Database Website Underlying server and infrastructure Make sure that you have access to applications and instances before you start creating application baselines. Engage your application owners, DevOps engineers, and product managers for access. Example: List of components Here is an example of the list of components in an application stack: Component Name Owner Language Stack Accessibility (Internet, Intranet) Operating System Service 1 John Doe Java Internet RHEL 6 Service 2 Maya Wiz .NET Intranet Win2003 R2 RabbitMQ John Doe Java Intranet AIX Website Maya Wiz Classic ASP Internet Win2000 MS SQL Dave Z NA Intranet Win2003 R2 2. Determine compatibility Once you identify the applications that you want to migrate, it is time to verify which application tiers to monitor with the New Relic platform. Work with stakeholders in your organization to determine the amount of instrumentation that is possible–or allowed–within your organization. This is an important step and one that will pay off, as the more you can instrument, the better your baselines. Here are the New Relic products to use for baselining, depending on the components that you identified: New Relic APM: Monitor your web apps with New Relic APM. See Compatibility and requirements for New Relic agents and products to learn precise compatibility details for each supported language. New Relic Infrastructure: Monitor your hosts with New Relic Infrastructure. See Compatibility and requirements for New Relic Infrastructure for supported operating systems and environments. You can also instrument other products and services with on-host integrations. New Relic Synthetics: Monitor web frontends and APIs with New Relic Synthetics. Sometimes, you may not be able to instrument your on-premise environment with APM or Infrastructure. For example, maybe your organization's policy forbids installing an agent behind a firewall. In these cases, if the application has a web frontend, use Synthetics, as it offers non-agent monitoring while still providing the ability to establish a baseline. Example: Components matched to New Relic products Match the components that you identified with their corresponding products: Component Name Tier Owner Language Stack Accessibility (Internet/ Intranet) Operating System New Relic Products Service 1 John Doe Java Internet RHEL 6 APM, Infrastructure, Synthetics Service 2 Maya Wiz .NET Intranet Win2003 R2 APM, Infrastructure ActiveMQ John Doe Java Intranet AIX APM, Plugin Website Maya Wiz Classic ASP Internet Win2000 Synthetics MS SQL Dave Z n/a Intranet Win2003 R2 Infrastructure, On-host Integration 3. Deploy monitoring Based on the component-product matches you made, deploy agents or monitors across your architecture: Deploy New Relic APM Install the APM agent on your application stack. The steps to install the APM agent are different based on language. Deploy New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, follow the instructions to install the Infrastructure agent on your hosts: Install for Linux Install for Windows Server Install on AWS Elastic Beanstalk Install with a configuration management tool Deploy Infrastructure on-host integrations To gain extended visibility into applications that your code depends on, deploy on-host integrations. Available integrations include Apache, MySQL, NGINX, and others. Create New Relic Synthetics monitors New Relic Synthetics is a suite of automated, scriptable tools to monitor your websites, critical business transactions, and API endpoints. To get started add a monitor. Make sure to verify that your website URL is accessible from the public network. You may also need to add New Relic IPs to your allow list. 4. Gather metrics After you deploy the agents and monitors, identify which metrics are the most important to your business and use these metrics to define your KPIs. Some recommendations include: Response time: Time taken to respond to a request. Throughput: Number of requests that came in through the application. Requesting queuing (Apache, IIS, NGINX): Duration of time taken for a request to reach your application. Database call duration: Duration of time taken to complete a database call. DB call counts: Number of calls made by application code to the database. Error rate: Percent of errors reported. Apdex score: An industry standard to measure user satisfaction with the response time of web applications and services. DNS setup timing: The time it takes to connect and receive data from DNS. SSL setup timing: The time it takes to establish an SSL connection. You can find some of these metrics in service maps, as well as on APM, and Browser overview pages. For more detailed information about navigating, interpreting, and using New Relic APM, check out these New Relic University’s tutorials: Overview dashboard tour Transactions dashboard Understanding Apdex 5. Set up Dashboards After you define your KPIs, it is easy to visualize them in New Relic Dashboards. Dashboards provide a single location to view all the data that New Relic products gather. Dashboards data consists of events, and each event has an event type, a timestamp, and key-value attributes. For more information about events, see Data collection and Default events for New Relic products. You can locate your KPIs and business metrics data in New Relic using the data explorer and the NRQL query language. You can also build Dashboards to track the performance of those KPIs: Example: Component performance compared against baselines Continuing the examples in this document, the following table illustrates the maturity of your application performance over a period of time based on deployment milestones. Each milestone will serve as a new baseline for your applications: Component Milestone 1 Milestone 2 Milestone N Environment Component Name Response Time SLA Apdex Response Time SLA Apdex Response On-Prem Service 1 1.5 secs 80% 70% 1.5 secs 68% 0.65 1.4 secs Cloud Service 1 0.9 secs 96.8% 95% 0.9 secs 98% 0.99 0.7 secs On-Prem Service 2 0.7 secs 73% 68% 0.7 secs 80% 0.78 0.85 secs Cloud Service 2 0.6 secs 90% 92% 0.6 secs 89% 0.90 0.5 secs After your migration, compare these baselines against your migration acceptance testing baselines. Expert tips If you find that you need data that is not captured by default instrumentation, New Relic makes it easy to capture custom data: APM custom instrumentation Browser custom data Infrastructure custom attributes Custom event data Mobile custom data Synthetics custom attributes You can also learn more about APM custom instrumentation with the New Relic University Custom data tutorial series. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 382.21042,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>application</em> baselines",
        "sections": "1. Identify <em>components</em>",
        "info": "Use New <em>Relic</em> to establish a baseline to use for comparison during your cloud adoption process.",
        "category_0": "New <em>Relic</em> solutions",
        "category_1": "New <em>Relic</em> solutions",
        "body": " ASP Internet Win2000 Synthetics MS SQL Dave Z n&#x2F;a Intranet Win2003 <em>R</em>2 Infrastructure, On-host Integration 3. Deploy monitoring Based on the <em>component</em>-product matches you made, deploy agents or monitors across your architecture: Deploy New Relic APM Install the APM agent on your application stack"
      },
      "id": "5ad48685c75d0766faa181bd"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Create a \"Hello, World!\" application",
        "Permissions for managing applications",
        "Set up your development environment",
        "Add, query, and mutate data using NerdStorage",
        "Add the NerdGraphQuery component to an application",
        "Add a time picker to your app",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps"
      ],
      "published_at": "2020-09-29T01:47:50Z",
      "title": "Build apps",
      "updated_at": "2020-09-25T01:49:59Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One   Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 20 min Add a time picker to your app Add a time picker to a sample application 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 333.08667,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add the NerdGraphQuery <em>component</em> to an <em>application</em>",
        "body": " <em>app</em> Add a time picker to a sample application 30 min Add a <em>table</em> to your <em>app</em> Add a <em>table</em> to your New Relic One <em>app</em> 30 min Create a custom map view Build an <em>app</em> to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Map page views by region in a custom app",
        "Before you begin",
        "New Relic terminology",
        "Build a custom app with a table chart",
        "Query your browser data",
        "Create and serve a new Nerdpack",
        "Review your app files and view your app locally",
        "Hard code your account ID",
        "Import the TableChart component",
        "Add a table with a single row",
        "Customize the look of your table (optional)",
        "Get your data into that table",
        "Make your app interactive with a text field",
        "Import the TextField component",
        "Add a row for your text field",
        "Build the text field object",
        "Get your data on a map",
        "Install Leaflet",
        "Add a webpack config file for Leaflet",
        "Import modules from Leaflet",
        "Import additional modules from New Relic One",
        "Get data for the map",
        "Customize the map marker colors",
        "Set your map's default center point",
        "Add a row for your map",
        "Replace \"Hello\" with the Leaflet code"
      ],
      "title": "Map page views by region in a custom app",
      "type": "developer",
      "tags": [
        "custom app",
        "map",
        "page views",
        "region",
        "nerdpack"
      ],
      "external_id": "6ff5d696556512bb8d8b33fb31732f22bab455cb",
      "image": "https://developer.newrelic.com/static/d87a72e8ee14c52fdfcb91895567d268/0086b/pageview.png",
      "url": "https://developer.newrelic.com/build-apps/map-pageviews-by-region/",
      "published_at": "2020-09-29T01:47:51Z",
      "updated_at": "2020-09-17T01:48:42Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a New Relic app showing page view data on a world map.",
      "body": "Map page views by region in a custom app 30 min New Relic has powerful and flexible tools for building custom apps and populating them with data. This guide shows you how to build a custom app and populate it with page view data using New Relic's Query Language (NRQL - pronounced 'nurkle'). Then you make your data interactive. And last, if you have a little more time and want to install a third-party React library, you can display the page view data you collect on a map of the world. In this guide, you build an app to display page view data in two ways: In a table On a map Please review the Before you begin section to make sure you have everything you need and don't get stuck halfway through. Before you begin In order to get the most out of this guide, you must have: A New Relic developer account, API key, and the command-line tool. If you don't have these yet, see the steps in Setting up your development environment New Relic Browser page view data to populate the app. Without this data, you won't be able to complete this guide. To add your data to a world map in the second half of the guide: npm, which you'll use during this section of the guide to install Leaflet, a third-party JavaScript React library used to build interactive maps. If you're new to React and npm, you can go here to install Node.js and npm. New Relic terminology The following are some terms used in this guide: New Relic application: The finished product where data is rendered in New Relic One. This might look like a series of interactive charts or a map of the world. Nerdpack: New Relic's standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see Nerdpack file structure. Launcher: The button on New Relic One that launches your application. Nerdlets: New Relic React components used to build your application. The three default files are index.js, nr1.json, and styles.scss, but you can customize and add your own. Build a custom app with a table chart Step 1 of 8 Query your browser data Use Query builder to write a NRQL query to see your page view data, as follows. On New Relic One, select Query your data (in the top right corner). That puts you in NRQL mode. You'll use NRQL to test your query before dropping the data into your table. Copy and paste this query into a clear query field, and then select Run. FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000 Copy If you have PageView data, this query shows a week of average page views broken down by country and limited to a thousand items. The table will be full width and use the \"chart\" class defined in the CSS. If you don't have any results at this point, ensure your query doesn't have any errors. If your query is correct, you might not have the Browser agent installed. Step 2 of 8 Create and serve a new Nerdpack To get started, create a new Nerdpack, and serve it up to New Relic from your local development environment: Create a new Nerdpack for this app: nr1 create --type nerdpack --name pageviews-app Copy Serve the project up to New Relic: cd pageviews-app && nr1 nerdpack:serve Copy Step 3 of 8 Review your app files and view your app locally Navigate to your pageviews-app to see how it's structured. It contains a launcher folder, where you can customize the description and icon that will be displayed on the app's launcher in New Relic One. It also contains nerdlets, which each contain three default files: index.js, nr1.json, and styles.scss. You'll edit some of these files as part of this guide. For more information, see Nerdpack file structure. Now in your browser, open https://one.newrelic.com/?nerdpacks=local, and then click Apps to see the pageview-apps Nerdpack that you served up. When you select the launcher, you see a Hello message. Step 4 of 8 Hard code your account ID For the purposes of this exercise and for your convenience, hard code your account ID. In the pageview-app-nerdlet directory, in the index.js file, add this code between the import and export lines. (Read about finding your account ID here). const accountId = [Replace with your account ID]; Copy Step 5 of 8 Import the TableChart component To show your data in a table chart, import the TableChart component from New Relic One. To do so, in index.js, add this code under import React. import { TableChart } from 'nr1'; Copy Step 6 of 8 Add a table with a single row To add a table with a single row, in the index.js file, replace this line: return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; Copy with this export code: export default class PageViewApp extends React.Component { render() { return ( <div className=\"container\"> <div className=\"row\"></div> </div> ); } } Copy Step 7 of 8 Customize the look of your table (optional) You can use standard CSS to customize the look of your components. In the styles.scss file, add this CSS. Feel free to customize this CSS to your taste. .container { width: 100%; height: 99vh; display: flex; flex-direction: column; .row { margin: 10px; display: flex; flex-direction: row; } .chart { height: 250px; } } Copy Step 8 of 8 Get your data into that table Now that you've got a table, you can drop a TableChart populated with data from the NRQL query you wrote at the very beginning of this guide. Put this code into the row div. <TableChart accountId={accountId} query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} fullWidth className=\"chart\" />; Copy Go to New Relic One and click your app to see your data in the table. (You might need to serve your app to New Relic again.) Congratulations! You made your app! Continue on to make it interactive and show your data on a map. Make your app interactive with a text field Once you confirm that data is getting to New Relic from your app, you can start customizing it and making it interactive. To do this, you add a text field to filter your data. Later, you use a third-party library called Leaflet to show that data on a world map. Step 1 of 3 Import the TextField component Like you did with the TableChart component, you need to import a TextField component from New Relic One. import { TextField } from 'nr1'; Copy Step 2 of 3 Add a row for your text field To add a text field filter above the table, put this code above the TableChart div. The text field will have a default value of \"US\". <div className=\"row\"> <TextField placeholder=\"US\" onChange={(event) => { this.setState({ countryCode: event.target.value }); }} /> </div>; Copy Step 3 of 3 Build the text field object Above the render() function, add a constructor to build the text field object. constructor(props) { super(props); this.state = { countryCode: null } } Copy Then, add a constructor to your render() function. Above return, add: const { countryCode } = this.state; Copy Now add countryCode to your table chart query. <TableChart accountId={accountId} query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} fullWidth className=\"chart\" />; Copy Reload your app to try out the text field. Get your data on a map To create the map, you use npm to install Leaflet. Step 1 of 9 Install Leaflet In your terminal, type: npm install --save leaflet react-leaflet Copy In your nerdlets styles.scss file, import the Leaflet CSS: @import `~leaflet/dist/leaflet.css`; Copy While you're in styles.scss, fix the width and height of your map: .containerMap { width: 100%; z-index: 0; height: 70vh; } Copy Step 2 of 9 Add a webpack config file for Leaflet Add a webpack configuration file .extended-webpackrc.js to the top-level folder in your nerdpack. This supports your use of map tiling information data from Leaflet. module.exports = { module: { rules: [ { test: /\\.(png|jpe?g|gif)$/, use: [ { loader: 'file-loader', options: {}, }, { loader: 'url-loader', options: { limit: 25000 }, }, ], }, ], }, }; Copy Step 3 of 9 Import modules from Leaflet In index.js, import modules from Leaflet. import { Map, CircleMarker, TileLayer } from 'react-leaflet'; Copy Step 4 of 9 Import additional modules from New Relic One You need several more modules from New Relic One to make the Leaflet map work well. Import them with this code: import { NerdGraphQuery, Spinner, Button, BlockText } from 'nr1'; Copy NerdGraphQuery lets you make multiple NRQL queries at once and is what will populate the map with data. Spinner adds a loading spinner. Button gives you button components. BlockText give you block text components. Step 5 of 9 Get data for the map Using latitude and longitude with country codes, you can put New Relic data on a map. mapData() { const { countryCode } = this.state; const query = `{ actor { account(id: 1606862) { mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : ''} LIMIT 1000 \") { results nrql } } } }`; return query; }; Copy Step 6 of 9 Customize the map marker colors Above the mapData function, add this code to customize the map marker colors. getMarkerColor(measure, apdexTarget = 1.7) { if (measure <= apdexTarget) { return '#11A600'; } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { return '#FFD966'; } else { return '#BF0016'; } }; Copy Feel free to change the HTML color code values to your taste. In this example, #11A600 is green, #FFD966 is sort of yellow, and #BF0016 is red. Step 7 of 9 Set your map's default center point Set a default center point for your map using latitude and longitude. const defaultMapCenter = [10.5731, -7.5898]; Copy Step 8 of 9 Add a row for your map Between the text field row and the table chart row, insert a new row for the map content using NerdGraphQuery. <div className=\"row\"> <NerdGraphQuery query={this.mapData()}> {({ loading, error, data }) => { if (loading) { return <Spinner fillContainer />; } if (error) { return 'Error'; } const { results } = data.actor.account.mapData; console.debug(results); return 'Hello'; }} </NerdGraphQuery> </div>; Copy Reload your application in New Relic One to test that it works. Step 9 of 9 Replace \"Hello\" with the Leaflet code Replace return \"Hello\"; with: return ( <Map className=\"containerMap\" center={defaultMapCenter} zoom={2} zoomControl> <TileLayer attribution='&amp;copy <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\" /> {results.map((pt, i) => { const center = [pt.lat, pt.lng]; return ( <CircleMarker key={`circle-${i}`} center={center} color={this.getMarkerColor(pt.y)} radius={Math.log(pt.x) * 3} onClick={() => { alert(JSON.stringify(pt)); }} /> ); })} </Map> ); Copy This code creates a world map centered on the latitude and longitude you chose using OpenStreetMap data and your marker colors. Reload your app to see the pageview data on the map!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 320.77435,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map page views by <em>region</em> <em>in</em> a custom <em>app</em>",
        "sections": "Import the <em>TableChart</em> <em>component</em>",
        "info": "Build a New <em>Relic</em> <em>app</em> showing page view data on a world map.",
        "tags": "custom <em>app</em>",
        "body": " with a single <em>row</em> To add a <em>table</em> with a single <em>row</em>, in the index.js file, replace this line: return &lt;h1&gt;Hello, pageview-<em>app</em>-nerdlet Nerdlet!&lt;&#x2F;h1&gt;; Copy with this export code: export default class PageView<em>App</em> extends React.<em>Component</em> { render() { return ( &lt;div className=&quot;container&quot;&gt; &lt;div className=&quot;<em>row</em>&quot;&gt;&lt;&#x2F;div"
      },
      "id": "5efa993c196a67066b766469"
    }
  ],
  "/automate-workflows/get-started-kubernetes": [
    {
      "category_2": "Alerts release notes",
      "nodeid": 40776,
      "sections": [
        "New Relic Platform release notes",
        "Alerts release notes",
        "APM release notes",
        "Cloud Integrations release notes",
        "Diagnostics release notes",
        "Mobile release notes",
        "Kubernetes integration release notes",
        "09-28-2020 : Action Required : New Relic One Streaming Alerts for NRQL Conditions",
        "Component: NRQL Conditions (Review Required)",
        "Announcing : New Relic One Streaming Alerts",
        "Please read the full announcement and FAQ here , and follow the links to enroll."
      ],
      "title": "09-28-2020 : Action Required : New Relic One Streaming Alerts for NRQL Conditions",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "New Relic Platform release notes",
      "external_id": "74ae41c7360962287ea605016bf7731035382166",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/platform-release-notes/alerts-release-notes/09-28-2020-action-required-new-relic-one-streaming-alerts-nrql-conditions",
      "published_at": "2020-09-29T22:06:08Z",
      "updated_at": "2020-09-29T22:06:08Z",
      "breadcrumb": "Contents / New Relic Platform Release Notes / Alerts release notes",
      "document_type": "release_notes_platform",
      "popularity": 1,
      "body": "[RSS] Released on:  September 28, 2020 Component: NRQL Conditions (Review Required) Announcing : New Relic One Streaming Alerts New Relic is rolling out a new, unified streaming alerts platform for New Relic One. This new streaming alerts platform will power NRQL Alert Conditions, and over the next year, all alert condition types will be consolidated into NRQL conditions. New Relic One Streaming Alerts delivers: More reliable alerting that is far less susceptible to data latency and processing lag. Increased accuracy of the data points that are being evaluated Reduced time-to-detect through improvements in the streaming algorithm, and configurable aggregation duration. Greater control over the signals being monitored. You can specify how to evaluate signal gaps, when to consider a signal as lost, and what actions should be taken. Consistent behavior and configuration of Alert conditions regardless of the telemetry type, source of the signal being monitored, or specifics of your NRQL query. Increased scalability in the number of time series that an Alert Condition can monitor and in the total number of conditions that can be configured ** Action Required : Opt-in Migration ** When we roll out this new streaming platform, there is a change in behavior related to how we process aggregation time windows that do not have data. If you are monitoring for when a signal goes to “0” in order to determine if an entity stops reporting, this approach will no longer work after moving to the new platform. To maintain this functionality you must enable Loss of Signal detection on these conditions in advance of moving your account in order to prevent false negatives. You may opt-in to this new platform now. Read more about the rollout plan in the FAQ section below. Please read the full announcement and FAQ here , and follow the links to enroll. When is this available? You can opt-in to enable New Relic Streaming Alerts on NRQL conditions right now. We plan to enable the majority of accounts the week of October 5th. Accounts that have NRQL Conditions that may be monitoring for loss of signal will not be enabled automatically until October 28th. These are NRQL Conditions that either use the “Less Than” operator, or have an operator and threshold of “Equals 0”. During the initial roll out the week of October 5th, you will see a banner on the top of the policy page and the NRQL Conditions create/edit page that will indicate whether your account has been enabled or whether you must update your configurations and opt-in.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.77158,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "09-28-2020 : Action Required : New Relic One Streaming <em>Alerts</em> for <em>NRQL</em> <em>Conditions</em>",
        "sections": "09-28-2020 : Action Required : New Relic One Streaming <em>Alerts</em> for <em>NRQL</em> <em>Conditions</em>",
        "category_2": "<em>Alerts</em> release notes",
        "body": "[RSS] Released on:  September 28, 2020 Component: <em>NRQL</em> <em>Conditions</em> (Review Required) Announcing : New Relic One Streaming Alerts New Relic is rolling out a new, unified streaming alerts platform for New Relic One. This new streaming alerts platform will power <em>NRQL</em> <em>Alert</em> <em>Conditions</em>, and over the next"
      },
      "id": "5f735c6964441f8a6aeb7297"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Set up New Relic using Helm charts",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Set up New Relic using Terraform"
      ],
      "published_at": "2020-09-29T01:47:50Z",
      "title": "Automate workflows",
      "updated_at": "2020-09-25T01:49:59Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 20 min Set up New Relic using Terraform Learn how to provision New Relic resources using Terraform",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.96814,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up New Relic using the <em>Kubernetes</em> <em>operator</em>",
        "body": " it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the <em>Kubernetes</em> <em>operator</em> Learn how to provision New Relic resources using the <em>Kubernetes</em> <em>operator</em> 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 20 min Set up New Relic using Terraform Learn how to provision New Relic resources using Terraform"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 9231,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Create NRQL alert conditions",
        "Create NRQL alert condition",
        "Alert threshold types",
        "NRQL alert syntax",
        "Sum of query results (limited or intermittent data)",
        "Offset the query time window",
        "NRQL alert threshold examples",
        "Create a description",
        "For more help"
      ],
      "title": "Create NRQL alert conditions",
      "category_0": "Alerts and Applied intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "external_id": "956a7a0b84d2afac5e6236df3143085ebc4f7459",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "published_at": "2020-09-28T03:46:01Z",
      "updated_at": "2020-09-03T23:54:56Z",
      "breadcrumb": "Contents / Alerts and Applied intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "How to define thresholds that trigger alert notifications based on your NRQL queries.",
      "body": "You can create alert conditions using NRQL queries. Create NRQL alert condition To create a NRQL alert condition: When you start to create a condition, where it prompts you to Select a product, click NRQL. Tips for creating and using a NRQL condition: Topic Tips Condition types NRQL condition types include static, baseline, and outlier. Create a description For some condition types, you can create a Description. Query results Queries must return a number. The condition works by evaluating that returned number against the thresholds you set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Condition settings Use the Condition settings to: Configure whether and how open violations are force-closed. Adjust the evaluation offset. Create a concise and descriptive condition name. (NerdGraph API Only) Provide a text description for the condition that will be included in violations and notifications. Troubleshooting procedures Optional: To include your organization's procedures for handling the incident, add the runbook URL to the condition. Limits on conditions See the maximum values. Health status NRQL alert conditions do not affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type, except you cannot use a FACET clause. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. NRQL alert syntax Here is the basic syntax for creating all NRQL alert conditions. Depending on the threshold type, also include a FACET clause as applicable. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Optional Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Static: Optional Baseline: Not allowed Outlier: Required Including a FACET clause in your NRQL syntax depends on the threshold type: static, baseline, or outlier. Use the FACET clause to separate your results by attribute and alert on each attribute independently. Faceted queries can return a maximum of 5000 values for static conditions and a maximum of 500 values for outlier conditions. If the query returns more than this number of values, the alert condition cannot be created. If you create the condition and the query returns more than this number later, the alert will fail. Sum of query results (limited or intermittent data) Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of the one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum, and the preview chart will update accordingly. Offset the query time window Every minute, we evaluate the NRQL query in one-minute time windows. The start time depends on the value you select in the NRQL condition's Advanced settings > Evaluation offset. Example: Using the default time window to evaluate violations With the Evaluation offset at the default setting of three minutes, the NRQL time window applied to your query will be: SINCE 3 minutes ago UNTIL 2 minutes ago If the event type is sourced from an APM language agent and aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend evaluating data from three minutes ago or longer. An offset of less than 3 minutes will trigger violations sooner, but you might see more false positives and negatives due to data latency. For cloud data, such as AWS integrations, you may need an offset longer than 3 minutes. Check our AWS polling intervals documentation to determine your best setting. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction SELECT percentile(databaseDuration, 75) FROM Transaction Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction SELECT average(duration) FROM Transaction Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Create a description You can define a description that passes useful information downstream for better violation responses or for use by downstream systems. For details, see Description. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.79298,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "sections": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "info": "How to define thresholds that trigger <em>alert</em> notifications based on your <em>NRQL</em> queries.",
        "category_0": "<em>Alerts</em> and Applied intelligence",
        "category_1": "New Relic <em>Alerts</em>",
        "category_2": "<em>Alert</em> <em>conditions</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;<em>alerts</em>-applied-intelligence&#x2F;new-relic-<em>alerts</em>&#x2F;<em>alert</em>-<em>conditions</em>&#x2F;create-<em>nrql</em>-<em>alert</em>-<em>conditions</em>",
        "body": "You can create <em>alert</em> <em>conditions</em> using <em>NRQL</em> queries. Create <em>NRQL</em> <em>alert</em> condition To create a <em>NRQL</em> <em>alert</em> condition: When you start to create a condition, where it prompts you to Select a product, click <em>NRQL</em>. Tips for creating and using a <em>NRQL</em> condition: Topic Tips Condition types <em>NRQL</em> condition types",
        "breadcrumb": "Contents &#x2F; Alerts and Applied intelligence &#x2F; New Relic Alerts &#x2F; <em>Alert</em> <em>conditions</em>"
      },
      "id": "5f2d992528ccbc489d88dfc1"
    },
    {
      "category_2": "Understand and use data",
      "nodeid": 37981,
      "sections": [
        "Elastic Container Service integration",
        "Get started",
        "Install",
        "Understand and use data",
        "Troubleshooting",
        "Recommended ECS alert conditions",
        "Recommended alert conditions",
        "For more help"
      ],
      "title": "Recommended ECS alert conditions",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Elastic Container Service integration",
      "external_id": "304f01e7a5c68e9ef4dc76782eb9ff6847854065",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/elastic-container-service-integration/understand-use-data/ecs-integration-recommended-alert-conditions",
      "published_at": "2020-09-27T18:12:23Z",
      "updated_at": "2020-08-06T00:29:40Z",
      "breadcrumb": "Contents / Integrations / Elastic Container Service integration / Understand and use data",
      "document_type": "page",
      "popularity": 1,
      "info": "Tips for useful alert conditions to set for New Relic's Amazon ECS integration. ",
      "body": "New Relic's ECS integration reports and displays performance data from your Amazon ECS environment. This document provides some recommended alert conditions for monitoring ECS performance. Recommended alert conditions Here are some recommended ECS alert conditions. To add these alerts, go to the Alerts UI and add the following NRQL alert conditions to an existing or new alert policy: High CPU usage NRQL: FROM ContainerSample SELECT cpuUsed / cpuLimitCores Critical: > 90% for 5 minutes High memory usage NRQL: FROM ContainerSample SELECT memoryUsageBytes / memorySizeLimitBytes Critical: > 80% for 5 minutes Restart count NRQL: FROM ContainerSample SELECT max(restartCount) - min(restartCount) Critical: > 5 for 5 minutes For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 62.34782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Recommended ECS <em>alert</em> <em>conditions</em>",
        "sections": "Recommended ECS <em>alert</em> <em>conditions</em>",
        "info": "Tips for useful <em>alert</em> <em>conditions</em> to set for New Relic&#x27;s Amazon ECS integration. ",
        "body": " to the Alerts UI and add the following <em>NRQL</em> <em>alert</em> <em>conditions</em> to an existing or new <em>alert</em> policy: High CPU usage <em>NRQL</em>: FROM ContainerSample SELECT cpuUsed &#x2F; cpuLimitCores Critical: &gt; 90% for 5 minutes High memory usage <em>NRQL</em>: FROM ContainerSample SELECT memoryUsageBytes &#x2F; memorySizeLimitBytes Critical: &gt; 80"
      },
      "id": "5ee05e9e28ccbcef4f4c8dda"
    },
    {
      "category_2": "New Relic One pricing and users",
      "nodeid": 39496,
      "sections": [
        "Accounts and billing",
        "Account setup",
        "Account structure",
        "New Relic One pricing and users",
        "General account settings",
        "Automated user management",
        "Partner install",
        "Query and alert on usage data",
        "Data types",
        "Query examples",
        "Data usage queries",
        "User count queries",
        "Set usage alerts",
        "General attributes",
        "For more help"
      ],
      "title": "Query and alert on usage data",
      "category_0": "New Relic accounts",
      "type": "docs",
      "category_1": "Accounts and billing",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/accounts/accounts-billing/new-relic-one-pricing-users/usage-queries-alerts",
      "external_id": "94429d3c0366a8dee43d771c143fc6dacf4c4e31",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-pricing-users/usage-queries-alerts",
      "published_at": "2020-09-27T19:00:35Z",
      "updated_at": "2020-09-24T19:20:19Z",
      "breadcrumb": "Contents / New Relic accounts / Accounts and billing / New Relic One pricing and users",
      "document_type": "page",
      "popularity": 1,
      "info": "How to create queries and alerts for your New Relic billing-related usage. ",
      "body": "For accounts on our New Relic One pricing plan, we provide a UI for understanding your New Relic usage and managing your data. Additionally, you can: Query your usage data to get more detail than is available in the UI Set up NRQL alert conditions to get notifications about changes in your usage. Note that account hierarchy may affect queried data. See Account structure. Data types Usage data is attached to two events: NrConsumption records usage every hour, and is the equivalent of \"real-time\" usage. Use this event to observe usage trends over time. NrMTDConsumption generates aggregate values from the NrConsumption event. Use this event to see usage or estimated cost for a billing period. Query examples The usage UI displays your data usage and billable user count. But to get more detail, you can use these NRQL queries. For definitions of some of the attributes used in these queries, see Attributes. Data usage queries Here are some data usage query examples: Daily data usage This query totals your billable ingested data, and displays a daily value for the past three months: FROM NrConsumption SELECT sum(GigabytesIngested) WHERE productLine = 'DataPlatform' SINCE 3 months ago TIMESERIES 1 day Daily usage by source This query totals your billable ingested data, and displays a daily value for the past three months faceted by the source: FROM NrConsumption SELECT sum(GigabytesIngested) WHERE productLine = 'DataPlatform' SINCE 3 months ago FACET usageMetric TIMESERIES 1 day Month-to-date data usage This query shows the current full user count. In other words, it shows how much you'd be billed for your data for that month if you were billed right now. FROM NrMTDConsumption SELECT latest(GigabytesIngested) WHERE productLine = 'DataPlatform' SINCE this month Month-to-date estimated data cost This query shows the estimated cost of your ingested data: FROM NrMTDConsumption SELECT latest(estimatedCost) WHERE productLine = 'DataPlatform' SINCE this month User count queries Here are some user-related query examples. For details on how users are counted, see User count calculations. Month-to-date full users This query shows the billable full users for the month. In other words, it shows how much you'd be billed for your users for that month if you were billed right now. FROM NrMTDConsumption SELECT latest(usersBillable) SINCE this month This query shows how many full users were counted by hour. This is useful for seeing how the full user count changed over time. from NrConsumption SELECT max(FullUsers) SINCE 10 days ago TIMESERIES 1 hour Projected monthly full user count This query shows a projected count of monthly users. This query would not be good for using in a dashboard; it requires values based on a) the days remaining in the month, b) the start of the month. Here's an example querying the projected end-of-month count with 10 days left in that month: FROM NrMTDConsumption SELECT predictLinear(FullUsers, 10 days) SINCE '2020-09-01' Count full users and basic users The usage UI shows the count of full users and basic users. The query used is: FROM NrUsage SELECT max(usage) SINCE 10 days ago WHERE productLine='FullStackObservability' WHERE metric in ('FullUsers', 'BasicUsers') FACET metric To see the count of full and basic users over time: FROM NrUsage SELECT max(usage) SINCE 10 days ago WHERE productLine='FullStackObservability' WHERE metric in ('FullUsers', 'BasicUsers') FACET metric TIMESERIES 1 hour Set usage alerts To help manage your billable data, you can set alerts to notify you of unexpected increases in usage. To learn about how to create alerts, see Alert workflow. When creating alert conditions, we recommend 20 minutes for the alert window value and the evaluation offset value. This will ensure it won't alert on normal gaps between usage event generation. Here are some NRQL alert condition examples. For attribute definitions, see Attributes. Ingested gigabytes exceed a fixed value This query will create an alert when your hourly usage exceeds a fixed value: FROM NrConsumption SELECT sum(GigabytesIngested) WHERE productLine = 'DataPlatform' If you have multiple sub-accounts, you may want to set threshold alerts for a specific subaccount: FROM NrConsumption SELECT sum(GigabytesIngested) WHERE productLine = 'DataPlatform' AND consumingAccountId = YOUR_SUB-ACCOUNT_ID Usage exceeds fixed threshold for GBs This query will create an alert when your usage exceeds fixed monthly threshold for GBs: FROM NrMTDConsumption SELECT latest(GigabytesIngested) WHERE productLine = 'DataPlatform' Usage exceeds fixed threshold for users This query will create an alert when your usage exceeds fixed monthly threshold for billable users: FROM NrMTDConsumption SELECT latest(usersBillable) Usage exceeds fixed threshold for estimated cost This query will create an alert when your usage exceeds fixed threshold for estimated cost: FROM NrMTDConsumption SELECT latest(estimatedCost) WHERE productLine = 'DataPlatform' SINCE this month General attributes These attributes are attached to the NrMTDConsumption and NrConsumption events. Attribute Description productLine The category of usage. There are four options: DataPlatform, FullStackObservability, IncidentIntelligence, or ProactiveDetection. For more details about these categories, see New Relic platform. metric Consolidates multiple categories of usage into a single metric. Helpful when faceting by productLine. consumingAccountId ID of the New Relic account that is directly responsible for the stored events, as determined from the license key used. estimatedCost Calculates a cost estimate based on usage and metric cost. This is an estimate of costs to date, not your monthly invoice. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 60.381645,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Query and <em>alert</em> on usage data",
        "sections": "Query and <em>alert</em> on usage data",
        "info": "How to create queries and <em>alerts</em> for your New Relic billing-related usage. ",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;accounts&#x2F;accounts-billing&#x2F;new-relic-one-pricing-users&#x2F;usage-queries-<em>alerts</em>",
        "body": "For accounts on our New Relic One pricing plan, we provide a UI for understanding your New Relic usage and managing your data. Additionally, you can: Query your usage data to get more detail than is available in the UI Set up <em>NRQL</em> <em>alert</em> <em>conditions</em> to get notifications about changes in your usage"
      },
      "id": "5f22f5bd64441f0c9e2a48ea"
    }
  ],
  "/collect-data/collect-data-from-any-source": [
    {
      "category_2": "Ingest APIs",
      "nodeid": 35471,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Ingest APIs",
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs",
        "For more help"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "47a4c8f38c1b1674504ea302d865fd499e90ea39",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-started/capabilities/telemetry-sdks-send-custom-telemetry-data-new-relic",
      "published_at": "2020-09-27T14:26:42Z",
      "updated_at": "2020-09-17T14:37:52Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Ingest APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Report custom telemetry data with New Relic's open-source Telemetry SDKs.",
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send metrics and trace data to the New Relic platform. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility To build with the Telemetry SDKs, you will need an Event API insert key. New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported data types Java Java library on GitHub New Relic Metrics New Relic Traces Node/TypeScript NodeJS library on GitHub New Relic Metrics New Relic Traces Python Python library on GitHub New Relic Metrics New Relic Events New Relic Traces Go Go library on Github New Relic Metrics New Relic Traces .NET .NET library on GitHub .NET package in NuGet New Relic Metrics New Relic Traces C C library on Github New Relic Traces Rust Rust library on Github New Relic Traces For more on the supported data types: Metrics: see the Metric API Traces: see the Trace API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.98175,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "sections": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "info": "Report custom <em>telemetry</em> data with New Relic&#x27;s open-source <em>Telemetry</em> <em>SDKs</em>.",
        "category_0": "<em>Telemetry</em> Data Platform",
        "category_2": "Ingest <em>APIs</em>",
        "body": " integrations) don&#x27;t meet your needs, you can use the <em>Telemetry</em> SDKs to create your own <em>telemetry</em> data solutions. Requirements and compatibility To build with the <em>Telemetry</em> SDKs, you will need an <em>Event</em> <em>API</em> insert key. New Relic has contributed the <em>Telemetry</em> <em>SDK</em> to the open source community under",
        "breadcrumb": "Contents &#x2F; <em>Telemetry</em> Data Platform &#x2F; Ingest and manage data &#x2F; Ingest APIs"
      },
      "id": "5d89fefbe7b9d2537ed30dc1"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13661,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Data requirements and limits for custom event data",
        "General requirements",
        "Reserved words",
        "Additional Browser PageAction requirements",
        "Additional Event API requirements",
        "Event type limits",
        "For more help"
      ],
      "title": "Data requirements and limits for custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "external_id": "f5beef0d09bb5918be3f8a1a3ece98c09947cd1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "published_at": "2020-09-27T17:50:31Z",
      "updated_at": "2020-09-27T17:50:31Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic, general limits and requirements for reporting custom events and attributes. ",
      "body": "You can report custom events to New Relic in several ways, including the New Relic Event API, APM agent APIs, Browser agent APIs, and the Mobile SDK. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. General requirements How long custom data is retained depends on your Insights subscription and its associated data retention. When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1 MB maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. This is not a complete list. In general, it's a good practice to avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Additional Browser PageAction requirements For additional requirements for using New Relic Browser's custom PageAction event, see Insert custom data via New Relic Browser agent. Additional Event API requirements For more requirements and details for the Event API, see Event API. Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.577194,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data requirements and limits for custom <em>event</em> data",
        "sections": "Additional <em>Event</em> <em>API</em> requirements",
        "info": "For New Relic, general limits and requirements for reporting custom <em>events</em> and attributes. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "Custom <em>events</em>",
        "body": "You can report custom events to New Relic in several ways, including the New Relic <em>Event</em> <em>API</em>, APM <em>agent</em> APIs, Browser <em>agent</em> APIs, and the Mobile <em>SDK</em>. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; Custom events"
      },
      "id": "59f4354f4bb81c2ea8b80d0a"
    },
    {
      "category_2": "Get started",
      "nodeid": 36051,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Ingest APIs",
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Agent APIs",
        "Telemetry SDKs",
        "APIs for sending metrics, traces, logs, and events",
        "New Relic One applications",
        "For more help"
      ],
      "title": "Get data into New Relic",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "7a413b4d7e5bd81088a08507ae4bad64c7e24b2d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-data-new-relic/getting-started/introduction-new-relic-data-ingest-apis-sdks",
      "published_at": "2020-09-27T16:19:59Z",
      "updated_at": "2020-08-10T23:16:39Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to how to get data into New Relic. ",
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our Telemetry Data Platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. To browse all New Relic-built tools and solutions, see New Relic integrations. Agent APIs Some of our monitoring solutions come with APIs and/or SDKs that allow you to customize the data reported and how it reports. For more information, see the relevant product: APM agent APIs Browser API Mobile API Infrastructure monitoring: the Flex integration tool Telemetry SDKs If our more curated solutions don't work for you, our open source Telemetry SDKs let you build your own solution. These SDKs are language wrappers for our data-ingest APIs (below) that let you send telemetry data to New Relic without requiring install of an agent. APIs for sending metrics, traces, logs, and events If our more curated solutions don't work for you, we also have data-ingest APIs: Trace API Event API Metric API Log API To learn about the differences between these data types, see Data types. New Relic One applications You can build entirely custom applications that reside in New Relic One and make use of any data you want. You can use existing open source New Relic One apps, or share your own with the open source community. For details, see New Relic One applications. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.12021,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>APIs</em> for sending <em>metrics</em>, <em>traces</em>, logs, and <em>events</em>",
        "category_0": "<em>Telemetry</em> Data Platform",
        "body": " also have data-ingest APIs: <em>Trace</em> <em>API</em> <em>Event</em> <em>API</em> <em>Metric</em> <em>API</em> Log <em>API</em> To learn about the differences between these data types, see Data types. New Relic One applications You can build entirely custom applications that reside in New Relic One and make use of any data you want. You can use existing open",
        "breadcrumb": "Contents &#x2F; <em>Telemetry</em> Data Platform &#x2F; Ingest and manage data &#x2F; Get started"
      },
      "id": "5f24aa60196a67ede394f5f3"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13806,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Report custom event data",
        "Overview of reporting custom events and attributes",
        "Send custom events and attributes",
        "Extend data retention",
        "For more help"
      ],
      "title": "Report custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "external_id": "afb5f5a81ae06b22935d98c470ed9cabd7c9da6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/report-custom-event-data",
      "published_at": "2020-09-27T21:40:24Z",
      "updated_at": "2020-07-26T05:52:23Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the options for sending custom event data to New Relic. ",
      "body": "New Relic products report a variety of default event data to your account. This document will explain how to report your own custom events and attributes. Overview of reporting custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. Reporting custom events allows you to create more useful and customized queries and charts of your data, and is a key part of optimizing how New Relic works for you. Before beginning, it's important to know that reporting a large number of custom events and/or attributes can cause degraded query performance, or cause you to approach or pass data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile agent Use the mobile agent API to send custom events and attributes. Synthetics Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn about how to extend how long events are retained in your account, see Event data retention. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.43796,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report custom <em>event</em> data",
        "sections": "<em>Event</em> data sources",
        "info": "An overview of the options for sending custom <em>event</em> data to New Relic. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "Custom <em>events</em>",
        "body": " the Flex integration tool to report your own custom <em>event</em> data. Mobile <em>agent</em> Use the mobile <em>agent</em> <em>API</em> to send custom events and attributes. Synthetics Add custom attributes to the SyntheticCheck <em>event</em> via the $util.insights tools. For ways to report other types of custom data, see: <em>Metric</em> <em>API</em> Logs <em>Trace</em>",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; Custom events"
      },
      "id": "5e8e7f9de7b9d2aa122cf0f6"
    },
    {
      "category_2": "Java agent release notes",
      "nodeid": 36271,
      "sections": [
        "APM agent release notes",
        "Go agent release notes",
        "Java agent release notes",
        ".NET agent release notes",
        "Node.js agent release notes",
        "PHP agent release notes",
        "Python agent release notes",
        "Ruby agent release notes",
        "C SDK release notes",
        "Java Agent 5.8.0",
        "New features",
        "New OSS SDK",
        "Fixes"
      ],
      "title": "Java Agent 5.8.0",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "APM agent release notes",
      "external_id": "bc3a41e5e576ff66be3ecfe7085f2d3c8bbd796d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/java-release-notes/java-agent-580",
      "published_at": "2020-09-27T14:29:44Z",
      "updated_at": "2019-10-31T15:19:35Z",
      "breadcrumb": "Contents / Release notes / APM agent release notes / Java agent release notes",
      "document_type": "release_notes",
      "popularity": -2,
      "body": "[RSS] Released on:  Tuesday, October 29, 2019 - 12:00 Download New features gRPC gRPC error reporting is now configurable Response codes, component type, and method type are now recorded as attributes. The agent now reports the gRPC status code rather than \"translating\" to HTTP status codes. Vert.x The Java agent now provides visibility into your applications built using the Vert.x 3.8. The agent instruments Vert.x Web, Vert.x Core, and Vert.x HTTP client. With this instrumentation, the agent will identify and name your transactions based on Vert.x web routing paths. The agent will also time web handlers, track async handlers, and external calls made with Vert.x HTTP client. XML custom instrumentation The custom XML instrumentation XSD has been enhanced to support now include support for specifying leaf tracers. Class Histogram A new Class Histogram extension is now available to report heap memory details as events. Jedis Added support for Jedis 3.0.0 and higher. You can now see your Jedis calls in breakdowns in the overview chart, entries in the Databases tab, and segments in transaction traces. Lettuce Instrumentation modules for Lettuce 4 and 5 are now available via the Java agent incubator. New OSS SDK We now have an open source Telemetry SDK for Java for sending telemetry data to New Relic. The current SDK supports sending dimensional metrics to the Metric API and spans to the Trace API. Fixes The Solr 7 instrumentation would not report Update JMX metrics. HttpURLConnection instrumentation produced External metrics only when network methods (getInputStream, getResponseCode) are called. MongoDB instrumentation would report duplicate metrics when applications invoked MongoClientOptions.build() more than once.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.77617,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Java <em>Agent</em> 5.8.0",
        "sections": "APM <em>agent</em> release notes",
        "category_1": "APM <em>agent</em> release notes",
        "category_2": "Java <em>agent</em> release notes",
        "body": " <em>agent</em> incubator. New OSS <em>SDK</em> We now have an open source <em>Telemetry</em> <em>SDK</em> for Java for sending <em>telemetry</em> data to New Relic. The current <em>SDK</em> supports sending dimensional metrics to the <em>Metric</em> <em>API</em> and spans to the <em>Trace</em> <em>API</em>. Fixes The Solr 7 instrumentation would not report Update JMX metrics",
        "breadcrumb": "Contents &#x2F; Release notes &#x2F; APM <em>agent</em> release notes &#x2F; Java <em>agent</em> release notes"
      },
      "id": "5dbafb88196a67d9b59aa23d"
    }
  ],
  "/explore-docs/nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Create a \"Hello, World!\" application",
        "Permissions for managing applications",
        "Set up your development environment",
        "Add, query, and mutate data using NerdStorage",
        "Add the NerdGraphQuery component to an application",
        "Add a time picker to your app",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps"
      ],
      "published_at": "2020-09-29T01:47:50Z",
      "title": "Build apps",
      "updated_at": "2020-09-25T01:49:59Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One   Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 20 min Add a time picker to your app Add a time picker to a sample application 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 334.9231,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "body": " you start building <em>apps</em>, and dive into our library of <em>components</em>. We also have a growing number of open source <em>apps</em> that you can use to get started. The rest is up to you. Guides to build <em>apps</em> 15 min Create a &quot;Hello, World!&quot; application Build a &quot;Hello, World!&quot; <em>app</em> and publish it to <em>New</em> <em>Relic</em> <em>One</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps"
      ],
      "title": "Add, query, and mutate data using NerdStorage",
      "type": "developer",
      "tags": [
        "add data",
        "query data",
        "mutate data",
        "nerdstorage"
      ],
      "external_id": "97cc9637edea35ecd68683f1010f67a5f8c79038",
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/",
      "published_at": "2020-09-29T01:52:56Z",
      "updated_at": "2020-08-30T01:49:16Z",
      "document_type": "page",
      "popularity": 1,
      "info": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next.",
      "body": "Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: cd / nr1 - how - to / use - nerdstorage; Copy Update the UUID and serve the application: nr1 nerdpack:uuid -gf nr1 nerdpack:serve Copy Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application’s index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you’ve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 280.23883,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "sections": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "info": "<em>NerdStorage</em> is a document <em>database</em> <em>accessible</em> within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next.",
        "tags": "<em>nerdstorage</em>",
        "body": " will return the URL to view your running application on <em>New</em> <em>Relic</em> <em>One</em>. Load the URL. Click <em>Apps</em> and under Your <em>apps</em> you&#x27;ll see the Use <em>Nerdstorage</em> <em>app</em> listed. Click to launch the <em>app</em>. Add <em>data</em> to <em>NerdStorage</em> Once the <em>app</em> is up and running on <em>New</em> <em>Relic</em> <em>One</em>, you can prepare the <em>app</em> and start adding <em>data</em>"
      },
      "id": "5efa98d4e7b9d26d6b7bab74"
    },
    {
      "sections": [
        "Intro to New Relic One API components",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One API components",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2020-09-29T01:52:56Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One API components",
      "body": "Intro to New Relic One API components To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.42775,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>New</em> <em>Relic</em> <em>One</em> API <em>components</em>",
        "sections": "Intro to <em>New</em> <em>Relic</em> <em>One</em> API <em>components</em>",
        "info": "Intro to <em>New</em> <em>Relic</em> <em>One</em> API <em>components</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>",
        "body": " settings <em>data</em>, or user-specific <em>data</em>. For more on this, see <em>NerdStorage</em>. Platform APIs The Platform API <em>components</em> of the SDK enable your application to interact with different parts of the <em>New</em> <em>Relic</em> <em>One</em> platform, by reading and writing state from and to the URL, setting the configuration, etc"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-09-29T01:52:56Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Copy Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.96173,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> CLI Reference",
        "sections": "<em>New</em> <em>Relic</em> CLI Reference",
        "info": "The command line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> cli",
        "body": "<em>New</em> <em>Relic</em> CLI Reference The <em>New</em> <em>Relic</em> CLI enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching <em>data</em> from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> CLI commands Find details for the <em>New</em> <em>Relic</em> CLI command docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.61206,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> CLI reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> CLI reference",
        "info": "An overview of the CLI to help you build, deploy, and manage <em>New</em> <em>Relic</em> <em>apps</em>.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>app</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> CLI reference To build a <em>New</em> <em>Relic</em> <em>One</em> <em>app</em>, you must install the <em>New</em> <em>Relic</em> <em>One</em> CLI. The CLI helps you build, publish, and manage your <em>New</em> <em>Relic</em> <em>app</em>. We provide a variety of tools for building <em>apps</em>, including the <em>New</em> <em>Relic</em> <em>One</em> CLI (command line interface). This page explains how to use"
      },
      "id": "5efa989e28ccbc535a307dd0"
    }
  ],
  "/explore-docs/nr1-nerdpack": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-subscription/",
      "sections": [
        "New Relic One CLI subscription commands",
        "Command details",
        "nr1 subscription:set",
        "Subscribe to a Nerdpack",
        "Usage",
        "Options",
        "Aliases",
        "nr1 subscription:list",
        "See your subscription",
        "nr1 subscription:unset",
        "Unsubscribe from a Nerdpack"
      ],
      "published_at": "2020-09-29T01:52:56Z",
      "title": "New Relic One CLI subscription commands",
      "updated_at": "2020-08-06T01:44:54Z",
      "type": "developer",
      "external_id": "12d2e1b06dede5b1272527f95a14518010aecc58",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI commands you can use to manage your Nerdpack subscriptions.",
      "body": "New Relic One CLI subscription commands To manage your Nerdpack subscriptions, use the commands below. You can click any command to see its usage options and additional details about the command. Command Description nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Command details nr1 subscription:set Subscribe to a Nerdpack Subscribes your account to a specific Nerdpack and channel. This command can be run with a Nerdpack UUID or within a specific Nerdpack folder. By default, the command uses the Nerdpack ID in package.json and subscribes to the STABLE channel. An account can only be subscribed to one Nerdpack and channel at a time. Usage $ nr1 subscription:set Options -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to subscribe to. By default, the command will use the one in package.json. -c, --channel=DEV/BETA/STABLE Specifies the channel to subscribe to. [default: STABLE] --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. Aliases $ nr1 nerdpack:subscribe nr1 subscription:list See your subscription Lists all the Nerdpacks your account is subscribed to. Your account is linked to your API key. Usage $ nr1 subscription:list Options --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 subscription:unset Unsubscribe from a Nerdpack Unsubscribes your account from a specific Nerdpack. When this command is executed within a Nerdpack folder, the Nerdpack ID from package.json is used by default. Usage $ nr1 subscription:unset Options -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to subscribe to. By default, the command will use the one in package.json. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. Aliases $ nr1 nerdpack:unsubscribe $ nr1 subscription:delete $ nr1 subscription:remove $ nr1 subscription:rm",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 804.23926,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> subscription <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> subscription <em>commands</em>",
        "info": "An overview of the <em>CLI</em> <em>commands</em> you can use to manage your <em>Nerdpack</em> subscriptions.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> subscription <em>commands</em> To manage your <em>Nerdpack</em> subscriptions, use the <em>commands</em> below. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 subscription:set Subscribes your account to a <em>Nerdpack</em> and channel. nr1"
      },
      "id": "5f2b6096e7b9d225ebc9de6f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2020-09-29T01:52:56Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 568.0169,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": " (<em>New</em> <em>Relic</em> query language). See our other <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> docs for <em>commands</em> specific to <em>Nerdpack</em> set-up, <em>Nerdpack</em> subscriptions, <em>CLI</em> configuration, plugins, or catalogs. <em>Command</em> details nr1 help See <em>commands</em> and get details Shows all nr1 <em>commands</em> by default. To get details about a specific <em>command</em>"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 318.01648,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": ". For more on how to serve and publish your application, see our guide on Deploying your <em>New</em> <em>Relic</em> <em>One</em> app. Get started nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1 update Updates to the latest version of the <em>CLI</em>. nr1 create Creates a <em>new</em> component from a template (<em>Nerdpack</em>, Nerdlet"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-catalog/",
      "sections": [
        "New Relic One CLI catalog commands",
        "Command details",
        "nr1 catalog:info",
        "Get catalog details",
        "Usage",
        "Options",
        "nr1 catalog:submit",
        "Send info to the catalog"
      ],
      "published_at": "2020-09-29T01:54:08Z",
      "title": "New Relic One CLI catalog commands",
      "updated_at": "2020-08-14T01:49:24Z",
      "type": "developer",
      "external_id": "e94d6ad2cd04e2c01aecef526778d341867b3031",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI commands you can use to manage your New Relic One catalog information.",
      "body": "New Relic One CLI catalog commands To manage your catalog, use the commands below. You can click any command to see its usage options and additional details about the command. Command Description nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder. Command details nr1 catalog:info Get catalog details Shows the information about your application that's displayed in the catalog. If run within a specific Nerdpack folder, the info from that Nerdpack will be shown. If you don't want to get info from your local Nerdpack, use the --nerdpack-id=NERDPACK_ID option to query from a specific Nerdpack. Usage $ nr1 catalog:info Options -f, --field=FIELD Specifies which field you want info from. -i, --nerdpack-id=NERDPACK_ID Specifies which Nerdpack to get info from. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 catalog:submit Send info to the catalog Gathers the information you add to the catalog directory for your application and saves it to the catalog. See our catalog docs for details on adding screenshots and metadata to your applications to make them easy to find, attractive, and informative. This command must be run on a Nerdpack folder. The command will search for specific files using convention names. Usage $ nr1 catalog:submit Options -P, --skip-screenshots Skips upload of screenshot assets. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.24857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> catalog <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> catalog <em>commands</em>",
        "info": "An overview of the <em>CLI</em> <em>commands</em> you can use to manage your <em>New</em> <em>Relic</em> <em>One</em> catalog information.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> catalog <em>commands</em> To manage your catalog, use the <em>commands</em> below. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 catalog:info Shows the <em>Nerdpack</em> info stored in the catalog. nr1 catalog:submit Gathers and submits"
      },
      "id": "5f28bd6a64441f805eb11a26"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-08-14T01:49:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Copy Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.81677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> file structure",
        "sections": "<em>Nerdpack</em> file structure",
        "info": "An overview of the <em>Nerdpack</em> File Structure",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " How to link your application with a monitored entity For basic component definitions, see our component reference. Generate <em>Nerdpack</em> components There are two ways to generate a <em>Nerdpack</em> template: Generate a <em>Nerdpack</em>: Use the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>command</em> nr1 create and select <em>Nerdpack</em> to create"
      },
      "id": "5efa989e196a671300766404"
    }
  ],
  "/explore-docs/nr1-catalog": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 323.46454,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " <em>CLI</em> <em>commands</em> to: Generate Nerdpack&#x2F;Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the <em>catalog</em> Installing the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> In <em>New</em> <em>Relic</em>, click Apps and then in the <em>New</em> <em>Relic</em> <em>One</em> <em>catalog</em> area, click the Build"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-09-29T01:40:52Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-27T01:38:35Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 16 Days : 22 Hours : 10 Minutes : 8 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 20 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.71085,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local <em>New</em> <em>Relic</em> <em>One</em> <em>Catalog</em> Start the guide Get inspired 30 min Add a table to your app Add a table to your <em>New</em> <em>Relic</em> <em>One</em> app 15 min Collect data - any"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2020-09-29T01:52:56Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.15837,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em> Here&#x27;s a list of common <em>commands</em> to get you started with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/nerd-days/",
      "sections": [
        "Nerd Days is a free 1-day event focused on building more perfect software",
        "Register for Nerd Days 1.0",
        "Save the date & join us online",
        "Additional Nerd Days Events",
        "REGISTER FOR NERD DAYS | AMERICAS",
        "Tracks",
        "Observability",
        "Cloud migration",
        "Open source",
        "Devops journey",
        "Fundamentals",
        "Nerd Days AMER Agenda",
        "DevOps journey",
        "Keynote",
        "Instrumenting your service using agents",
        "Increased Maturity with Full Stack Observability",
        "Deploying an app on Kubernetes",
        "Delivering SRE as a Service",
        "Building applications on New Relic One",
        "Exploring your data using NRQL",
        "New Relic AI",
        "Going Serverless: Chipping at the monolith",
        "Logging for Modern Organizations",
        "Grafana and Prometheus with TDP",
        "Lunch Break",
        "Custom Instrumentation",
        "Exploring Data with NerdGraph",
        "Tool Consolidation",
        "Flex Integration - Build Your First Linux Configuration",
        "Open Source powers the New Relic One Catalog",
        "Alerts Best Practices",
        "The Art & Science of Deciphering Perceived Performance: A look at how user behavior affects your data",
        "Kubernetes Observability",
        "Measuring code pipelines",
        "New Relic CLI Wizardry/ Reducing toil with Terraform",
        "True availability using Synthetics",
        "How Observability-Driven Development accelerates DevOps transformations",
        "CFP Customer Session: Cloud fundamentals",
        "Testing in Production",
        "NerdStorageVault: ThirdParty Secrets",
        "Closing + Swag",
        "Engage with the developer community"
      ],
      "published_at": "2020-09-29T01:55:32Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-27T01:39:41Z",
      "type": "developer",
      "external_id": "0b8374051901a77e242ce296c00eeb3c760439d1",
      "document_type": "page",
      "popularity": 1,
      "body": "Nerd Days is a free 1-day event focused on building more perfect software Register for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region) Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. Save the date & join us online Choose the sessions you're interested in add Nerd Days to your calendar. You’ll hear from fellow engineers who built New Relic solutions and New Relic users from various industries. Whether you’re new or a data nerd, there’s an interactive session for you. Date: October 13, 2020 Time: 9AM PST - 3PM PST We look forward to building with you during Nerd Days! If you have any questions about Nerd Days please emails deco@newrelic.com. Additional Nerd Days Events EMEA RegistrationNov 10, 2020 APJ RegistrationOct 22, 2020 REGISTER FOR NERD DAYS | AMERICAS Tracks Tracks will vary by region. All sessions will be recorded and distributed after the event. Observability Cloud migration Open source Devops journey Fundamentals Nerd Days AMER Agenda We’ve got a packed schedule with thought-leaders of their respective industries Fundamentals Observability Cloud migration DevOps journey Open source 9:00 AM Keynote Lew Cirne 10:00 AM Instrumenting your service using agents Increased Maturity with Full Stack Observability Deploying an app on Kubernetes Delivering SRE as a Service Building applications on New Relic One 11:00 AM Exploring your data using NRQL New Relic AI Going Serverless: Chipping at the monolith Logging for Modern Organizations Grafana and Prometheus with TDP 12:00 PM Lunch Break Distant Disco 1:00 PM Custom Instrumentation Exploring Data with NerdGraph Tool Consolidation Flex Integration - Build Your First Linux Configuration Open Source powers the New Relic One Catalog 2:00 PM Alerts Best Practices The Art & Science of Deciphering Perceived Performance: A look at how user behavior affects your data Kubernetes Observability Measuring code pipelines New Relic CLI Wizardry/ Reducing toil with Terraform 3:00 PM True availability using Synthetics How Observability-Driven Development accelerates DevOps transformations CFP Customer Session: Cloud fundamentals Testing in Production NerdStorageVault: ThirdParty Secrets 4:00 PM Closing + Swag Jemiah Sius and Team Engage with the developer community @newrelic New Relic Forum Developers Hopin logo Event powered by Hopin",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.72498,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "Open Source powers the <em>New</em> <em>Relic</em> <em>One</em> <em>Catalog</em>",
        "body": " with NerdGraph Tool Consolidation Flex Integration - Build Your First Linux Configuration Open Source powers the <em>New</em> <em>Relic</em> <em>One</em> <em>Catalog</em> 2:00 PM Alerts Best Practices The Art &amp; Science of Deciphering Perceived Performance: A look at how user behavior affects your data Kubernetes Observability Measuring code"
      },
      "id": "5f3dd5bf28ccbc2349f56e4e"
    },
    {
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Subscribe or unsubsribe apps",
        "Handle duplicate applications"
      ],
      "title": "Serve, publish, and deploy your New Relic One app",
      "type": "developer",
      "tags": [
        "publish apps",
        "deploy apps",
        "subscribe apps",
        "add metadata apps"
      ],
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "published_at": "2020-09-29T01:52:56Z",
      "updated_at": "2020-09-02T02:05:55Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Start sharing and using the custom New Relic One apps you build",
      "body": "Serve, publish, and deploy your New Relic One app 30 min When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. nr1 update Copy Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. nr1 catalog:submit Copy Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Subscribe or unsubsribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.1633,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and deploy your <em>New</em> <em>Relic</em> <em>One</em> app",
        "sections": "Serve, publish, and deploy your <em>New</em> <em>Relic</em> <em>One</em> app",
        "info": "Start sharing and using the custom <em>New</em> <em>Relic</em> <em>One</em> apps you build",
        "body": " a matter of kicking off a <em>catalog</em> <em>command</em> that validates the information and saves it to the <em>catalog</em>. Step 1 of 3 Update the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> to ensure you&#x27;re working with the latest version. nr1 update Copy Step 2 of 3 Add <em>catalog</em> metadata and screenshots. Run nr1 create and then select <em>catalog</em> to add"
      },
      "id": "5efa999de7b9d283e67bab8f"
    }
  ],
  "/collect-data/custom-attributes": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Collect data - any source",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL"
      ],
      "published_at": "2020-09-29T01:48:50Z",
      "title": "Collect data",
      "updated_at": "2020-09-27T01:53:36Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Collect data Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data   Add custom attributes Use custom attributes for deeper analysis 15 min Collect data - any source APIs, agents, OS emitters - get any data 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events 25 min Build queries with NerdGraph Try NerdGraph and build the queries you need 10 min Query data with NRQL Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.55133,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>custom</em> <em>attributes</em>",
        "body": " data   Add <em>custom</em> <em>attributes</em> Use <em>custom</em> <em>attributes</em> for deeper analysis 15 min Collect data - any source APIs, agents, OS emitters - get any data 5 min Create <em>custom</em> events Define, visualize, and get alerts on the data you want using <em>custom</em> events 25 min Build queries with NerdGraph Try NerdGraph and build the queries you need 10 min Query data with <em>NRQL</em> Query default data, <em>custom</em> events, and <em>attributes</em>"
      },
      "id": "5efa997328ccbc768c307de2"
    },
    {
      "category_2": "Measure DevOps success",
      "nodeid": 16556,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Customer experience improvement: track experience indicators",
        "Prerequisites",
        "1. Use custom attributes to associate performance data",
        "2. Create dashboards with performance and business metrics",
        "3. Share dashboards across departments",
        "4. Utilize data to separate performance by cohort and debug issues at the customer level",
        "For more help"
      ],
      "title": "Customer experience improvement: track experience indicators",
      "category_0": "New Relic solutions",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "f9dd5a60c37a9ce8e30b061f42dd92b77c97829c",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/Insights-catalyst-dashbaord-1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/customer-experience-improvement-track-experience-indicators",
      "published_at": "2020-09-27T21:45:56Z",
      "updated_at": "2020-09-27T21:45:56Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "Identify and track the key indicators of customer experience to understand the effect of application performance on your business.",
      "body": "This tutorial covers methods to identify and track the key indicators of customer experience and clarifies the effect of application performance on your business. A clear understanding of what creates successful customer experience helps DevOps teams drive greater efficiencies in work efforts and deliver greater productivity. An efficient, well-functioning DevOps culture enables organizations to make rapid, frequent releases and product changes. A strong DevOps culture also democratizes data beyond the typical backend users, and makes it available to groups like customer service, support, sales, and marketing. However, this data information enablement is only useful if its purpose is to improve and optimize customer experience. Prerequisites This tutorial assumes you’ve reviewed the Establish team dashboards tutorial. 1. Use custom attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the front- and back-end transactions that are responsible for their interactions with your application. In New Relic, you collect this data with custom attributes. If you plan to collect this information in both frontend and backend, be sure to forward custom attributes from APM to Browser. Here are some common attributes to collect: User ID Organization or customer ID A/B testing cohort value High-value customer indicator Purchase value or product IDs (for e-commerce) If you’ve completed the Iterate and measure impact or Establish objectives and baselines tutorials, consider what service level objectives (SLOs) or key metrics you defined in those stages. New Relic recommends including attributes like the above to measure the impact of your changes and optimizations at a customer level—not only a performance level. 2. Create dashboards with performance and business metrics Using the attributes collected in Step 1, build dashboards to examine the impact of performance issues on your users. Additionally, to drive visibility across your teams, add dedicated widgets to the team dashboards you built in the Establish team dashboards . insights.newrelic.com > Dashboards For example, if you were collecting a custom username attribute, you could use NRQL queries like these to create your widgets for your New Relic Insights dashboard: Number of errors by username: SELECT count(*) FROM TransactionError FACET username Median response time by username: SELECT percentile(duration,50) FROM Transaction FACET username Total purchase value in transactions with errors: SELECT sum(purchaseTotal) FROM TransactionError FACET username If you include a FACET clause in your queries, you’ll be able to click into metric results to see corresponding change in the performance data. For more information on faceting, see Linking Between Dashboards to Drill Into Your Data. 3. Share dashboards across departments Dashboards, data, and metrics that nobody looks at or knows about might as well not exist. When considering how, or with whom, to share your dashboards, consider the following questions: Which teams are responsible for applications that have high levels of end-user interaction? What non-engineering teams could benefit from this information? Customer support: Could customer issues be resolved faster? Product/engineering: Could product make more informed roadmap decisions? Customer success: Can this data be used to make our customers more successful? Are there other teams that can benefit from cohort analysis that includes performance metrics? 4. Utilize data to separate performance by cohort and debug issues at the customer level After you create your dashboards, use them to scope issues affecting particular customers or sets of customers. For example, the following widget shows which apps have errors for a particular user: insights.newrelic.com > Dashboards Use attributes that track user and performance to set alerts on high priority users or customers. For example, you could include a WHERE clause in your NRQL queries to scope the results to a set of user IDs or customer IDs. Set alerts on any performance or business metric that is tied to these attributes. See NRQL alerts will change how you think about using New Relic data for more information. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.72308,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Customer</em> experience improvement: track experience indicators",
        "sections": "1. Use <em>custom</em> <em>attributes</em> to associate performance data",
        "info": "Identify and track the key indicators of <em>customer</em> experience to understand the effect of application performance on your business.",
        "body": ", sales, and marketing. However, this data information enablement is only useful if its purpose is to improve and optimize customer experience. Prerequisites This tutorial assumes you’ve reviewed the Establish team dashboards tutorial. 1. Use <em>custom</em> <em>attributes</em> to associate performance data In order"
      },
      "id": "5f5adb2728ccbc7152532752"
    },
    {
      "category_2": "Optimize your cloud native environment",
      "nodeid": 32796,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Customer experience improvement: Track experience indicators",
        "1. Use custom attributes to associate performance data",
        "2. Create dashboards with performance and business metrics",
        "3. Share dashboards across departments",
        "4. Use data to separate performance by cohort and debug issues at the customer level",
        "For more help"
      ],
      "title": "Customer experience improvement: Track experience indicators",
      "category_0": "New Relic solutions",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "4e6a6333e185fe1886b02fa3e5b98a819d9e0f99",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/Insights-catalyst-dashbaord-1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/customer-experience-improvement-track-experience-indicators",
      "published_at": "2020-09-27T20:35:02Z",
      "updated_at": "2020-09-27T20:35:02Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Optimize your cloud native environment",
      "document_type": "page",
      "popularity": 1,
      "info": "The four steps help you leverage the data you collect to make the greatest possible improvements in your organization’s digital customer experience.",
      "body": "This tutorial covers methods to identify and track the key indicators of customer experience and clarifies the effects of application and infrastructure performance on your business. A clear understanding of what creates a successful customer experience can help modern software teams become more efficient and boost productivity. An efficient, well-functioning IT culture helps organizations make rapid, frequent releases and product changes. A strong culture also democratizes data beyond the typical backend users, making it available to groups such as customer service, support, sales, and marketing. However, this information enablement is useful only if it serves to optimize customer experience. The four steps outlined here are designed to help you leverage the data you collect to make the greatest possible improvements in your organization’s digital customer experience. 1. Use custom attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with your application. In New Relic, you collect this data with custom attributes. If you plan to collect this information in both the frontend and backend, be sure to forward custom attributes from APM to Browser. Here are some common attributes to collect: User ID Organization or customer ID A/B testing cohort value High-value customer indicator Purchase value or product IDs (for e-commerce) If you’ve completed the Establish objectives and baselines tutorials, consider what service-level objectives (SLOs) or key metrics you defined in those stages. New Relic recommends including attributes like the ones listed above to measure the impact of your changes and optimizations at a customer level—rather than just measuring pure performance. 2. Create dashboards with performance and business metrics Using the attributes collected in Step 1, build dashboards to examine the impact of performance issues on your users. insights.newrelic.com > Dashboards For example, if you were collecting a custom username attribute, you could use NRQL queries like these to create your widgets for your New Relic Insights dashboard: Number of errors by username: SELECT count(*) FROM TransactionError FACET username Median response time by username: SELECT percentile(duration,50) FROM Transaction FACET username Total purchase value in transactions with errors: SELECT sum(purchaseTotal) FROM TransactionError FACET username If you include a FACET clause in your queries, you’ll be able to click into metric results to see corresponding change in the performance data. For more information on faceting, see Linking Between Dashboards to Drill Into Your Data. 3. Share dashboards across departments Dashboards, data, and metrics that nobody looks at or knows about might as well not exist. When considering how, or with whom, to share your dashboards, consider the following questions: Which teams are responsible for applications that have high levels of end-user interaction? What non-engineering teams could benefit from this information? Customer support: Could customer issues be resolved faster? Product/engineering: Could the product team make more informed roadmap decisions? Customer success: Can this data be used to make customers more successful? Are there other teams that can benefit from cohort analysis that includes performance metrics? 4. Use data to separate performance by cohort and debug issues at the customer level After you create your dashboards, use them to scope issues affecting particular customers or sets of customers. For example, the following widget shows which apps have errors for a particular user: insights.newrelic.com > Dashboards Use attributes that track user and performance to set alerts on high priority users or customers. For example, you could include a WHERE clause in your NRQL queries to scope the results to a set of user IDs or customer IDs. Set alerts on any performance or business metric that is tied to these attributes. See NRQL alerts will change how you think about using New Relic data for more information. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.30603,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Customer</em> experience improvement: Track experience indicators",
        "sections": "1. Use <em>custom</em> <em>attributes</em> to associate performance data",
        "info": "The four steps help you leverage the data you collect to make the greatest possible improvements in your organization’s digital <em>customer</em> experience.",
        "body": " with <em>custom</em> <em>attributes</em>. If you plan to collect this information in both the frontend and backend, be sure to forward <em>custom</em> <em>attributes</em> from APM to Browser. Here are some common <em>attributes</em> to collect: User ID Organization or customer ID A&#x2F;B testing cohort value High-value customer indicator Purchase"
      },
      "id": "5f5ac17528ccbce4f0532733"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13661,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Data requirements and limits for custom event data",
        "General requirements",
        "Reserved words",
        "Additional Browser PageAction requirements",
        "Additional Event API requirements",
        "Event type limits",
        "For more help"
      ],
      "title": "Data requirements and limits for custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "external_id": "f5beef0d09bb5918be3f8a1a3ece98c09947cd1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "published_at": "2020-09-27T17:50:31Z",
      "updated_at": "2020-09-27T17:50:31Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic, general limits and requirements for reporting custom events and attributes. ",
      "body": "You can report custom events to New Relic in several ways, including the New Relic Event API, APM agent APIs, Browser agent APIs, and the Mobile SDK. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. General requirements How long custom data is retained depends on your Insights subscription and its associated data retention. When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1 MB maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. This is not a complete list. In general, it's a good practice to avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Additional Browser PageAction requirements For additional requirements for using New Relic Browser's custom PageAction event, see Insert custom data via New Relic Browser agent. Additional Event API requirements For more requirements and details for the Event API, see Event API. Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.104744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data requirements and limits for <em>custom</em> event data",
        "sections": "<em>Custom</em> events",
        "info": "For New Relic, general limits and requirements for reporting <em>custom</em> events and <em>attributes</em>. ",
        "category_2": "<em>Custom</em> events",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;insights-data-sources&#x2F;<em>custom</em>-data&#x2F;insights-<em>custom</em>-data-requirements-limits",
        "body": "You can report <em>custom</em> events to New Relic in several ways, including the New Relic Event API, APM agent APIs, Browser agent APIs, and the Mobile SDK. This document contains general requirements and rules for inserting and using <em>custom</em> events and their associated <em>attributes</em>. Additional requirements",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; Event data sources &#x2F; <em>Custom</em> events"
      },
      "id": "59f4354f4bb81c2ea8b80d0a"
    },
    {
      "category_2": "Measure DevOps success",
      "nodeid": 16476,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Establish team dashboards: gather and visualize key metrics",
        "Prerequisites",
        "Basic process",
        "1. Make a dashboard of your SLIs",
        "2. Share the first version of your dashboard",
        "3. Create the team dashboard",
        "4. Create a business performance dashboard",
        "For more help"
      ],
      "title": "Establish team dashboards: gather and visualize key metrics ",
      "category_0": "New Relic solutions",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "e1de321520ff50464c1f9ff75fc4b6753cc344ea",
      "image": "https://docs.newrelic.com/sites/default/files/styles/inline_660px/public/thumbnails/image/catalyst-team-dashboard.png?itok=JXMq0zgC",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/establish-team-dashboards-gather-visualize-key-metrics",
      "published_at": "2020-09-29T02:00:57Z",
      "updated_at": "2020-09-28T00:43:51Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "When issues arise, dashboards in New Relic Insights help teams narrow their search to a manageable number of endpoints, reducing the time to resolution.",
      "body": "New Relic Insights dashboards enable collaboration and help teams provide improved digital customer experience through better performing applications and websites. Dashboards also increase employee productivity by helping teams align with business goals to better understand how their application's performance impacts their full business. When issues arise, dashboards help teams narrow their search to a manageable number of endpoints and service layers, reducing the time to detection or resolution. Fostering collaboration mitigates the risk of friction, giving each stakeholder data relevant to their role. Prerequisites This tutorial assumes: You have instrumented your applications in New Relic. You understand the basics of creating dashboard widgets. Optional: you have added custom attributes and events. For more information, review New Relic's objectives and baselines tutorial, which also includes detailed information about SLIs, SLOs, and SLAs. Basic process In this tutorial, New Relic recommends that you start with team dashboards and then build a business performance dashboard. Team dashboards let you visualize the service level indicators (SLIs) and other key performance indicators (KPIs) for your applications at a glance by providing the status of relevant components in a single view. Use team dashboards in your daily standups to guide your work for the day. Use business performance dashboards as a single source of truth for broader observation about your business as a whole. For more information on why development and operations teams should track services running in production and make them highly visible, see the O'Reilly DevOps Handbook 1. Make a dashboard of your SLIs Team dashboards enable collaboration and provide a shared understanding of which areas of your application or organization needs attention. Group your dashboards by business units or functional areas as appropriate. Personalize the information that is relevant to your business units. Ask questions such as: Application owners: What are the top five error types affecting my application? Online store manager: How many people are affected by “Unable to display the shopping cart” errors? Executives: What is the revenue at risk when customers check online fares and availability of flights? Which channels are affected? After you select the metrics to capture, use the data explorer to create views of your SLIs to add to your dashboard. If the data explorer does not provide exactly what you need, create your own NRQL queries. For example, for an SLI based on HTTP status codes, use the following NRQL query: SELECT count(*) FROM Transaction WHERE httpResponseCode != 200 insights.newrelic.com: Here is an example NRQL query for an SLI based on HTTP status codes. In addition to application performance, it's also important to measure efficiency of your delivery pipeline. Key indicators of your team’s progress toward fully functional DevOps include: Deployment frequency: Companies with DevOps cultures deploy code more frequently. Change lead time: How quickly teams make change is a great way to measure their agility. High-performing DevOps teams average less than one hour between code commits and deploys, while traditional teams take between one to six months. Mean time to recover (MTTR): Every organization has failures. Modern teams recover in minutes, not hours. Having precise measurements of MTTR helps IT managers monitor the people, processes, and technology that enable rapid recovery and head off problems before they result in significant downtime. For more information about these metrics, review New Relic's tutorial about iterating and measuring impact. As you gather interesting views for your first dashboard, don't overthink it. Consider this initial dashboard a discussion starter. 2. Share the first version of your dashboard After creating a basic dashboard that charts some of the key data for your business and your team, share the dashboard with your team and other stakeholders. As you engage others for feedback, you may find metrics are missing. At the same time, do not be afraid to remove a metric that is not actionable or does not make sense. A well-formed team dashboard can help facilitate productive daily discussions and effective collaboration across your team. Good discussion questions include: Does this dashboard make sense to us? Are we measuring the right things? What assumptions are we making to capture this data? Is what we are measuring actionable? What would we do if we were alerted on this SLI? Could someone else understand this dashboard without explanation? What would the CTO think if they saw this dashboard? Also, determine how this team dashboard can be most helpful in your daily workflow. For example, check your dashboards during your daily standup to see if you need to re-prioritize their daily work. 3. Create the team dashboard Now that you have buy-in from the team, build out a full dashboard with the widgets your team has agreed on. At the application level, your goal is to ensure that your dashboard tracks both of these criteria: What is your application's health; for example, memory usage and transaction counts What extent is your team achieving its business goals; for example, the number of new users, user session lengths, percent of users active, etc. insights.newrelic.com: Here is an example Insights team dashboard that shows both the app's health and the team's success with business goals. Insights lets you create many chart types for the most logical data to track. Recommendation: At a minimum, include the following: Response time: Area chart Availability percentage: Billboard Errors: Pie chart Throughput: Area chart Page views: Billboard If your app is particularly complex, create a collection of linked team dashboards (data apps) for a curated, application-like experience. When it's complete, share the dashboard with your team and any upstream or downstream teams as appropriate. 4. Create a business performance dashboard Your business performance dashboard will give your teams an overview of how users are experiencing your app. Most New Relic customers want to know how their apps are experienced across different cohorts, such as geographic locations or device types. insights.newrelic.com: Here is an example Insights team dashboard that shows key performance indicators (KPIs). Companies in many industries consider the following key performance indicators (KPIs) essential to business performance. Use the following NRQL examples to build widgets for your dashboards. Session count NRQL query To run a NRQL query for Browser session count: SELECT uniqueCount(session) FROM PageView Session duration NRQL query To run a NRQL query for Browser session duration: SELECT average(duration) AS 'Seconds' FROM PageView FACET session Page views NRQL query To run a NRQL query for Browser page views: SELECT count(*) AS '' FROM PageView Page render time NRQL query To run a NRQL query for Browser page rendering: SELECT average(pageRenderingDuration) FROM PageView Conversion funnel NRQL query To run a NRQL query for page conversion funnel: SELECT funnel(session, WHERE pageUrl LIKE 'https://newrelic.com//'/ AS 'Home', WHERE pageUrl LIKE 'https://newrelic.com/search#stq=apm&stp=1' AS 'Search', WHERE pageUrl LIKE 'https://docs.newrelic.com/docs/apm' AS 'Select') FROM PageView Error percentage NRQL query To run a NRQL query for APM error percentage: SELECT count(*) FROM Transaction WHERE httpResponseCode !='200' Apdex NRQL query To run a NRQL query for APM Apdex: SELECT apdex(duration, t:0.5) FROM Transaction DOM readiness NRQL query To run a NRQL query for Browser DOM readiness: SELECT average(domProcessingDuration) FROM PageView For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.80168,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to their role. Prerequisites This tutorial assumes: You have instrumented your applications in New Relic. You understand the basics of creating dashboard widgets. Optional: you have added <em>custom</em> <em>attributes</em> and events. For more information, review New Relic&#x27;s objectives and baselines tutorial, which"
      },
      "id": "5f5a021ce7b9d2ddb9acfd3d"
    }
  ],
  "/collect-data/query-data-nrql": [
    {
      "category_2": "Custom events",
      "nodeid": 13661,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Data requirements and limits for custom event data",
        "General requirements",
        "Reserved words",
        "Additional Browser PageAction requirements",
        "Additional Event API requirements",
        "Event type limits",
        "For more help"
      ],
      "title": "Data requirements and limits for custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "external_id": "f5beef0d09bb5918be3f8a1a3ece98c09947cd1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "published_at": "2020-09-27T17:50:31Z",
      "updated_at": "2020-09-27T17:50:31Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic, general limits and requirements for reporting custom events and attributes. ",
      "body": "You can report custom events to New Relic in several ways, including the New Relic Event API, APM agent APIs, Browser agent APIs, and the Mobile SDK. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. General requirements How long custom data is retained depends on your Insights subscription and its associated data retention. When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1 MB maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. This is not a complete list. In general, it's a good practice to avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Additional Browser PageAction requirements For additional requirements for using New Relic Browser's custom PageAction event, see Insert custom data via New Relic Browser agent. Additional Event API requirements For more requirements and details for the Event API, see Event API. Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.3344,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for custom event <em>data</em>",
        "sections": "Event <em>data</em> sources",
        "category_1": "Event <em>data</em> sources",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;insights-<em>data</em>-sources&#x2F;custom-<em>data</em>&#x2F;insights-custom-<em>data</em>-requirements-limits",
        "body": " may apply based on the method you use. General requirements How long custom <em>data</em> is retained depends on your Insights subscription and its associated <em>data</em> retention. When reporting custom events and attributes, follow these general requirements for supported <em>data</em> types, naming <em>syntax</em>, and size",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; Event <em>data</em> sources &#x2F; Custom events"
      },
      "id": "59f4354f4bb81c2ea8b80d0a"
    },
    {
      "category_2": "Get started",
      "nodeid": 11431,
      "sections": [
        "NRQL: New Relic Query Language",
        "Get started",
        "NRQL query tools",
        "NRQL query tutorials",
        "Introduction to NRQL, New Relic's query language",
        "What is NRQL?",
        "Where can you use NRQL?",
        "What data can you query with NRQL?",
        "Start using NRQL",
        "NRQL query examples",
        "NRQL syntax",
        "For more help"
      ],
      "title": "Introduction to NRQL, New Relic's query language",
      "category_0": "Query your data",
      "type": "docs",
      "category_1": "NRQL: New Relic Query Language",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language",
      "external_id": "d44be2c7df7addda8679b4c842015223cfcbd1a3",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-view-chart-nrql-query_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language",
      "published_at": "2020-09-28T00:02:05Z",
      "updated_at": "2020-09-24T08:40:20Z",
      "breadcrumb": "Contents / Query your data / NRQL: New Relic Query Language / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to New Relic Query Language (NRQL) and how to use it.",
      "body": "One way to query your New Relic data is with the New Relic Query Language (NRQL). This resource explains what NRQL is, when and how you can use it, and basic syntax rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see NRQL syntax, clauses, and functions. What is NRQL? NRQL is New Relic's SQL-like query language. You can use NRQL to retrieve detailed New Relic data and get insight into your applications, hosts, and business-important activity. Reasons to use NRQL include: To answer a question for the purpose of troubleshooting or business analysis To create a new chart To make API queries of New Relic data (for example, using our NerdGraph API) NRQL is used behind the scenes to generate some New Relic charts: Some New Relic charts are built using NRQL. One way to start using NRQL is to view a chart's query and then edit it to make your own custom chart. Where can you use NRQL? You can use NRQL in these places: New Relic One query builder: Advanced mode is a NRQL query interface Basic mode provides a simplified query experience that doesn't require knowledge of NRQL but that uses NRQL to generate results New Relic Insights NerdGraph: our GraphQL-format API, which includes options for making NRQL queries one.newrelic.com > Query your data: You can run a NRQL query in both New Relic One and New Relic Insights. This NRQL query shows a count of distributed tracing spans faceted by their entity names. NRQL is one of several ways to query New Relic data. For more on all query options, see Query your data. What data can you query with NRQL? NRQL allows you to query these New Relic data types: Event data from all New Relic products, including: APM events, like Transaction New Relic Browser events, like PageView New Relic Mobile events, like Mobile Infrastructure events, like ProcessSample Synthetics events, like SyntheticCheck Custom events, like those reported by the Event API Metric timeslice data (metrics reported by New Relic APM, Browser, and Mobile) The Metric data type (metrics reported by the Metric API and data sources that use that API) The Span data type (distributed tracing data) The Log data type (data from New Relic Logs) Some data, like relationships between monitored entities, is not available via NRQL but is available using our NerdGraph API. Start using NRQL One way to start using NRQL and to understand what data you have available is to go to a NRQL interface (for example, the New Relic One query builder), type FROM, and press space. The interface will suggest available types of data: To see the attributes available for a specific data type, type FROM DATA_TYPE SELECT and press space. The interface will suggest available attributes. For example: To see the complete JSON associated with a data type, including all of its attributes, use the keyset() attribute. For example: FROM Transaction SELECT keyset() NRQL is used behind the scenes to build some New Relic charts and dashboards. One way to learn NRQL is to find one of these NRQL-generated charts and start playing with the NRQL to create new, customized queries and charts: Charts built with NRQL will have View query as an option. You can then edit and customize that query to see how your changes affect the resulting visualization. To explore your data without having to use NRQL, use the basic mode of New Relic One query builder. NRQL query examples Here's an example NRQL query of Transaction data, which is reported by New Relic APM. FROM Transaction SELECT average(duration) FACET appName TIMESERIES auto This would generate a chart that looks like: Here are some more query examples: Basic NRQL query of Browser data Here's a NRQL query of PageView data, which is reported by New Relic Browser. SELECT uniqueCount(user) FROM PageView WHERE userAgentOS = 'Mac' FACET countryCode SINCE 1 day ago LIMIT 20 Attribute name with a space in it If a custom attribute name has a space in it, use backticks around the attribute name: SELECT count(*) FROM Transaction FACET `Logged-in user` Querying multiple data sources To return data from two data sources, separate their data types with a comma. For example, this query returns a count of all APM transactions and Browser events over the last three days:​ SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Query returning multiple columns To return multiple columns from a dataset, separate the aggregator arguments with a comma: SELECT function(attribute), function(attribute) ... FROM ... This query returns the minimum, average, and maximum duration for New Relic Browser PageView events over the last week: SELECT min(duration), max(duration), average(duration) FROM PageView SINCE 1 week ago See more NRQL query examples. NRQL syntax The syntax of a NRQL query is similar to standard SQL queries. Here is a breakdown of the structure of a NRQL query: SELECT function(attribute) [AS 'label'][, ...] FROM data type [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Basic rules include: NRQL condition Details Required values The SELECT statement and FROM clause are required. All other clauses are optional. You can start your query with either SELECT or FROM. Query string size The query string must be less than 4 KB. Case sensitivity The data type names and attribute names are case sensitive. NRQL clauses and functions are not case sensitive. Syntax for strings NRQL uses single quotes to designate strings. For example: ... where traceId = '030a573f0df02c57' Attribute names with spaces Use backticks `` to quote a custom attribute name that has a space in it. For example: ... FACET `Logged-in user` Data type coercion Insights does not support data type \"coercion.\" For more information, see Data type conversion. Use of math functions Basic and advanced math functions are supported in the SELECT statement. JOIN functions NRQL does not have the equivalent of the SQL JOIN function, but you can simulate a JOIN with custom attributes. Read more about NRQL syntax and functions. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.41745,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>NRQL</em>, New Relic&#x27;s query language",
        "sections": "What <em>data</em> can you query with <em>NRQL</em>?",
        "info": "An introduction to New Relic Query Language (<em>NRQL</em>) and how to use it.",
        "category_0": "Query your <em>data</em>",
        "category_1": "<em>NRQL</em>: New Relic Query Language",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;query-your-<em>data</em>&#x2F;<em>nrql</em>-new-relic-query-language&#x2F;get-started&#x2F;introduction-<em>nrql</em>-new-relics-query-language",
        "body": "One way to query your New Relic <em>data</em> is with the New Relic Query Language (<em>NRQL</em>). This resource explains what <em>NRQL</em> is, when and how you can use it, and basic <em>syntax</em> rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see <em>NRQL</em> <em>syntax</em>",
        "breadcrumb": "Contents &#x2F; Query your <em>data</em> &#x2F; <em>NRQL</em>: New Relic Query Language &#x2F; Get started"
      },
      "id": "5f2abd47196a67747343fbe1"
    },
    {
      "category_2": "Ingest APIs",
      "nodeid": 35526,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Ingest APIs",
        "Metric API limits and restricted attributes",
        "Endpoint requirements and maximum limits",
        "Rate limit violations",
        "Restricted attributes",
        "For more help"
      ],
      "title": "Metric API limits and restricted attributes",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "32ae97feb47a5a92dc7bf9809d396ef133b8b5a7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-data/apis/metric-api-limits-restricted-attributes",
      "published_at": "2020-09-27T21:34:10Z",
      "updated_at": "2020-09-27T21:34:10Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Ingest APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Rate limits and restricted keywords for the New Relic Metric API, and what to do if you reach their limits.",
      "body": "This document describes data requirements for the Metric API, including: Data specifications and maximum limits Restricted attributes For instructions on sending metric data and formatting of the JSON payload, see Report metrics via the Metric API. Endpoint requirements and maximum limits All metric data is sent using a POST to: https://metric-api.newrelic.com/metric/v1 If your account hosts data in New Relic's European Union data center, ensure you're using the proper API endpoints for EU region accounts. The following default limits apply for all metric data: Condition Limit Age range for timestamp values Metrics reported with a timestamp older than 48 hours ago or newer than 24 hours from the time they are reported are dropped. Max data points per minute (DPM) See Additional account conditions. 1 million DPM Max unique timeseries (cardinality) per account per day See Additional account conditions. 1 million A timeseries is a single, unique combination of a metric name and any attributes. Max unique timeseries (cardinality) per metric name per day 100k Max payloads per minute 50k Max attributes per metric 100 Max metric attribute name length 255 characters Max characters for an attribute key 255 characters Max metric attribute value length 4096 characters Allowed HTTP protocols HTTPS only Numerical long values falling outside minimum or maximum Java long values Numerical long values that fall outside of the minimum or maximum Java long value will be rejected. If the number is in the common block, then the entire block will be dropped. If the number is in a metric data point, then the metric data point it resides in will be dropped. Numerical double values falling outside minimum or maximum Java double values Numeric double values that fall outside of a the minimum or maximum Java double value will be rejected. If the number is in the common block, then the entire block will be dropped. If the number is in a metric data point, then the metric data point it resides in will be dropped. Payload size Total maximum size or length: 1 MB maximum per POST. We highly recommend using compression. Payload format The payload must encoded as UTF-8. Attribute naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Additional account conditions: Metric API limits apply at the individual account level. Trial and paid accounts receive a 1M DPM and 1M cardinality limit for trial purposes, but you can request up to 15M DPM and 15M cardinality for your account. To request changes to your metric rate limits, contact your New Relic account representative, or visit our Support portal. Rate limit violations This section describes how the Metric API behaves when you exceed the rate limits, and how to respond if limits are exceeded. Max data points per minute (DPM) Data points per minute refers to the per minute rate at which individual metric values are sent to the Metric API. When the maximum DPM limit is exceeded for an account, the New Relic Metric API returns a 429 response for the remainder of the minute. The response will include a Retry-After header indicating how long to wait in seconds before resubmitting or sending new data. To resolve this issue, either reduce the number of data points you are sending, or request a rate limit change. Subsequent subscription changes do not impact modified rate limits. If an account change impacts your rate limit, you must notify us to adjust your rate limit. To request rate limit changes, contact your New Relic account representative, or visit our Support portal. Max unique timeseries per account per day A timeseries is a single, unique combination of a metric name and any attributes assigned to that metric. For example, if a CPU utilization metric with a single attribute hostname is sent from ten different hosts, this equals ten distinct values for the hostname attribute and ten unique metric timeseries. If the per-account, per-day unique metric timeseries (cardinality) limit is exceeded during a 24 hour period, the endpoint will continue to receive and store raw metric data. However, New Relic will stop creating additional aggregate rollups (1 minute, 5 minutes, etc.) for the remainder of the 24 hour period. (These rollups are used used by default to query time windows longer than 60 minutes.) You can continue to query your data when such a violation occurs by specifying a 60 minute or shorter time window or specifying the RAW keyword as described in view and query your metrics. This can be helpful in identifying potential causes for the violation. Max unique timeseries per metric name per day A timeseries is a single, unique combination of a metric name and any attributes assigned to that metric. For example, if a CPU utilization metric with a single attribute hostname is sent from ten different hosts, this equals ten distinct values for the hostname attribute and ten unique metric timeseries. If the per-metric name, per-day unique metric timeseries (cardinality) limit is exceeded during a 24 hour period, the endpoint will continue to receive and store raw metric data. However, New Relic will stop creating additional aggregate rollups (1 minute, 5 minutes, etc.) for the remainder of the 24 hour period. (These rollups are used used by default to query time windows longer than 60 minutes.) You can continue to query your data when such a violation occurs by specifying a 60 minute or shorter time window or specifying the RAW keyword as described in view and query your metrics. This can be helpful in identifying potential causes for the violation. Max payloads per minute If you make more than 50k POST requests to the Metric API endpoint within a minute, the endpoint will return a 429 response for the remainder of the minute. The response will include a Retry-After header indicating how long to wait in seconds before resubmitting or sending new data. In general, if you reach this limit, consider creating larger payloads. To do this, combine more data points into each request to reduce the number of POSTs that are necessary. If this is not an option, you can request a rate limit increase by contacting your New Relic account representative or visiting our Support portal. Restricted attributes These attributes are restricted by the New Relic platform. Any values submitted with these keys in the attributes section of a metric data point will cause the data point to be dropped, or the value to be omitted or overwritten: Attribute Description newrelic.source This resets to the value metricAPI. metricName This resets to the name value passed into each data point. This allows name to be an attribute key. endTimestamp timestamp and interval.ms will be converted to an endTimestamp for the data point. Additional restrictions include: Restriction Comments Metric and attribute names You cannot pass the same value for metric name and attribute name. In the following example, the metric is invalid because the metric is named service.errors.all and there is an attribute service.errors.all. Example: Metric value used as an attribute (invalid) [ { \"metrics\": [ { \"name\": \"service.errors.all\" , \"type\": \"count\", \"value\": 15, \"timestamp\": 1531414060739, \"interval.ms\": 10000, \"attributes\": { \"service.response.statuscode\": \"400\", \"service.errors.all\" : \"test\", \"service.name\": \"foo\" } } ] } ] Reserved words The Metric API inherits some reserved words from New Relic Insights, including accountID, appId, and eventType. Additionally, the syntax terms for NRQL are restricted unless you backtick (``) them. For a full list, see Reserved words: NRQL syntax terms. Keys within metric JSON All keys used within the metric JSON cannot be attribute keys. This includes interval.ms, timestamp, value, common, min, max, count, sum, and metrics. Exception: You can use name as an attribute key. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 95.79527,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Ingest and manage <em>data</em>",
        "category_0": "Telemetry <em>Data</em> Platform",
        "category_1": "Ingest and manage <em>data</em>",
        "body": ", appId, and eventType. Additionally, the <em>syntax</em> terms for <em>NRQL</em> are restricted unless you backtick (``) them. For a full list, see Reserved words: <em>NRQL</em> <em>syntax</em> terms. Keys within metric JSON All keys used within the metric JSON cannot be attribute keys. This includes interval.ms, timestamp, value",
        "breadcrumb": "Contents &#x2F; Telemetry <em>Data</em> Platform &#x2F; Ingest and manage <em>data</em> &#x2F; Ingest APIs"
      },
      "id": "5f24e4ede7b9d28743c8231c"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 9231,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Create NRQL alert conditions",
        "Create NRQL alert condition",
        "Alert threshold types",
        "NRQL alert syntax",
        "Sum of query results (limited or intermittent data)",
        "Offset the query time window",
        "NRQL alert threshold examples",
        "Create a description",
        "For more help"
      ],
      "title": "Create NRQL alert conditions",
      "category_0": "Alerts and Applied intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "external_id": "956a7a0b84d2afac5e6236df3143085ebc4f7459",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "published_at": "2020-09-28T03:46:01Z",
      "updated_at": "2020-09-03T23:54:56Z",
      "breadcrumb": "Contents / Alerts and Applied intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "How to define thresholds that trigger alert notifications based on your NRQL queries.",
      "body": "You can create alert conditions using NRQL queries. Create NRQL alert condition To create a NRQL alert condition: When you start to create a condition, where it prompts you to Select a product, click NRQL. Tips for creating and using a NRQL condition: Topic Tips Condition types NRQL condition types include static, baseline, and outlier. Create a description For some condition types, you can create a Description. Query results Queries must return a number. The condition works by evaluating that returned number against the thresholds you set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Condition settings Use the Condition settings to: Configure whether and how open violations are force-closed. Adjust the evaluation offset. Create a concise and descriptive condition name. (NerdGraph API Only) Provide a text description for the condition that will be included in violations and notifications. Troubleshooting procedures Optional: To include your organization's procedures for handling the incident, add the runbook URL to the condition. Limits on conditions See the maximum values. Health status NRQL alert conditions do not affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type, except you cannot use a FACET clause. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. NRQL alert syntax Here is the basic syntax for creating all NRQL alert conditions. Depending on the threshold type, also include a FACET clause as applicable. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Optional Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Static: Optional Baseline: Not allowed Outlier: Required Including a FACET clause in your NRQL syntax depends on the threshold type: static, baseline, or outlier. Use the FACET clause to separate your results by attribute and alert on each attribute independently. Faceted queries can return a maximum of 5000 values for static conditions and a maximum of 500 values for outlier conditions. If the query returns more than this number of values, the alert condition cannot be created. If you create the condition and the query returns more than this number later, the alert will fail. Sum of query results (limited or intermittent data) Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of the one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum, and the preview chart will update accordingly. Offset the query time window Every minute, we evaluate the NRQL query in one-minute time windows. The start time depends on the value you select in the NRQL condition's Advanced settings > Evaluation offset. Example: Using the default time window to evaluate violations With the Evaluation offset at the default setting of three minutes, the NRQL time window applied to your query will be: SINCE 3 minutes ago UNTIL 2 minutes ago If the event type is sourced from an APM language agent and aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend evaluating data from three minutes ago or longer. An offset of less than 3 minutes will trigger violations sooner, but you might see more false positives and negatives due to data latency. For cloud data, such as AWS integrations, you may need an offset longer than 3 minutes. Check our AWS polling intervals documentation to determine your best setting. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction SELECT percentile(databaseDuration, 75) FROM Transaction Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction SELECT average(duration) FROM Transaction Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Create a description You can define a description that passes useful information downstream for better violation responses or for use by downstream systems. For details, see Description. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.54929,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>NRQL</em> alert conditions",
        "sections": "<em>NRQL</em> alert <em>syntax</em>",
        "info": "How to define thresholds that trigger alert notifications based on your <em>NRQL</em> queries.",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;alerts-applied-intelligence&#x2F;new-relic-alerts&#x2F;alert-conditions&#x2F;create-<em>nrql</em>-alert-conditions",
        "body": " for handling the incident, add the runbook URL to the condition. Limits on conditions See the maximum values. Health status <em>NRQL</em> alert conditions do not affect an entity&#x27;s health status display. Examples For more information, see: Expected <em>NRQL</em> <em>syntax</em> Examples of <em>NRQL</em> condition queries Alert threshold"
      },
      "id": "5f2d992528ccbc489d88dfc1"
    },
    {
      "category_2": "Explore data",
      "nodeid": 1131,
      "sections": [
        "Use Insights UI",
        "Getting started",
        "Explore data",
        "Guides",
        "Manage account data",
        "Manage dashboards",
        "Time settings",
        "Export data",
        "Troubleshooting",
        "Query page: Create and edit NRQL queries",
        "Use NRQL query history",
        "For more help"
      ],
      "title": "Query page: Create and edit NRQL queries",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Use Insights UI",
      "external_id": "e00d2b865680d15c361b4058e22270fe5103aa8e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/manage-account-data/query-page-create-edit-nrql-queries",
      "published_at": "2020-09-27T23:32:19Z",
      "updated_at": "2020-07-26T08:08:39Z",
      "breadcrumb": "Contents / Insights / Use Insights UI / Explore data",
      "document_type": "page",
      "popularity": 1,
      "info": "Use the New Relic Insights Query page to create and edit NRQL queries, favorite them for later use, and add query results to dashboards. ",
      "body": "New Relic Insights' Query page is one place you can run NRQL queries of your data. To get started: Go to insights.newrelic.com > Query, then use any of the available NRQL syntax and functions. Use the Query page to: Create and run queries of your data. View your query history. View favorite queries. Use the NRQL query to create, view, organize, and share Insights dashboards. For a library of educational videos about how to use New Relic Insights, visit learn.newrelic.com. Use NRQL query history To view up to twenty of your most recent queries, select the History tab directly below the query command line interface. Use the query history to adjust and improve recent queries. If you want to... Do this... Run recent queries Select a recent query from the history list. The query will appear on the command line, where it can be edited. Delete queries Mouse over a query in the history list so the delete [trash] icon appears. The query history only retains the twenty most recent queries, so it can be useful to delete unwanted queries to make room for queries you like. Favorite queries Mouse over a query in the history list and the favorite star icon appears. Then, to view and use your favorite queries, select the Favorites tab. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.163605,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Query page: Create and edit <em>NRQL</em> queries",
        "sections": "Explore <em>data</em>",
        "info": "Use the New Relic Insights Query page to create and edit <em>NRQL</em> queries, favorite them for later use, and add query results to dashboards. ",
        "category_2": "Explore <em>data</em>",
        "body": "New Relic Insights&#x27; Query page is one place you can run <em>NRQL</em> queries of your <em>data</em>. To get started: Go to insights.newrelic.com &gt; Query, then use any of the available <em>NRQL</em> <em>syntax</em> and functions. Use the Query page to: Create and run queries of your <em>data</em>. View your query history. View favorite queries",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; Use Insights UI &#x2F; Explore <em>data</em>"
      },
      "id": "59425a3c8e9c0f6937f1cda9"
    }
  ],
  "/build-apps/permission-manage-apps": [
    {
      "category_2": "Original users and roles",
      "nodeid": 1101,
      "sections": [
        "Original accounts and billing",
        "Original product-based pricing",
        "Original users and roles",
        "SAML SSO (original users)",
        "Original data retention",
        "Original pricing plan usage",
        "Users and roles (original user model)",
        "View and manage users",
        "User types: basic user and full user",
        "Account roles",
        "Add-on roles",
        "Account permissions",
        "Alert permissions",
        "APM permissions",
        "Browser permissions",
        "Infrastructure permissions",
        "Insights permissions",
        "Mobile permissions",
        "Synthetics permissions",
        "Workloads",
        "For more help"
      ],
      "title": "Users and roles (original user model)",
      "category_0": "New Relic accounts",
      "type": "docs",
      "category_1": "Original accounts and billing",
      "external_id": "39c7440fe944f68b4de943d2c9619cbcc85408d2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/original-accounts-billing/original-users-roles/users-roles-original-user-model",
      "published_at": "2020-09-27T23:44:21Z",
      "updated_at": "2020-09-24T08:31:54Z",
      "breadcrumb": "Contents / New Relic accounts / Original accounts and billing / Original users and roles",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic original user model: explanation of how to manage users, and how user roles work. ",
      "body": "Original user model This doc contains information about how to manage users on our original user model. Not sure which pricing plan or user model you're on? See Overview of pricing plan and user models. View and manage users To see the users on your New Relic account and their current roles: select the account dropdown, select Account settings, and select Users and roles. Some features in the UI are visible only to account Owners and Admins. User types: basic user and full user On the Users and roles UI page, users are categorized as either full users or basic users. This only affects your account once you've switched to the New Relic One pricing plan, released July 2020. Once you've changed your pricing plan, the number of full users is a factor in your billing. Your users on our original user model remain on that user model (and use these original user docs) and additionally have the new full/basic categorization. To learn more, see Transition to new pricing. You can also bulk update changes to user type. Account roles A New Relic account can have only one Owner. To share an account with other users in your organization, create Admins, Users, or Restricted Users. Account role Description Owner The person who initially creates the New Relic account and receives all billing queries. The Owner has complete access to all of the account information. The Owner can also install and configure the New Relic agent, and they can enable or set up features. Admins One or more individuals who can add, edit, and delete account users. Admins can also install and configure the New Relic agent, and they can enable or set up features. Users One or more individuals who use (and optionally set up) the available New Relic features. In general, Admins take responsibility for setting up features, and Users and Restricted Users can use them. Restricted Users One or more individuals who can view (but not set up or change) any New Relic features. The Restricted User role is useful, for example, for demos. You can change your New Relic session settings so that Restricted User logins do not time out, and then set the user interface to Kiosk mode. Add-on roles With add-on roles, you can grant variable levels of access to all users in your account, across the entire platform of New Relic products. This allows you to tailor your account permissions levels to suit the needs of Users and Restricted Users within your account. Giving a User or Restricted User add-on manager access to a product grants them the equivalent of Admin capabilities within the product. They will continue to have User or Restricted User capabilities for all other New Relic products. For example, you could make a software engineer in your company a User in most products, but assign Admin-level access to APM. For another example, you might assign the Nerdpack manager role to a user, and that gives them the ability to subscribe and unsubscribe New Relic One applications to an account. There are two types of add-on roles: Add-on Manager roles are available to grant permissions on a per-product basis. Giving a User or Restricted User managed add-on access to a product grants them the equivalent of Admin capabilities within the product. Custom add-on roles can grant feature-specific permissions across different New Relic products. For example, a group of Users could have the ability to acknowledge incidents and close violations in New Relic Alerts, but not have the ability to modify your existing alert preferences. Individuals on a master account that has sub-accounts automatically have the same level of access for all sub-accounts. Below are options for managing both managed add-on roles and custom add-on roles: View roles To view the list of individuals assigned to your account and their current roles: Go to account dropdown > Account settings > Users and roles. Assign a managed role Owner and Admins Managed add-on roles are available by default for each New Relic product. Adding a managed role for a user grants them Admin-level permissions for the assigned product. They cannot be edited or deleted. To assign a managed add-on role for a User or Restricted User in your account: Go to account dropdown > Account settings > Users and roles. From the list of users associated with your account, select their name. Under Add-on roles, select the type of manager role for the user. To understand which capabilities may be added, use the Capabilities preview chart. Features in the Capabilities preview chart may not exactly match what features are available for your subscription level. You can also add, update, or delete users in bulk by using a CSV file. Create a custom role To create a custom add-on role for your account: Go to account dropdown > Account settings > Users and roles > Roles. Select plus-circle New custom add-on role. Select the capabilities necessary for the new custom role, then Create role. Assign a custom role Owners and Admins You must create a custom role before assigning it to a user. To assign a custom add-on role for a User or Restricted User in your account: Go to account dropdown > Account settings > Users and roles > Users. From the list of users associated with your account, select their name ]. Under Add-on roles, select a custom role for the user. Click Update user. Edit or delete a custom role Owners and Admins You cannot edit or delete New Relic's default roles. However, you can edit or delete custom add-on roles for your account: Go to account dropdown > Account settings > Users and roles > Roles. From the Add-on roles list, select the custom add-on role, then select pencil Edit role or trash-o Delete role as appropriate. Account permissions Here is a summary of basic user rights for your New Relic account. Individuals on a master account with sub-accounts automatically have the same level of access for all sub-accounts. However, they will not receive email notifications for alerts or weekly reports for sub-accounts unless they are explicitly granted permission on these sub-accounts. Function Owner Admin User Restricted Maintain billing information. fa-check Change the account Owner. fa-check Add, update, and delete account Admins, Users, and Restricted Users. When the account Owner and Admins add individuals to the account, New Relic automatically sends them an email message. fa-check fa-check Update users' job titles and roles from Account settings in the New Relic UI. fa-check fa-check Create, modify and delete sub-accounts from Account settings in the New Relic UI. fa-check fa-check Update your own account information (name, password change or password reset request, default account, email preferences, etc.) from User preferences in the New Relic UI. fa-check fa-check fa-check fa-check Change someone else's password. You cannot reset passwords for anyone else on the account, even if you are an Owner or Admin. Instead, follow standard procedures to request a password reset from New Relic. View the list of individuals on the account from (account dropdown) > Account settings > Account > Summary in the New Relic UI. fa-check fa-check fa-check fa-check Manage flexible data retention. fa-check Subscribe and unsubscribe applications to New Relic One fa-check fa-check Alert permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Alerts. To allow a User or Restricted User to execute any of these functions in New Relic Alerts, assign an Alerts add-on manager role. Admin and manager capabilities for Alerts include: Create or name alert policies. Specify incident preferences. Disable or define alert conditions. Provide runbook instructions. Select product targets. Alter alert condition thresholds. Create, modify, or delete notification channels. APM permissions Here is a summary of Admin and Add-on manager capabilities with New Relic APM. To allow a User or Restricted User to execute any of these functions in New Relic APM, assign an APM add-on manager role. Admin and manager capabilities for APM include: Remove applications from the New Relic UI. Delete app traces and error traces. Browser permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Browser. To allow a User or Restricted User to execute any of these functions in New Relic Browser, assign a Browser add-on manager role. Admin and manager capabilities for Browser include: Add, rename, or delete applications. Manage whitelists. Manage domain conditions. Infrastructure permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Infrastructure. To allow a User or Restricted User to execute any of these functions in New Relic Infrastructure, assign an Infrastructure manager role. Admin and manager capabilities for Infrastructure include: Create alert conditions in New Relic Infrastructure, including conditions for host not reporting. Add or modify integrations. Insights permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Insights. To allow a User or Restricted User to execute any of these functions in New Relic Insights, assign an Insights manager role. These functions include: Create, view, modify, or delete Query API keys or Insert API keys. New Relic Insights includes permission levels to share your Insights dashboards with others. Mobile permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Mobile. To allow a User or Restricted User to execute any of these functions in New Relic Mobile, assign a Mobile manager role. Admin and manager capabilities for Mobile include: Delete a mobile application from New Relic. Install New Relic Mobile for Android or iOS. Synthetics permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Synthetics. To allow a User or Restricted User to execute any of these functions in New Relic Synthetics, assign a Synthetics add-on manager role. Admin and manager capabilities for Synthetics include: Create, edit, or delete monitors. Edit monitor scripts. Create, edit, or delete private locations. Create, edit, or delete monitor downtimes. Create, view, edit, or delete secure credentials. For more information, see User roles in Synthetics. Workloads Here's a summary of Admin and Add-on manager capabilities with New Relic One workloads: Create, duplicate, modify, or delete workloads. Link dashboards to workloads and save filters. To allow a User or Restricted User to execute these functions, assign the workloads manager add-on role. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.21445,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Account <em>permissions</em>",
        "info": "For New Relic original user model: explanation of how to <em>manage</em> users, and how user roles work. ",
        "body": " a software engineer in your company a User in most products, but assign Admin-level access to APM. For another example, you might assign the <em>Nerdpack</em> <em>manager</em> role to a user, and that gives them the ability to subscribe and unsubscribe New Relic One applications to an account. There are two types"
      },
      "id": "5f3e194028ccbc18c7f56de3"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/2g790g7la1iot/promo-image.1573253956.png",
      "url": "https://learn.newrelic.com/live-learncast-new-relic-one-programmability",
      "sections": [
        "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications.",
        "About this Learncast",
        "Prerequisites",
        "Virtual Training Session List"
      ],
      "published_at": "2020-09-29T01:41:50Z",
      "title": "Live Learncast: New Relic One Programmability",
      "updated_at": "2020-07-31T01:40:49Z",
      "type": "",
      "external_id": "053510b559767dbde34e3f1ee9a73bbf813a5a83",
      "popularity": 1,
      "body": "Sign In Live Learncast: New Relic One Programmability Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. Not currently available Available until July 10, 2020, 3:30 p.m. PDT. Already registered? Sign In About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably.   During this session we will review the following topics:   1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites   This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications.   Must have:   Permissions to install  Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy   Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably.   During this session we will review the following topics:   1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites   This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications.   Must have:   Permissions to install  Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy   Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) © 2020 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.0435,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic <em>Applications</em>.",
        "body": " A text editor or IDE of your choice (we will be using VS Code) <em>Nerdpack</em> <em>manager</em> roll to deploy   Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials"
      },
      "id": "5dc618cbe7b9d2a0a8e4649c"
    },
    {
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Subscribe or unsubsribe apps",
        "Handle duplicate applications"
      ],
      "title": "Serve, publish, and deploy your New Relic One app",
      "type": "developer",
      "tags": [
        "publish apps",
        "deploy apps",
        "subscribe apps",
        "add metadata apps"
      ],
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "published_at": "2020-09-29T01:52:56Z",
      "updated_at": "2020-09-02T02:05:55Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Start sharing and using the custom New Relic One apps you build",
      "body": "Serve, publish, and deploy your New Relic One app 30 min When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. nr1 update Copy Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. nr1 catalog:submit Copy Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Subscribe or unsubsribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.934006,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and deploy your New Relic One <em>app</em>",
        "sections": "Add images and metadata to your <em>apps</em>",
        "info": "Start sharing and using the custom New Relic One <em>apps</em> you build",
        "tags": "publish <em>apps</em>",
        "body": " to the <em>app</em> Handle duplicate applications Before you begin This guide requires the following: A New Relic One <em>app</em> or <em>Nerdpack</em> New Relic One CLI A <em>Nerdpack</em> <em>manager</em> role for publishing, deploying, and subscribing <em>apps</em>. Serve your <em>app</em> locally You can locally serve the <em>app</em> you create to New Relic One to test"
      },
      "id": "5efa999de7b9d283e67bab8f"
    },
    {
      "image": "https://newrelic.com/dam/new-relic/opengraph/newrelic_og_image.png",
      "url": "https://newrelic.com/resources/webinars/NR-One-Programmability-191126",
      "sections": [
        "During this session we will review the following topics:",
        "Related Links",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-09-27T15:01:28Z",
      "title": "New Relic One Programmability Online Training",
      "updated_at": "2020-09-03T03:22:32Z",
      "type": "storefront",
      "external_id": "f583edb88ca2d2430ca297364eac839705311616",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Video New Relic One Programmability Online Training 46:59   Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. Prerequisites This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications.  Must have: Permissions to install  Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager role to deploy Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests JavaScript layouts   During this session we will review the following topics: Installation of New Relic CLI and Environment setup Familiarisation with New Relic One Application component model and lifecycle Advanced UI construction and data processing Individual self paced experimentation and Open Source example deployment Request a Demo Related Links Case Study La plus grande brasserie au monde se tourne vers New Relic pour que la bière continue de couler à flots dans l’ère numérique Webinar Introduction to Custom Apps on New Relic One eBook Understanding the 3 Phases of DevOps Maturity Article Black Friday Is Coming: Are Your Sites and Apps Ready? eBook DevOps – so geht es richtig : Best Practices zur Überwindung von Erfolgshindernissen eBook DevOps Done Right: Best Practices to Knock Down Barriers to Success eBook Creating a Framework for Digital Media Success Article 7 Requirements for Monitoring Cloud Apps and Infrastructure COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.22993,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "; this training will provide important context to start you on the journey of developing New Relic Applications.  Must have: <em>Permissions</em> to install  Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) <em>Nerdpack</em> <em>manager</em> role to deploy Technical exercises include exposure"
      },
      "id": "5ece92cb28ccbc3012c1356a"
    },
    {
      "nodeid": 9921,
      "sections": [
        "Install and configure the infrastructure agent",
        "Get started",
        "Linux installation",
        "Windows installation",
        "Config management tools",
        "Configuration",
        "Update or uninstall",
        "Manage your agent",
        "Requirements for the infrastructure agent",
        "Processor architectures",
        "Operating systems",
        "Unique hostname",
        "Permissions",
        "Libraries",
        "Network access",
        "Container software",
        "CPU, memory, and disk usage",
        "Configuration management tools",
        "For more help"
      ],
      "title": "Requirements for the infrastructure agent",
      "category_0": "Infrastructure monitoring",
      "type": "docs",
      "category_1": "Install and configure the infrastructure agent",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/infrastructure/install-infrastructure-agent/get-started/requirements-infrastructure-agent",
      "external_id": "71d7349826202468aec8827527896e9bd07d0b2b",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/amazon%20linux.png",
      "url": "https://docs.newrelic.com/docs/infrastructure/install-infrastructure-agent/get-started/requirements-infrastructure-agent",
      "published_at": "2020-09-27T15:22:30Z",
      "updated_at": "2020-09-27T15:22:30Z",
      "breadcrumb": "Contents / Infrastructure monitoring / Install and configure the infrastructure agent / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "Compatibility information for infrastructure monitoring, including supported Linux and Windows versions.",
      "body": "Before installing our infrastructure agent, make sure your system and any on-host integrations you configure meet the requirements. Processor architectures The infrastructure agent supports only x86 processor architectures: Linux: 64-bit architecture (also requires 64-bit package manager and dependencies) Windows: both 32 and 64-bit architectures ARM: AWS Graviton 2 processor (using the tarball setup instructions). Support is limited to infrastructure monitoring. Integrations, such as log forwarding, may not work as expected. Operating systems The infrastructure agent supports these operating systems: Operating system Supported by the infrastructure agent Amazon Linux All versions CentOS Version 6 or higher Debian Version 8 (\"Jessie\") or higher Docker Docker 1.12 Kubernetes Tested with versions 1.10 to 1.16 Red Hat Enterprise Linux (RHEL) Version 6 or higher SUSE Linux Enterprise Server (SLES) Versions 11.4, 12.1, 12.2, 12.3, and 12.4 Ubuntu LTS versions 14.04.x, 16.04.x, and 18.04.x Windows Windows Server 2012, 2016, and 2019, and their service packs. Windows 10 (only the infrastructure agent is supported). Operating systems are not supported beyond end-of-life. You can monitor Amazon BottleRocket workloads: When running EC2 instances, use the containerized agent. On EKS, install the Kubernetes integration. For ECS clusters, deploy the ECS integration. Unique hostname The infrastructure agent uses the hostname to uniquely identify each server. To avoid inaccurate metrics from combining multiple servers under a single hostname, make sure that each monitored server has a unique hostname. You can use the optional display_name setting to override the default hostname. Servers named localhost are not reported: it's a default name and inherently non-unique. Permissions The infrastructure agent requires these permissions: Linux: By default, the agent runs and installs as root. You can also select privileged or unprivileged run modes. Windows: The agent must be installed from an Administrator account and requires Administrator privileges to run. Libraries For agent versions 1.1.19 or higher, you need the libcap library in order to install Infrastructure. It's available in the official repositories of your distribution. Network access In order to report data to New Relic, our infrastructure agent must have outbound access to certain domains and ports. If your system needs a proxy to connect to these domains, use the proxy setting. Container software The infrastructure agent instruments Docker containers when installed on the host server. We support Docker versions 1.12 or higher. CPU, memory, and disk usage The infrastructure agent is fairly lightweight. For typical CPU, memory, and disk usage, see our page on agent performance overhead. For more information on supported file systems, see Storage sample attributes. Configuration management tools The infrastructure agent can be deployed programmatically using several config management and deploy tools: Ansible Chef Elastic Beanstalk Puppet For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.22852,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Permissions</em>",
        "body": "Before installing our infrastructure agent, make sure your system and any on-host integrations you configure meet the requirements. Processor architectures The infrastructure agent supports only x86 processor architectures: Linux: 64-bit architecture (also requires 64-bit package <em>manager</em>"
      },
      "id": "5f57ecf0e7b9d21d5facfd7b"
    }
  ],
  "/automate-workflows/kubernetes-helm-deployment": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Set up New Relic using Helm charts",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Set up New Relic using Terraform"
      ],
      "published_at": "2020-09-29T01:47:50Z",
      "title": "Automate workflows",
      "updated_at": "2020-09-25T01:49:59Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 20 min Set up New Relic using Terraform Learn how to provision New Relic resources using Terraform",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 4995.5312,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em>",
        "body": " solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 20 min <em>Set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em> Learn how to <em>set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em> 30 min Automatically tag a simple &quot;Hello World&quot; Demo across the entire stack See how easy"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Enable log monitoring",
      "nodeid": 34166,
      "sections": [
        "Enable log management",
        "New Relic Logs",
        "Enable log monitoring",
        "Configure logs in context",
        "Logs in context for Go",
        "Logs in context for Java",
        "Logs in context for .NET",
        "Logs in context for Node.js",
        "Logs in context for PHP",
        "Logs in context for Python",
        "Logs in context for Ruby",
        "Logs in context with agent APIs",
        "Kubernetes plugin for log forwarding",
        "Requirements",
        "Enable Kubernetes for logs management",
        "View log data",
        "What's next?",
        "For more help"
      ],
      "title": "Kubernetes plugin for log forwarding",
      "category_0": "Log management",
      "type": "docs",
      "category_1": "Enable log management",
      "external_id": "f41bf00f11ec3abe2ccb843a05cbf6d00c004983",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/enable-log-management-new-relic/enable-log-monitoring-new-relic/kubernetes-plugin-log-forwarding",
      "published_at": "2020-09-27T16:17:57Z",
      "updated_at": "2020-09-27T16:17:57Z",
      "breadcrumb": "Contents / Log management / Enable log management / Enable log monitoring",
      "document_type": "page",
      "popularity": 1,
      "info": "A description of New Relic's Kubernetes logging plugin, and how to install it and configure it. ",
      "body": "Use the Fluent Bit output plugin to easily forward your logs to New Relic. This plugin is also provided in a standalone Docker image that can be installed in a Kubernetes cluster in the form of a DaemonSet, which we refer as the Kubernetes plugin. Requirements To forward your logs to New Relic using the Kubernetes plugin, ensure your configuration meets the following requirements: A New Relic license key Kubernetes cluster deployed Enable Kubernetes for logs management To enable logs management with the Fluent Bit Kubernetes plugin: Install the Kubernetes plugin. When installing the plugin as a Helm chart, you can set numerous configurations. However, we recommend the standard setup, as it is valid for most users. Generate some traffic and wait a few minutes, then check your account for data. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log What's next? Now that you've enabled Logs, here are some potential next steps: Explore your data using the Logs UI. Configure your agent to see contextual log data, such as distributed tracing, stack traces, application logs, and more. Query your data and create custom dashboards or alerts. If no data appears after you enable New Relic Logs, follow the troubleshooting procedures. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.99747,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> Logs",
        "info": "A description of <em>New</em> <em>Relic&#x27;s</em> Kubernetes logging plugin, and how to install it and configure it. ",
        "body": "<em>Use</em> the Fluent Bit output plugin to easily forward your logs to <em>New</em> <em>Relic</em>. This plugin is also provided in a standalone Docker image that can be installed in a Kubernetes cluster in the form of a Daemon<em>Set</em>, which we refer as the Kubernetes plugin. Requirements To forward your logs to <em>New</em> <em>Relic</em>"
      },
      "id": "5f37c1d064441f0d21a0a5e1"
    },
    {
      "category_2": "Cloud adoption",
      "nodeid": 16176,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Optimize your cloud spend",
        "1. Deploy the New Relic Infrastructure agent",
        "2. Create dashboard charts for cloud performance",
        "3. Configure the Amazon AWS integration",
        "4. Set up billing budgets in AWS",
        "5. Add cloud spend and budget widgets to Insights dashboard",
        "6. Create dashboards for every level of your organization",
        "7. Set up alerts",
        "For more help"
      ],
      "title": "Optimize your cloud spend",
      "category_0": "New Relic solutions",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "2f064e99493b6d1ee5b3684b6be93f466ec74929",
      "image": "https://docs.newrelic.com/sites/default/files/styles/inline_660px/public/thumbnails/image/CloudPerformanceForAppXwSpend.png?itok=ODnQ9YW4",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/optimize-your-cloud-spend",
      "published_at": "2020-09-27T22:50:50Z",
      "updated_at": "2020-09-27T22:50:50Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Cloud adoption",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic to keep control of your cloud spending costs, and get your teams alerted when you go over your budgets.",
      "body": "Now that you are using cloud-hosted infrastructure and services, it is important to start looking very early and very closely at your cloud spend: Make sure that your assumptions about your cloud spend are playing out as expected. Quickly catch and correct any unexpected spikes in spending. Start fine-tuning the usage of your cloud-based resources. For example, if you have a set of 20 instances all running at 10% CPU, you can think about using smaller instances or consolidating more work onto those instances. This kind of thinking about your cloud spend helps you optimize and save money quickly. New Relic can help you monitor all this. From a data perspective, it is really just another metric that our platform can collect for you. As with any other metric, you can visualize, report, and alert on your cloud spend data, just like you can with any data New Relic can help you collect. Using the New Relic applied intelligence platform is a great way to help you learn about your cloud spending or about any of your performance data. 1. Deploy the New Relic Infrastructure agent Review the requirements for the New Relic Infrastructure agent and follow the documentation for instructions on installing the agent. After you install the Infrastructure agent on your hosts, you immediately have access to the broad spectrum of metrics that the agent receives automatically. Then, you can set up the cloud integration to start collecting billing information. 2. Create dashboard charts for cloud performance New Relic Dashboards is the product that you use to write powerful custom queries about your data, and then visualize the results in charts that you collect on a dashboard. You can also feed the results of your dashboard queries directly into New Relic Alerts, where you can get notifications on any deviations that you specify. Include charts for various Infrastructure metrics related to performance and usage; for example: CPU Memory Disk Database You may also want to include charts that represent the application using this cloud infrastructure. In this way you can correlate the cloud infrastructure performance with that of the application. As you right-size your cloud infrastructure, you will want to monitor application performance to make sure you are achieving any targets. Here is an example of an Insights dashboard for cloud performance. Break out data by cloud performance and application metrics The following dashboard shows several charts that present key cloud infrastructure metrics and an associated application metric. Every one of these charts represents the result of a query. [Downs: Updated image based on New Relic One can be found at: https://www.dropbox.com/s/rjq7tqrswxwtte9/Tutorial-Run-OptimizeCloudSpen... Image caption: one.newrelic.com > Dashboards: Create dashboards that include both cloud infrastructure and application metrics.] insights.newrelic.com: Create dashboards that include both cloud infrastructure and application metrics. 3. Configure the Amazon AWS integration New Relic Infrastructure comes with several types of integrations, including Amazon Web Services (AWS), Microsoft Azure, and on-host integrations. This tutorial focuses on the AWS Billing integration. First, configure the integration with your AWS account, and then you can set up the AWS Billing integration. 4. Set up billing budgets in AWS The Amazon AWS Billing integration requires some additional configuration on the AWS side. Specifically, you need to go into your AWS Billing dashboard and set up Budgets. Our documentation and the blog post Show Me (Where I’m Spending) the Money! AWS Billing Comes to New Relic Insights provide walk-throughs of this process. When creating Budgets, be sure to: Fill in an application name. Decide whether you are doing cost or service-based budgeting. Decide if your budget is open-ended or has a definite ending date. 5. Add cloud spend and budget widgets to Insights dashboard New Relic Insights is the product that you use to write powerful custom queries about your data, and then visualize the results in widgets that you collect on a dashboard. You can also feed the results of your Insights queries directly into New Relic Alerts, where you can get notifications on any deviations that you specify. Here are some examples of ways to use Insights dashboards to visualize your AWS cloud spend data. Break out data by application and by AWS budget The following dashboard shows several widgets that present key information about an AWS budget vs. actual spending, with data broken out by an application AWS budget. Every one of these widgets represents the result of an Insights query, and the data in the supporting Insights tables is the data that our integration automatically receives from AWS. [Downs: Updated image based on New Relic One can be found at: https://www.dropbox.com/s/ecp5mrnkezh6hjh/Tutorial-Run-OptimizeCloudSpen... Image caption: one.newrelic.com > Dashboards: Add charts that include AWS cloud and budgets data.] [Downs: put this 'code' section below the image please. Here is the query to create the Application X Cloud Cost budget chart in this dashboard example: SELECT latest(`provider.actualAmount`) as '$ Actual', latest(`provider.forecastedAmount`) as '$ Forecast', max(`provider.limitAmount`) as '$ Limit' FROM FinanceSample WHERE provider = 'BillingBudget' AND `provider.budgetName` = 'NAME_OF_YOUR_CLOUD_BUDGET' ] insights.newrelic.com: Create dashboards that include AWS cloud and budgets. 6. Create dashboards for every level of your organization Whether you are a developer, in DevOps, or an executive, having information about your cloud spend can help you optimize your cloud environment. Here are a few ways dashboards can help at each level of your organization: Dashboards for developers Understanding how much applications cost to run helps developers properly configure applications to use more efficient services. For example, could developers save cloud costs using Amazon AWS Lambda or properly sized instances instead of randomly selecting an instance? Dashboards for DevOps Monitoring application costs allows operators to catch possible overruns due to misconfigured services. For example, is the DevOps team’s auto-scaling configuration not scaling down properly? Are they spending money on instances that are not being used? Dashboards for executives An overall view of both forecasted and actual cloud spends for individual applications on a per region basis, as well as total costs, helps executives make better business decisions. Use New Relic to keep control of your cloud spending costs, and get your teams alerted when you go over your budgets. 7. Set up alerts After you write queries on your data in Insights, you can easily use them to create alert conditions. New Relic gives you the ability to write baseline queries against your data. A baseline query is a query that you write without setting hard limits on the results and instead let New Relic Applied Intelligence “machine-learn” your performance data. New Relic alerts you when you go too far outside of your baseline numbers. Configure a baseline query using the forecasted amount Configuring a baseline query using a forecasted amount is a great starting point for monitoring any cloud budget, as you grow to understand what your cloud spend will be over time. New Relic notifies you if something spikes beyond your forecasted trend. That query looks like this: SELECT latest(`provider.forecastedAmount`) FROM FinanceSample WHERE provider = 'BillingBudget' and `provider.budgetName` = 'NAME_OF_YOUR_CLOUD_BUDGET' When you create a baseline query and alert on it, you decide how restrictively Applied Intelligence should analyze your data using a simple slider and visualization based on your recent performance. The slider either increases or decreases the gray band around your budget threshold (the blue line): alerts.newrelic.com > Alert policies > (select a policy) > Alert conditions: Create alert conditions based on your NRQL queries and Insights data. This example would have resulted in zero violations based on recent data, and that is exactly what you are looking for. However, if that blue line spikes up out of the gray band, New Relic notifies you. For more detailed information about creating, managing, and using alerts, view these New Relic University tutorials: Intro to alerting Alert policies Alerting incident lifecycle Notification channels For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.5721,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> solutions",
        "info": "<em>Use</em> <em>New</em> <em>Relic</em> to keep control of your cloud spending costs, and get your teams alerted when you go over your budgets.",
        "category_0": "<em>New</em> <em>Relic</em> solutions",
        "category_1": "<em>New</em> <em>Relic</em> solutions",
        "body": " cloud spending costs, and get your teams alerted when you go over your budgets. 7. <em>Set</em> <em>up</em> alerts After you write queries on your data in Insights, you can easily <em>use</em> them to create alert conditions. <em>New</em> <em>Relic</em> gives you the ability to write baseline queries against your data. A baseline query",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; Cloud adoption"
      },
      "id": "5f59fc5b196a672f27ce6a45"
    },
    {
      "category_2": "Private locations",
      "nodeid": 23821,
      "sections": [
        "Synthetic monitoring",
        "Getting started",
        "Guides",
        "Using monitors",
        "Monitor scripting",
        "Administration",
        "Private locations",
        "UI pages",
        "Synthetics API",
        "Troubleshooting",
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Stop or delete the CPM",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Docker image repository",
        "Additional considerations for CPM connection",
        "For more help"
      ],
      "title": "Install containerized private minions (CPMs)",
      "category_0": "Synthetic monitoring",
      "type": "docs",
      "category_1": "Synthetic monitoring",
      "external_id": "63c77c4ba313098967f23929294f2cbc2f8d31d3",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/img-integration-k8s@2x.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms",
      "published_at": "2020-09-27T22:59:08Z",
      "updated_at": "2020-08-13T23:22:19Z",
      "breadcrumb": "Contents / Synthetic monitoring / Synthetic monitoring / Private locations",
      "document_type": "page",
      "popularity": 1,
      "info": "Install New Relic's Docker-based private minion that accepts and runs the jobs assigned to your private locations",
      "body": "You may not modify any CPM files and New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Read on to learn about the New Relic containerized private minion (CPM), a Docker container-based private minion that accepts and executes synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Memory 2.5 GB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a Scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a Simple Browser or Scripted Browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a Runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and Memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ quay.io/newrelic/synthetics-minion:latest Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ quay.io/newrelic/synthetics-minion:latest When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com/charts If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion helm show values YOUR_REPO_NAME/synthetics-minion Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.932846,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Using</em> monitors",
        "info": "Install <em>New</em> <em>Relic&#x27;s</em> Docker-based private minion that accepts and runs the jobs assigned to your private locations",
        "body": " appears, your CPM is <em>up</em> and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. <em>Set</em> <em>up</em> the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy the <em>Helm</em> <em>charts</em> from the <em>New</em> <em>Relic</em> <em>Helm</em> repo. If you"
      },
      "id": "5f31d981196a678103fbd731"
    },
    {
      "category_2": "Get started",
      "nodeid": 27301,
      "sections": [
        "Kubernetes integration",
        "Get started",
        "Installation",
        "Understand and use data",
        "Link apps and services",
        "Kubernetes events",
        "Logs",
        "Troubleshooting",
        "Introduction to the Kubernetes integration",
        "Get started: Install the Kubernetes integration",
        "Why it matters",
        "Navigate all your Kubernetes events",
        "Bring your cluster logs to New Relic",
        "Check the source code",
        "For more help"
      ],
      "title": "Introduction to the Kubernetes integration",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Kubernetes integration",
      "external_id": "4ad996d529753d173874d752239ece44c8e6d43f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/get-started/introduction-kubernetes-integration",
      "published_at": "2020-09-29T01:44:53Z",
      "updated_at": "2020-08-05T01:57:55Z",
      "breadcrumb": "Contents / Integrations / Kubernetes integration / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic's Kubernetes integration: features, requirements, and getting started. ",
      "body": "New Relic's Kubernetes integration gives you full observability into the health and performance of your environment, no matter whether you run Kubernetes on-premises or in the cloud. With our cluster explorer, you can cut through layers of complexity to see how your cluster is performing, from the heights of the control plane down to applications running on a single pod. one.newrelic.com > Kubernetes cluster explorer: The cluster explorer is our powerful, fully visual answer to the challenges associated with running Kubernetes at a large scale. You can see the power of the Kubernetes integration in the cluster explorer, where the full picture of a cluster is made available on a single screen: nodes and pods are visualized according to their health and performance, with pending and alerting nodes in the innermost circles. Predefined alert conditions help you troubleshoot issues right from the start. Clicking each node reveals its status and how each app is performing. Get started: Install the Kubernetes integration We have an automated installer to help you with many types of installations: servers, virtual machines, and unprivileged environments. It can also help you with installations in managed services or platforms, but you'll need to review a few preliminary notes before getting started. Here's what the automated installer does: Asks for the cluster name and namespace of the integration. Asks for additional setup options, such as Kube state metrics. Asks for the installation method: manifest file or Helm. Generates either the manifest or Helm chart. Read the install docs Start the installer If your New Relic account is in the EU region, access the automated installer from one.eu.newrelic.com. Why it matters Governing the complexity of Kubernetes can be challenging; there's so much going on at any given moment, with containers being created and deleted in a matter of minutes, applications crashing, and resources being consumed unexpectedly. Our integration helps you navigate Kubernetes abstractions across on-premises, cloud, and hybrid deployments. In New Relic, you can build your own charts and query all your Kubernetes data, which our integration collects by instrumenting the container orchestration layer. This gives you additional insight into nodes, namespaces, deployments, replica sets, pods, and containers. one.newrelic.com > Dashboards: Using the chart builder you can turn any query on Kubernetes data to clear visuals. With the Kubernetes integration you can also: Link your APM data to Kubernetes to measure the performance of your web and mobile applications, with metrics such as request rate, throughput, error rate, and availability. Monitor services running on Kubernetes, such as Apache, NGINX, Cassandra, and many more (see our tutorial for monitoring Redis on Kubernetes). Create new alert policies and alert conditions based on your Kubernetes data, or extend the predefined alert conditions. These features are in addition to the data New Relic already reports for containerized processes running on instrumented hosts. Navigate all your Kubernetes events The Kubernetes events integration, which is installed separately, watches for events happening in your Kubernetes clusters and sends those events to New Relic. Events data is then visualized in the cluster explorer. To set it up, check the Kubernetes events box in step 3 of our install wizard, or follow the instructions. one.newrelic.com > Kubernetes cluster explorer > Events: Browse and filter all your Kubernetes events, and dig into application logs and infrastructure data. Bring your cluster logs to New Relic Our Kubernetes plugin for log monitoring can collect all your cluster's logs and send them to our platform, so that you can set up new alerts and charts. To set it up, check the Log data box in step 3 of our install wizard, or follow the instructions. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or you can create your own fork and build it. For more information, see the README. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.4586,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Bring your cluster logs to <em>New</em> <em>Relic</em>",
        "info": "<em>New</em> <em>Relic&#x27;s</em> Kubernetes integration: features, requirements, and getting started. ",
        "body": " data. Bring your cluster logs to <em>New</em> <em>Relic</em> Our Kubernetes plugin for log monitoring can collect all your cluster&#x27;s logs and send them to our platform, so that you can <em>set</em> <em>up</em> <em>new</em> alerts and <em>charts</em>. To <em>set</em> it <em>up</em>, check the Log data box in step 3 of our install wizard, or follow the instructions. Check"
      },
      "id": "5cf9564164441f8f472a9169"
    }
  ],
  "/build-apps/add-nerdgraphquery-guide": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Create a \"Hello, World!\" application",
        "Permissions for managing applications",
        "Set up your development environment",
        "Add, query, and mutate data using NerdStorage",
        "Add the NerdGraphQuery component to an application",
        "Add a time picker to your app",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps"
      ],
      "published_at": "2020-09-29T01:47:50Z",
      "title": "Build apps",
      "updated_at": "2020-09-25T01:49:59Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One   Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 20 min Add a time picker to your app Add a time picker to a sample application 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 605.4878,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add the <em>NerdGraphQuery</em> <em>component</em> to an <em>application</em>",
        "body": ". It allows you to modify, save, and retrieve documents from one session to the next. 20 minutes Add the <em>NerdGraphQuery</em> <em>component</em> to an application The <em>NerdGraphQuery</em> <em>component</em> allows you to <em>query</em> <em>data</em> from your <em>account</em> and add it to a dropdown <em>menu</em> in an application 20 min Add a time picker to your"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Map page views by region in a custom app",
        "Before you begin",
        "New Relic terminology",
        "Build a custom app with a table chart",
        "Query your browser data",
        "Create and serve a new Nerdpack",
        "Review your app files and view your app locally",
        "Hard code your account ID",
        "Import the TableChart component",
        "Add a table with a single row",
        "Customize the look of your table (optional)",
        "Get your data into that table",
        "Make your app interactive with a text field",
        "Import the TextField component",
        "Add a row for your text field",
        "Build the text field object",
        "Get your data on a map",
        "Install Leaflet",
        "Add a webpack config file for Leaflet",
        "Import modules from Leaflet",
        "Import additional modules from New Relic One",
        "Get data for the map",
        "Customize the map marker colors",
        "Set your map's default center point",
        "Add a row for your map",
        "Replace \"Hello\" with the Leaflet code"
      ],
      "title": "Map page views by region in a custom app",
      "type": "developer",
      "tags": [
        "custom app",
        "map",
        "page views",
        "region",
        "nerdpack"
      ],
      "external_id": "6ff5d696556512bb8d8b33fb31732f22bab455cb",
      "image": "https://developer.newrelic.com/static/d87a72e8ee14c52fdfcb91895567d268/0086b/pageview.png",
      "url": "https://developer.newrelic.com/build-apps/map-pageviews-by-region/",
      "published_at": "2020-09-29T01:47:51Z",
      "updated_at": "2020-09-17T01:48:42Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a New Relic app showing page view data on a world map.",
      "body": "Map page views by region in a custom app 30 min New Relic has powerful and flexible tools for building custom apps and populating them with data. This guide shows you how to build a custom app and populate it with page view data using New Relic's Query Language (NRQL - pronounced 'nurkle'). Then you make your data interactive. And last, if you have a little more time and want to install a third-party React library, you can display the page view data you collect on a map of the world. In this guide, you build an app to display page view data in two ways: In a table On a map Please review the Before you begin section to make sure you have everything you need and don't get stuck halfway through. Before you begin In order to get the most out of this guide, you must have: A New Relic developer account, API key, and the command-line tool. If you don't have these yet, see the steps in Setting up your development environment New Relic Browser page view data to populate the app. Without this data, you won't be able to complete this guide. To add your data to a world map in the second half of the guide: npm, which you'll use during this section of the guide to install Leaflet, a third-party JavaScript React library used to build interactive maps. If you're new to React and npm, you can go here to install Node.js and npm. New Relic terminology The following are some terms used in this guide: New Relic application: The finished product where data is rendered in New Relic One. This might look like a series of interactive charts or a map of the world. Nerdpack: New Relic's standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see Nerdpack file structure. Launcher: The button on New Relic One that launches your application. Nerdlets: New Relic React components used to build your application. The three default files are index.js, nr1.json, and styles.scss, but you can customize and add your own. Build a custom app with a table chart Step 1 of 8 Query your browser data Use Query builder to write a NRQL query to see your page view data, as follows. On New Relic One, select Query your data (in the top right corner). That puts you in NRQL mode. You'll use NRQL to test your query before dropping the data into your table. Copy and paste this query into a clear query field, and then select Run. FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000 Copy If you have PageView data, this query shows a week of average page views broken down by country and limited to a thousand items. The table will be full width and use the \"chart\" class defined in the CSS. If you don't have any results at this point, ensure your query doesn't have any errors. If your query is correct, you might not have the Browser agent installed. Step 2 of 8 Create and serve a new Nerdpack To get started, create a new Nerdpack, and serve it up to New Relic from your local development environment: Create a new Nerdpack for this app: nr1 create --type nerdpack --name pageviews-app Copy Serve the project up to New Relic: cd pageviews-app && nr1 nerdpack:serve Copy Step 3 of 8 Review your app files and view your app locally Navigate to your pageviews-app to see how it's structured. It contains a launcher folder, where you can customize the description and icon that will be displayed on the app's launcher in New Relic One. It also contains nerdlets, which each contain three default files: index.js, nr1.json, and styles.scss. You'll edit some of these files as part of this guide. For more information, see Nerdpack file structure. Now in your browser, open https://one.newrelic.com/?nerdpacks=local, and then click Apps to see the pageview-apps Nerdpack that you served up. When you select the launcher, you see a Hello message. Step 4 of 8 Hard code your account ID For the purposes of this exercise and for your convenience, hard code your account ID. In the pageview-app-nerdlet directory, in the index.js file, add this code between the import and export lines. (Read about finding your account ID here). const accountId = [Replace with your account ID]; Copy Step 5 of 8 Import the TableChart component To show your data in a table chart, import the TableChart component from New Relic One. To do so, in index.js, add this code under import React. import { TableChart } from 'nr1'; Copy Step 6 of 8 Add a table with a single row To add a table with a single row, in the index.js file, replace this line: return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; Copy with this export code: export default class PageViewApp extends React.Component { render() { return ( <div className=\"container\"> <div className=\"row\"></div> </div> ); } } Copy Step 7 of 8 Customize the look of your table (optional) You can use standard CSS to customize the look of your components. In the styles.scss file, add this CSS. Feel free to customize this CSS to your taste. .container { width: 100%; height: 99vh; display: flex; flex-direction: column; .row { margin: 10px; display: flex; flex-direction: row; } .chart { height: 250px; } } Copy Step 8 of 8 Get your data into that table Now that you've got a table, you can drop a TableChart populated with data from the NRQL query you wrote at the very beginning of this guide. Put this code into the row div. <TableChart accountId={accountId} query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} fullWidth className=\"chart\" />; Copy Go to New Relic One and click your app to see your data in the table. (You might need to serve your app to New Relic again.) Congratulations! You made your app! Continue on to make it interactive and show your data on a map. Make your app interactive with a text field Once you confirm that data is getting to New Relic from your app, you can start customizing it and making it interactive. To do this, you add a text field to filter your data. Later, you use a third-party library called Leaflet to show that data on a world map. Step 1 of 3 Import the TextField component Like you did with the TableChart component, you need to import a TextField component from New Relic One. import { TextField } from 'nr1'; Copy Step 2 of 3 Add a row for your text field To add a text field filter above the table, put this code above the TableChart div. The text field will have a default value of \"US\". <div className=\"row\"> <TextField placeholder=\"US\" onChange={(event) => { this.setState({ countryCode: event.target.value }); }} /> </div>; Copy Step 3 of 3 Build the text field object Above the render() function, add a constructor to build the text field object. constructor(props) { super(props); this.state = { countryCode: null } } Copy Then, add a constructor to your render() function. Above return, add: const { countryCode } = this.state; Copy Now add countryCode to your table chart query. <TableChart accountId={accountId} query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} fullWidth className=\"chart\" />; Copy Reload your app to try out the text field. Get your data on a map To create the map, you use npm to install Leaflet. Step 1 of 9 Install Leaflet In your terminal, type: npm install --save leaflet react-leaflet Copy In your nerdlets styles.scss file, import the Leaflet CSS: @import `~leaflet/dist/leaflet.css`; Copy While you're in styles.scss, fix the width and height of your map: .containerMap { width: 100%; z-index: 0; height: 70vh; } Copy Step 2 of 9 Add a webpack config file for Leaflet Add a webpack configuration file .extended-webpackrc.js to the top-level folder in your nerdpack. This supports your use of map tiling information data from Leaflet. module.exports = { module: { rules: [ { test: /\\.(png|jpe?g|gif)$/, use: [ { loader: 'file-loader', options: {}, }, { loader: 'url-loader', options: { limit: 25000 }, }, ], }, ], }, }; Copy Step 3 of 9 Import modules from Leaflet In index.js, import modules from Leaflet. import { Map, CircleMarker, TileLayer } from 'react-leaflet'; Copy Step 4 of 9 Import additional modules from New Relic One You need several more modules from New Relic One to make the Leaflet map work well. Import them with this code: import { NerdGraphQuery, Spinner, Button, BlockText } from 'nr1'; Copy NerdGraphQuery lets you make multiple NRQL queries at once and is what will populate the map with data. Spinner adds a loading spinner. Button gives you button components. BlockText give you block text components. Step 5 of 9 Get data for the map Using latitude and longitude with country codes, you can put New Relic data on a map. mapData() { const { countryCode } = this.state; const query = `{ actor { account(id: 1606862) { mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : ''} LIMIT 1000 \") { results nrql } } } }`; return query; }; Copy Step 6 of 9 Customize the map marker colors Above the mapData function, add this code to customize the map marker colors. getMarkerColor(measure, apdexTarget = 1.7) { if (measure <= apdexTarget) { return '#11A600'; } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { return '#FFD966'; } else { return '#BF0016'; } }; Copy Feel free to change the HTML color code values to your taste. In this example, #11A600 is green, #FFD966 is sort of yellow, and #BF0016 is red. Step 7 of 9 Set your map's default center point Set a default center point for your map using latitude and longitude. const defaultMapCenter = [10.5731, -7.5898]; Copy Step 8 of 9 Add a row for your map Between the text field row and the table chart row, insert a new row for the map content using NerdGraphQuery. <div className=\"row\"> <NerdGraphQuery query={this.mapData()}> {({ loading, error, data }) => { if (loading) { return <Spinner fillContainer />; } if (error) { return 'Error'; } const { results } = data.actor.account.mapData; console.debug(results); return 'Hello'; }} </NerdGraphQuery> </div>; Copy Reload your application in New Relic One to test that it works. Step 9 of 9 Replace \"Hello\" with the Leaflet code Replace return \"Hello\"; with: return ( <Map className=\"containerMap\" center={defaultMapCenter} zoom={2} zoomControl> <TileLayer attribution='&amp;copy <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\" /> {results.map((pt, i) => { const center = [pt.lat, pt.lng]; return ( <CircleMarker key={`circle-${i}`} center={center} color={this.getMarkerColor(pt.y)} radius={Math.log(pt.x) * 3} onClick={() => { alert(JSON.stringify(pt)); }} /> ); })} </Map> ); Copy This code creates a world map centered on the latitude and longitude you chose using OpenStreetMap data and your marker colors. Reload your app to see the pageview data on the map!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 414.73218,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map page views by region in a custom <em>app</em>",
        "sections": "<em>Query</em> your browser <em>data</em>",
        "info": "Build a New Relic <em>app</em> showing page view <em>data</em> on a world map.",
        "tags": "custom <em>app</em>",
        "body": " &lt;Spinner fillContainer &#x2F;&gt;; } if (error) { return &#x27;Error&#x27;; } const { results } = <em>data.actor.account.mapData</em>; console.debug(results); return &#x27;Hello&#x27;; }} &lt;&#x2F;<em>NerdGraphQuery</em>&gt; &lt;&#x2F;div&gt;; Copy Reload your application in New Relic One to test that it works. Step 9 of 9 Replace &quot;Hello&quot; with the Leaflet code Replace"
      },
      "id": "5efa993c196a67066b766469"
    },
    {
      "category_2": "Enable and configure",
      "nodeid": 38171,
      "sections": [
        "Distributed tracing",
        "Get started",
        "Enable and configure",
        "Other requirements",
        "UI and data",
        "Trace API",
        "Troubleshooting",
        "Integrations: Enable distributed tracing",
        "Step 1. Install the integration",
        "Step 2. (Infinite Tracing) Find or create a trace observer endpoint",
        "Step 3. (Infinite Tracing) Configure the integration",
        "Step 4. View traces",
        "For more help"
      ],
      "title": "Integrations: Enable distributed tracing",
      "category_0": "Understand dependencies",
      "type": "docs",
      "category_1": "Distributed tracing",
      "external_id": "6fd698d8077aa70b61b867bec09cac86be69214c",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/Infinite_Tracing_GraphiQL_URL_Results_0_0.png",
      "url": "https://docs.newrelic.com/docs/understand-dependencies/distributed-tracing/enable-configure/integrations-enable-distributed-tracing",
      "published_at": "2020-09-27T18:17:00Z",
      "updated_at": "2020-09-27T18:16:59Z",
      "breadcrumb": "Contents / Understand dependencies / Distributed tracing / Enable and configure",
      "document_type": "page",
      "popularity": 1,
      "info": "These are instructions for enabling distributed tracing for New Relic integrations with Istio, Open Census, and OpenTelemetry.",
      "body": "If you have telemetry data from Istio, Kamon, OpenCensus, and OpenTelemetry, you can view it in the New Relic UI by sending it through one of our telemetry integrations. To integrate your AWS X-Ray telemetry data, use the infrastructure integration. Since distributed systems can generate a lot of trace data, telemetry tools rely on data sampling (filtering) to find useful data. Our telemetry integrations offer you two sampling options: Use your tool’s native sampling (default): The default installation assumes you are relying on your telemetry tool to sample the data before the integration passes the data to our Trace API. Even though your tool may be sampling data, our Trace API may randomly sample out traces that exceed your rate limit. Use Infinite Tracing (limited release): This approach assumes you set sampling to 100% in your telemetry tool so you send all your data to a New Relic trace observer in AWS. The trace observer selects the most important and actionable traces using tail-based sampling and then sends your traces to our Trace API. To use this approach, complete the default installation but then configure a new endpoint for a trace observer. To start using Infinite Tracing, please go to our sign-up page. Here's an overview of the steps to enable distributed tracing: Install the integration (Infinite Tracing) Provision a trace observer on New Relic Edge (Infinite Tracing) Configure your open source integration View your traces in New Relic One Step 1. Install the integration If you haven't already installed one of these integrations in your services, follow the link for your integration and complete the installation. After the installation, if you are not enabling Infinite Tracing, skip to Step 4. View traces in New Relic One. Istio adapter Kamon reporter OpenCensus Go language exporter Python language exporter OpenTelemetry Go language exporter Java language exporter .NET language exporter Step 2. (Infinite Tracing) Find or create a trace observer endpoint Infinite Tracing collects your span data in a trace observer, which runs in a cluster of services in AWS called New Relic Edge. Integrations send all your spans to the trace observer so they can be assembled into traces for you to view in New Relic. If you send your data to a trace observer in one of our EU provider regions, you'll still need a US-based New Relic account because the tail-based sampling data is reported to data centers in the United States. If you have questions, contact your account representative. You can use GraphQL to see if someone has already created a trace observer endpoint for your account. If you can't find one, you need to create a new endpoint. Complete the following trace observer steps: 2a. Open NerdGraph API explorer Prepare to execute some GraphQL: Open NerdGraph API explorer. In the API key dropdown next to Tools, select your personal API key for your account under one of these options: Select an existing API Key Create a new API Key 2b. See if anyone in your organization has already created a trace observer endpoint The following steps show you how to execute a GraphQL query to find out if you can use an existing trace observer in your AWS region. If one isn't available, you can go to Step 2c. Create a new one. Copy the following query into the middle pane of the NerdGraph API explorer and replace YOUR_ACCOUNT_ID with your account ID (the number next to your account name in NerdGraph API explorer): { actor { account(id: YOUR_ACCOUNT_ID) { edge { tracing { traceObservers { errors { message type } traceObservers { endpoints { agent { host port } endpointType https { host port url } status } id name providerRegion } } } } } } } Click the triangle button to execute the query or press Ctrl+Enter. Check the right pane showing the results: In traceObservers, if you see an AWS region (providerRegion) appropriate for your location, copy its associated endpoint values. Here's an example of what to copy: (Required) https: host (save to use later as YOUR_TRACE_OBSERVER_HOST in Configure the integration) (Required)https: port (save to use later as YOUR_TRACE_OBSERVER_PORT in Configure the integration) (Optional) https: url (save to use later as YOUR_TRACE_OBSERVER_URL in Send test data to the trace observer) If you don't see any values in traceObservers as shown below, continue to Step 2c. Create a new one. 2c. If you can't find an existing trace observer endpoint, create a new one If you didn't find a trace observer after running the query in the previous section, you need to create one. To do this, you execute a GraphQL mutation that passes your configuration details. Copy the following into the middle pane of the NerdGraph API explorer. mutation { edgeCreateTraceObserver(accountId: YOUR_ACCOUNT_ID, traceObserverConfigs: {name: \"YOUR_DESCRIPTIVE_NAME\", providerRegion: YOUR_PROVIDER_REGION}) { responses { errors { message type } traceObserver { endpoints { agent { host port } endpointType https { host port url } status } id name providerRegion } } } } Insert your own values into the mutation: Value Description YOUR_ACCOUNT_ID Replace this with your account ID (the number next to your account name in NerdGraph API explorer). YOUR_DESCRIPTIVE_NAME Replace this with a name that describes the services that report to this trace observer (for example, production or query services). YOUR_PROVIDER_REGION Replace this with the provider region enum value for your location: AWS_EU_WEST_1 AWS_US_EAST_1 AWS_US_WEST_2 Click the triangle button to execute the mutation or press Ctrl+Enter. In the right pane showing the results, copy the following endpoint values to a text file so you can use them later: (Required) https: host (save to use later as YOUR_TRACE_OBSERVER_HOST in Configure the integration) (Required)https: port (save to use later as YOUR_TRACE_OBSERVER_PORT in Configure the integration) (Optional) https: url (save to use later as YOUR_TRACE_OBSERVER_URL in Send test data to the trace observer) 2d. (Optional) Send test data to the trace observer This test includes a sample payload with one trace and two spans from the same service: Test Service A. Follow these steps to send a test request: Get or generate your Insert API key so you can use it later in the test. Copy the following curl request into a text editor: curl request curl -i -H \"Content-Type: application/json\" \\ -H \"Api-Key: YOUR_INSERT_API_KEY\" \\ -H 'Data-Format: newrelic' \\ -H 'Data-Format-Version: 1' \\ -X POST \\ -d '[ { \"common\": { \"attributes\": { \"environment\": \"staging\" } }, \"spans\": [ { \"trace.id\": \"123456\", \"id\": \"ABC\", \"attributes\": { \"duration.ms\": 12.53, \"host\": \"host123.test.com\", \"name\": \"/home\", \"service.name\": \"Test Service A\" } }, { \"trace.id\": \"123456\", \"id\": \"DEF\", \"attributes\": { \"duration.ms\": 2.97, \"host\": \"host456.test.com\", \"error.message\": \"Invalid credentials\", \"name\": \"/auth\", \"parent.id\": \"ABC\", \"service.name\": \"Test Service B\" } } ] } ]' \\ 'YOUR_TRACE_OBSERVER_URL' Insert your own values into the curl request: Value Description YOUR_INSERT_API_KEY Replace this with your Insert API key (not the same as your personal API key for NerdGraph API explorer) YOUR_TRACE_OBSERVER_URL Replace this with the value under https: url from above. Copy the content of the text editor into a terminal, and then execute the request. If the test does not return HTTP/1.1 202 Accepted indicating success, check the following and try again: Confirm that you substituted the url (not host) value for YOUR_TRACE_OBSERVER_URL. Confirm that you only have single quotes around the value you inserted for YOUR_TRACE_OBSERVER_URL. Check that you are using the Insert API Key (not a license). If your test returned HTTP/1.1 202 Accepted, go to New Relic One to see a query of your test data using the span attribute service.name = Test Service A. Because the sample payload contains an error attribute, the error sampler will mark it for keeping. If you modify the payload to remove the error attributes, the random sampler may not choose to keep this particular trace. Traces may take up to one minute to be processed by both the trace observer and the Trace API. Step 3. (Infinite Tracing) Configure the integration To enable Infinite Tracing, configure your integration to send the telemetry data to the trace observer by using the results from Step 2. Find or create a trace observer endpoint. Find the section below describing these steps for your integration: Istio adapter Set the spansHost value with YOUR_TRACE_OBSERVER_URL when deploying the Helm chart. Kamon reporter Set the span-ingest-uri value with YOUR_TRACE_OBSERVER_URL in your kamon.newrelic configuration block. OpenCensus (Go language exporter) Set the SpansURLOverride field on the Config object with YOUR_TRACE_OBSERVER_URL when creating the Exporter. OpenCensus (Python language exporter) Pass the host and port parameters to the Trace Exporter using YOUR_TRACE_OBSERVER_HOST and YOUR_TRACE_OBSERVER_PORT. OpenTelemetry (Go language exporter) Set the SpansURLOverride field on the Config object with YOUR_TRACE_OBSERVER_URL when creating the Exporter. OpenTelemetry (Java language exporter) Complete the following: Create a java.net.URI with YOUR_TRACE_OBSERVER_URL. Pass the URI to com.newrelic.telemetry.opentelemetry.export.NewRelicSpanExporter builder’s uriOverride method. See an example where a NewRelicSpanExporter is created. OpenTelemetry (.NET language exporter) Configure the TraceUrlOverride parameter with YOUR_TRACE_OBSERVER_URL. Step 4. View traces After you configure your integration to send data to New Relic, you are ready to view traces. Here are two alternatives: View traces that include a specific service The Entity explorer helps you navigate to a specific service so you can see traces that include that service. Go to one.newrelic.com. Click Entity explorer in the top menu bar. Filter to the service you enabled for Infinite Tracing by typing the service name, and then press Enter. In the left navigation's Monitor section, click Distributed tracing. View traces across accounts This option allows you to search all traces across all New Relic accounts in your organization that you have access to. Go to one.newrelic.com. Click Apps in the top menu bar. Under Favorites click Distributed tracing. In the Find traces... search, type a search clause to find the service. For example, to query service.name or trace.id: service.name = YOUR_SERVICE_NAME trace.id = YOUR_TRACE_ID For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 351.4455,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "UI and <em>data</em>",
        "body": " running the <em>query</em> in the previous section, you need to create one. To do this, you execute a <em>Graph</em>QL mutation that passes your configuration details. Copy the following into the middle pane of the <em>NerdGraph</em> API explorer. mutation { edgeCreateTraceObserver(<em>account</em>Id: YOUR_<em>ACCOUNT</em>_ID, traceObserverConfigs"
      },
      "id": "5ea0617064441ff137912311"
    },
    {
      "category_2": "UI and data",
      "nodeid": 38701,
      "sections": [
        "Log management",
        "Get started",
        "Enable Logs",
        "UI and data",
        "Log API",
        "Troubleshooting",
        "Drop data with drop filter rules",
        "Why it matters",
        "How drop filter rules work",
        "Create drop filter rules",
        "Types of drop filter rules",
        "Drop log events",
        "Drop attributes",
        "Cautions when dropping data",
        "Delete drop filter rules",
        "For more help"
      ],
      "title": "Drop data with drop filter rules ",
      "category_0": "Log management",
      "type": "docs",
      "category_1": "Log management ",
      "external_id": "054102731b07bea12e6877a2314f4114139b1a72",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-logs-create-drop-filter.png",
      "url": "https://docs.newrelic.com/docs/logs/log-management/ui-data/drop-data-drop-filter-rules",
      "published_at": "2020-09-27T18:33:09Z",
      "updated_at": "2020-09-24T10:19:45Z",
      "breadcrumb": "Contents / Log management / Log management / UI and data",
      "document_type": "page",
      "popularity": 1,
      "info": "Data retention information for New Relic's log management and logs in context.",
      "body": "After log event data has been shipped to New Relic, it can either be stored in our database (NRDB) or dropped (discarded). New Relic can drop both log events and event attributes via drop filter rules. You can manage drop filter rules using New Relic's log management or NerdGraph. Use caution when deciding to drop data. The data you drop is not recoverable. Before using this feature, review Responsibilities and considerations. Why it matters Drop filter rules help you accomplish some very important goals: You lower costs by storing only logs relevant to your account. You protect privacy and security by removing personal identifiable information (PII). You reduce noise by removing irrelevant events and attributes. How drop filter rules work A drop filter rule matches data based on a query. When triggered, the drop filter rule removes the matching data from the ingestion pipeline before it is written to in NRDB. Since the data does not reach the backend, it cannot be queried: the data is gone and cannot be restored. During the ingestion process, log data can be parsed, transformed, or dropped before being stored. Create drop filter rules You must have admin permissions in New Relic to create and edit drop filters, or be a member of a role with create and edit permissions for Logging Parsing Rules. Drop filter rules can be created from one.newrelic.com > Logs using new or existing log queries. To create a new drop filter rule: Filter or query to the specific set of logs which contain the data to be dropped. Once the query is active, click on the + button to show the query options and select Create a new drop filter. You can choose to either drop the entire log event that matches the query or just a specific subset of attributes in the matching events. Save the drop filter rule. Before saving the rule, consider changing its name. Once a drop filter rule is active, it's applied to all log events ingested from that point onwards. Rules are not applied retroactively: logs collected prior to the creation of a rule are not filtered by that rule. Types of drop filter rules Drop log events The default type of drop filter rule is to drop logs. This option drops the entire log events that match the filter query. When creating a rule try to provide a specific query that only matches log data which should be dropped. New Relic won't let you create drop filter rules without values in the matching query: this prevents badly formed rules from dropping all log data. Drop attributes You can specify attributes to be dropped in a log event that matches your query. At least one or more attributes must be selected. Any attribute which is selected will be dropped; all remaining attributes will be kept and stored in NRDB. We recommend this method for removing fields which could contain personal identifiable information (PII) or other sensitive attributes without losing valuable monitoring data. ​ Cautions when dropping data When creating drop rules, you are responsible for ensuring that the rules accurately identify and discard the data that meets the conditions that you have established. You are also responsible for monitoring the rule, as well as the data you disclose to New Relic. New Relic cannot guarantee that this functionality will completely resolve data disclosure concerns you may have. New Relic does not review or monitor how effective the rules you develop are. Creating rules about sensitive data can leak information about what kinds of data you maintain, including the format of your data or systems (for example, through referencing email addresses or specific credit card numbers). Rules you create, including all information in those rules, can be viewed and edited by any user with the relevant role-based access control permissions. Delete drop filter rules Drop filter rules can be deleted from one.newrelic.com > Logs. To delete a drop filter rule: Click on the + button to show the query options and select View all drop filters. Click the delete [trash icon] icon next to the drop filter rule you want to remove. Once deleted, rules no longer filter ingested log events. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 309.5142,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Drop</em> <em>data</em> with <em>drop</em> filter rules ",
        "sections": "<em>Drop</em> <em>data</em> with <em>drop</em> filter rules",
        "info": "<em>Data</em> retention information for New Relic&#x27;s log management and logs in context.",
        "category_2": "UI and <em>data</em>",
        "body": "After log event <em>data</em> has been shipped to New Relic, it can either be stored in our database (NRDB) or dropped (discarded). New Relic can <em>drop</em> both log events and event attributes via <em>drop</em> filter rules. You can manage <em>drop</em> filter rules using New Relic&#x27;s log management or <em>NerdGraph</em>. Use caution when",
        "breadcrumb": "Contents &#x2F; Log management &#x2F; Log management &#x2F; UI and <em>data</em>"
      },
      "id": "5f37d6fb196a67021c55e5eb"
    },
    {
      "category_2": "Manage data",
      "nodeid": 39276,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Ingest APIs",
        "Manage data coming into New Relic",
        "Data ingestion sources",
        "Set alerts for data use",
        "Adjust your data ingest",
        "For more help"
      ],
      "title": "Manage data coming into New Relic",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "ba12759affe2895e875af1af096d895d09f6d030",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/data-ingest-page_0.png",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-data-new-relic/manage-data/manage-data-coming-new-relic",
      "published_at": "2020-09-27T18:53:23Z",
      "updated_at": "2020-09-24T17:20:11Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Manage data",
      "document_type": "page",
      "popularity": 1,
      "info": "For accounts on the New Relic One pricing plan: how we ingest and store and calculate ingested data. ",
      "body": "When you connect your data to New Relic, we process what we receive and apply data dropping and transformation rules. Then we count the bytes needed to represent your data in a standard format, like JSON. If you're on our New Relic One pricing plan, this ingest process tells us how many GB you pay for, above and beyond the standard amount that’s free. This doc is for accounts on our New Relic One pricing plan. If you're on our original product-based pricing plan, see Original data retention. Not sure which you're on? See Overview of pricing and account/user structure. The Data ingestion page shows your ingest rates for a period you specify on the top-right of the Data management hub. Since 30 days ago is the default setting, but you can also set a custom date span. The page shows your daily average GBs, and the total for the range you set. It also provides the current month-to-date, and the projected end-of-month total ingest rates. With this information, you can proactively drop data or turn off agents in order to manage ingest and, therefore, costs. If you want to take a look at how we query the data, click the ellipsis icon (just above the chart) to slide out the chart query and open it in our query builder. Data ingest page with GB rates for daily average and 30-day total. To open, select your user name > Data management hub > Data ingestion Data ingestion sources The Data ingestion page describes which of your data sources provide the most data on average and during specific data ranges. The sources are described here. Billable data sources Description Timeslices (1-minute) and Metric:Raw Metrics are timeslices + MetricRaw Metric group: MetricsBytes Metric timeslice data averages to one-hour periods after eight days. After 90 days, the permanent metric data continues to be stored in one-hour periods. We currently store the raw metric data for 30 days. You are only billed for the initial ingest volume. You are not billed for subsequent rollups. APM (transactions and errors) APM events Metric group: ApmEventsBytes InfraSamples:Raw Includes multiple Infrastructure events Infrastructure host data Metric group:InfraHostBytes Information related to your servers and virtual machines coming from infrastructure agents, including storage and network data Infrastructure process data stored in ProcessSample. Metric group: InfraProcessBytes Data are metrics related to each process running on the hosts running the Infrastructure agent. This feature is turned off by default. Infrastructure integrations Metric group: InfraIntegrationBytes Performance data related to applications and services, typically managed by the customer, including data related to Docker containers, Windows services, Nagios checks, and cloud integrations such as managed services in AWS, Azure, and GCP. Logging Includes logs and LogExtendedRecord Metric group: LoggingBytes Log messages longer than 4KB are split into multiple events that, when needed, are stitched together to display the original message; this reduces the size of message data. Default Custom events Metric group: CustomEventsBytes Mobile error Mobile general Breadcrumb crash event trails Mobile session Mobile exception Mobile crash Mobile events Metric group: MobileEventsBytes Tracing Metric group: TracingBytes Namespaces that contain all tracing events, including tracing spans and excluding internal tracing. Browser:EventLog Browser Browser:JSErrors PcvPerf (PageView timing) Browser events Metric group: BrowserEventsBytes Lambda Serverless Metric group: ServerlessBytes Set alerts for data use Query and alert on usage data describes how to set alerts to get notified if you're nearing data ingest limits you don't want to cross. For example, you might set an alert on logs, which can stack up quickly in an active system. Adjust your data ingest Drop data for lower retention costs and data compliance On ingest, we apply data dropping rules so you won't be charged for data that's not useful. Learn how to set additional data dropping ​​​​​rules yourself. Use NerdGraph to drop entire data types or drop data attributes from data types so they’re not written to NRDB. This enables you to focus on the data you want, reduces retention costs, and avoids writing sensitive data to the database. For dropping log data, see Drop data with drop filter rules. Turn off agents and integrations If you don’t need data from specific agents or integrations that you have installed, you can uninstall/delete those tools. For instructions, see the specific documentation for an agent or integration. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 292.44684,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>data</em> coming into New Relic",
        "sections": "Ingest and manage <em>data</em>",
        "info": "For <em>accounts</em> on the New Relic One pricing plan: how we ingest and store and calculate ingested <em>data</em>. ",
        "category_0": "Telemetry <em>Data</em> Platform",
        "category_1": "Ingest and manage <em>data</em>",
        "category_2": "Manage <em>data</em>",
        "body": " On ingest, we apply <em>data</em> dropping rules so you won&#x27;t be charged for <em>data</em> that&#x27;s not useful. Learn how to set additional <em>data</em> dropping ​​​​​rules yourself. Use <em>NerdGraph</em> to <em>drop</em> entire <em>data</em> types or <em>drop</em> <em>data</em> attributes from <em>data</em> types so they’re not written to NRDB. This enables you to focus on the <em>data</em>",
        "breadcrumb": "Contents &#x2F; Telemetry <em>Data</em> Platform &#x2F; Ingest and manage <em>data</em> &#x2F; Manage <em>data</em>"
      },
      "id": "5f24629ae7b9d251c2c82338"
    }
  ],
  "/build-apps/map-pageviews-by-region": [
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-09-29T01:40:52Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-27T01:38:35Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 16 Days : 22 Hours : 10 Minutes : 8 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 20 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.36465,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a <em>custom</em> <em>map</em> <em>view</em>",
        "body": " source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a <em>custom</em> <em>map</em> <em>view</em> Build an <em>app</em> to show <em>page</em> <em>view</em> data on a <em>map</em> 20 min Add a time picker to your <em>app</em> Add a time picker to a sample application   Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-09-29T01:48:49Z",
      "updated_at": "2020-08-26T01:47:20Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.13641,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Prepare to build or modify <em>apps</em>",
        "info": "Prepare to build <em>apps</em> and contribute to this site",
        "body": ", publish it to New Relic One, and share it with others by subscribing accounts to it. <em>Map</em> pageviews by <em>region</em> takes you through the steps to create one of our popular open source apps. You learn to add a <em>custom</em> query to an <em>app</em> and <em>view</em> it in a table, then add that data to a <em>map</em>. Contribute"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "category_2": "Ingest APIs",
      "nodeid": 35531,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Ingest APIs",
        "Report metrics via the Metric API",
        "Quick start: Send metric data",
        "Endpoint URL",
        "HTTP request headers",
        "HTTP request body",
        "Structure",
        "Required key-value pairs",
        "Metric types",
        "Share attributes across metrics with common",
        "Response validation and status codes",
        "Missing data with 202 response",
        "Status codes",
        "For more help"
      ],
      "title": "Report metrics via the Metric API",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "598db7bbcb5435515493a3118f3428fbb63a9c08",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-data/apis/report-metrics-metric-api",
      "published_at": "2020-09-27T15:39:33Z",
      "updated_at": "2020-09-27T15:39:33Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Ingest APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Quick start guide to send your first metrics using New Relic's Metric API, and a full spec for the JSON payload and endpoint. ",
      "body": "Use the Metric API to send custom metrics to the New Relic platform. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric data. Quick start: Send metric data Metric data is submitted to New Relic through an HTTP POST request. Each request is composed of one or more metric data points, which consist of a metric name, a timestamp, and a value. Follow this example to send your first metric data points to New Relic: Find or register an Insert API key for your account: Go to: one.newrelic.com > account dropdown > Account settings > API keys, and select Insights API keys. Insert your API key into the following JSON, and then send the JSON to our endpoint. This example creates a single metric data point for a metric named memory.heap, but you can create additional attributes or data points by specifying metric types or adding optional common blocks. curl -vvv -k -H \"Content-Type: application/json\" \\ -H \"Api-Key: YOUR_API_KEY_HERE\" \\ -X POST https://metric-api.newrelic.com/metric/v1 \\ --data '[{ \"metrics\":[{ \"name\":\"memory.heap\", \"type\":\"gauge\", \"value\":2.3, \"timestamp\":CURRENT_TIME_IN_MILLISECONDS_HERE, \"attributes\":{\"host.name\":\"dev.server.com\"} }] }]' The metric should be available in New Relic in a few seconds. You can query the data from any NRQL interface using this query: FROM Metric SELECT max(memory.heap) TIMESERIES For more on where data shows up, see Find Metric API data. Endpoint URL Use an HTTP POST when sending metric data to the metric API endpoint: https://metric-api.newrelic.com/metric/v1 If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. HTTP request headers Include the following HTTP request headers with the POST request. You can send some parameters as query parameters instead of request headers. Header Send as a query parameter? Details Content-Type No Required. Must be application/json. Content-Length No Required (usually set automatically by the HTTP client). The length of the request body in octets (8-bit bytes) unless sent with chunked encoding. This header is generally set by default by the underlying HTTP client sending the data and in most cases should not require any additional effort by the end user. Api-Key Yes Required. The Insert API key authenticates you to use the Metric API. If this is provided as both a header and a query parameter, the values must match. Content-Encoding No Required if GZIP. The value must be GZIP or Identity. If no value is present, then Identity is assumed. x-request-id No Optional - Reserved for future use. The value must be a valid UUID4. The value is expected to be unique for each request. HTTP request body The body of the HTTP POST request must be in JSON format. The following describes the requirements and recommendations for the JSON payload. The payload must be encoded as UTF-8. Structure The JSON payload uses this structure: The JSON payload is an array of maps. Each map must contain a metrics key whose value is an array containing one or more metric data points. A metric data point is identified by a name, type, and value along with an optional set of attributes. JSON payload creating two metrics This example payload creates two metrics. service.errors.all is a count metric with three attributes and service.memory is a gauge metric with two attributes. [ { \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 15, \"timestamp\": CURRENT_TIME_IN_MILLISECONDS_HERE, \"interval.ms\": 10000, \"attributes\": { \"service.response.statuscode\": \"400\", \"host.name\": \"dev.server.com\", \"service.name\": \"foo\" } }, { \"name\": \"service.memory\", \"type\": \"gauge\", \"value\": 2.7, \"timestamp\": CURRENT_TIME_IN_MILLISECONDS_HERE, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Required key-value pairs Each metric data point map in the metrics array uses the following key-value structure: Key Description name string Required. The name of the metric. The value must be less than 255 characters. value number or map Required. The value varies depending on the metric type. For gauge and count the value should be a single number. For summary, the value should be a map with key-value pairs specifying the count, sum, min, and max. timestamp long Required. The metric's start time in Unix time. Defaults to the current time in UTC timezone. This field also support seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and query. Metrics reported with a timestamp older than 48 hours ago or newer than 24 hours from the time they are reported are dropped. interval.ms positive long Required for count and summary metric types. The length of the time window. type Recommended. This should be one of the supported metric types. If you do not specify a type, then this will default to a gauge. attributes strings, JSON numbers, or booleans Recommended. A map of key value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Keys are case-sensitive and must be less than 255 characters. Metric types The metric type determines how the data is aggregated over longer time windows. It also determines which query functions you can use to visualize the data. The Metric API supports these types: Metric types Description Available query functions gauge Represents a value that can increase or decrease with time. Examples of gauges include the temperature, CPU usage, and memory. For example, there is always a temperature, but you are periodically taking the temperature and reporting it. The value must fit into the range of a Java double. latest min max average sum count count Measures the number of occurrences of an event. The count should be reset to 0 every time the metric is reported. Examples include cache hits per reporting interval and the number of threads created per reporting interval. You must specify a value for interval.ms when using the count metric type. The value must be a positive double. Generally, you want to take the rate of the sum: From Metric select rate(sum(myMetric), 1 minute) . . . sum summary Used to report pre-aggregated data, or information on aggregated discrete events. A summary includes a count, sum value, min value, and max value. The count value must be positive. Examples include transaction count/durations and queue count/ durations. You must specify a value for interval.ms when using the summary metric type. average min max count sum JSON payload with three metric types Here's an example payload containing one metric data point for each metric type: [ { \"metrics\": [ { \"name\": \"cache.misses\", \"type\": \"count\", \"value\": 15, \"timestamp\": CURRENT_TIME_IN_MILLISECONDS_HERE, \"interval.ms\": 10000, \"attributes\": { \"cache.name\": \"myCache\", \"host.name\": \"dev.server.com\" } }, { \"name\": \"temperature\", \"type\": \"gauge\", \"value\": 15, \"timestamp\": CURRENT_TIME_IN_MILLISECONDS_HERE, \"attributes\": { \"city\": \"Portland\", \"state\": \"Oregon\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"interval.ms\": 10000, \"timestamp\": CURRENT_TIME_IN_MILLISECONDS_HERE, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Share attributes across metrics with common If you want to include a set of attributes on multiple metrics (and not add the same attributes for each metric), you can use the common block. This is an optional map that specifies information that applies to all associated metric data points. Values in the common section will be overridden if the same key exists on a metric data point. The block can include: Attribute Description timestamp long The metric's start time in Unix time. This defaults to the current time in the UTC timezone. This field also supports seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and later querying. interval.ms positive long Required for count and summary.The length of the time window. attributes strings, JSON numbers, or booleans A map of key-value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Example of common attributes In the following example payload, three metrics are sent. All three metrics share app.name and host.name attributes, specified in the common block. Each metric also has a unique value for another attribute, server.response.statuscode. [ { \"common\" : { \"timestamp\": 1531414060739, \"interval.ms\": 10000, \"attributes\": { \"app.name\": \"foo\", \"host.name\": \"dev.server.com\" } }, \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 9, \"attributes\": { \"service.response.statuscode\": \"400\" } }, { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 4, \"attributes\": { \"service.response.statuscode\": \"500\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"attributes\": { \"service.response.statuscode\": \"200\" } } ] } ] Response validation and status codes The Metric API returns a 202 response code for successful requests. When your data is accepted, an HTTP 202 response code is returned with a response structure like this: HTTP/1.1 202 Accepted Content-Type: application/json; charset=UTF-8 Content-Length: 52 Access-Control-Allow-Methods: GET, POST, PUT, HEAD, OPTIONS Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive {\"requestId\":\"f0e7bfff-001a-b000-0000-01682bcf4565\"} Missing data with 202 response A 202 code indicates the API did receive your data, and that the data passed basic validation checks. Normally, your data will be available for querying within a few seconds. However, New Relic runs additional validation asynchronously after receiving your data. If you receive a 202 response but can't find your metric, this indicates that New Relic found an error during this asynchronous validation. You can find these errors in the NrIntegrationError event in the account associated with the Insert API key you used. The requestId for each request will be tagged on the NrIntegrationError event. See Troubleshoot a NRIntegrationError event for more information. Status codes The Metric API can return the following HTTP status codes: Status code Definition 202 Data accepted. 400 Structure of the request is invalid. 403 Authentication failure. 404 The request path is incorrect. 405 Used a request method other than POST. 408 The request took too long to reach the endpoint. 411 The Content-Length header wasn’t included. 413 The payload was too big. Payloads must be under 1MB. 414 The request URI was too long. 415 The Content-Type or Content-Encoding was invalid. 429 The request rate quota has been exceeded. 431 The request headers are too long. 5xx There was a server error (please retry). For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.47075,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " of the time window. attributes strings, JSON numbers, or booleans A <em>map</em> of key-value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Example of common attributes In the following example payload, three metrics are sent. All three metrics share <em>app</em>"
      },
      "id": "5f24f945196a67b9e394f61a"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-09-08T01:50:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users's configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { 'YourNerdpackUuid': { 'collection-1': { 'document-1-of-collection-1': '{\"lastNumber\": 42, \"another\": [1]}', 'document-2-of-collection-1': '\"userToken\"', // ... }, 'another-collection': { 'fruits': '[\"pear\", \"apple\"]', // ... }, // ... }, } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.373215,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use NerdStorage in your <em>apps</em>",
        "tags": "new relic one <em>apps</em>",
        "body": " as a nested key-value <em>map</em>. Data is inside documents, which are nested inside collections: { &#x27;Your<em>Nerdpack</em>Uuid&#x27;: { &#x27;collection-1&#x27;: { &#x27;document-1-of-collection-1&#x27;: &#x27;{&quot;lastNumber&quot;: 42, &quot;another&quot;: [1]}&#x27;, &#x27;document-2-of-collection-1&#x27;: &#x27;&quot;userToken&quot;&#x27;, &#x2F;&#x2F; ... }, &#x27;another-collection&#x27;: { &#x27;fruits&#x27;: &#x27;[&quot;pear&quot;, &quot;apple"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Subscribe or unsubsribe apps",
        "Handle duplicate applications"
      ],
      "title": "Serve, publish, and deploy your New Relic One app",
      "type": "developer",
      "tags": [
        "publish apps",
        "deploy apps",
        "subscribe apps",
        "add metadata apps"
      ],
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "published_at": "2020-09-29T01:52:56Z",
      "updated_at": "2020-09-02T02:05:55Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Start sharing and using the custom New Relic One apps you build",
      "body": "Serve, publish, and deploy your New Relic One app 30 min When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. nr1 update Copy Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. nr1 catalog:submit Copy Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Subscribe or unsubsribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.94805,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and deploy your New Relic One <em>app</em>",
        "sections": "Serve, publish, and deploy your New Relic One <em>app</em>",
        "info": "Start sharing and using the <em>custom</em> New Relic One <em>apps</em> you build",
        "tags": "publish <em>apps</em>",
        "body": " that you haven&#x27;t subscribed to, some developed by New Relic engineers to provide visualizations we think you&#x27;ll want, like Cloud Optimizer, which analyzes your cloud environment, or <em>PageView</em> <em>Map</em>, which uses Browser events to chart performance across geographies. Your apps in the catalog are created"
      },
      "id": "5efa999de7b9d283e67bab8f"
    }
  ],
  "/collect-data/get-started-nerdgraph-api-explorer": [
    {
      "category_2": "Examples",
      "nodeid": 39021,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "Use NerdGraph to manage license keys and personal API keys",
        "Feature description",
        "Create keys",
        "Update keys",
        "Delete keys",
        "Query keys",
        "For more help"
      ],
      "title": "Use NerdGraph to manage license keys and personal API keys",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "f4b228fbc3fdc408adc6d7e10a93edd0464b7762",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-personal-api-keys",
      "published_at": "2020-09-27T18:43:14Z",
      "updated_at": "2020-09-24T10:26:23Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic NerdGraph (our GraphQL API) to create and manage your New Relic license keys, browser license keys, and personal API keys. ",
      "body": "This document contains tutorials on how to use NerdGraph to programmatically create and manage several types of New Relic keys. To build queries and see responses, use our GraphiQL explorer. For more information on our API keys, see API keys. Feature description NerdGraph's ApiAccess field can be used to programmatically create and manage the following types of keys: Personal API keys License keys, including: General license key used for APM Browser license key One common use case for this feature is the ability to create and manage license keys to let you rotate keys for security purposes. Note that you can't use this NerdGraph functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you've created. General notes about this functionality: All mutations can accept multiple keys as arguments, and will return details about successful changes and errors. See examples below for details. All mutations (create, update and delete) will result in an NrAuditEvent that can be queried for auditing purposes. For details, see Audit events. Some notes about license keys: In the context of using NerdGraph, the license keys are referred to as ingest keys. This feature allows you to create up to 1,000 keys of each license key type, which allows for key rotation. You can't use this NerdGraph functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you've created. License keys created through NerdGraph can't be found in the New Relic UI. They're only queryable via the API. Some notes about personal API keys: In the context of using NerdGraph, personal API keys are referred to as user keys. User keys are displayed in various UI locations (for example: the User settings UI page). The examples below use license keys (ingest keys), but personal API keys (user keys) are queried in similar ways. We recommend you experiment with queries using the GraphiQL explorer. You can also create, view, and delete personal API keys using the UI. Create keys You can create multiple keys in a single mutation, for multiple accounts and key types. Note that the mutation can return successfully created keys as well as any errors encountered trying to create keys. Example of creating a key: mutation { apiAccessCreateKeys(keys: {ingest: {accountId: YOUR_ACCOUNT_ID, ingestType: BROWSER, name: \"Browser Key\", notes: \"A note.\"}}) { createdKeys { id key name accountId notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Update keys The update mutation takes the key ID, not the key string, to identify keys. mutation { apiAccessUpdateKeys(keys: {ingest: {keyId: KEY_ID, name: \"Updated name\", notes: \"A new note!\"}}) { updatedKeys { id key type name notes } errors { message } } } Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Delete keys The delete mutation takes the key ID, not the key string, to identify keys. Deleted keys will no longer grant access to New Relic systems and will no longer be returned by queries to the API access GraphQL API. mutation { apiAccessDeleteKeys(keys: {ingestKeyIds: INGEST_KEY_ID}) { deletedKeys { id } errors { message } } } Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Query keys You can access ingest and user keys by querying a single key or all keys, scoped to the actor. If querying for a single key, you must provide the key ID and type (INGEST or USER). Querying for multiple keys is done via a key search, which uses a mandatory types list and an optional scope to filter results. User keys belonging to other users will be obfuscated in the results. Single key example query: query { actor { apiAccess { key(id: INGEST_KEY_ID, keyType: INGEST) { key name type ... on ApiAccessIngestKey { ingestType } } } } } Key search example query: query { actor { apiAccess { keySearch(query: {types: INGEST, scope: {ingestTypes: BROWSER}}) { keys { name key type ... on ApiAccessIngestKey { ingestType } } } } } } Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 259.2041,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>NerdGraph</em> to manage license keys and personal API keys",
        "sections": "<em>NerdGraph</em>",
        "info": "Use New Relic <em>NerdGraph</em> (our GraphQL API) to create and manage your New Relic license keys, browser license keys, and personal API keys. ",
        "category_1": "<em>NerdGraph</em>",
        "body": ". Note that you can&#x27;t use this <em>NerdGraph</em> functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you&#x27;ve created. General notes about this functionality: All <em>mutations</em> can accept multiple keys as arguments, and will return details",
        "breadcrumb": "Contents &#x2F; APIs &#x2F; <em>NerdGraph</em> &#x2F; Examples"
      },
      "id": "5efe0487196a6710b1766452"
    },
    {
      "nodeid": 37751,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "NerdGraph API: Examples",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Queries",
        "Mutations",
        "For more help"
      ],
      "title": "NerdGraph API: Examples ",
      "category_0": "Alerts and Applied intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "017d6c34d340b9bc035e91483d675915fa5252eb",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples",
      "published_at": "2020-09-27T17:00:16Z",
      "updated_at": "2020-08-11T04:59:00Z",
      "breadcrumb": "Contents / Alerts and Applied intelligence / New Relic Alerts / Alerts and Nerdgraph",
      "document_type": "page",
      "popularity": 1,
      "info": "Read about how you can manage alerts conditions, policies, and muting rules using NerdGraph.",
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer: For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.10312,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> API: Examples ",
        "sections": "<em>Mutations</em>",
        "info": "Read about how you can manage alerts conditions, policies, and muting rules using <em>NerdGraph</em>.",
        "body": " Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and <em>mutations</em> is through the <em>NerdGraph</em> API explorer. <em>NerdGraph</em> API explorer Our <em>NerdGraph</em> API explorer is a GraphiQL editor where you can prototype queries and <em>mutations</em>. Here are some examples showing",
        "breadcrumb": "Contents &#x2F; Alerts and Applied intelligence &#x2F; New Relic Alerts &#x2F; Alerts and <em>Nerdgraph</em>"
      },
      "id": "5f2dbad864441fd15456a9eb"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Collect data - any source",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL"
      ],
      "published_at": "2020-09-29T01:48:50Z",
      "title": "Collect data",
      "updated_at": "2020-09-27T01:53:36Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Collect data Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data   Add custom attributes Use custom attributes for deeper analysis 15 min Collect data - any source APIs, agents, OS emitters - get any data 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events 25 min Build queries with NerdGraph Try NerdGraph and build the queries you need 10 min Query data with NRQL Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.96196,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build <em>queries</em> with <em>NerdGraph</em>",
        "body": " data   Add custom attributes Use custom attributes for deeper analysis 15 min Collect data - any source APIs, agents, OS emitters - get any data 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events 25 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries you need 10 min <em>Query</em> data with NRQL <em>Query</em> default data, custom events, and attributes"
      },
      "id": "5efa997328ccbc768c307de2"
    },
    {
      "category_2": "Enable and configure",
      "nodeid": 38171,
      "sections": [
        "Distributed tracing",
        "Get started",
        "Enable and configure",
        "Other requirements",
        "UI and data",
        "Trace API",
        "Troubleshooting",
        "Integrations: Enable distributed tracing",
        "Step 1. Install the integration",
        "Step 2. (Infinite Tracing) Find or create a trace observer endpoint",
        "Step 3. (Infinite Tracing) Configure the integration",
        "Step 4. View traces",
        "For more help"
      ],
      "title": "Integrations: Enable distributed tracing",
      "category_0": "Understand dependencies",
      "type": "docs",
      "category_1": "Distributed tracing",
      "external_id": "6fd698d8077aa70b61b867bec09cac86be69214c",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/Infinite_Tracing_GraphiQL_URL_Results_0_0.png",
      "url": "https://docs.newrelic.com/docs/understand-dependencies/distributed-tracing/enable-configure/integrations-enable-distributed-tracing",
      "published_at": "2020-09-27T18:17:00Z",
      "updated_at": "2020-09-27T18:16:59Z",
      "breadcrumb": "Contents / Understand dependencies / Distributed tracing / Enable and configure",
      "document_type": "page",
      "popularity": 1,
      "info": "These are instructions for enabling distributed tracing for New Relic integrations with Istio, Open Census, and OpenTelemetry.",
      "body": "If you have telemetry data from Istio, Kamon, OpenCensus, and OpenTelemetry, you can view it in the New Relic UI by sending it through one of our telemetry integrations. To integrate your AWS X-Ray telemetry data, use the infrastructure integration. Since distributed systems can generate a lot of trace data, telemetry tools rely on data sampling (filtering) to find useful data. Our telemetry integrations offer you two sampling options: Use your tool’s native sampling (default): The default installation assumes you are relying on your telemetry tool to sample the data before the integration passes the data to our Trace API. Even though your tool may be sampling data, our Trace API may randomly sample out traces that exceed your rate limit. Use Infinite Tracing (limited release): This approach assumes you set sampling to 100% in your telemetry tool so you send all your data to a New Relic trace observer in AWS. The trace observer selects the most important and actionable traces using tail-based sampling and then sends your traces to our Trace API. To use this approach, complete the default installation but then configure a new endpoint for a trace observer. To start using Infinite Tracing, please go to our sign-up page. Here's an overview of the steps to enable distributed tracing: Install the integration (Infinite Tracing) Provision a trace observer on New Relic Edge (Infinite Tracing) Configure your open source integration View your traces in New Relic One Step 1. Install the integration If you haven't already installed one of these integrations in your services, follow the link for your integration and complete the installation. After the installation, if you are not enabling Infinite Tracing, skip to Step 4. View traces in New Relic One. Istio adapter Kamon reporter OpenCensus Go language exporter Python language exporter OpenTelemetry Go language exporter Java language exporter .NET language exporter Step 2. (Infinite Tracing) Find or create a trace observer endpoint Infinite Tracing collects your span data in a trace observer, which runs in a cluster of services in AWS called New Relic Edge. Integrations send all your spans to the trace observer so they can be assembled into traces for you to view in New Relic. If you send your data to a trace observer in one of our EU provider regions, you'll still need a US-based New Relic account because the tail-based sampling data is reported to data centers in the United States. If you have questions, contact your account representative. You can use GraphQL to see if someone has already created a trace observer endpoint for your account. If you can't find one, you need to create a new endpoint. Complete the following trace observer steps: 2a. Open NerdGraph API explorer Prepare to execute some GraphQL: Open NerdGraph API explorer. In the API key dropdown next to Tools, select your personal API key for your account under one of these options: Select an existing API Key Create a new API Key 2b. See if anyone in your organization has already created a trace observer endpoint The following steps show you how to execute a GraphQL query to find out if you can use an existing trace observer in your AWS region. If one isn't available, you can go to Step 2c. Create a new one. Copy the following query into the middle pane of the NerdGraph API explorer and replace YOUR_ACCOUNT_ID with your account ID (the number next to your account name in NerdGraph API explorer): { actor { account(id: YOUR_ACCOUNT_ID) { edge { tracing { traceObservers { errors { message type } traceObservers { endpoints { agent { host port } endpointType https { host port url } status } id name providerRegion } } } } } } } Click the triangle button to execute the query or press Ctrl+Enter. Check the right pane showing the results: In traceObservers, if you see an AWS region (providerRegion) appropriate for your location, copy its associated endpoint values. Here's an example of what to copy: (Required) https: host (save to use later as YOUR_TRACE_OBSERVER_HOST in Configure the integration) (Required)https: port (save to use later as YOUR_TRACE_OBSERVER_PORT in Configure the integration) (Optional) https: url (save to use later as YOUR_TRACE_OBSERVER_URL in Send test data to the trace observer) If you don't see any values in traceObservers as shown below, continue to Step 2c. Create a new one. 2c. If you can't find an existing trace observer endpoint, create a new one If you didn't find a trace observer after running the query in the previous section, you need to create one. To do this, you execute a GraphQL mutation that passes your configuration details. Copy the following into the middle pane of the NerdGraph API explorer. mutation { edgeCreateTraceObserver(accountId: YOUR_ACCOUNT_ID, traceObserverConfigs: {name: \"YOUR_DESCRIPTIVE_NAME\", providerRegion: YOUR_PROVIDER_REGION}) { responses { errors { message type } traceObserver { endpoints { agent { host port } endpointType https { host port url } status } id name providerRegion } } } } Insert your own values into the mutation: Value Description YOUR_ACCOUNT_ID Replace this with your account ID (the number next to your account name in NerdGraph API explorer). YOUR_DESCRIPTIVE_NAME Replace this with a name that describes the services that report to this trace observer (for example, production or query services). YOUR_PROVIDER_REGION Replace this with the provider region enum value for your location: AWS_EU_WEST_1 AWS_US_EAST_1 AWS_US_WEST_2 Click the triangle button to execute the mutation or press Ctrl+Enter. In the right pane showing the results, copy the following endpoint values to a text file so you can use them later: (Required) https: host (save to use later as YOUR_TRACE_OBSERVER_HOST in Configure the integration) (Required)https: port (save to use later as YOUR_TRACE_OBSERVER_PORT in Configure the integration) (Optional) https: url (save to use later as YOUR_TRACE_OBSERVER_URL in Send test data to the trace observer) 2d. (Optional) Send test data to the trace observer This test includes a sample payload with one trace and two spans from the same service: Test Service A. Follow these steps to send a test request: Get or generate your Insert API key so you can use it later in the test. Copy the following curl request into a text editor: curl request curl -i -H \"Content-Type: application/json\" \\ -H \"Api-Key: YOUR_INSERT_API_KEY\" \\ -H 'Data-Format: newrelic' \\ -H 'Data-Format-Version: 1' \\ -X POST \\ -d '[ { \"common\": { \"attributes\": { \"environment\": \"staging\" } }, \"spans\": [ { \"trace.id\": \"123456\", \"id\": \"ABC\", \"attributes\": { \"duration.ms\": 12.53, \"host\": \"host123.test.com\", \"name\": \"/home\", \"service.name\": \"Test Service A\" } }, { \"trace.id\": \"123456\", \"id\": \"DEF\", \"attributes\": { \"duration.ms\": 2.97, \"host\": \"host456.test.com\", \"error.message\": \"Invalid credentials\", \"name\": \"/auth\", \"parent.id\": \"ABC\", \"service.name\": \"Test Service B\" } } ] } ]' \\ 'YOUR_TRACE_OBSERVER_URL' Insert your own values into the curl request: Value Description YOUR_INSERT_API_KEY Replace this with your Insert API key (not the same as your personal API key for NerdGraph API explorer) YOUR_TRACE_OBSERVER_URL Replace this with the value under https: url from above. Copy the content of the text editor into a terminal, and then execute the request. If the test does not return HTTP/1.1 202 Accepted indicating success, check the following and try again: Confirm that you substituted the url (not host) value for YOUR_TRACE_OBSERVER_URL. Confirm that you only have single quotes around the value you inserted for YOUR_TRACE_OBSERVER_URL. Check that you are using the Insert API Key (not a license). If your test returned HTTP/1.1 202 Accepted, go to New Relic One to see a query of your test data using the span attribute service.name = Test Service A. Because the sample payload contains an error attribute, the error sampler will mark it for keeping. If you modify the payload to remove the error attributes, the random sampler may not choose to keep this particular trace. Traces may take up to one minute to be processed by both the trace observer and the Trace API. Step 3. (Infinite Tracing) Configure the integration To enable Infinite Tracing, configure your integration to send the telemetry data to the trace observer by using the results from Step 2. Find or create a trace observer endpoint. Find the section below describing these steps for your integration: Istio adapter Set the spansHost value with YOUR_TRACE_OBSERVER_URL when deploying the Helm chart. Kamon reporter Set the span-ingest-uri value with YOUR_TRACE_OBSERVER_URL in your kamon.newrelic configuration block. OpenCensus (Go language exporter) Set the SpansURLOverride field on the Config object with YOUR_TRACE_OBSERVER_URL when creating the Exporter. OpenCensus (Python language exporter) Pass the host and port parameters to the Trace Exporter using YOUR_TRACE_OBSERVER_HOST and YOUR_TRACE_OBSERVER_PORT. OpenTelemetry (Go language exporter) Set the SpansURLOverride field on the Config object with YOUR_TRACE_OBSERVER_URL when creating the Exporter. OpenTelemetry (Java language exporter) Complete the following: Create a java.net.URI with YOUR_TRACE_OBSERVER_URL. Pass the URI to com.newrelic.telemetry.opentelemetry.export.NewRelicSpanExporter builder’s uriOverride method. See an example where a NewRelicSpanExporter is created. OpenTelemetry (.NET language exporter) Configure the TraceUrlOverride parameter with YOUR_TRACE_OBSERVER_URL. Step 4. View traces After you configure your integration to send data to New Relic, you are ready to view traces. Here are two alternatives: View traces that include a specific service The Entity explorer helps you navigate to a specific service so you can see traces that include that service. Go to one.newrelic.com. Click Entity explorer in the top menu bar. Filter to the service you enabled for Infinite Tracing by typing the service name, and then press Enter. In the left navigation's Monitor section, click Distributed tracing. View traces across accounts This option allows you to search all traces across all New Relic accounts in your organization that you have access to. Go to one.newrelic.com. Click Apps in the top menu bar. Under Favorites click Distributed tracing. In the Find traces... search, type a search clause to find the service. For example, to query service.name or trace.id: service.name = YOUR_SERVICE_NAME trace.id = YOUR_TRACE_ID For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.21808,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " running the <em>query</em> in the previous section, you need to create one. To do this, you execute a GraphQL mutation that passes your configuration details. Copy the following into the middle pane of the <em>NerdGraph</em> API explorer. mutation { edgeCreateTraceObserver(accountId: YOUR_ACCOUNT_ID, traceObserverConfigs"
      },
      "id": "5ea0617064441ff137912311"
    },
    {
      "category_2": "Examples",
      "nodeid": 17141,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "NerdGraph cloud integrations API tutorial",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Mutation examples",
        "Enable an Amazon AWS integration",
        "Change polling interval for Amazon AWS integration",
        "Disable Amazon AWS integration",
        "For more help"
      ],
      "title": "NerdGraph cloud integrations API tutorial",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "15caa0b35be84f2e6245826a5c9ac8e49cad6a89",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial",
      "published_at": "2020-09-27T20:48:02Z",
      "updated_at": "2020-08-10T23:22:01Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic's NerdGraph (our GraphQL API) to query your New Relic Infrastructure cloud integration data. ",
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to https://api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_account_id_1>, name: <new_provider_account_name> }, { id: <linked_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_account_id_1> }, { linkedAccountId: <linked_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_account_id_3>}, { linkedAccountId: <linked_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } }</integration_slug></provider_slug> Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } }</integration_slug></provider_slug> Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.597824,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> cloud integrations API tutorial",
        "sections": "<em>NerdGraph</em>",
        "info": "Use New Relic&#x27;s <em>NerdGraph</em> (our GraphQL API) to <em>query</em> your New Relic Infrastructure cloud integration data. ",
        "category_1": "<em>NerdGraph</em>",
        "body": "This document provides examples of how to use New Relic <em>NerdGraph</em> to <em>query</em> and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the <em>NerdGraph</em> GraphiQL explorer, you can also <em>query</em> NRQL data. These examples for querying",
        "breadcrumb": "Contents &#x2F; APIs &#x2F; <em>NerdGraph</em> &#x2F; Examples"
      },
      "id": "5d83537b28ccbc263a1b7bf7"
    }
  ],
  "/explore-docs/query-and-store-data": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-09-08T01:50:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users's configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { 'YourNerdpackUuid': { 'collection-1': { 'document-1-of-collection-1': '{\"lastNumber\": 42, \"another\": [1]}', 'document-2-of-collection-1': '\"userToken\"', // ... }, 'another-collection': { 'fruits': '[\"pear\", \"apple\"]', // ... }, // ... }, } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.15268,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "nerdstorage <em>components</em>",
        "body": " and EntityStorage<em>Mutation</em> Each of these <em>components</em> can operate declaratively (for example, as part of your React rendering <em>methods</em>) or imperatively (by using the <em>static</em> <em>methods</em> for <em>query</em> and <em>mutation</em>). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "category_2": "Java agent release notes",
      "nodeid": 11976,
      "sections": [
        "APM agent release notes",
        "Go agent release notes",
        "Java agent release notes",
        ".NET agent release notes",
        "Node.js agent release notes",
        "PHP agent release notes",
        "Python agent release notes",
        "Ruby agent release notes",
        "C SDK release notes",
        "Java Agent 3.36.0",
        "Improvements",
        "Fixes"
      ],
      "title": "Java Agent 3.36.0",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "APM agent release notes",
      "external_id": "f94f5c53e522a9835ea42514e90d9a39e81fd050",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/java-release-notes/java-agent-3360",
      "published_at": "2020-09-28T01:25:55Z",
      "updated_at": "2018-04-14T23:39:35Z",
      "breadcrumb": "Contents / Release notes / APM agent release notes / Java agent release notes",
      "document_type": "release_notes",
      "popularity": -2,
      "body": "[RSS] Released on:  Wednesday, February 15, 2017 - 09:55 Download Improvements APIs This release adds a number of APIs that will allow you to instrument and get expanded visibility into frameworks, libraries, and any custom code that New Relic does not automatically instrument. In addition to instrumenting your web frameworks, you can also instrument calls to and from messaging systems, database calls, and external calls! By passing context about your code to the APIs, you will get the same reporting, including cross application tracing, that you get with New Relic’s built-in instrumentation. Solr This release adds support for Solr versions 5 and 6 (up to and including version 6.3.0). Fixes Fixes a bug that prevents an application from starting up when a JAX-RS annotated method contains more than 8 parameters. Fixes an issue that affected Spring and JAX-RS applications compiled with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using static methods. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page for customers injecting the X-Queue-Start or X-Request-Start HTTP headers. This fix brings the Java Agent into compliance with the behavior of other New Relic Agents. Fixes an issue in which custom Hystrix Commands that are subclassed multiple times in Groovy cause an application to throw an exception on startup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 47.677505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using <em>static</em> <em>methods</em>. The agent now reports WildFly dispatcher name and version. Fixes a bug"
      },
      "id": "58a53cf38e9c0f755a81db4e"
    },
    {
      "category_2": "API guides",
      "nodeid": 11521,
      "sections": [
        "Java agent",
        "Getting started",
        "Installation",
        "Additional installation",
        "Heroku",
        "Configuration",
        "Attributes",
        "Features",
        "Instrumentation",
        "Custom instrumentation",
        "API guides",
        "Async instrumentation",
        "Troubleshooting",
        "Guide to using the Java agent API",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Implement distributed tracing",
        "Implement cross application tracing",
        "Obtain references to New Relic entities",
        "Additional API functionality",
        "Additional API usage examples",
        "For more help"
      ],
      "title": "Guide to using the Java agent API ",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Java agent",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/agents/java-agent/api-guides/guide-using-java-agent-api",
      "external_id": "a31c751c7c29dd46effac2e568f7c0a92b033b18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api",
      "published_at": "2020-09-28T00:05:34Z",
      "updated_at": "2020-09-03T11:06:02Z",
      "breadcrumb": "Contents / APM agents / Java agent / API guides",
      "document_type": "page",
      "popularity": 1,
      "info": "A goal-focused guide to New Relic's Java agent API, with links to relevant sections of the complete API documentation on GitHub.",
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 3.36.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Implement distributed tracing These APIs require distributed tracing to be enabled. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() For more on obtaining references to the current transaction and other entities, see Obtain references. Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) For more on obtaining references to the current transaction and other entities, see Obtain references. Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Implement cross application tracing To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Also refer to the information in this document about using Transaction to obtain references to New Relic entities. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic entities. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic entities. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic entities. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic entities. Obtain references to New Relic entities Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events to Insights. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the first call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic entities. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 34.45126,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: <em>Static</em> <em>methods</em> on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "5a3137f4e621f4576cf1e35f"
    },
    {
      "category_2": "PHP agent API",
      "nodeid": 11821,
      "sections": [
        "PHP agent",
        "Getting started",
        "Installation",
        "Advanced installation",
        "Configuration",
        "API guides",
        "PHP agent API",
        "Attributes",
        "Features",
        "Frameworks and libraries",
        "Troubleshooting",
        "newrelic_add_custom_tracer",
        "Requirements",
        "Description",
        "Parameters",
        "Return value(s)",
        "Example(s)",
        "Instrument a function",
        "Instrument a method within a class",
        "Instrument a method within a namespaced class",
        "For more help"
      ],
      "title": "newrelic_add_custom_tracer (PHP agent API)",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "PHP agent",
      "external_id": "12242c1e6fe8cb70e2d42ff670cad04c01e9317e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_add_custom_tracer",
      "published_at": "2020-09-28T01:19:22Z",
      "updated_at": "2019-09-30T22:55:59Z",
      "breadcrumb": "Contents » APM agents / PHP agent / PHP agent API",
      "document_type": "api_doc",
      "popularity": 1,
      "info": "New Relic PHP agent API call to add custom instrumentation to particular methods in your app code. ",
      "body": "newrelic_add_custom_tracer(string $function_name) Specify functions or methods for the agent to instrument with custom instrumentation. Requirements Compatible with all agent versions. Description Specify functions or methods for the agent to target for custom instrumentation. This is the API equivalent of the newrelic.transaction_tracer.custom setting. You cannot apply custom tracing to internal PHP functions. Parameters Parameter Description $function_name string Required. The name can be formatted either as function_name for procedural functions, or as \"ClassName::method\" for methods. Both static and instance methods will be instrumented if the method syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return value(s) Returns true if the tracer was added successfully. Example(s) Instrument a function function example_function() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"example_function\"); } } Instrument a method within a class class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"ExampleClass::example_method\"); } } } Instrument a method within a namespaced class namespace Foo\\Bar; class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"Foo\\\\Bar\\\\ExampleClass::example_method\"); } } } Alternatively, on PHP 5.5 or later, the ::class syntax can be used instead: namespace Foo\\Bar { class ExampleClass { function example_method() { // ... } } } namespace { use Foo\\Bar; if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(Bar::class . \"::example_method\"); } } }",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 26.676685,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Instrument a <em>method</em> within a class",
        "info": "New Relic PHP agent API call to add custom instrumentation to particular <em>methods</em> in your app code. ",
        "body": " <em>static</em> and instance <em>methods</em> will be instrumented if the <em>method</em> syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return value(s) Returns true if the tracer was added successfully. Example(s) Instrument"
      },
      "id": "58ca4191e621f45edd466e7a"
    },
    {
      "nodeid": 9691,
      "sections": [
        "Introduction to New Relic Mobile (Unity)",
        "Contents",
        "Monitor mobile app performance",
        "Install and configure",
        "Use Unity SDK API",
        "Send custom events and attributes to Insights",
        "Track custom network requests",
        "Uninstall plugin",
        "Unity release notes",
        "For more help"
      ],
      "title": "Introduction to New Relic Mobile (Unity)",
      "type": "docs",
      "external_id": "9e03a54ec6df360532302d4dfe7484070f8ba80c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/introduction-new-relic-mobile-unity",
      "published_at": "2020-09-27T15:19:17Z",
      "updated_at": "2020-07-25T00:44:01Z",
      "breadcrumb": "Contents",
      "document_type": "page",
      "popularity": 1,
      "body": "Legacy feature This document is for historical reference. Unity is no longer supported for new customers. Contents Monitor mobile app performance The New Relic Unity plugin allows Unity developers to embed a New Relic Mobile agent (iOS or Android) in a Unity app build for mobile devices to monitor your app's performance. The plugin is written in C#, but it includes the native iOS and Android agents that embed the appropriate files for your build. Features New Relic Mobile Features Comprehensive performance data View your mobile app's performance Overview page for summary information about active sessions, or drill down to detailed information, including (note limitations below): Interaction times and trace details Crash reporting Devices Operating systems Detailed network views Available by using the API to track custom network requests For iOS apps, receive automatic instrumentation for networking for any parts of the app that are native and non-Unity (using standard Apple networking components such as NSURLConnection) Examine HTTP errors and network failures (such as DNS lookups, timeouts, SSL errors, etc.) and server error traces. Usage details at a glance Compare performance between versions of your app with detailed information for memory, CPU (iOS only), interaction speed, network requests per minute, and network failures. View a monthly report with a bar chart tracking the number of devices running your app for each month over the last year. Mobile SDK API options Use the Unity API to: Create and complete interactions Record custom metrics Send custom events to Insights Track custom network requests Known limitations The New Relic Unity plugin does not automatically instrument interactions. You must use the Unity API to track specific interactions. The New Relic Unity plugin does not automatically instrument network requests. You must use the Unity API to track network calls. Android builds: Unity still generates an Eclipse project, but Android Studio can import the Eclipse project. Install and configure The Unity plugin includes iOS and Android agent files that will embed the appropriate files for your build. To instrument interactions and network requests, you must use the Unity API to manually instrument your code. Install the Unity plugin As part of the installation process, New Relic Mobile automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile project you monitor in New Relic Mobile. For Admins with existing New Relic accounts, follow these steps to install and configure your Unity application. (If you do not have a New Relic account, see New Relic Mobile.) Go to rpm.newrelic.com/mobile. From the mobile apps index, select Add a new app. From the Get started page, select Unity as the platform for mobile monitoring. Type a name for your mobile project, then select Continue. Continue with the procedures to configure the Unity plugin. Configure the Unity plugin These procedures to configure your app also appear on the Get started page in the New Relic UI. Install NewRelic-Unity-Plugin.unitypackage into your project by going to Assets > Import package > Custom package... and selecting NewRelic-Unity-Plugin.unitypackage. Create a new GameObject in your project's initial scene by going to GameObject > Create empty and naming it NewRelicAgent. Add NewRelicAgent.cs script (located in Assets/Plugins) to the NewRelicAgent GameObject: Drag it on top of NewRelicAgent in the Hierarchy tab. OR Click Add Component button, then select New Relic Agent from the Scripts option. In the Inspector tab, set the iOS or Android application token from your New Relic Mobile apps. (Recommendation: Keep New Relic Mobile apps on separate platforms.) Build for your platform (iOS or Android), then open the resulting project (Xcode or Eclipse). For Eclipse, import the generated project into Android Studio. Android only: Ensure that your app requests the INTERNET permission through the Player Settings inspector window. In Other Settings, Configuration, ensure the Internet access dropdown is set to Required. This will result in the following permission added to the app's manifest: <uses-permission android:name=\"android.permission.INTERNET\" /> Run your app in an emulator or device to generate data. Check New Relic Mobile to ensure the data is reporting to your account. Configure crash reporting The New Relic Unity plugin cannot automatically upload dSYMs for iOS crash reporting. You must manually upload dSYMs once your iOS unity app is built for release. If the application is bitcode enabled, follow the procedures for bitcode enabled apps once the your iOS app is submitted to Apple. If you are building an Android app with ProGuard enabled, you must follow similar steps. The ProGuard mapping must be uploaded to New Relic so crash reports can be de-obfuscated. For more information, see Android agent crash reporting. Optional: Change the logging level Six logging levels are available for mobile apps monitoring: NONE ERROR WARNING INFO VERBOSE DEBUG Recommendation: Set the logging level from the Unity Inspector tab. Use Unity SDK API Use the New Relic Unity SDK API to further configure and extend the plugin's instrumentation. Create and complete interactions To start an interaction: string interactionIdentifier = NewRelicAgent.StartInteractionWithName(\"new interaction\"); To stop the current interaction: NewRelicAgent.StopCurrentInteraction(interactionIdentifier); Interactions work in conjuction with method tracing. To trace a method insert startTracingMethod, insert at the start of the method to trace, and insert endTracingMethodWithTimer at each exit point of the method. To start tracing a method: Timer methodTimer = new Timer(); NewRelicAgent.StartTracingMethod(\"MethodName\",\"ClassName\",methodTimer,NewRelicAgent.NRTraceType.None); To end tracing a method, use the same timer as the startTracingMethod:> NewRelicAgent.EndTracingMethodWithTimer(methodTimer); Set a custom build identifier Custom build identifiers are set as the Application Build property in the inspector pane for the NewRelicAgent game object, under the New Relic Agent (Script) settings. Execute a demo crash If you have trouble getting your project to crash, use the New Relic Unity plugin API to execute a demo crash. Recommendation: Add this line of code to a button click event handler as applicable: NewRelicAgent.CrashNow(\"message\")> Record custom metrics With the custom metric API, you can record arbitrary numerical data and named events. Custom metrics can help to track high level events specific to your application. You can use several API calls to record custom metrics that provide different levels of detail. To create a custom metric, use this method: NewRelicAgent.RecordMetricWithName(String name, String category) The name parameter is the textual name of the metric that will appear in the user interface for New Relic Mobile. Using clear, concise metric names will help you get the most out of the metrics. The guidelines for naming a custom metric include: Use case and white space characters appropriate for display in the user interface. Metric names are rendered as-is. Capitalize the metric name. Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. If you want to specify more details about a custom metric, three other API methods are available: NewRelicAgent.RecordMetricWithName(String name, String category, double value) NewRelicAgent.RecordMetricWithName(string name, string category, double value, string valueUnits) NewRelicAgent.RecordMetricWithName(string name, string category, double value, string valueUnits, string countUnits) With these methods, you can record additional details: Parameter Description count The number of times the event has happened totalValue The total value of the recording exclusiveValue The exclusive value of the recording; for example, if the total value contains measurements accounted for elsewhere countUnit Unit of measurement for the metric count, including PERCENT, BYTES, SECONDS, BYTES_PER_SECOND, or OPERATIONS valueUnit Unit of measurement for the metric value, including PERCENT, BYTES, SECONDS, BYTES_PER_SECOND, or OPERATIONS To view the custom metrics you collect, follow standard procedures to create custom dashboards. Send custom events and attributes to Insights The SDK can store up to 64 user-defined attributes at a time. If you attempt to store more than 64 attributes, the SDK returns false. Use the following static methods in the NewRelicAgent namespace to send custom attributes and events to New Relic Insights. Methods that return boolean results return true if they succeed, or false if the operation did not complete. The following methods are available for custom attributes and events: RecordEvent (name, attributes) NewRelicAgent.RecordEvent (string name, string dictionary attributes) Records a custom Insights event. Includes a list of attributes specified as a map. SetAttribute (name, value) NewRelicAgent.SetAttribute (string name, string value) NewRelicAgent.SetAttribute (string name, double value) Creates an attribute with the specified text name and text/float value. SetAttribute overwrites its previous value and type each time it is called. Examples boolean attributeSet = NewRelicAgent.SetAttribute(\"username\", \"SampleUserName\"); boolean attributeSet = NewRelicAgent.SetAttribute(\"rate\", 9999.99); IncrementAttribute (name [, value]) public static boolean IncrementAttribute(String name); public static boolean incrementAttribute(String name, double value) If value is not specified, this method increments the count for the specified attribute by 1. If the attribute does not exist, it creates the attribute with a value of 1. If value is specified, the method will increment the attribute by the specified amount. Examples boolean incremented = NewRelicAgent.IncrementAttribute(\"rate\"); boolean incremented = NewRelicAgent.IncrementAttribute(\"rate\", 9999.99, false); RemoveAttribute (name) NewRelicAgent.RemoveAttribute(String name) Removes the specified attribute. Example boolean attributeRemoved = NewRelicAgent.RemoveAttribute(\"rate\"); removeAllAttributes NewRelicAgent.removeAllAttributes() Removes all attributes from the session. Example boolean attributesRemoved = NewRelicAgent.RemoveAllAttributes(); Track custom network requests New Relic Mobile's API provides several methods to track network requests and network failures. For example, use the noticeHttpTransaction family of methods to record HTTP transactions with several available levels of detail. If a network request fails, you can record details about the failure with noticeNetworkFailure. NoticeNetworkRequest NewRelicAgent.NoticeNetworkRequest (\"http://newrelic.com\", \"GET\", timer, null, 200, 1024, 8192, bytes, httpParameters); Parameter Description url The URL of the request httpMethod The HTTP method used, such as GET or POST statusCode The statusCode of the HTTP response, such as 200 for OK timer A timer created when the network request was started bytesSent The number of bytes sent in the request bytesReceived The number of bytes received in the response responseBody The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. params Additional parameters included in an HTTP Error metric if the HTTP transaction is an error. NoticeNetworkFailure NewRelicAgent.NoticeNetworkFailure(String url, String httpMethod, Timer timer, NewRelicAgent.NetworkFailureCode failureCode, String message) Parameter Description url The URL of the request httpMethod The HTTP method used, such as GET or POST timer A timer created when the network request was started exception The exception that occurred. New Relic Mobile can automatically translate many common exceptions into network failure types. failure The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Uninstall plugin To uninstall the Unity plugin, use the project console to remove all related files and resources that were installed with the Unity package: Delete NewRelicAgent object from the Hierarchy pane of the Unity project console. From All Scripts, delete all the scripts that start with newrelic. Then do the following as applicable: From Assets > Plugin > iOS, delete the NewRelicIos, NewRelicUnityPlugin, post-build, and restore-framework files. Then remove the mod_pbxproj and NewRelicAgent.framework directories. From Assets > Plugin > Android, delete the newrelic.android and NewRelicAndroid files. Then remove the LICENSE and README directories. Unity release notes These release notes are for historical reference. Unity is no longer supported for new customers. Unity plugin 1.2.0 Released on: Monday, March 13, 2017 - 13:00 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.2.0.zip Notes: Updated Unity plugin to iOS agent 5.9.0 and Android agent 5.9.0 Unity plugin 1.1.0 Released on: Tuesday, September 6, 2016 - 14:53 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.1.0.zip Notes: Updated Unity plugin to iOS agent 5.8.0 and Android agent 5.7.1 Unity plugin 1.0.1 Released on: Monday, August 8, 2016 - 14:00 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.0.1.zip Notes: Bundle Android class rewriter JAR file (version 5.6.1) into the Unity package. Unity plugin 1.0.0 Released on: Wednesday, May 25, 2016 - 14:00 Download URL: http://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.0.0.zip Notes: This plugin provides New Relic Mobile agent support for iOS and Android applications built with Unity. It also gives Unity developers access to New Relic crash reporting. It provides information about app performance, sessions, devices, operating systems, and more. It also includes APIs for custom instrumentation to gain deeper insights into specific areas of your app. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 17.70617,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " The SDK can store up to 64 user-defined attributes at a time. If you attempt to store more than 64 attributes, the SDK returns false. Use the following <em>static</em> <em>methods</em> in the NewRelicAgent namespace to send custom attributes and events to New Relic Insights. <em>Methods</em> that return boolean results return"
      },
      "id": "5c52cbec8e9c0f0b286080ec"
    }
  ],
  "/collect-data/custom-events": [
    {
      "category_2": "Custom events",
      "nodeid": 13661,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Data requirements and limits for custom event data",
        "General requirements",
        "Reserved words",
        "Additional Browser PageAction requirements",
        "Additional Event API requirements",
        "Event type limits",
        "For more help"
      ],
      "title": "Data requirements and limits for custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "external_id": "f5beef0d09bb5918be3f8a1a3ece98c09947cd1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "published_at": "2020-09-27T17:50:31Z",
      "updated_at": "2020-09-27T17:50:31Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic, general limits and requirements for reporting custom events and attributes. ",
      "body": "You can report custom events to New Relic in several ways, including the New Relic Event API, APM agent APIs, Browser agent APIs, and the Mobile SDK. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. General requirements How long custom data is retained depends on your Insights subscription and its associated data retention. When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1 MB maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. This is not a complete list. In general, it's a good practice to avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Additional Browser PageAction requirements For additional requirements for using New Relic Browser's custom PageAction event, see Insert custom data via New Relic Browser agent. Additional Event API requirements For more requirements and details for the Event API, see Event API. Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.87116,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data requirements and limits for <em>custom</em> <em>event</em> data",
        "sections": "<em>Custom</em> <em>events</em>",
        "info": "For New Relic, general limits and requirements for reporting <em>custom</em> <em>events</em> and attributes. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "<em>Custom</em> <em>events</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;insights-data-sources&#x2F;<em>custom</em>-data&#x2F;insights-<em>custom</em>-data-requirements-limits",
        "body": "You can report <em>custom</em> <em>events</em> to New Relic in several ways, including the New Relic <em>Event</em> <em>API</em>, APM <em>agent</em> <em>APIs</em>, Browser <em>agent</em> <em>APIs</em>, and the Mobile SDK. This document contains general requirements and rules for inserting and using <em>custom</em> <em>events</em> and their associated attributes. Additional requirements",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; <em>Custom</em> <em>events</em>"
      },
      "id": "59f4354f4bb81c2ea8b80d0a"
    },
    {
      "category_2": "Logs in context with agent APIs",
      "nodeid": 36921,
      "sections": [
        "Enable log management",
        "New Relic Logs",
        "Enable log monitoring",
        "Configure logs in context",
        "Logs in context for Go",
        "Logs in context for Java",
        "Logs in context for .NET",
        "Logs in context for Node.js",
        "Logs in context for PHP",
        "Logs in context for Python",
        "Logs in context for Ruby",
        "Logs in context with agent APIs",
        "Annotate logs for logs in context using APM agent APIs",
        "APM agent trace metadata and linking metadata APIs",
        "Resources for correctly annotating logs",
        "For more help"
      ],
      "title": "Annotate logs for logs in context using APM agent APIs",
      "category_0": "Log management",
      "type": "docs",
      "category_1": "Enable log management",
      "external_id": "9d737d9f02561f18b47103b62ce11ada3dfae106",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/enable-log-management-new-relic/logs-context-agent-apis/annotate-logs-logs-context-using-apm-agent-apis",
      "published_at": "2020-09-27T21:36:25Z",
      "updated_at": "2020-09-27T21:36:25Z",
      "breadcrumb": "Contents / Log management / Enable log management / Logs in context with agent APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic's  log management: How to use APM agent APIs to manually set up your own logs in context solution. ",
      "body": "If you use log management and APM, you can configure logs in context to correlate log data with other New Relic features. If you use a logging framework not covered by our existing logs in context solutions, we provide a way for you to configure your logging libraries to achieve annotated logs necessary for logs in context. APM agent trace metadata and linking metadata APIs To get properly annotated logs for logs in context, use APM agent API calls (listed below). These APIs pass metadata required for linking log data to other New Relic data. This metadata is referred to as trace metadata and linking metadata. For tips on using these, see Resources for correct annotation. APM agent APIs: Go agent APIs: GetTraceMetadata GetLinkingMetadata Java agent APIs: getTraceMetadata getLinkingMetadata .NET agent APIs: TraceMetadata GetLinkingMetadata Node.js agent APIs: getTraceMetadata getLinkingMetadata PHP agent APIs: GetTraceMetadata GetLinkingMetadata Python agent API: get_linking_metadata Ruby agent APIs: linking_metadata current_trace_id current_span_id Resources for correctly annotating logs For more information on using the trace metadata and linking metadata APIs to annotate logs for logs in context, see the following resources: Review the APM agent specifications for getting properly formatted annotated logs for logs in context functionality, which include the required fields and properly formatted output. View the source code for our own logs in context extensions to see how we use these APIs: Go: Logrus extension Java: Log4j2 extension .NET: Serilog extension Node.js: Winston extension Python: see Python agent logging configuration PHP: Monolog extension Ruby: Logging extension For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.17876,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Annotate logs for logs in context using APM <em>agent</em> <em>APIs</em>",
        "sections": "Logs in context with <em>agent</em> <em>APIs</em>",
        "info": "New Relic&#x27;s  log management: How to use APM <em>agent</em> <em>APIs</em> to manually set up your own logs in context solution. ",
        "category_2": "Logs in context with <em>agent</em> <em>APIs</em>",
        "body": " necessary for logs in context. APM <em>agent</em> trace metadata and linking metadata <em>APIs</em> To get properly annotated logs for logs in context, use APM <em>agent</em> <em>API</em> calls (listed below). These <em>APIs</em> pass metadata required for linking log data to other New Relic data. This metadata is referred to as trace metadata",
        "breadcrumb": "Contents &#x2F; Log management &#x2F; Enable log management &#x2F; Logs in context with <em>agent</em> <em>APIs</em>"
      },
      "id": "5f37535c196a67c8c055e5ff"
    },
    {
      "category_2": "Custom events",
      "nodeid": 6256,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "APM: Report custom events",
        "Data considerations",
        "Record a custom event",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words",
        "For more help"
      ],
      "title": "APM: Report custom events",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/event-data-sources/custom-events/apm-report-custom-events",
      "external_id": "0c3f09d0d0e04ad50bedcdf7088eed7c171001d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/apm-report-custom-events",
      "published_at": "2020-09-27T20:58:51Z",
      "updated_at": "2020-09-24T07:10:11Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic APM: how to report custom events and attributes.",
      "body": "If you have APM, you can report custom event data, which is then available for querying in New Relic. Related documentation: Add custom attributes to existing events Send custom events using the Event API (without need for APM) Custom events sent with the agent APIs are not compatible with high security mode. Data considerations The New Relic agents sends event data to New Relic as part of its normal harvest cycle every 5 seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB in size will not be recorded, regardless of the custom event limit. For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record a custom event To record a custom event, follow the procedure for your New Relic language agent: C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see Limits and restricted characters and Reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 To disable custom events entirely, add the following to your newrelic.yml:​ custom_insights_events: enabled: false For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see Limits and restricted characters and Reserved words. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see Limits and restricted characters and Reserved words. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see Limits and restricted characters and Reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see Limits and restricted characters and Reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see Limits and restricted characters and Reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 85.15033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> <em>events</em>",
        "sections": "<em>Custom</em> <em>events</em>",
        "info": "New Relic APM: how to report <em>custom</em> <em>events</em> and attributes.",
        "category_1": "<em>Event</em> data sources",
        "category_2": "<em>Custom</em> <em>events</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;<em>event</em>-data-sources&#x2F;<em>custom</em>-<em>events</em>&#x2F;apm-report-<em>custom</em>-<em>events</em>",
        "body": "If you have APM, you can report <em>custom</em> <em>event</em> data, which is then available for querying in New Relic. Related documentation: Add <em>custom</em> attributes to existing <em>events</em> Send <em>custom</em> <em>events</em> using the <em>Event</em> <em>API</em> (without need for APM) <em>Custom</em> <em>events</em> sent with the <em>agent</em> <em>APIs</em> are not compatible with high",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; <em>Custom</em> <em>events</em>"
      },
      "id": "5f480a5a64441f578bfdcdb1"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13806,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Report custom event data",
        "Overview of reporting custom events and attributes",
        "Send custom events and attributes",
        "Extend data retention",
        "For more help"
      ],
      "title": "Report custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "external_id": "afb5f5a81ae06b22935d98c470ed9cabd7c9da6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/report-custom-event-data",
      "published_at": "2020-09-27T21:40:24Z",
      "updated_at": "2020-07-26T05:52:23Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the options for sending custom event data to New Relic. ",
      "body": "New Relic products report a variety of default event data to your account. This document will explain how to report your own custom events and attributes. Overview of reporting custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. Reporting custom events allows you to create more useful and customized queries and charts of your data, and is a key part of optimizing how New Relic works for you. Before beginning, it's important to know that reporting a large number of custom events and/or attributes can cause degraded query performance, or cause you to approach or pass data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile agent Use the mobile agent API to send custom events and attributes. Synthetics Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn about how to extend how long events are retained in your account, see Event data retention. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 57.20172,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>custom</em> <em>event</em> data",
        "sections": "<em>Custom</em> <em>events</em>",
        "info": "An overview of the options for sending <em>custom</em> <em>event</em> data to New Relic. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "<em>Custom</em> <em>events</em>",
        "body": " retention policy. Send <em>custom</em> <em>events</em> and attributes Methods for sending <em>custom</em> <em>events</em> and attributes include: Source How to send <em>custom</em> data APM <em>agent</em> Use APM <em>agent</em> <em>APIs</em> to report <em>custom</em> <em>events</em> and <em>custom</em> attributes. Browser <em>agent</em> Add <em>custom</em> attributes to the PageView <em>event</em> via the Browser <em>API</em> call",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; <em>Custom</em> <em>events</em>"
      },
      "id": "5e8e7f9de7b9d2aa122cf0f6"
    },
    {
      "category_2": "Ingest APIs",
      "nodeid": 17376,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Ingest APIs",
        "Use the Event API to report custom events",
        "Basic workflow",
        "Register an Insert API key",
        "Format the JSON",
        "Submit the custom event",
        "Verify or troubleshoot request response",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests",
        "For more help"
      ],
      "title": "Use the Event API to report custom events",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/telemetry-data-platform/ingest-manage-data/ingest-apis/use-event-api-report-custom-events",
      "external_id": "589a1cbf9b6b64be620689b3af3cbadff0c67da2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-manage-data/ingest-apis/use-event-api-report-custom-events",
      "published_at": "2020-09-27T21:21:35Z",
      "updated_at": "2020-09-27T21:21:35Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Ingest APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic's Event API, which lets you send custom event data to your New Relic account. ",
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. To send a custom event to your New Relic account: Register an Insert API key. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Register an Insert API key You must have the correct user permissions to register Insert API keys. Insert API keys are generated for an account. They aren't associated with a specific user. Anyone in the account with access to the Insert API key can use it. You submit multiple event types under a single Insert API key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. To register an Insert API key: From one.newrelic.com, click the account dropdown and then click Account settings. Click API keys. On the next page, click Insights API keys. Next to the Insert keys heading, select the plus symbol and follow the instructions. The Insert key page lists the curl command necessary to add event data for the key. For security reasons, the Insert API key cannot be altered or read using the API. To change or read a key, use the New Relic UI. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. The timestamp must be a 64-bit integer within 24 hours of the time the event is submitted to New Relic. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent to the Event API: Payload total size: 1MB maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. The Insert key page in the Insights UI automatically generates a sample curl query for you to use as a template. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"X-Insert-Key: YOUR_KEY_HERE\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_KEY_HERE\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"X-Insert-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The X-Insert-Key contains the correct Insert API key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, use the Insights data explorer to ensure your events are reporting correctly and to generate queries. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid API key: Invalid Insert key, or the account does not have access to Insights. Register a valid Insert key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To have New Relic Alerts notify you about parsing errors, create a NRQL condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes an unformatted Unix timestamp. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the Insert API key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 55.502472,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use the <em>Event</em> <em>API</em> to report <em>custom</em> <em>events</em>",
        "sections": "Use the <em>Event</em> <em>API</em> to report <em>custom</em> <em>events</em>",
        "info": "Intro to New Relic&#x27;s <em>Event</em> <em>API</em>, which lets you send <em>custom</em> <em>event</em> data to your New Relic account. ",
        "category_2": "Ingest <em>APIs</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;telemetry-data-platform&#x2F;ingest-manage-data&#x2F;ingest-<em>apis</em>&#x2F;use-<em>event</em>-<em>api</em>-report-<em>custom</em>-<em>events</em>",
        "body": "The New Relic <em>Event</em> <em>API</em> is one way to report <em>custom</em> <em>events</em> to New Relic. The <em>Event</em> <em>API</em> lets you send <em>custom</em> <em>event</em> data to your New Relic account with a POST command. These <em>events</em> are then queryable and chartable using NRQL. If your account hosts data in the EU data center, ensure you are using",
        "breadcrumb": "Contents &#x2F; Telemetry Data Platform &#x2F; Ingest and manage data &#x2F; Ingest <em>APIs</em>"
      },
      "id": "5f37a5b7196a6743a355e613"
    }
  ],
  "/explore-docs/nerdpack-file-structure": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Summary",
        "Related information"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2020-09-29T01:47:52Z",
      "updated_at": "2020-08-21T01:45:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Create a \"Hello, World!\" application 15 min Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin To get started, make sure you have accounts in GitHub and New Relic. To develop projects, you need the New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete all the steps in the CLI quick start. For additional details about setting up your environment, see Set up your development environment. Tip Use the NR1 VS Code extension to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two artifacts: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: npm start Copy Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: nr1 nerdpack:publish Copy Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: nr1 create Copy Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: nr1 catalog:submit Copy Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it. Related information Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can see it directly on their homepage.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.3181,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Publish your application to <em>New</em> <em>Relic</em>",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "body": "!&quot; application The <em>CLI</em> allows you to run a local version of <em>New</em> <em>Relic</em> <em>One</em>. You can develop your application locally before you publish it in <em>New</em> <em>Relic</em> <em>One</em>. If you followed all the steps in the <em>CLI</em> quick start, you now have files under a <em>new</em> directory named after your <em>nerdpack</em> project. Here&#x27;s how you edit"
      },
      "id": "5efa9973196a67d16d76645c"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 370.4605,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " <em>CLI</em> commands to: Generate <em>Nerdpack</em>&#x2F;<em>Nerdlet</em> templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> In <em>New</em> <em>Relic</em>, click Apps and then in the <em>New</em> <em>Relic</em> <em>One</em> catalog area, click the Build"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "Map page views by region in a custom app",
        "Before you begin",
        "New Relic terminology",
        "Build a custom app with a table chart",
        "Query your browser data",
        "Create and serve a new Nerdpack",
        "Review your app files and view your app locally",
        "Hard code your account ID",
        "Import the TableChart component",
        "Add a table with a single row",
        "Customize the look of your table (optional)",
        "Get your data into that table",
        "Make your app interactive with a text field",
        "Import the TextField component",
        "Add a row for your text field",
        "Build the text field object",
        "Get your data on a map",
        "Install Leaflet",
        "Add a webpack config file for Leaflet",
        "Import modules from Leaflet",
        "Import additional modules from New Relic One",
        "Get data for the map",
        "Customize the map marker colors",
        "Set your map's default center point",
        "Add a row for your map",
        "Replace \"Hello\" with the Leaflet code"
      ],
      "title": "Map page views by region in a custom app",
      "type": "developer",
      "tags": [
        "custom app",
        "map",
        "page views",
        "region",
        "nerdpack"
      ],
      "external_id": "6ff5d696556512bb8d8b33fb31732f22bab455cb",
      "image": "https://developer.newrelic.com/static/d87a72e8ee14c52fdfcb91895567d268/0086b/pageview.png",
      "url": "https://developer.newrelic.com/build-apps/map-pageviews-by-region/",
      "published_at": "2020-09-29T01:47:51Z",
      "updated_at": "2020-09-17T01:48:42Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a New Relic app showing page view data on a world map.",
      "body": "Map page views by region in a custom app 30 min New Relic has powerful and flexible tools for building custom apps and populating them with data. This guide shows you how to build a custom app and populate it with page view data using New Relic's Query Language (NRQL - pronounced 'nurkle'). Then you make your data interactive. And last, if you have a little more time and want to install a third-party React library, you can display the page view data you collect on a map of the world. In this guide, you build an app to display page view data in two ways: In a table On a map Please review the Before you begin section to make sure you have everything you need and don't get stuck halfway through. Before you begin In order to get the most out of this guide, you must have: A New Relic developer account, API key, and the command-line tool. If you don't have these yet, see the steps in Setting up your development environment New Relic Browser page view data to populate the app. Without this data, you won't be able to complete this guide. To add your data to a world map in the second half of the guide: npm, which you'll use during this section of the guide to install Leaflet, a third-party JavaScript React library used to build interactive maps. If you're new to React and npm, you can go here to install Node.js and npm. New Relic terminology The following are some terms used in this guide: New Relic application: The finished product where data is rendered in New Relic One. This might look like a series of interactive charts or a map of the world. Nerdpack: New Relic's standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see Nerdpack file structure. Launcher: The button on New Relic One that launches your application. Nerdlets: New Relic React components used to build your application. The three default files are index.js, nr1.json, and styles.scss, but you can customize and add your own. Build a custom app with a table chart Step 1 of 8 Query your browser data Use Query builder to write a NRQL query to see your page view data, as follows. On New Relic One, select Query your data (in the top right corner). That puts you in NRQL mode. You'll use NRQL to test your query before dropping the data into your table. Copy and paste this query into a clear query field, and then select Run. FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000 Copy If you have PageView data, this query shows a week of average page views broken down by country and limited to a thousand items. The table will be full width and use the \"chart\" class defined in the CSS. If you don't have any results at this point, ensure your query doesn't have any errors. If your query is correct, you might not have the Browser agent installed. Step 2 of 8 Create and serve a new Nerdpack To get started, create a new Nerdpack, and serve it up to New Relic from your local development environment: Create a new Nerdpack for this app: nr1 create --type nerdpack --name pageviews-app Copy Serve the project up to New Relic: cd pageviews-app && nr1 nerdpack:serve Copy Step 3 of 8 Review your app files and view your app locally Navigate to your pageviews-app to see how it's structured. It contains a launcher folder, where you can customize the description and icon that will be displayed on the app's launcher in New Relic One. It also contains nerdlets, which each contain three default files: index.js, nr1.json, and styles.scss. You'll edit some of these files as part of this guide. For more information, see Nerdpack file structure. Now in your browser, open https://one.newrelic.com/?nerdpacks=local, and then click Apps to see the pageview-apps Nerdpack that you served up. When you select the launcher, you see a Hello message. Step 4 of 8 Hard code your account ID For the purposes of this exercise and for your convenience, hard code your account ID. In the pageview-app-nerdlet directory, in the index.js file, add this code between the import and export lines. (Read about finding your account ID here). const accountId = [Replace with your account ID]; Copy Step 5 of 8 Import the TableChart component To show your data in a table chart, import the TableChart component from New Relic One. To do so, in index.js, add this code under import React. import { TableChart } from 'nr1'; Copy Step 6 of 8 Add a table with a single row To add a table with a single row, in the index.js file, replace this line: return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; Copy with this export code: export default class PageViewApp extends React.Component { render() { return ( <div className=\"container\"> <div className=\"row\"></div> </div> ); } } Copy Step 7 of 8 Customize the look of your table (optional) You can use standard CSS to customize the look of your components. In the styles.scss file, add this CSS. Feel free to customize this CSS to your taste. .container { width: 100%; height: 99vh; display: flex; flex-direction: column; .row { margin: 10px; display: flex; flex-direction: row; } .chart { height: 250px; } } Copy Step 8 of 8 Get your data into that table Now that you've got a table, you can drop a TableChart populated with data from the NRQL query you wrote at the very beginning of this guide. Put this code into the row div. <TableChart accountId={accountId} query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} fullWidth className=\"chart\" />; Copy Go to New Relic One and click your app to see your data in the table. (You might need to serve your app to New Relic again.) Congratulations! You made your app! Continue on to make it interactive and show your data on a map. Make your app interactive with a text field Once you confirm that data is getting to New Relic from your app, you can start customizing it and making it interactive. To do this, you add a text field to filter your data. Later, you use a third-party library called Leaflet to show that data on a world map. Step 1 of 3 Import the TextField component Like you did with the TableChart component, you need to import a TextField component from New Relic One. import { TextField } from 'nr1'; Copy Step 2 of 3 Add a row for your text field To add a text field filter above the table, put this code above the TableChart div. The text field will have a default value of \"US\". <div className=\"row\"> <TextField placeholder=\"US\" onChange={(event) => { this.setState({ countryCode: event.target.value }); }} /> </div>; Copy Step 3 of 3 Build the text field object Above the render() function, add a constructor to build the text field object. constructor(props) { super(props); this.state = { countryCode: null } } Copy Then, add a constructor to your render() function. Above return, add: const { countryCode } = this.state; Copy Now add countryCode to your table chart query. <TableChart accountId={accountId} query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} fullWidth className=\"chart\" />; Copy Reload your app to try out the text field. Get your data on a map To create the map, you use npm to install Leaflet. Step 1 of 9 Install Leaflet In your terminal, type: npm install --save leaflet react-leaflet Copy In your nerdlets styles.scss file, import the Leaflet CSS: @import `~leaflet/dist/leaflet.css`; Copy While you're in styles.scss, fix the width and height of your map: .containerMap { width: 100%; z-index: 0; height: 70vh; } Copy Step 2 of 9 Add a webpack config file for Leaflet Add a webpack configuration file .extended-webpackrc.js to the top-level folder in your nerdpack. This supports your use of map tiling information data from Leaflet. module.exports = { module: { rules: [ { test: /\\.(png|jpe?g|gif)$/, use: [ { loader: 'file-loader', options: {}, }, { loader: 'url-loader', options: { limit: 25000 }, }, ], }, ], }, }; Copy Step 3 of 9 Import modules from Leaflet In index.js, import modules from Leaflet. import { Map, CircleMarker, TileLayer } from 'react-leaflet'; Copy Step 4 of 9 Import additional modules from New Relic One You need several more modules from New Relic One to make the Leaflet map work well. Import them with this code: import { NerdGraphQuery, Spinner, Button, BlockText } from 'nr1'; Copy NerdGraphQuery lets you make multiple NRQL queries at once and is what will populate the map with data. Spinner adds a loading spinner. Button gives you button components. BlockText give you block text components. Step 5 of 9 Get data for the map Using latitude and longitude with country codes, you can put New Relic data on a map. mapData() { const { countryCode } = this.state; const query = `{ actor { account(id: 1606862) { mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : ''} LIMIT 1000 \") { results nrql } } } }`; return query; }; Copy Step 6 of 9 Customize the map marker colors Above the mapData function, add this code to customize the map marker colors. getMarkerColor(measure, apdexTarget = 1.7) { if (measure <= apdexTarget) { return '#11A600'; } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { return '#FFD966'; } else { return '#BF0016'; } }; Copy Feel free to change the HTML color code values to your taste. In this example, #11A600 is green, #FFD966 is sort of yellow, and #BF0016 is red. Step 7 of 9 Set your map's default center point Set a default center point for your map using latitude and longitude. const defaultMapCenter = [10.5731, -7.5898]; Copy Step 8 of 9 Add a row for your map Between the text field row and the table chart row, insert a new row for the map content using NerdGraphQuery. <div className=\"row\"> <NerdGraphQuery query={this.mapData()}> {({ loading, error, data }) => { if (loading) { return <Spinner fillContainer />; } if (error) { return 'Error'; } const { results } = data.actor.account.mapData; console.debug(results); return 'Hello'; }} </NerdGraphQuery> </div>; Copy Reload your application in New Relic One to test that it works. Step 9 of 9 Replace \"Hello\" with the Leaflet code Replace return \"Hello\"; with: return ( <Map className=\"containerMap\" center={defaultMapCenter} zoom={2} zoomControl> <TileLayer attribution='&amp;copy <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\" /> {results.map((pt, i) => { const center = [pt.lat, pt.lng]; return ( <CircleMarker key={`circle-${i}`} center={center} color={this.getMarkerColor(pt.y)} radius={Math.log(pt.x) * 3} onClick={() => { alert(JSON.stringify(pt)); }} /> ); })} </Map> ); Copy This code creates a world map centered on the latitude and longitude you chose using OpenStreetMap data and your marker colors. Reload your app to see the pageview data on the map!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 327.52112,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Import additional modules from <em>New</em> <em>Relic</em> <em>One</em>",
        "info": "Build a <em>New</em> <em>Relic</em> app showing page view data on a world map.",
        "tags": "<em>nerdpack</em>",
        "body": " look like a series of interactive charts or a map of the world. <em>Nerdpack</em>: <em>New</em> <em>Relic</em>&#x27;s standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see <em>Nerdpack</em> <em>file</em> <em>structure</em>. <em>Launcher</em>: The button on <em>New</em> <em>Relic</em> <em>One</em>"
      },
      "id": "5efa993c196a67066b766469"
    },
    {
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps"
      ],
      "title": "Add tables to your New Relic One application",
      "type": "developer",
      "tags": [
        "table in app",
        "Table component",
        "TableHeaderc omponent",
        "TableHeaderCell component",
        "TableRow component",
        "TableRowCell component"
      ],
      "external_id": "7ff7a8426eb1758a08ec360835d9085fae829936",
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/",
      "published_at": "2020-09-29T01:47:51Z",
      "updated_at": "2020-09-17T01:48:42Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a table to your New Relic One app.",
      "body": "Add tables to your New Relic One application 30 min Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. git clone https://github.com/newrelic/nr1-how-to.git` cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet` Copy Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. nr1 nerdpack:uuid -gf # Update the app unique ID npm install # Install dependencies nr1 nerdpack:serve # Serve the demo app locally Copy Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the nerdlets/create-a-table-nerdlet subdirectory and open the index.js file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside of the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 297.97058,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add tables to your <em>New</em> <em>Relic</em> <em>One</em> application",
        "sections": "Add tables to your <em>New</em> <em>Relic</em> <em>One</em> application",
        "info": "Add a table to your <em>New</em> <em>Relic</em> <em>One</em> app.",
        "body": " application, you need to update its unique id by invoking the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. Once you&#x27;ve assigned a <em>new</em> UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. nr1 <em>nerdpack</em>:uuid -gf # Update the app unique ID npm install # Install"
      },
      "id": "5efa989ee7b9d2ad567bab51"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2020-09-29T01:52:56Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 294.18747,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common commands",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common commands",
        "info": "An overview of common commands you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": " update Updates to the latest version of the <em>CLI</em>. nr1 create Creates a <em>new</em> component from a template (<em>Nerdpack</em>, <em>Nerdlet</em>, <em>launcher</em>, or catalog). nr1 profiles Manages the profiles you use to run <em>CLI</em> commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    }
  ],
  "/build-apps/set-up-dev-env": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.86572,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference To build a <em>New</em> <em>Relic</em> <em>One</em> app, you must install the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (command line interface). This page explains how to use"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "category_2": "Enable log monitoring",
      "nodeid": 34686,
      "sections": [
        "Enable log management",
        "New Relic Logs",
        "Enable log monitoring",
        "Configure logs in context",
        "Logs in context for Go",
        "Logs in context for Java",
        "Logs in context for .NET",
        "Logs in context for Node.js",
        "Logs in context for PHP",
        "Logs in context for Python",
        "Logs in context for Ruby",
        "Logs in context with agent APIs",
        "Fluent Bit plugin for log forwarding",
        "Compatibility and requirements",
        "Enable Fluent Bit for log management",
        "Recommended usage",
        "Install the Fluent Bit plugin",
        "Configure the Fluent Bit plugin",
        "Test the Fluent Bit plugin",
        "Optional: Configure plugin attributes",
        "Plugin configuration",
        "View log data",
        "What's next?",
        "For more help"
      ],
      "title": "Fluent Bit plugin for log forwarding",
      "category_0": "Log management",
      "type": "docs",
      "category_1": "Enable log management",
      "external_id": "b32bba2a148de0353e819ce82c14d16acfcab068",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/enable-log-management-new-relic/enable-log-monitoring-new-relic/fluent-bit-plugin-log-forwarding",
      "published_at": "2020-09-27T21:53:23Z",
      "updated_at": "2020-09-27T21:53:23Z",
      "breadcrumb": "Contents / Log management / Enable log management / Enable log monitoring",
      "document_type": "page",
      "popularity": 1,
      "info": "A description of New Relic's Fluent Bit logging plugin, and how to install it and configure it. ",
      "body": "New Relic offers a Fluent Bit output plugin to connect your Fluent Bit monitored log data to New Relic. Read on to learn how to enable this feature. Compatibility and requirements To use New Relic Logs with Fluent Bit, ensure your configuration meets the following requirements: New Relic license key (recommended) or Insert API key Fluent Bit 0.12 or higher is supported; however, version 1.0 or higher is recommended. Enable Fluent Bit for log management To forward your logs to New Relic using Fluent Bit: Install the Fluent Bit plugin. Configure the Fluent Bit plugin. Test the Fluent Bit plugin. Generate some traffic and wait a few minutes, then check your account for data. Recommended usage We have published a container with the plugin installed. It serves as a base image to be used by our Kubernetes integration. We recommend you use this base image and layer your own custom configuration files. Install the Fluent Bit plugin To install the Fluent Bit plugin: Navigate to New Relic's Fluent Bit plugin repository on GitHub. From the repository page, clone or download the repository. Run the following command to build your plugin: cd newrelic-fluent-bit-output && make all Configure the Fluent Bit plugin Fluent Bit needs to know the location of the New Relic plugin and the New Relic license key (recommended) or Insert API key to output data to New Relic. To configure your Fluent Bit plugin: Pay attention to white space when editing your config files. Be sure to use four spaces to indent and one space between keys and values. Locate or create a plugins.conf file in your plugins directory. In the plugins.conf file, add a reference to out_newrelic.so, adjacent to your fluent-bit.conf file: [PLUGINS] Path /PATH/TO/newrelic-fluent-bit-output/out_newrelic.so In the fluent-bit.conf file, add the following line under the service block: [SERVICE] # This is the main configuration block for fluent bit. # Ensure the follow line exists somewhere in the SERVICE block Plugins_File plugins.conf At the bottom of the fluent-bit.conf file, add the following to set up the input and output filters. Replace the placeholder text with your New Relic license key (recommended) or Insert API key: [INPUT] Name tail Path /PATH/TO/YOUR/LOG/FILE [OUTPUT] Name newrelic Match * licenseKey YOUR_LICENSE_KEY # Optional maxBufferSize 256000 maxRecords 1024 Restart your Fluent Bit instance with the following command: fluent-bit -c /PATH/TO/fluent-bit.conf Test the Fluent Bit plugin To test if your Fluent Bit plugin is receiving input from a log file: Run the following command to append a test log message to your log file: echo \"test message\" >> /PATH/TO/YOUR/LOG/FILE Search New Relic Logs UI for test message. Optional: Configure plugin attributes Plugin configuration Once you have installed and configured the Fluent Bit plugin, you can use the following attributes to configure how the plugin sends data to New Relic: Key Description licenseKey The New Relic license key. Use either licenseKey (recommended) or apiKey, not both. Default: none maxBufferSize The maximum size the payloads sent, in bytes. Default: 256000 maxRecords The maximum number of records to send at a time. Default: 1024 apiKey New Relic's Insert API key. Use either licenseKey (recommended) or apiKey, not both. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log What's next? Now that you've enabled Logs, here are some potential next steps: Explore your data using the Logs UI. Configure your agent to see contextual log data, such as distributed tracing, stack traces, application logs, and more. Query your data and create custom dashboards or alerts. If no data appears after you enable New Relic Logs, follow the troubleshooting procedures. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.65463,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> Logs",
        "info": "A description of <em>New</em> <em>Relic&#x27;s</em> Fluent Bit logging plugin, and how to install it and configure it. ",
        "body": " <em>key</em> (recommended) or Insert <em>API</em> <em>key</em> Fluent Bit 0.12 or higher is supported; however, version 1.0 or higher is recommended. Enable Fluent Bit for log management To forward your logs to <em>New</em> <em>Relic</em> using Fluent Bit: Install the Fluent Bit plugin. Configure the Fluent Bit plugin. Test the Fluent Bit plugin"
      },
      "id": "5f375ef4196a6743b655e634"
    },
    {
      "category_2": "Enable log monitoring",
      "nodeid": 35821,
      "sections": [
        "Enable log management",
        "New Relic Logs",
        "Enable log monitoring",
        "Configure logs in context",
        "Logs in context for Go",
        "Logs in context for Java",
        "Logs in context for .NET",
        "Logs in context for Node.js",
        "Logs in context for PHP",
        "Logs in context for Python",
        "Logs in context for Ruby",
        "Logs in context with agent APIs",
        "AWS FireLens plugin for log forwarding",
        "Requirements",
        "Enable FireLens for log management",
        "Configure the FireLens log router container",
        "Configure the application container",
        "AWS Secrets Manager (recommended)",
        "Plaintext Key Configuration",
        "Example configuration",
        "Sending logs to an EU New Relic account",
        "View log data",
        "What's next?",
        "For more help"
      ],
      "title": "AWS FireLens plugin for log forwarding",
      "category_0": "Log management",
      "type": "docs",
      "category_1": "Enable log management",
      "external_id": "7e456f495efb447881c7d13687725344c2f367fc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/enable-log-management-new-relic/enable-log-monitoring-new-relic/aws-firelens-plugin-log-forwarding",
      "published_at": "2020-09-28T00:12:17Z",
      "updated_at": "2020-09-28T00:12:17Z",
      "breadcrumb": "Contents / Log management / Enable log management / Enable log monitoring",
      "document_type": "page",
      "popularity": 1,
      "info": "A description of New Relic's FireLens logging plugin, and how to install it and configure it. ",
      "body": "Use our AWS FireLens integration is built on our Fluentbit output plugin to connect your FireLens monitored log data to New Relic. Read on to learn how to enable this feature. Requirements To forward logs to New Relic using FireLens, ensure your configuration meets the following requirements: New Relic Insert API key Amazon EC2 Container Service (ECS) cluster Enable FireLens for log management To enable log management with FireLens: Configure the FireLens log router container to run as a sidecar. Configure the Application container. Generate some traffic and wait a few minutes, then check your account for data. Configure the FireLens log router container New Relic uses a Fluent Bit image to configure the FireLens Log Router container. This container handles all log routing from application plugins. To enable FireLens with Logs, you need to add a sidecar container to your pre-existing ECS task definition that will act as the Firelens log router. For help configuring ECS log routing, see Custom Log Routing, substituting the recommended images with the New Relic Fluentbit Output plugin image for your AWS region. AWS Region Full Image Name us-east-1 533243300146.dkr.ecr.us-east-1.amazonaws.com/newrelic/logging-firelens-fluentbit us-east-2 533243300146.dkr.ecr.us-east-2.amazonaws.com/newrelic/logging-firelens-fluentbit us-west-1 533243300146.dkr.ecr.us-west-1.amazonaws.com/newrelic/logging-firelens-fluentbit us-west-2 533243300146.dkr.ecr.us-west-2.amazonaws.com/newrelic/logging-firelens-fluentbit ca-central-1 533243300146.dkr.ecr.ca-central-1.amazonaws.com/newrelic/logging-firelens-fluentbit eu-central-1 533243300146.dkr.ecr.eu-central-1.amazonaws.com/newrelic/logging-firelens-fluentbit eu-west-1 533243300146.dkr.ecr.eu-west-1.amazonaws.com/newrelic/logging-firelens-fluentbit eu-west-2 533243300146.dkr.ecr.eu-west-2.amazonaws.com/newrelic/logging-firelens-fluentbit eu-west-3 533243300146.dkr.ecr.eu-west-3.amazonaws.com/newrelic/logging-firelens-fluentbit eu-north-1 533243300146.dkr.ecr.eu-north-1.amazonaws.com/newrelic/logging-firelens-fluentbit For example: { \"essential\": true, // Image below is New Relic's fluentbit output plugin available on ECR \"image\": \"533243300146.dkr.ecr.us-east-2.amazonaws.com/newrelic/logging-firelens-fluentbit\", \"name\": \"log_router\", \"firelensConfiguration\": { \"type\": \"fluentbit\", \"options\": { \"enable-ecs-log-metadata\": \"true\" } } } Note: EC2-type clusters will require setting the \"memoryReservation\" attribute for this container as well Configure the application container AWS Secrets Manager (recommended) To prevent exposing your Insights Insert key in your task definition, we strongly recommend using the AWS Secrets Manager service. When adding the secret, use the Plaintext tab. Once you've added the secret to the Secrets Manager, you can then reference it using the logConfiguration block suggested below, replacing SECRET_NAME with the name of your AWS secret. \"logConfiguration\": { \"logDriver\":\"awsfirelens\", \"options\": { \"Name\": \"newrelic\" }, \"secretOptions\": [{ \"name\": \"apiKey\", \"valueFrom\": \"arn:aws:secretsmanager:region:aws_account_id:secret:SECRET_NAME\" }] } Plaintext Key Configuration During configuration, outlined in FireLens Task Definitions, use the logConfiguration block suggested below, replacing INSERT_API_KEY with your New Relic Insert API key. \"logConfiguration\": { \"logDriver\":\"awsfirelens\", \"options\": { \"Name\": \"newrelic\", \"apiKey\": \"INSERT_API_KEY\" } Example configuration Example Task Definition configuration (Fargate) Example Task Definition for a basic nginx server: { \"family\": \"newrelic-firelens\", \"networkMode\": \"awsvpc\", \"requiresCompatibilities\": [ \"FARGATE\" ], \"containerDefinitions\": [ // FireLens log router container { \"essential\": true, // Image below is New Relic's fluentbit output plugin available on ECR \"image\": \"533243300146.dkr.ecr.us-east-2.amazonaws.com/newrelic/logging-firelens-fluentbit\", \"name\": \"log_router\", \"firelensConfiguration\": { \"type\": \"fluentbit\", \"options\": { \"enable-ecs-log-metadata\": \"true\" } } }, // Application container { \"essential\": true, \"name\": \"webserver\", // Application image goes here \"image\": \"nginx\", \"cpu\": 512, \"memoryReservation\": 1024, \"portMappings\": [{ \"containerPort\": 5000 }], \"environment\": [{ \"name\": \"VERSION\", \"value\": \"V1\" }], // New Relic Fluentbit Output configuration \"logConfiguration\": { \"logDriver\":\"awsfirelens\", \"options\": { \"Name\": \"newrelic\" }, \"secretOptions\": [{ \"name\": \"apiKey\", \"valueFrom\": \"arn:aws:secretsmanager:region:aws_account_id:secret:secret_name-AbCdEf\" }] } } ], // Use your own role here \"executionRoleArn\": \"arn:aws:iam::XXXXXXXXXXXX:role/ecsTaskExecutionRole\", \"taskRoleArn\": \"arn:aws:iam::XXXXXXXXXXXX:role/ecsTaskExecutionRole\", \"cpu\": \"1 vcpu\", \"memory\": \"2 gb\" } Example Task Definition configuration (EC2) Example Task Definition for a basic nginx server: { \"family\": \"newrelic-firelens\", \"networkMode\": \"bridge\", \"requiresCompatibilities\": [ \"EC2\" ], \"containerDefinitions\": [ // FireLens log router container { \"essential\": true, // Image below is New Relic's fluentbit output plugin available on ECR \"image\": \"533243300146.dkr.ecr.us-east-2.amazonaws.com/newrelic/logging-firelens-fluentbit\", \"name\": \"log_router\", \"memoryReservation\": 50, \"firelensConfiguration\": { \"type\": \"fluentbit\", \"options\": { \"enable-ecs-log-metadata\": \"true\" } } }, // Application container { \"essential\": true, \"name\": \"webserver\", // Application image goes here \"image\": \"nginx\", \"cpu\": 512, \"memoryReservation\": 1024, \"portMappings\": [{ \"containerPort\": 5000 }], \"environment\": [{ \"name\": \"VERSION\", \"value\": \"V1\" }], // New Relic Fluentbit Output configuration \"logConfiguration\": { \"logDriver\":\"awsfirelens\", \"options\": { \"Name\": \"newrelic\" }, \"secretOptions\": [{ \"name\": \"apiKey\", \"valueFrom\": \"arn:aws:secretsmanager:region:aws_account_id:secret:secret_name-AbCdEf\" }] } } ], // Use your own role here \"executionRoleArn\": \"arn:aws:iam::XXXXXXXXXXXX:role/ecsTaskExecutionRole\", \"taskRoleArn\": \"arn:aws:iam::XXXXXXXXXXXX:role/ecsTaskExecutionRole\", \"cpu\": \"1 vcpu\", \"memory\": \"2 gb\" } Sending logs to an EU New Relic account If you want to send logs from Firelens to an EU account then you need to add an additional property to the options field of the logConfiguration object in your application containers. \"endpoint\": \"https://log-api.eu.newrelic.com/log/v1\" View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log What's next? Now that you've enabled Logs, here are some potential next steps: Explore your data using the Logs UI. Configure your agent to see contextual log data, such as distributed tracing, stack traces, application logs, and more. Query your data and create custom dashboards or alerts. If no data appears after you enable log management, follow the troubleshooting procedures. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.50073,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Sending logs to an EU <em>New</em> <em>Relic</em> <em>account</em>",
        "info": "A description of <em>New</em> <em>Relic&#x27;s</em> FireLens logging plugin, and how to install it and configure it. ",
        "body": " INSERT_<em>API_KEY</em> with your <em>New</em> <em>Relic</em> Insert <em>API</em> <em>key</em>. &quot;logConfiguration&quot;: { &quot;logDriver&quot;:&quot;awsfirelens&quot;, &quot;options&quot;: { &quot;Name&quot;: &quot;newrelic&quot;, &quot;<em>apiKey</em>&quot;: &quot;INSERT_<em>API_KEY</em>&quot; } Example configuration Example Task Definition configuration (Fargate) Example Task Definition for a basic nginx server: { &quot;family&quot;: &quot;newrelic"
      },
      "id": "5f377f4928ccbc2b3ee2406d"
    },
    {
      "category_2": "Enable log monitoring",
      "nodeid": 34846,
      "sections": [
        "Enable log management",
        "New Relic Logs",
        "Enable log monitoring",
        "Configure logs in context",
        "Logs in context for Go",
        "Logs in context for Java",
        "Logs in context for .NET",
        "Logs in context for Node.js",
        "Logs in context for PHP",
        "Logs in context for Python",
        "Logs in context for Ruby",
        "Logs in context with agent APIs",
        "Fluentd plugin for log forwarding",
        "Compatibility and requirements",
        "Enable Fluentd for New Relic log management",
        "Install the Fluentd plugin",
        "Configure the Fluentd plugin",
        "Test the Fluentd plugin",
        "Optional configuration",
        "View log data",
        "What's next?",
        "For more help"
      ],
      "title": "Fluentd plugin for log forwarding",
      "category_0": "Log management",
      "type": "docs",
      "category_1": "Enable log management",
      "external_id": "c61c675a9e5a02c4f157cba5847c1b7dd936f0c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/enable-log-management-new-relic/enable-log-monitoring-new-relic/fluentd-plugin-log-forwarding",
      "published_at": "2020-09-27T20:54:51Z",
      "updated_at": "2020-09-27T20:54:51Z",
      "breadcrumb": "Contents / Log management / Enable log management / Enable log monitoring",
      "document_type": "page",
      "popularity": 1,
      "info": "A description of New Relic's Fluentd logging plugin, and how to install it and configure it. ",
      "body": "New Relic offers a Fluentd output plugin to connect your Fluentd monitored log data to New Relic. Read on to learn how to enable this feature. Compatibility and requirements To forward logs to New Relic using Fluentd, ensure your configuration meets the following requirements: Insert API key (recommended) or New Relic license key Fluentd 1.0 or higher Enable Fluentd for New Relic log management To enable log management with Fluentd: Install the Fluentd plugin. Configure the Fluentd plugin. Test the Fluentd plugin. Optional: Configure additional plugin attributes. Generate some traffic and wait a few minutes, then check your account for data. Install the Fluentd plugin To install the Fluentd plugin: Install using fluent-gem install To install using fluent-gem install, enter the following command into your terminal or command line interface: fluent-gem install fluent-plugin-newrelic Install using td-agent-gem To install using the td-agent plugin, enter the following command into your terminal or command line interface: td-agent-gem install fluent-plugin-newrelic Configure the Fluentd plugin NOTE: If you're configuring Fluentd for the first time, you may find it helpful to review our collection of pre-built configuration files addressing common use cases. To configure your Fluentd plugin: In your fluent.conf file, or td-agent.conf if using the td-agent, add the following block of data, replacing the placeholder text with your Insert API key ​(recommended) or New Relic license key. Configure with the New Relic Insert API key (recommended) Configure with the New Relic Insert API key: #Tail one or more log files <source> @type tail <parse> @type none </parse> path /path/to/file tag example.service </source> #Add hostname and service_name to all events with \"example.service\" tag <filter example.service> @type record_transformer <record> service_name ${tag} hostname \"#{Socket.gethostname}\" </record> </filter> #Forward all events to New Relic <match **> @type newrelic api_key YOUR_API_INSERT_KEY </match> Configure with the New Relic license key Configure with the New Relic license key: #Tail one or more log files <source> @type tail <parse> @type none </parse> path /path/to/file tag example.service </source> #Add hostname and service_name to all events with \"example.service\" tag <filter example.service> @type record_transformer <record> service_name ${tag} hostname \"#{Socket.gethostname}\" </record> </filter> #Forward all events to New Relic <match **> @type newrelic license_key YOUR_LICENSE_KEY </match> Restart the Fluentd service to ensure your changes are applied. Test the Fluentd plugin To test if your Fluentd plugin is receiving input from a log file: Run the following command to append a test log message to your log file: echo \"test message\" >> /PATH/TO/YOUR/LOG/FILE Search New Relic Logs UI for test message. Optional configuration Once you have installed and configured the Fluentd plugin, you can use the following attributes to configure how the plugin sends data to New Relic: Property Description Default value base_uri The New Relic ingestion endpoint. US endpoint: https://log-api.newrelic.com/log/v1 EU endpoint: https://log-api.eu.newrelic.com/log/v1 For more information and examples, see Example Configurations for Fluentd. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log What's next? Now that you've enabled Logs, here are some potential next steps: Explore your data using the Logs UI. Configure your agent to see contextual log data, such as distributed tracing, stack traces, application logs, and more. Query your data and create custom dashboards or alerts. If no data appears after you enable New Relic Logs, follow the troubleshooting procedures. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.28697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> Logs",
        "info": "A description of <em>New</em> <em>Relic&#x27;s</em> Fluentd logging plugin, and how to install it and configure it. ",
        "body": " <em>key</em>. Configure with the <em>New</em> <em>Relic</em> Insert <em>API</em> <em>key</em> (recommended) Configure with the <em>New</em> <em>Relic</em> Insert <em>API</em> <em>key</em>: #Tail <em>one</em> or more log files &lt;source&gt; @type tail &lt;parse&gt; @type none &lt;&#x2F;parse&gt; path &#x2F;path&#x2F;to&#x2F;file tag example.service &lt;&#x2F;source&gt; #Add hostname and service_name to all events with &quot;example.service"
      },
      "id": "5f375ef4196a67903d55e5f0"
    },
    {
      "category_2": "Enable log monitoring",
      "nodeid": 32921,
      "sections": [
        "Enable log management",
        "New Relic Logs",
        "Enable log monitoring",
        "Configure logs in context",
        "Logs in context for Go",
        "Logs in context for Java",
        "Logs in context for .NET",
        "Logs in context for Node.js",
        "Logs in context for PHP",
        "Logs in context for Python",
        "Logs in context for Ruby",
        "Logs in context with agent APIs",
        "Logstash plugin for log forwarding",
        "Compatibility and requirements",
        "Enable Logstash for log management",
        "Install the Logstash plugin",
        "Configure the Logstash plugin",
        "Optional configuration",
        "Test the Logstash plugin",
        "View log data",
        "What's next?",
        "For more help"
      ],
      "title": "Logstash plugin for log forwarding",
      "category_0": "Log management",
      "type": "docs",
      "category_1": "Enable log management",
      "external_id": "3f891ac13f600467b6ee772851a1f6ec430dbffe",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/enable-log-management-new-relic/enable-log-monitoring-new-relic/logstash-plugin-log-forwarding",
      "published_at": "2020-09-27T20:37:23Z",
      "updated_at": "2020-09-27T20:37:23Z",
      "breadcrumb": "Contents / Log management / Enable log management / Enable log monitoring",
      "document_type": "page",
      "popularity": 1,
      "info": "A description of New Relic's Logstash logging plugin, and how to install it and configure it. ",
      "body": "Use our Logstash output plugin to connect your Logstash monitored log data to New Relic. Read on to learn how to enable this feature. Compatibility and requirements To forward your logs to New Relic using Logstash, ensure your configuration meets the following requirements: New Relic license key (recommended) or Insert API key Logstash 6.6 or higher Logstash requires Java 8 or Java 11. Use the official Oracle distribution or an open-source distribution such as OpenJDK. Enable Logstash for log management To enable log management using Logstash: Install the Logstash plugin. Configure the Logstash plugin. Optional: Configure additional plugin attributes. Test the Logstash plugin. Generate some traffic and wait a few minutes, then check your account for data. Install the Logstash plugin To install the Logstash plugin, enter the following command into your terminal or command line interface: logstash-plugin install logstash-output-newrelic Configure the Logstash plugin To configure your Logstash plugin: In your logstash.conf file, add the following block of data. Be sure to replace the placeholder text with your New Relic license key or Insights Insert key. Configure with the New Relic license key (recommended): output { newrelic { license_key => \"LICENSE_KEY\" } } Or, configure with the New Relic Insert API key: output { newrelic { api_key => \"INSERT_API_KEY\" } } Restart your Logstash instance. Optional configuration Once you have installed and configured the Logstash plugin, you can use the following attributes to configure how the plugin sends data to New Relic: Property Description Default value concurrent_requests The number of threads to make requests from. 1 base_uri The New Relic ingestion endpoint. US endpoint: https://log-api.newrelic.com/log/v1 EU endpoint: https://log-api.eu.newrelic.com/log/v1 For more information on adding or configuring attributes, see Example Configurations for Logstash. Test the Logstash plugin To test if your Logstash plugin is receiving input from a log file: Add the following to your logstash.conf file: input { file { path => \"/PATH/TO/YOUR/LOG/FILE\" } } Restart your Logstash instance. Run the following command to append a test log message to your log file: echo \"test message\" >> /PATH/TO/YOUR/LOG/FILE Search New Relic Logs UI for test message. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log What's next? Now that you've enabled Logs, here are some potential next steps: Explore your data using the Logs UI. Configure your agent to see contextual log data, such as distributed tracing, stack traces, application logs, and more. Query your data and create custom dashboards or alerts. If no data appears after you enable New Relic Logs, follow the troubleshooting procedures. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.50021,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> Logs",
        "info": "A description of <em>New</em> <em>Relic&#x27;s</em> Logstash logging plugin, and how to install it and configure it. ",
        "body": " license <em>key</em> (recommended): output { newrelic { license_<em>key</em> =&gt; &quot;LICENSE_<em>KEY</em>&quot; } } Or, configure with the <em>New</em> <em>Relic</em> Insert <em>API</em> <em>key</em>: output { newrelic { <em>api_key</em> =&gt; &quot;INSERT_<em>API_KEY</em>&quot; } } Restart your Logstash instance. Optional configuration Once you have installed and configured the Logstash plugin, you"
      },
      "id": "5f375e9c28ccbccd42e2408b"
    }
  ],
  "/automate-workflows/get-started-terraform": [
    {
      "category_2": "Measure DevOps success",
      "nodeid": 16501,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Incident orchestration: Align teams, tools, processes",
        "Prerequisites",
        "1. Assign first responders to team dashboards",
        "2. Determine incident thresholds for alert conditions",
        "3. Ensure alerts have auditable notification channels",
        "4. Automate triage and resolution steps",
        "For more help"
      ],
      "title": "Incident orchestration: Align teams, tools, processes",
      "category_0": "New Relic solutions",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "0bec265edc6b4792a80c5a5810e624d5545fbc4e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/incident-orchestration-align-teams-tools-processes",
      "published_at": "2020-09-29T01:59:44Z",
      "updated_at": "2020-09-28T00:43:51Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "Incident orchestration is the alignment of teams, tools, and processes to prepare for incidents and outages in your software. ",
      "body": "Incident orchestration is the alignment of teams, tools, and processes to prepare for incidents and outages in your software. The goal is to provide your teams a predictable framework and process to: Maximize efficiency in communication and effort. Minimize the overall impact to your business. Prerequisites Before starting this tutorial, be sure to complete these New Relic tutorials: Establish team dashboards Set up proactive alerting 1. Assign first responders to team dashboards Recommendation: For each team dashboard, make sure: It has an owner who assumes responsibility for the health of the applications and features it monitors. There is no ambiguity about who is responsible for attending to and resolving an alert condition. This policy will vary between organizations depending on size, structure, and culture. For example, some teams may prefer to assign dashboards and alerts based on de-facto features or application ownership. Other teams may prefer to adopt an on-call rotation (often referred to as \"pager duty\"). In on-call rotations, designated team members handle all first-line incident responses, and they resolve or delegate responsibilities based on predetermined incident thresholds. 2. Determine incident thresholds for alert conditions For each of your applications: Identify the thresholds for what is officially considered an incident. As you create alert policies with New Relic Alerts, make sure each set of threshold criteria is context-dependent. Document incident evaluation and known remediation procedures in runbooks. Include links to your runbooks when you define conditions and thresholds for your alert policies. For instance, a certain alert condition may be dismissable during low-traffic periods but require active remediation during peak hours. 3. Ensure alerts have auditable notification channels Recommendation: Make sure that communications during critical incidents take place in easily accessible and highly visible channels. A group chat room dedicated to incident communication is usually a great choice. This allows all stakeholders to participate or observe and provides a chronology of notifications, key decisions, and actions for postmortem analysis. Use any of the available notification channels in New Relic Alerts. For example, to set up a notification channel in Slack: Make sure your organization has completed New Relic's integration requirements with Slack. In the Slack app, select the dropdown in the top-left corner of the app, and select Customize Slack. Click Configure apps. From the list of app integrations, select New Relic. Expand the instructions for New Relic Alerts, and follow the steps to configure notifications from New Relic. 4. Automate triage and resolution steps Automation of simple or repeatable incident response tasks will increase efficiency and minimize the impact of incidents. With proper automation in place, you can disable or isolate faulty application components as soon as an alert threshold is reached, rather than after a notification has been issued. For example, a team managing an application for a digital media company wants to be able to remove commenting abilities from the website if the system has errors. In this case, they could: Add an endpoint to their front-end web application that will toggle a feature flag enabling or disabling the UI components associated with posting comments on an article. Create an alert policy with a threshold set on the sustained error rate in the commenting service. Assign a webhook notification channel that will send a POST request to this endpoint, as well as to the standard team notification channels. In this scenario, errors in the commenting system will trigger the webhook and remove the commenting UI from the website. Users can still use core functionality of the site without seeing errors generated by the commenting service. The application will maintain a stable but degraded state, allowing the team to focus on recovery without the pressure of preventing users from accessing the site. You can also use webhooks to create issues and action items in ticketing systems that have REST APIs, such as Zendesk. Use New Relic Alerts to create a webhook notification channel, and customize the webhook payload as needed. New Relic also provides integrations for some common ticketing systems. You can use any of the available integrations to file tickets from New Relic APM. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.34258,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "3. Ensure alerts have auditable <em>notification</em> <em>channels</em>",
        "body": " to participate or observe and provides a chronology of notifications, key decisions, and actions for postmortem analysis. Use any of the available <em>notification</em> channels in New Relic Alerts. For example, to set up a <em>notification</em> <em>channel</em> in Slack: Make sure your organization has completed New Relic"
      },
      "id": "5f5b2113e7b9d2249dacfd34"
    },
    {
      "category_2": "Optimize your cloud native environment",
      "nodeid": 32791,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Set proactive alerts and align teams, tools, and processes for incident response",
        "Prerequisites",
        "1. Define policies",
        "2. Set specific alerts",
        "3. Identify groups",
        "4. Determine thresholds",
        "5. Set notification channels",
        "6. Automate resolution",
        "7. Establish reviews",
        "8. Fine-tune process",
        "Expert tip",
        "For more help"
      ],
      "title": "Set proactive alerts and align teams, tools, and processes for incident response ",
      "category_0": "New Relic solutions",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "6040cb4f86b1533eb31ac0e71e58709d77f79b50",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/proactive-baseline-alerts-devops_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/set-proactive-alerts-align-teams-tools-processes-incident-response",
      "published_at": "2020-09-27T20:35:02Z",
      "updated_at": "2020-09-27T20:35:02Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Optimize your cloud native environment",
      "document_type": "page",
      "popularity": 1,
      "info": "Using New Relic's proactive alerting, you can spend less time firefighting and more time deploying significant changes to your product.",
      "body": "The term alerting often carries some negative connotations: many developers correlate alerting with errors, mistakes, and ongoing issues. However, developers who are proactive about alerting, know they don't have to stare at dashboards all day because effective alerts tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Further, a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or environment. With proactive alerting, you'll decrease user-reported incidents, and your teams will spend less time firefighting and more time deploying significant changes to your product. After you define the right alerts, proper incident orchestration aligns your teams, tools, and processes to prepare for incidents and outages in your software. The goal is to provide your teams a predictable framework and process to: Maximize efficiency in communication and effort. Minimize the overall impact to your business. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the Establish objectives and baselines tutorial. Optionally added custom attributes and events. 1. Define policies Define required alerting policies based on SLOs. A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples of service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, 95% of requests completed within 250 ms AND availability is 99.99%), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it's meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than 0.20%. However, not every SLO needs to become an alert. A strong alerting strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alerting strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” Example questions and KPI solutions For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? New Relic Browser and New Relic APM can be used to alert on site availability. How's our underlying infrastructure? Set KPIs for key hardware, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (Browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie them to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site's availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don't yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds You can set this same kind of alert in Browser to catch sub-optimal performance. In the following example, we've set both a warning and a violation for throughput: alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier, which can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic across five different servers. You can set an alert based on a NRQL query and receive a notification if any server starts getting significantly more or less traffic than the other servers. Here is an example chart: And here's a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups Identify groups to alert, set broadcasting methods, and assign first responders to team dashboards Alerting without the proper broadcasting methods leaves you vulnerable. Your alerting strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack or PagerDuty). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the types of alerts that warrant waking someone up. Recommendation: For each team dashboard, make sure: It has an owner who assumes responsibility for the health of the applications and features it monitors. There is no ambiguity about who is responsible for attending to and resolving an alert condition. This policy will vary between organizations depending on size, structure, and culture. For example, some teams may prefer to assign dashboards and alerts based on de-facto features or application ownership. Other teams may prefer to adopt an on-call rotation (often referred to as pager duty). In on-call rotations, designated team members handle all first-line incident responses, and they resolve or delegate responsibilities based on predetermined incident thresholds. 4. Determine thresholds Determine incident thresholds for alert conditions For each of your applications: Identify the thresholds for what is officially considered an incident. Make sure each set of threshold criteria is context-dependent. Document incident evaluation and known remediation procedures in runbooks. Include links to your runbooks when you define conditions and thresholds for your alert policies. For instance, a certain alert condition may be dismissable during low-traffic periods but require active remediation during peak hours. 5. Set notification channels Ensure alerts have auditable notification channels Make sure that communications during critical incidents take place in easily accessible and highly visible channels. A group chat room dedicated to incident communication is usually a great choice. This allows all stakeholders to participate or observe and provides a chronology of notifications, key decisions, and actions for postmortem analysis. Use any of the available notification channels in New Relic Alerts. For example, to set up a notification channel in Slack: Make sure your organization has completed New Relic's integration requirements with Slack. In the Slack app, select the dropdown in the top-left corner of the app, and select Customize Slack. Click Configure apps. From the list of app integrations, select New Relic. Expand the instructions for New Relic Alerts, and follow the steps to configure notifications from New Relic. 6. Automate resolution Automate triage and resolution steps Automation of simple or repeatable incident response tasks will increase efficiency and minimize the impact of incidents. With proper automation in place, you can disable or isolate faulty application components as soon as an alert threshold is reached, rather than after a notification has been issued. For example, a team managing an application for a digital media company wants to be able to remove commenting abilities from the website if the system has errors. In this case, they could: Add an endpoint to their front-end web application that will toggle a feature flag enabling or disabling the UI components associated with posting comments on an article. Create an alert policy with a threshold set on the sustained error rate in the commenting service. Assign a webhook notification channel that will send a POST request to this endpoint, as well as to the standard team notification channels. In this scenario, errors in the commenting system will trigger the webhook and remove the commenting UI from the website. Users can still use core functionality of the site without seeing errors generated by the commenting service. The application will maintain a stable but degraded state, allowing the team to focus on recovery without the pressure of preventing users from accessing the site. You can also use webhooks to create issues and action items in ticketing systems that have REST APIs, such as Zendesk. Use New Relic Alerts to create a webhook notification channel, and customize the webhook payload as needed. New Relic also provides integrations for common ticketing systems. You can use any of these integrations to file tickets from New Relic APM. 7. Establish reviews Establish a post mortem process After the incident has been resolved, key stakeholders and participants must capture accurate and thorough documentation of the incident. At a minimum, we recommend that the retro documentation includes: A root cause analysis A chronology and summary of remediation steps and their result, whether they were successful or not A measure of the impact to the business in terms of user experience and financial losses, if possible Recommendations for system or feature improvements to prevent a recurrence Recommendations for process and communication improvements Store post mortem reports in a highly visible, searchable repository, such as a shared drive folder or wiki. Culturally, it's essential that this process focuses on constructive learning and improvement rather than punishment or blame. Example post mortem report Here is a brief example of a post mortem report: Post mortem Comments Date March 1, 2018 Executive summary From approximately 1:45PM until 2:30PM, users could not add items to their carts, which prevented any checkouts from occurring during the incident period. Root cause We determined that a change was made to the CSS rules on the product detail page that effectively disabled the Add to cart button. Timeline 1:50PM: Successful checkouts < 10 for 5 minutes alert triggered; assigned to Alice. 1:55PM: After reviewing the ecommerce team dashboard, Alice determined that the threshold was breached immediately following a deploy by Bob. She notified him of the incident. 2:00PM: Alice and Bob began troubleshooting. Attempts at recreating the issue in production were successful. 2:20PM: Bob determined that his change to the CSS on the product detail page disabled the Add to cart button. He deployed a hotfix. 2:30PM: Functionality was restored and the incident was resolved. Impact No checkouts were completed during the duration of the incident. Our typical revenue for a Thursday during this timeframe is $30,000. Recommendations We have been discussing implementing New Relic Synthetics for awhile now. If we had a Synthetic check on the checkout process, this issue would have been detected immediately. We should also implement more thorough unit tests in the front-end web app. 8. Fine-tune process Fine-tune alerts and thresholds As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. When rolling out new code or modifications that could negatively impact performance over a period of time, loosen your threshold conditions to allow for these short-term changes. For instance, we recommend using pre-established baselines and thresholds to increase efficiency during high-impact times for your business, such as annual events and major releases. Fine-tuning gives you the flexibility you need to increase efficiencies and extend your notification channels. As noted earlier, we recommend you start with a group chat service when you first establish notifications. Once you've identified other tools you'd like to integrate with, set up a notification channel to maintain your momentum. Tools such as xMatters and PagerDuty provide popular integrations, but don't overlook simple methods, such as webhooks. The goal is to continuously improve your alerting scheme. Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use the New Relic query language and the Insights query API to create your dashboards. For detailed instructions, check out Sending alerts data to Insights. The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you're using. Expert tip In addition to instrumenting and measuring application and infrastructure metrics, mature DevOps organizations often measure and optimize the efficiency of incident response processes. For example, you can use webhooks to send alert events to New Relic Insights. This allows you to supplement your team dashboards with New Relic Alerts data. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.931465,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "5. Set <em>notification</em> <em>channels</em>",
        "body": " acceptable levels, as defined by your SLOs. You can set warning thresholds to <em>monitor</em> issues that may be approaching a critical severity but don&#x27;t yet warrant a pager <em>notification</em>. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create"
      },
      "id": "5f5ac17764441ff9d5e067ec"
    },
    {
      "category_2": "Rules, limits, and glossary",
      "nodeid": 8421,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Rules and limits for alerts",
        "Permission levels",
        "Limits",
        "For more help"
      ],
      "title": "Rules and limits for alerts",
      "category_0": "Alerts and Applied intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "901afbed24b00ad4bc060e0f1fb57dff969bdd67",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/rules-limits-glossary/rules-limits-alerts",
      "published_at": "2020-09-27T14:48:05Z",
      "updated_at": "2020-09-27T14:48:04Z",
      "breadcrumb": "Contents / Alerts and Applied intelligence / New Relic Alerts / Rules, limits, and glossary",
      "document_type": "page",
      "popularity": 1,
      "info": "Read about assorted technical rules and min/max limits for alerts functionality.  ",
      "body": "This document contains some technical rules and limits for alerts. Permission levels Permissions differ depending on whether you're on our original product-based pricing plan or our New Relic One pricing plan: New Relic One pricing plan See Users and roles. Original pricing plan For accounts on our original product-based pricing plan, the user role determines the Alerts features available: Owner and Admins can add, change, disable, and delete alert policies, conditions, and channels. Users and Restricted Users can only view alert policies and conditions and their settings. Any user role can acknowledge an incident or close a violation. Limits Sub-accounts do not inherit a master account's alert policies. You must create policies separately for all accounts and sub-accounts. The following rules apply both to the New Relic One user interface and to the REST API (v2). New Relic Alerts Minimum value Maximum value Alert policies: Alert policy name 1 character 64 characters Policies per account n/a 10000 policies Products per policy any New Relic product (APM, Mobile, Synthetics, etc.) any New Relic product Alert conditions: Condition name 1 character 64 characters Conditions per policy 0 conditions 500 conditions Infrastructure alert conditions 0 conditions 3700 conditions NRQL query conditions OR Web app response percentiles per account 0 conditions 4000 conditions Targets (product entities) per condition 1 target 1000 targets from 1 or more products Thresholds per condition 0 Warnings, 1 Critical 1 Warning, 1 Critical Alert violations: Duration for condition violation 5 minutes Exception: 1 minute for at least once conditions, because the violation could occur during the first minute (or any minute). 2 hours Violations per incident 1 violation 10,000 violations Violations beyond this limit will not be persisted. Violation Search API - Page Size 1 page (less than or equal to 25 violations) 1000 pages (25K violations) Only use the only-open parameter to retrieve all open violations. If you have more than 25K open violations and need to retrieve them via the REST API, please contact New Relic Support. Notification channels: Notification channel name 1 character 64 characters Channels per account n/a 1000 channels per type Exception: No limits for user channels Channel limitations Depends on channel Depends on channel For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.549515,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Alert <em>notifications</em>",
        "body": ", please contact New Relic Support. <em>Notification</em> channels: <em>Notification</em> <em>channel</em> name 1 character 64 characters Channels per account n&#x2F;a 1000 channels per type Exception: No limits for user channels <em>Channel</em> limitations Depends on <em>channel</em> Depends on <em>channel</em> For more help If you need more help, check out"
      },
      "id": "5f34470b28ccbc19cb88dfc3"
    },
    {
      "category_2": "Measure DevOps success",
      "nodeid": 16431,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Set proactive alerting: understand and respond to performance issues",
        "Prerequisites",
        "1. Define required alerting policies based on Service Level Objectives",
        "2. Set specific alerts for performance, correctness, throughput, availability, and dependencies",
        "3. Identify groups to alert, and set broadcasting methods",
        "4. Fine-tune alerts and thresholds",
        "Conclusion",
        "For more help"
      ],
      "title": "Set proactive alerting: understand and respond to performance issues",
      "category_0": "New Relic solutions",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "ed965f151768836bb0ddd956e2fd1288df6e9ddc",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/proactive-baseline-alerts-devops_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/set-proactive-alerting-understand-respond-performance-issues",
      "published_at": "2020-09-27T22:58:23Z",
      "updated_at": "2020-09-27T22:58:23Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "Set well-defined alerts to help you understand the health of your systems, so you can respond to performance problems before they affect your customers.",
      "body": "The term \"alerting\" often carries some negative connotations; for too many developers, alerting correlates too closely with errors, mistakes, and ongoing issues. However, for developers who are proactive about alerting, they know they don’t have to stare at their dashboards all day, because effective alerts will tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the tutorial Establish objectives and baselines before you begin this one. Optional: added custom attributes and events. 1. Define required alerting policies based on Service Level Objectives A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, “95% of requests completed within 250 ms AND availability is 99.99%”), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it’s meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature DevOps customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic DevOps customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alert strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? New Relic Browser and New Relic APM can be used to alert on site availability. How's our underlying infrastructure? Set KPIs for key hardware, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (Browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie that to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site’s availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don’t yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds You can set this same kind of alert in Browser to catch sub-optimal performance. In the following example, we’ve set both a warning and a violation for throughput: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier -- this can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic approximately evenly across five different servers. You can set an alert based on a NRQL query, and notification to be sent if any server starts getting significantly more or less traffic than the other servers. Here’s the graph: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds And here’s a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups to alert, and set broadcasting methods Alerting without the proper broadcasting methods leaves you vulnerable. Your alerts strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the the types of alerts that warrant waking someone up. 4. Fine-tune alerts and thresholds As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. When rolling out new code or modifications that could negatively impact performance over a period of time, loosen your threshold conditions to allow for these short-term changes. For instance, we recommend using pre-established baselines and thresholds to increase efficiency during high-impact times for your business, such as annual events and major releases. Fine-tuning gives you the flexibility you need to increase efficiencies and extend your notification channels. As noted earlier, we recommend you start with a group chat service when you first establish notifications. Once you’ve identified other tools you’d like to integrate with, set up a notification channel to maintain your momentum. Tools such as xMatters and PagerDuty provide popular integrations, but don’t overlook simple methods, such as webhooks. The goal is to continuously improve your alerting scheme. Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use the New Relic query language and the Insights query API to create your dashboards. For detailed instructions, check out Sending alerts data to Insights. The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you’re using. For a more extensive discussion on notification channels, refer to the incident orchestration tutorial. Conclusion Establishing a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or infrastructure. With proactive alerting, you will decrease user-reported incidents, and allow your teams to spend less time firefighting and more time deploying significant changes to your product. For more help For more tips and best practices for alerting, see the following documentation: Tame application monitoring with dynamic targeting in New Relic Alerts Best practices for alert policies New Relic Infrastructure best practices guide Infrastructure alerting examples If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.90091,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", as defined by your SLOs. You can set warning thresholds to <em>monitor</em> issues that may be approaching a critical severity but don’t yet warrant a pager <em>notification</em>. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while"
      },
      "id": "5f5af2a0e7b9d205d8acfd0c"
    },
    {
      "category_2": "Alert notifications",
      "nodeid": 6491,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Test alert notification channels",
        "Request the test",
        "Troubleshoot the test results",
        "For more help"
      ],
      "title": "Test alert notification channels",
      "category_0": "Alerts and Applied intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "fcea4cf920f099fa1fcf7fab3760d57bdf2e02b7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/test-alert-notification-channels",
      "published_at": "2020-09-27T16:43:18Z",
      "updated_at": "2020-08-11T04:16:54Z",
      "breadcrumb": "Contents / Alerts and Applied intelligence / New Relic Alerts / Alert notifications",
      "document_type": "page",
      "popularity": 1,
      "info": "Be sure to save your alerts notification channels before testing them to make sure they're working properly.",
      "body": "You must save a new notification channel or any changes to an existing notification channel before testing it. Alerts will then send a test message to your chosen destination. Request the test To test a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Follow standard procedures to add a new notification channel or to update an existing notification channel, and save it. Select a notification channel, and then click Envelope Message Icon Send a test notification. Review the test confirmation message, and then click Got it. Troubleshoot the test results A confirmation message will automatically show up in the user interface that indicates where the test was sent (for example, email) and whether it was successful. Also, the test notification message itself includes detailed information, including: The person who requested the test Links to policies for the channel Links to all notification channels and policies for the account When troubleshooting problems, review the test notification message, and verify the setup requirements for the type of notification channel you selected. If necessary, make additional changes to your notification channel, and test it again as needed. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.06378,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Test alert <em>notification</em> <em>channels</em>",
        "sections": "Test alert <em>notification</em> <em>channels</em>",
        "info": "Be sure to save your alerts <em>notification</em> <em>channels</em> before testing them to make sure they&#x27;re working properly.",
        "category_2": "Alert <em>notifications</em>",
        "body": "You must save a new <em>notification</em> <em>channel</em> or any changes to an existing <em>notification</em> <em>channel</em> before testing it. Alerts will then send a test message to your chosen destination. Request the test To test a <em>notification</em> <em>channel</em>: Go to one.newrelic.com, in the top nav click Alerts &amp; AI, then click"
      },
      "id": "5f2dbb3664441fd3a556a97c"
    }
  ],
  "/build-apps/build-hello-world-app": [
    {
      "sections": [
        "Intro to New Relic One API components",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One API components",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2020-09-29T01:52:56Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One API components",
      "body": "Intro to New Relic One API components To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.05557,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to New Relic <em>One</em> API components",
        "sections": "Intro to New Relic <em>One</em> API components",
        "info": "Intro to New Relic <em>One</em> API components",
        "tags": "New Relic <em>One</em> apps",
        "body": ", and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-08-14T01:49:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Copy Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.98724,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "sections": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "info": "An overview of the <em>Nerdpack</em> <em>File</em> <em>Structure</em>",
        "tags": "<em>file</em> <em>structure</em>",
        "body": " components, see our app building guides and the New Relic <em>One</em> <em>CLI</em> command reference. <em>Nerdpack</em> <em>file</em> <em>structure</em> When you generate a <em>Nerdpack</em> template using the <em>nr1</em> create command, it has the following <em>file</em> <em>structure</em>: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2020-09-29T01:52:56Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.15979,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>One</em> <em>CLI</em> common commands",
        "sections": "New Relic <em>One</em> <em>CLI</em> common commands",
        "info": "An overview of common commands you can use with the New Relic <em>One</em> <em>CLI</em>.",
        "body": " Nerdpacks and their <em>file</em> <em>structure</em>, see <em>Nerdpack</em> <em>file</em> <em>structure</em>. For more on how to set up your Nerdpacks, see our <em>Nerdpack</em> <em>CLI</em> commands. Usage $ <em>nr1</em> create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "Map page views by region in a custom app",
        "Before you begin",
        "New Relic terminology",
        "Build a custom app with a table chart",
        "Query your browser data",
        "Create and serve a new Nerdpack",
        "Review your app files and view your app locally",
        "Hard code your account ID",
        "Import the TableChart component",
        "Add a table with a single row",
        "Customize the look of your table (optional)",
        "Get your data into that table",
        "Make your app interactive with a text field",
        "Import the TextField component",
        "Add a row for your text field",
        "Build the text field object",
        "Get your data on a map",
        "Install Leaflet",
        "Add a webpack config file for Leaflet",
        "Import modules from Leaflet",
        "Import additional modules from New Relic One",
        "Get data for the map",
        "Customize the map marker colors",
        "Set your map's default center point",
        "Add a row for your map",
        "Replace \"Hello\" with the Leaflet code"
      ],
      "title": "Map page views by region in a custom app",
      "type": "developer",
      "tags": [
        "custom app",
        "map",
        "page views",
        "region",
        "nerdpack"
      ],
      "external_id": "6ff5d696556512bb8d8b33fb31732f22bab455cb",
      "image": "https://developer.newrelic.com/static/d87a72e8ee14c52fdfcb91895567d268/0086b/pageview.png",
      "url": "https://developer.newrelic.com/build-apps/map-pageviews-by-region/",
      "published_at": "2020-09-29T01:47:51Z",
      "updated_at": "2020-09-17T01:48:42Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a New Relic app showing page view data on a world map.",
      "body": "Map page views by region in a custom app 30 min New Relic has powerful and flexible tools for building custom apps and populating them with data. This guide shows you how to build a custom app and populate it with page view data using New Relic's Query Language (NRQL - pronounced 'nurkle'). Then you make your data interactive. And last, if you have a little more time and want to install a third-party React library, you can display the page view data you collect on a map of the world. In this guide, you build an app to display page view data in two ways: In a table On a map Please review the Before you begin section to make sure you have everything you need and don't get stuck halfway through. Before you begin In order to get the most out of this guide, you must have: A New Relic developer account, API key, and the command-line tool. If you don't have these yet, see the steps in Setting up your development environment New Relic Browser page view data to populate the app. Without this data, you won't be able to complete this guide. To add your data to a world map in the second half of the guide: npm, which you'll use during this section of the guide to install Leaflet, a third-party JavaScript React library used to build interactive maps. If you're new to React and npm, you can go here to install Node.js and npm. New Relic terminology The following are some terms used in this guide: New Relic application: The finished product where data is rendered in New Relic One. This might look like a series of interactive charts or a map of the world. Nerdpack: New Relic's standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see Nerdpack file structure. Launcher: The button on New Relic One that launches your application. Nerdlets: New Relic React components used to build your application. The three default files are index.js, nr1.json, and styles.scss, but you can customize and add your own. Build a custom app with a table chart Step 1 of 8 Query your browser data Use Query builder to write a NRQL query to see your page view data, as follows. On New Relic One, select Query your data (in the top right corner). That puts you in NRQL mode. You'll use NRQL to test your query before dropping the data into your table. Copy and paste this query into a clear query field, and then select Run. FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000 Copy If you have PageView data, this query shows a week of average page views broken down by country and limited to a thousand items. The table will be full width and use the \"chart\" class defined in the CSS. If you don't have any results at this point, ensure your query doesn't have any errors. If your query is correct, you might not have the Browser agent installed. Step 2 of 8 Create and serve a new Nerdpack To get started, create a new Nerdpack, and serve it up to New Relic from your local development environment: Create a new Nerdpack for this app: nr1 create --type nerdpack --name pageviews-app Copy Serve the project up to New Relic: cd pageviews-app && nr1 nerdpack:serve Copy Step 3 of 8 Review your app files and view your app locally Navigate to your pageviews-app to see how it's structured. It contains a launcher folder, where you can customize the description and icon that will be displayed on the app's launcher in New Relic One. It also contains nerdlets, which each contain three default files: index.js, nr1.json, and styles.scss. You'll edit some of these files as part of this guide. For more information, see Nerdpack file structure. Now in your browser, open https://one.newrelic.com/?nerdpacks=local, and then click Apps to see the pageview-apps Nerdpack that you served up. When you select the launcher, you see a Hello message. Step 4 of 8 Hard code your account ID For the purposes of this exercise and for your convenience, hard code your account ID. In the pageview-app-nerdlet directory, in the index.js file, add this code between the import and export lines. (Read about finding your account ID here). const accountId = [Replace with your account ID]; Copy Step 5 of 8 Import the TableChart component To show your data in a table chart, import the TableChart component from New Relic One. To do so, in index.js, add this code under import React. import { TableChart } from 'nr1'; Copy Step 6 of 8 Add a table with a single row To add a table with a single row, in the index.js file, replace this line: return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; Copy with this export code: export default class PageViewApp extends React.Component { render() { return ( <div className=\"container\"> <div className=\"row\"></div> </div> ); } } Copy Step 7 of 8 Customize the look of your table (optional) You can use standard CSS to customize the look of your components. In the styles.scss file, add this CSS. Feel free to customize this CSS to your taste. .container { width: 100%; height: 99vh; display: flex; flex-direction: column; .row { margin: 10px; display: flex; flex-direction: row; } .chart { height: 250px; } } Copy Step 8 of 8 Get your data into that table Now that you've got a table, you can drop a TableChart populated with data from the NRQL query you wrote at the very beginning of this guide. Put this code into the row div. <TableChart accountId={accountId} query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} fullWidth className=\"chart\" />; Copy Go to New Relic One and click your app to see your data in the table. (You might need to serve your app to New Relic again.) Congratulations! You made your app! Continue on to make it interactive and show your data on a map. Make your app interactive with a text field Once you confirm that data is getting to New Relic from your app, you can start customizing it and making it interactive. To do this, you add a text field to filter your data. Later, you use a third-party library called Leaflet to show that data on a world map. Step 1 of 3 Import the TextField component Like you did with the TableChart component, you need to import a TextField component from New Relic One. import { TextField } from 'nr1'; Copy Step 2 of 3 Add a row for your text field To add a text field filter above the table, put this code above the TableChart div. The text field will have a default value of \"US\". <div className=\"row\"> <TextField placeholder=\"US\" onChange={(event) => { this.setState({ countryCode: event.target.value }); }} /> </div>; Copy Step 3 of 3 Build the text field object Above the render() function, add a constructor to build the text field object. constructor(props) { super(props); this.state = { countryCode: null } } Copy Then, add a constructor to your render() function. Above return, add: const { countryCode } = this.state; Copy Now add countryCode to your table chart query. <TableChart accountId={accountId} query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} fullWidth className=\"chart\" />; Copy Reload your app to try out the text field. Get your data on a map To create the map, you use npm to install Leaflet. Step 1 of 9 Install Leaflet In your terminal, type: npm install --save leaflet react-leaflet Copy In your nerdlets styles.scss file, import the Leaflet CSS: @import `~leaflet/dist/leaflet.css`; Copy While you're in styles.scss, fix the width and height of your map: .containerMap { width: 100%; z-index: 0; height: 70vh; } Copy Step 2 of 9 Add a webpack config file for Leaflet Add a webpack configuration file .extended-webpackrc.js to the top-level folder in your nerdpack. This supports your use of map tiling information data from Leaflet. module.exports = { module: { rules: [ { test: /\\.(png|jpe?g|gif)$/, use: [ { loader: 'file-loader', options: {}, }, { loader: 'url-loader', options: { limit: 25000 }, }, ], }, ], }, }; Copy Step 3 of 9 Import modules from Leaflet In index.js, import modules from Leaflet. import { Map, CircleMarker, TileLayer } from 'react-leaflet'; Copy Step 4 of 9 Import additional modules from New Relic One You need several more modules from New Relic One to make the Leaflet map work well. Import them with this code: import { NerdGraphQuery, Spinner, Button, BlockText } from 'nr1'; Copy NerdGraphQuery lets you make multiple NRQL queries at once and is what will populate the map with data. Spinner adds a loading spinner. Button gives you button components. BlockText give you block text components. Step 5 of 9 Get data for the map Using latitude and longitude with country codes, you can put New Relic data on a map. mapData() { const { countryCode } = this.state; const query = `{ actor { account(id: 1606862) { mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : ''} LIMIT 1000 \") { results nrql } } } }`; return query; }; Copy Step 6 of 9 Customize the map marker colors Above the mapData function, add this code to customize the map marker colors. getMarkerColor(measure, apdexTarget = 1.7) { if (measure <= apdexTarget) { return '#11A600'; } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { return '#FFD966'; } else { return '#BF0016'; } }; Copy Feel free to change the HTML color code values to your taste. In this example, #11A600 is green, #FFD966 is sort of yellow, and #BF0016 is red. Step 7 of 9 Set your map's default center point Set a default center point for your map using latitude and longitude. const defaultMapCenter = [10.5731, -7.5898]; Copy Step 8 of 9 Add a row for your map Between the text field row and the table chart row, insert a new row for the map content using NerdGraphQuery. <div className=\"row\"> <NerdGraphQuery query={this.mapData()}> {({ loading, error, data }) => { if (loading) { return <Spinner fillContainer />; } if (error) { return 'Error'; } const { results } = data.actor.account.mapData; console.debug(results); return 'Hello'; }} </NerdGraphQuery> </div>; Copy Reload your application in New Relic One to test that it works. Step 9 of 9 Replace \"Hello\" with the Leaflet code Replace return \"Hello\"; with: return ( <Map className=\"containerMap\" center={defaultMapCenter} zoom={2} zoomControl> <TileLayer attribution='&amp;copy <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\" /> {results.map((pt, i) => { const center = [pt.lat, pt.lng]; return ( <CircleMarker key={`circle-${i}`} center={center} color={this.getMarkerColor(pt.y)} radius={Math.log(pt.x) * 3} onClick={() => { alert(JSON.stringify(pt)); }} /> ); })} </Map> ); Copy This code creates a world map centered on the latitude and longitude you chose using OpenStreetMap data and your marker colors. Reload your app to see the pageview data on the map!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.83873,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create and serve a new <em>Nerdpack</em>",
        "tags": "<em>nerdpack</em>",
        "body": " look like a series of interactive charts or a map of the world. <em>Nerdpack</em>: New Relic&#x27;s standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see <em>Nerdpack</em> <em>file</em> <em>structure</em>. Launcher: The button on New Relic <em>One</em>"
      },
      "id": "5efa993c196a67066b766469"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.98474,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>One</em> <em>CLI</em> reference",
        "sections": "New Relic <em>One</em> <em>CLI</em> reference",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage New Relic apps.",
        "tags": "New Relic <em>One</em> app",
        "body": ". For more on how to serve and publish your application, see our guide on Deploying your New Relic <em>One</em> app. Get started <em>nr1</em> help Shows all <em>nr1</em> commands or details about each command. <em>nr1</em> update Updates to the latest version of the <em>CLI</em>. <em>nr1</em> create Creates a new component from a template (<em>Nerdpack</em>, Nerdlet"
      },
      "id": "5efa989e28ccbc535a307dd0"
    }
  ],
  "/explore-docs/intro-to-sdk": [
    {
      "category_2": "Optimize your cloud native environment",
      "nodeid": 32786,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Migrate to microservices",
        "1. Deploy instrumentation on all application tiers and components",
        "2. Use key metrics to identify components that you can migrate to microservices",
        "3. Use deployment markers to establish app performance baselines",
        "4. Implement the new microservice-based architecture, and measure the success of your application development processes",
        "5. Create a dashboard to monitor KPIs",
        "6. Create a new baseline to use for comparisons",
        "For more help"
      ],
      "title": "Migrate to microservices ",
      "category_0": "New Relic solutions",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "b8b8cd8f4c66a7b2d0af83e118b5c43bccfbd4a4",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new_processes.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/migrate-microservices",
      "published_at": "2020-09-27T20:34:00Z",
      "updated_at": "2020-09-27T20:33:59Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Optimize your cloud native environment",
      "document_type": "page",
      "popularity": 1,
      "info": "Use microservices to optimize applications. With microservices, app developers can resolve issues faster and deliver an enhanced end-user experience.",
      "body": "As IT departments seek to optimize their cloud applications, they are decomposing application monoliths into microservices. A microservice architecture is an approach that delivers a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms. Following a service-oriented architecture (SOA) model, each service should offer public API interfaces to any other service in the environment. Fragmenting applications into their most basic services enables the continuous delivery/deployment of large, complex applications by removing barriers and silos that previously lengthened the application release cycle. It also enables an organization to evolve its technology stack for modern cloud environments and to operate at internet-scale. With microservices, app developers can build, manage, scale, and reuse services independently, resolve issues faster, increase the rate of deployments, and ultimately deliver an enhanced end-user experience. This quest to use microservices to optimize applications is an iterative process. We recommend the following six steps, using the New Relic platform, to ensure an effective migration path to microservices. 1. Deploy instrumentation on all application tiers and components In order to determine which components of an application can be broken into microservices, you need to deploy instrumentation on all tiers and components of the target application. This will allow you to determine baseline application performance, quantify transaction volumes, and gather other key metrics that will determine where you begin your microservice journey. Specifically, you should: Monitor your web apps with APM. See Compatibility and requirements for New Relic agents and products to learn precise compatibility details for each supported language, and then install the APM agent on your application stack. Steps for installing APM agents vary based on language. Monitor your compute resources with Infrastructure. See Compatibility and requirements for Infrastructure for supported operating systems and environments. You can also instrument other products and services with on-host integrations. In some cases, it may be helpful to use custom instrumentation to gather detailed performance metrics that aren’t necessarily required in the course of normal application monitoring. For example, you may want to add custom instrumentation to key controllers that are candidates for decomposition to gather very granular response time and throughput information. 2. Use key metrics to identify components that you can migrate to microservices Once you have instrumented your application, you can begin to identify which components are strong candidates to migrate to microservices. It is important to consult with colleagues who have written, designed, and/or maintained the application, to supplement the context that your baseline data provides. Their experience and recommendations will help to guide the decomposition effort. In addition, you should analyze objective metrics such as transaction call volume and response time. These metrics will point to components in your monolithic application that are heavily called and/or are responding slowly, which means that they are adding disproportionate load to the monolith, possibly degrading application performance and end-user experience. As microservices, it will be easier to regularly improve and optimize these components. As a result, you will be able to break away and eliminate the most pressing bottlenecks from your monolithic application. one.newrelic.com > APM > Transactions: Identify which components are slowing you down. 3. Use deployment markers to establish app performance baselines Breaking down monolithic applications into a microservice architecture is typically an iterative project. You will be continually identifying monolithic components that can be decomposed into microservices, and then optimizing them as business and technology requirements dictate. Deployment tracking lets you quickly see, in a side-by-side comparative view, how architectural and code changes impact your application’s performance. You can then use this information to direct future development efforts and to demonstrate return on investment to the business. You should make deployment markers an integral part of the development process by adding them into your build/deployment process automation. You can view instructions on setting up deployment markers on the Deployments page in APM. one.newrelic.com > APM > Events > Deployments: Understand how deployments affect your performance. 4. Implement the new microservice-based architecture, and measure the success of your application development processes Your developers should now have marching orders for which application components to migrate to microservices. It’s important for these teams to embrace modern software development practices to support your overarching business and technology initiatives. Measuring process improvements is vital to driving alignment and velocity. You should instrument your build/test pipeline using custom events. This will allow you to gather data about: The rate at which new code is moving through the pipeline Quality metrics (for example, what percent of the code is passing tests, if there is automated testing involved) The rate of new deployments via deployment markers These quantitative data points will allow development and operations teams to visualize the adoption of new processes, measure development team productivity, and assess whether these new processes are moving the needle positively or negatively. one.newrelic.com > Dashboards: Visualize the adoption of new processes with dashboards. 5. Create a dashboard to monitor KPIs Once you have determined that the application and its microservices components are (somewhat) production-ready, compare the performance of your new, modern application to the monolithic application (either today or how it performed pre-migration). This will allow you to demonstrate success and to highlight areas for improvement. Key KPIs to monitor and compare include Response Time, Error Rate, Transaction Call Volume, Operational Cost, Availability, and Apdex. one.newrelic.com > Dashboards: Build KPI dashboards to view all your indicators in one place. 6. Create a new baseline to use for comparisons At this point, you have migrated components of your monolithic application to microservices, and you are now empowered with up-to-date data on how your new application is performing compared to your legacy application. Now you have a new launching point for evaluating which other components of your application can be decomposed into microservices, or which microservice components require more performance tuning. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 748.3137,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "1. Deploy instrumentation on all <em>application</em> tiers <em>and</em> <em>components</em>",
        "info": "Use microservices to optimize <em>applications</em>. With microservices, <em>app</em> developers can resolve issues faster <em>and</em> deliver an enhanced end-user experience.",
        "category_0": "<em>New</em> <em>Relic</em> solutions",
        "category_1": "<em>New</em> <em>Relic</em> solutions",
        "body": ", resolve issues faster, increase the rate of deployments, and ultimately deliver an enhanced end-user experience. This quest to use microservices to optimize applications is an iterative process. We recommend the following six steps, using the <em>New</em> <em>Relic</em> <em>platform</em>, to ensure an effective migration path",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; Optimize your cloud native environment"
      },
      "id": "5f58347e64441f8c45e0684c"
    },
    {
      "category_2": "Measure DevOps success",
      "nodeid": 16416,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Establish objectives and baselines: define team SLOs",
        "Service level components",
        "Resources",
        "1. Build an inventory of services requiring SLOs",
        "2. Research customer expectations for SLOs",
        "3. Define SLOs",
        "4. Determine what can be instrumented",
        "5. Review the default metrics",
        "6. Set up custom instrumentation",
        "7. Create Insights dashboards to track SLIs",
        "For more help"
      ],
      "title": "Establish objectives and baselines: define team SLOs",
      "category_0": "New Relic solutions",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "c51fb6972a0e1d7cd72eaea21310026ec5ddb6a4",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/catalyst-establish-objectives-2.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/establish-objectives-baselines-define-team-slos",
      "published_at": "2020-09-28T00:26:46Z",
      "updated_at": "2020-09-28T00:26:46Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "Service level objectives (SLOs) provide a powerful mechanism to codify the goals of a DevOps team in a way that can be measured and shared.",
      "body": "A DevOps transformation requires a cultural shift so that teams can build new skills and motivations for the type of cross-team work required in a true DevOps practice. The transformation can be difficult when the people involved do not see the benefits of change as a clear objective. Service level objectives (SLOs) provide a powerful mechanism to codify the goals of a DevOps team in a way that can be measured and shared. They also provide clear boundaries on service expectations that help teams achieve greater velocity and freedom in experimenting with new approaches. This tutorial defines SLOs for successful service delivery objectives and utilize New Relic instrumentation to surface the current performance metrics relative to those objectives. Measurable SLOs and visibility into your current progress against those SLOs ensure that you will be able to properly assess future optimization efforts. Service level components An SLO is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI); for example: Average response time Response time percentile Application availability SLOs clarify a target value for SLIs; for example: Average response time should be less than 200 ms 95% of requests should be completed within 250 ms Availability of the service should be 99.99% Logically group SLOs together to provide an overall boolean indicator of whether or not the service is meeting expectations. For example, a helpful SLO for alerting purposes could be: 95% of requests completed within 250 ms AND availability is 99.99% Service level components Example values SLI (Indicator) HTTP status codes SLO (Objective) < 1% HTTP 500s over 30 days SLA (Agreement) For every additional .1% of HTTP 500s, 5% refund of total contract Resources Value stream mapping can be a useful exercise to work through before setting SLOs. Work with your teams to clarify key components of your service and the appropriate metrics. Use these inputs as starting points for this tutorial. In addition: Learn about SLOs, SLIs, and SLAs from the Google Cloud Platform blog. Learn how New Relic has applied SLOs and SLIs into its reliability practices form this SREcon18 Americas presentation (approximately 21 minutes). 1. Build an inventory of services requiring SLOs Start defining SLOs for your application by first taking an inventory of the services that your application provides to both your internal and external customers. Draft a list of services. Make the scope of services you consider as comprehensive as possible. Engage your team members and other stakeholders to validate the list for completeness. Segment your application stack to understand the potential components that might require SLOs. For example, most applications can be segmented as: Application (backend/microservices) Dependency services (such as the message queue) Database Website Underlying servers This example lists components that would benefit from SLOs: Customer type Component name Owner Language stack Operating system External Service 1 John D. Java RHEL 6 Internal Service 2 Jane A. .NET Win2003 R2 Internal ActiveMQ John D. Java AIX External Website Jane A. Classic ASP Win2000 Internal MS SQL Dave Z. n/a Win2003 R2 Building a definitive list of services that require an SLO can be challenging, because an application often consists of many endpoints with complex interdependencies. Begin your SLO journey with pragmatism. Start by defining a broader, simpler set of SLOs that are driven by what your customers care about most and what your team can control. As your teams better align around SLOs, you can then begin to fine-tune and add more complexity. 2. Research customer expectations for SLOs Once you have an inventory of services, begin to gather the information you need to define the SLOs for those services. Interviews with customers that depend on your services are often valuable for understanding service expectations. For example, to define SLOs for internal teams, New Relic, ask questions such as: If possible, can you broadly categorize the types of requests we can expect from you and your service? To what extent do you or your service depend on timely responses to requests? Are there requests for which response time is not critical? How does your service handle unavailable dependencies or data? What is the maximum amount of unavailable data that your service can handle? At what threshold does your service fail if a request takes too long? What are acceptable rates of errors? What would a SLA look like between our product and yours? Existing usage data can also be a helpful research input. 3. Define SLOs Using the research on customer expectations that you gathered, draft a focused set of SLOs. New Relic recommends setting SLOs against one or more of the following SLIs: Application availability percentage Average response time Response percentile Error rate Apdex value Also, consider instrumenting and tracking the following SLIs: Throughput (peak and trough) Database call count and duration DNS and SSL timing DOM processing and page rendering Mean-time-to-detection (MTTD) For a more comprehensive list of potential areas to measure, see Measuring DevOps. Recommendation: To determine if your application is performing to customer expectations: Consider combining multiple SLIs (for example, availability and response time) into one SLO. Aim to define a consistent set of conditions across all of the services in your list. Consult your team and stakeholders to validate that the SLOs you set are reasonable, consistently attainable (even if you are not currently meeting them), and aligned to customer expectations. After you finish this step, you should have a set of well-defined SLOs and SLIs. 4. Determine what can be instrumented Now you are ready to deploy agents or monitors to establish a performance baseline for the SLIs you created. With proper instrumentation in place, you will have visibility into the performance indicators that matter for your team and your customers. In addition, you will also have a clear understanding of how to meet your SLOs. Identify the service components your team will optimize. Verify which application tiers meet New Relic monitoring requirements. To ensure you have robust baselines from which to work, determine the level of instrumentation that is possible (or allowed) within your organization. There may be situations where instrumentation of the current on-premise environment is not viable. For example, firewalls with certain settings may not permit New Relic agents to transmit data. Recommendation: If the application has a web front end in these situations, use New Relic Synthetics. Synthetics offers non-agent monitoring while still providing the ability to establish a baseline. To instrument the example applications and components in this tutorial, use these New Relic products: New Relic products Customer type Component name Tier owner Language stack Server OS New Relic products External Service 1 John D. Java RHEL 6 APM, Infrastructure, Synthetics Internal Service 2 Jane A. .Net Win2003 R2 APM, Infrastructure Internal ActiveMQ John D. Java AIX APM, Plugins External Website Jane A. Classic ASP Win2000 Synthetics Internal MS SQL Dave Z. NA Win2003 R2 Infrastructure, On-host integration APM installation After reviewing the compatibility and requirements for New Relic APM, install the APM agent on your application stack. Steps for installing APM agents vary based on language agent type. Follow the installation procedures for specific APM agents. Infrastructure installation After reviewing the requirements for New Relic Infrastructure, follow the installation procedures to install the Infrastructure agent on instances that host your applications. The New Relic Infrastructure agent requires the following host permissions: Linux: To install and run the agent, you must have root privileges. Windows: To install and run the agent, you must have Administrator privileges. Infrastructure on-host integrations To gain extended visibility into applications that your code depends on, deploy on-host integrations based on their availability. New Relic supports several commonly used application components, including MySQL, Apache, NGINX, and more. For more information, see New Relic's on-host integrations documentation. Synthetics New Relic Synthetics is a suite of automated, scriptable tools to monitor your websites, critical business transactions, and API endpoints. Follow the procedures to create a simple browser check. Be sure to verify that your website URL is accessible from the Synthetics public network locations. Browser New Relic Browser provides deep insights into how your users are interacting with your application or website. Browser complements Synthetics with data based on actual user experiences, which is useful in discerning how DevOps efforts are ultimately improving the experience for the customer. For more information, see the compatibility and requirements, then install the New Relic Browser agent. Mobile The growing role of mobile apps in customer experience often spurs new performance data needs. Installation of New Relic Mobile lets DevOps teams instrument iOS and Android applications to gain a fuller understanding of service delivery quality. Plugins Developers can use the New Relic Plugins product to create plugins that monitor numerical metrics provided by external services, hosts, or equipment. You can install existing plugins from Plugin Central, or plan, develop, test, and create your own plugins. 5. Review the default metrics After you deploy the agents and monitors, use service maps to review the default metrics that New Relic captures. For example, a typical service map show many of the common SLIs that application teams rely on, including response time, Apdex, throughput, and error rate metrics from APM. It also shows page load time, Ajax response, throughput, and error rate from Browser. rpm.newrelic.com > Service maps: To explore detailed granularity for any area, use the service map's nodes. 6. Set up custom instrumentation To close any remaining gaps in visibility for your SLIs, use custom instrumentation. New Relic provides several avenues for adding custom instrumentation, including: Making API calls to agents from inside your source code Packaging XML-based custom instrumentation modules with deployed applications Adding UI-based instrumentation without a code deploy In addition, you can add custom attributes to each transaction event that match application performance factors to critical business information. Then you can track those attributes in Insights dashboards. For more information, see the custom instrumentation documentation for your application: APM Browser Infrastructure Insights Mobile Synthetics 7. Create Insights dashboards to track SLIs Once you implement the appropriate instrumentation, it is easy to visualize your service level indicators with New Relic Insights dashboards. Insights provides a single location to query and view all the data that New Relic products gather. For example, Insights helps visualize the following data gathered from New Relic products: Infrastructure: Use default Infrastructure events and attributes for your systems, processes, events, storage, and network; Infrastructure integrations; and custom attributes. APM: Use Transaction and TransactionError event types. Browser: Use PageView and PageAction event types. Mobile: Use several Mobile event types. Synthetics: Use SyntheticCheck, SyntheticRequest, and SyntheticPrivateMinion event types. Each event has an event type, a timestamp, and one or more key attributes. For more information about the data that New Relic receives from your app, see Data collection. To query and view the data from the SLIs you selected for baselining: Use the Insights Data explorer to create widgets for your dashboards. Create dashboards that include widgets for the SLI baseline data. Use these widgets and dashboards to establish team dashboards that you can share and use to conduct operations reviews. insights.newrelic.com > (select a dashboard): Query your SLI baseline data, create dashboards with widgets to visualize the data, then share with your team and stakeholders.​ The metrics you capture will become your application's baseline. Share your Insights dashboard with your application team and stakeholders to provide visibility into what is happening with your application and to monitor future performance. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 734.1808,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Establish objectives <em>and</em> baselines: define team SLOs",
        "sections": "<em>New</em> <em>Relic</em> solutions",
        "info": "Service level objectives (SLOs) provide a powerful mechanism to codify the goals of a DevOps team in a way that can be measured <em>and</em> shared.",
        "category_0": "<em>New</em> <em>Relic</em> solutions",
        "category_1": "<em>New</em> <em>Relic</em> solutions",
        "body": ". Each event has an event type, a timestamp, and <em>one</em> or more key attributes. For more information about the data that <em>New</em> <em>Relic</em> receives from your <em>app</em>, see Data collection. To <em>query</em> and view the data from the SLIs you selected for baselining: Use the Insights Data explorer to create widgets for your",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; Measure DevOps success"
      },
      "id": "5f5b215064441f4c48e06825"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-09-08T01:50:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users's configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { 'YourNerdpackUuid': { 'collection-1': { 'document-1-of-collection-1': '{\"lastNumber\": 42, \"another\": [1]}', 'document-2-of-collection-1': '\"userToken\"', // ... }, 'another-collection': { 'fruits': '[\"pear\", \"apple\"]', // ... }, // ... }, } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 711.07764,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use NerdStorage in your <em>apps</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "Intro to Nerd<em>Storage</em> 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em>. On this page, you’ll learn how to use Nerd<em>Storage</em> <em>SDK</em> <em>components</em>. Use Nerd<em>Storage</em> in your <em>apps</em> Nerd<em>Storage</em> is used to store and retrieve simple sets of data, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Create a \"Hello, World!\" application",
        "Permissions for managing applications",
        "Set up your development environment",
        "Add, query, and mutate data using NerdStorage",
        "Add the NerdGraphQuery component to an application",
        "Add a time picker to your app",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps"
      ],
      "published_at": "2020-09-29T01:47:50Z",
      "title": "Build apps",
      "updated_at": "2020-09-25T01:49:59Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One   Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 20 min Add a time picker to your app Add a time picker to a sample application 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 694.5531,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Publish <em>and</em> deploy <em>apps</em>",
        "body": " you start building <em>apps</em>, and dive into our library of <em>components</em>. We also have a growing number of open source <em>apps</em> that you can use to get started. The rest is up to you. Guides to build <em>apps</em> 15 min Create a &quot;Hello, World!&quot; application Build a &quot;Hello, World!&quot; <em>app</em> and publish it to <em>New</em> <em>Relic</em> <em>One</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "category_2": "Cloud adoption",
      "nodeid": 16121,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Create application baselines",
        "1. Identify components",
        "2. Determine compatibility",
        "3. Deploy monitoring",
        "4. Gather metrics",
        "5. Set up Dashboards",
        "Expert tips",
        "For more help"
      ],
      "title": "Create application baselines",
      "category_0": "New Relic solutions",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "e971df6f5f6a6360b22e2929f33f9d7af6ff130f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/create-application-baselines",
      "published_at": "2020-09-27T20:07:57Z",
      "updated_at": "2020-09-27T20:07:57Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Cloud adoption",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic to establish a baseline to use for comparison during your cloud adoption process.",
      "body": "Cloud migrations can take many forms. Some companies choose to port their applications directly from their data center to the cloud (a “Lift and Shift” migration) while others focus on completely re-architecting their applications to take advantage of benefits available only in the cloud. No matter your approach, there are three primary questions you want to answer after your migration: Has my application gotten slower? Is my application less stable than before? Am I losing customers due to either of the previous questions? To answer these questions, start by performing some basic testing to establish a baseline for the performance and availability of your systems. A baseline is a measurement of the current performance and availability of your application, which you then use as a comparison after your migration to validate your business case. In some cases, you may change a baseline when you perform migration acceptance testing. You can also use a baseline as a comparison point during your migration to make sure that you are on track. 1. Identify components Before you begin a cloud migration, identify all the tiers of your entire application stack. List all of the components (applications, services, etc.) that you want to migrate. Segment the application stack as follows: Application (backend/microservices/cron jobs) Dependency services, such as the message queue Database Website Underlying server and infrastructure Make sure that you have access to applications and instances before you start creating application baselines. Engage your application owners, DevOps engineers, and product managers for access. Example: List of components Here is an example of the list of components in an application stack: Component Name Owner Language Stack Accessibility (Internet, Intranet) Operating System Service 1 John Doe Java Internet RHEL 6 Service 2 Maya Wiz .NET Intranet Win2003 R2 RabbitMQ John Doe Java Intranet AIX Website Maya Wiz Classic ASP Internet Win2000 MS SQL Dave Z NA Intranet Win2003 R2 2. Determine compatibility Once you identify the applications that you want to migrate, it is time to verify which application tiers to monitor with the New Relic platform. Work with stakeholders in your organization to determine the amount of instrumentation that is possible–or allowed–within your organization. This is an important step and one that will pay off, as the more you can instrument, the better your baselines. Here are the New Relic products to use for baselining, depending on the components that you identified: New Relic APM: Monitor your web apps with New Relic APM. See Compatibility and requirements for New Relic agents and products to learn precise compatibility details for each supported language. New Relic Infrastructure: Monitor your hosts with New Relic Infrastructure. See Compatibility and requirements for New Relic Infrastructure for supported operating systems and environments. You can also instrument other products and services with on-host integrations. New Relic Synthetics: Monitor web frontends and APIs with New Relic Synthetics. Sometimes, you may not be able to instrument your on-premise environment with APM or Infrastructure. For example, maybe your organization's policy forbids installing an agent behind a firewall. In these cases, if the application has a web frontend, use Synthetics, as it offers non-agent monitoring while still providing the ability to establish a baseline. Example: Components matched to New Relic products Match the components that you identified with their corresponding products: Component Name Tier Owner Language Stack Accessibility (Internet/ Intranet) Operating System New Relic Products Service 1 John Doe Java Internet RHEL 6 APM, Infrastructure, Synthetics Service 2 Maya Wiz .NET Intranet Win2003 R2 APM, Infrastructure ActiveMQ John Doe Java Intranet AIX APM, Plugin Website Maya Wiz Classic ASP Internet Win2000 Synthetics MS SQL Dave Z n/a Intranet Win2003 R2 Infrastructure, On-host Integration 3. Deploy monitoring Based on the component-product matches you made, deploy agents or monitors across your architecture: Deploy New Relic APM Install the APM agent on your application stack. The steps to install the APM agent are different based on language. Deploy New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, follow the instructions to install the Infrastructure agent on your hosts: Install for Linux Install for Windows Server Install on AWS Elastic Beanstalk Install with a configuration management tool Deploy Infrastructure on-host integrations To gain extended visibility into applications that your code depends on, deploy on-host integrations. Available integrations include Apache, MySQL, NGINX, and others. Create New Relic Synthetics monitors New Relic Synthetics is a suite of automated, scriptable tools to monitor your websites, critical business transactions, and API endpoints. To get started add a monitor. Make sure to verify that your website URL is accessible from the public network. You may also need to add New Relic IPs to your allow list. 4. Gather metrics After you deploy the agents and monitors, identify which metrics are the most important to your business and use these metrics to define your KPIs. Some recommendations include: Response time: Time taken to respond to a request. Throughput: Number of requests that came in through the application. Requesting queuing (Apache, IIS, NGINX): Duration of time taken for a request to reach your application. Database call duration: Duration of time taken to complete a database call. DB call counts: Number of calls made by application code to the database. Error rate: Percent of errors reported. Apdex score: An industry standard to measure user satisfaction with the response time of web applications and services. DNS setup timing: The time it takes to connect and receive data from DNS. SSL setup timing: The time it takes to establish an SSL connection. You can find some of these metrics in service maps, as well as on APM, and Browser overview pages. For more detailed information about navigating, interpreting, and using New Relic APM, check out these New Relic University’s tutorials: Overview dashboard tour Transactions dashboard Understanding Apdex 5. Set up Dashboards After you define your KPIs, it is easy to visualize them in New Relic Dashboards. Dashboards provide a single location to view all the data that New Relic products gather. Dashboards data consists of events, and each event has an event type, a timestamp, and key-value attributes. For more information about events, see Data collection and Default events for New Relic products. You can locate your KPIs and business metrics data in New Relic using the data explorer and the NRQL query language. You can also build Dashboards to track the performance of those KPIs: Example: Component performance compared against baselines Continuing the examples in this document, the following table illustrates the maturity of your application performance over a period of time based on deployment milestones. Each milestone will serve as a new baseline for your applications: Component Milestone 1 Milestone 2 Milestone N Environment Component Name Response Time SLA Apdex Response Time SLA Apdex Response On-Prem Service 1 1.5 secs 80% 70% 1.5 secs 68% 0.65 1.4 secs Cloud Service 1 0.9 secs 96.8% 95% 0.9 secs 98% 0.99 0.7 secs On-Prem Service 2 0.7 secs 73% 68% 0.7 secs 80% 0.78 0.85 secs Cloud Service 2 0.6 secs 90% 92% 0.6 secs 89% 0.90 0.5 secs After your migration, compare these baselines against your migration acceptance testing baselines. Expert tips If you find that you need data that is not captured by default instrumentation, New Relic makes it easy to capture custom data: APM custom instrumentation Browser custom data Infrastructure custom attributes Custom event data Mobile custom data Synthetics custom attributes You can also learn more about APM custom instrumentation with the New Relic University Custom data tutorial series. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 658.0222,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>application</em> baselines",
        "sections": "<em>New</em> <em>Relic</em> solutions",
        "info": "Use <em>New</em> <em>Relic</em> to establish a baseline to use for comparison during your cloud adoption process.",
        "category_0": "<em>New</em> <em>Relic</em> solutions",
        "category_1": "<em>New</em> <em>Relic</em> solutions",
        "body": " to migrate, it is time to verify which application tiers to monitor with the <em>New</em> <em>Relic</em> <em>platform</em>. Work with stakeholders in your organization to determine the amount of instrumentation that is possible–or allowed–within your organization. This is an important step and <em>one</em> that will pay off",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; Cloud adoption"
      },
      "id": "5ad48685c75d0766faa181bd"
    }
  ],
  "/explore-docs/nr1-plugins": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.22998,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " extension to build your apps. <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em> This table provides descriptions for the <em>New</em> <em>Relic</em> <em>One</em> <em>commands</em>. For more context, including usage and option details, click any individual <em>command</em> or the <em>command</em> category. For details on user permissions, see Authentication and permissions"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-09-29T01:52:56Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Copy Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.06044,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2020-09-29T01:52:56Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.83377,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em> Here&#x27;s a list of common <em>commands</em> to get you started with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-nerdpack/",
      "sections": [
        "New Relic One CLI Nerdpack commands",
        "Command details",
        "nr1 nerdpack:build",
        "Builds a Nerdpack",
        "Usage",
        "Options",
        "nr1 nerdpack:clone",
        "Clone an existing Nerdpack",
        "nr1 nerdpack:serve",
        "Serve your Nerdpack locally",
        "nr1 nerdpack:uuid",
        "Get your Nerdpack's UUID",
        "nr1 nerdpack:publish",
        "Publish your Nerdpack",
        "nr1 nerdpack:deploy",
        "Deploy your Nerdpack to a channel",
        "nr1 nerdpack:undeploy",
        "Undeploy your Nerdpack",
        "nr1 nerdpack:clean",
        "Removes all built artifacts",
        "nr1 nerdpack:validate",
        "Validates artifacts inside your Nerdpack",
        "nr1 nerdpack:Info",
        "Shows the state of your Nerdpack in the New Relic's registry"
      ],
      "published_at": "2020-09-29T01:54:07Z",
      "title": "New Relic One CLI Nerdpack commands",
      "updated_at": "2020-09-17T01:49:55Z",
      "type": "developer",
      "external_id": "7c1050a6a8624664b90c15111f7c72e96b2fbe17",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI commands you can use to set up your New Relic One Nerdpacks.",
      "body": "New Relic One CLI Nerdpack commands To set up your Nerdpacks, use the commands below. You can click any command to see its usage options and additional details about the command. Command Description nr1 nerdpack:build Assembles your Nerdpack into bundles nr1 nerdpack:clone Clones a Nerdpack from a git repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your development folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Command details nr1 nerdpack:build Builds a Nerdpack Runs a webpack process to assemble your Nerdpack into javascript and CSS bundles. As many other CLI commands, it should be run at the package.json level of your Nerdpack. Usage $ nr1 nerdpack:build OPTION Options --extra-metadata-path=extra-metadata-path Specify a json file path with extra metadata. [default: extra-metadata.json] --prerelease=prerelease If specififed, the value will be appended to the current version of generated files. ie: --prerelease=abc. Then the version will be \"1.2.3-abc\". --profile=profile The authencation profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:clone Clone an existing Nerdpack Duplicates an existing Nerdpack onto your local computer. You can clone an open source Nerdpack from our Open Source GitHub repositories. After choosing a git repository, this command performs the following actions so that you can start using the Nerdpack: Clones the repository. Sets the repository as remote upstream. Installs all of its dependencies (using npm). Generates a new UUID using your profile, and commits it. Usage $ nr1 nerdpack:clone OPTION Options -r, --repo=REPO Repository location (either an HTTPS or SSH path). (Required) -p, --path=PATH Determines the directory to clone to (defaults to the repository name). -f, --force Replaces destination folder if it exists. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:serve Serve your Nerdpack locally Launches a server with your Nerdpack locally on the New Relic One platform, where it can be tested live. To learn more about working with apps locally, see our guide on how to serve, publish, and deploy documentation. Usage $ nr1 nerdpack:serve Options --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:uuid Get your Nerdpack's UUID Prints the UUID (Universal Unique ID) of your Nerdpack, by default. The UUID determines what data the Nerdpack can access and who can subscribe to the Nerdpack. To deploy a Nerdpack you didn't make, you'll have to assign it a new UUID by using the -g or --generate option. For more details, see our GitHub workshop on GitHub. Usage $ nr1 nerdpack:uuid Options --profile=PROFILE The authentication profile you want to use. -f, --force If present, it will override the existing UUID without asking. -g, --generate Generates a new UUID if not available. --verbose Adds extra information to the output. nr1 nerdpack:publish Publish your Nerdpack Publishes your Nerdpack to New Relic. Please note: If no additional parameters are passed in, this command will automatically deploy the Nerdpack onto the DEV channel. If you want to specify your own list of deploy channels, add the --channel option. For example, $ nr1 nerdpack:publish --channel BETA --channel STABLE. If you want to disable this behavior, add -D or --skip-deploy to the command. Then, you can use nr1 nerdpack:deploy to perform a deploy manually. For more on publishing and deploying, see Deploy to New Relic One. Usage $ nr1 nerdpack:publish Options -B, --skip-build Skips the previous build process. -D, --skip-deploy Skips the following deploy process. -c, --channel=DEV/BETA/STABLE Specifies the channel to deploys to. [default: STABLE] -f, --force Forces the publish, overriding any existing version in the registry. --dry-run Undergoes publishing process without actually publishing anything. --extra-metadata-path=extra-metadata-path Specifies a json file .path with extra metadata. [default: extra-metadata.json] --prerelease=STRING The value you enter will be appended to the current version of generated files. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:deploy Deploy your Nerdpack to a channel Deploys a Nerdpack version to a specific channel (DEV, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. For more on publishing and deploying, see Deploy to New Relic One. Usage $ nr1 nerdpack:deploy OPTION Options -c, --channel=DEV/BETA/STABLE Specifies the channel to deploy to. (required) -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to deploy. By default, the command will use the one in package.json. --from-version=VERSION Specifies which version to deploy. By default, the command will use the one in package.json. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:undeploy Undeploy your Nerdpack Undeploys a Nerdpack version from a specific channel (for example, DEV, BETA, or STABLE). Usage $ nr1 nerdpack:undeploy OPTION Options -c, --channel=DEV/BETA/STABLE Specifies the channel to undeploy from. (required) -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to deploy. By default, the command will use the one in package.json. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:clean Removes all built artifacts Cleans and removes the content and the developtment folders (dist/, tmp/). Usage $ nr1 nerdpack:clean OPTION Options --profile=profile The authentication profile you want to use --verbose Adds extra information to the output. nr1 nerdpack:validate Validates artifacts inside your Nerdpack Validates artifacts inside your Nerdpack. Usage $ nr1 nerdpack:validate OPTION Options -l, --force-local The authentication profile you want to use. -r, --force-remote Force download of new schema files. --profile=profile The authentication profile you want to uset. --verbose Adds extra information to the output. nr1 nerdpack:Info Shows the state of your Nerdpack in the New Relic's registry Shows the state of your Nerdpack in the New Relic's registry. The default amount of versions shown is 10 but all versions can be shown if the --all (or -a) flag is used Usage $ nr1 nerdpack:info OPTION Options -a, --all Show all versions. -i, --nerdpack-id=nerdpack-id Get info from the specified Nerdpack instead of local one. --profile=profile The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.14273,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> Nerdpack <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> Nerdpack <em>commands</em>",
        "info": "An overview of the <em>CLI</em> <em>commands</em> you can use to set up your <em>New</em> <em>Relic</em> <em>One</em> Nerdpacks.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> Nerdpack <em>commands</em> To set up your Nerdpacks, use the <em>commands</em> below. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 nerdpack:build Assembles your Nerdpack into bundles nr1 nerdpack:clone Clones a Nerdpack from"
      },
      "id": "5f28bd6a64441f9817b11a38"
    },
    {
      "nodeid": 27692,
      "sections": [
        "AWS Lambda monitoring",
        "Get started",
        "Enable Lambda monitoring",
        "UI and data",
        "Troubleshooting",
        "Enable serverless monitoring for AWS Lambda",
        "How Lambda monitoring works",
        "Enable procedure overview",
        "Step 1. Install the newrelic-lambda-cli tool",
        "CLI requirements",
        "CLI installation",
        "Step 2. Connect AWS to New Relic",
        "Use CLI tool",
        "Manual procedures",
        "Step 3. Enable Lambda instrumentation",
        "Step 4. Configure CloudWatch logs to stream to New Relic Lambda",
        "What's next?",
        "Optional: Stream all logs to New Relic",
        "For more help"
      ],
      "title": "Enable serverless monitoring for AWS Lambda",
      "category_0": "Serverless function monitoring",
      "type": "docs",
      "category_1": "AWS Lambda monitoring",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/enable-serverless-monitoring-aws-lambda",
      "external_id": "7992b896d4c35ca29aba34698aedd621dfe0b572",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-lambda-monitoring-architecture.png",
      "url": "https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/enable-serverless-monitoring-aws-lambda",
      "published_at": "2020-09-28T01:01:03Z",
      "updated_at": "2020-09-24T09:32:20Z",
      "breadcrumb": "Contents / Serverless function monitoring / AWS Lambda monitoring / Enable Lambda monitoring",
      "document_type": "page",
      "popularity": 1,
      "info": "Read about how to install and enable New Relic monitoring for Amazon AWS Lambda. ",
      "body": "Serverless monitoring for AWS Lambda offers in-depth performance monitoring for your Lambda functions. Read on to learn how to enable this feature and get started using it. Using this feature may result in AWS charges. For more information, see the Lambda monitoring requirements.​​​ How Lambda monitoring works Before enabling Lambda monitoring, understanding how data flows from your Lambda functions to New Relic may be helpful: Diagram showing how data flows from a Lambda function to New Relic. When our Lambda monitoring is enabled, this is how data moves from your Lambda function to New Relic: The Lambda function is instrumented with our code. When the Lambda is invoked, log data is sent to CloudWatch. CloudWatch collects Lambda log data and sends it to our log-ingestion Lambda. The log-ingestion Lambda sends that data to New Relic. Enable procedure overview If you already have a New Relic account and use Node.js or Python, we recommend you use our automated installer. If you do not use the automated installer, complete these steps to set up monitoring: Install our CLI tool (recommended) Connect AWS and New Relic (required) Enable instrumentation of your Lambda (required) Stream CloudWatch logs to New Relic (required) Step 1. Install the newrelic-lambda-cli tool We provide a command line interface (CLI) tool that's used in steps 2 through 4. We recommend the CLI because it simplifies some of the work, but you can also perform those steps manually. If you want to understand what it does before you install it, see the manual procedures that the CLI tool performs in Step 2, Step 3 (option 2), and Step 4. You can also see the CLI documentation on GitHub. If you prefer a manual install, skip to Step 2. Connect AWS to New Relic. CLI requirements To use the CLI too, you need: Python 3.3 or higher The AWS CLI You must be a user or admin with an infrastructure manager Add-on role. Your AWS account needs permissions for creating IAM resources (Role and Policy) and Lambda functions. These resources are created using CloudFormation stacks, so you'll need permissions to create those. For more on permissions, including setting custom policies, expand this collapser: AWS permissions details Resource: * Actions: \"cloudformation:CreateChangeSet\", \"cloudformation:CreateStack\", \"cloudformation:DescribeStacks\", \"cloudformation:ExecuteChangeSets\", \"iam:AttachRolePolicy\", \"iam:CreateRole\", \"iam:GetRole\", \"iam:PassRole\", \"lambda:AddPermission\", \"lambda:CreateFunction\", \"lambda:GetFunction\", \"logs:DeleteSubscriptionFilter\", \"logs:DescribeSubscriptionFilters\", \"logs:PutSubscriptionFilter\" \"s3:GetObject\" \"serverlessrepo:CreateCloudFormationChangeSet\" Resource: \"arn:aws:serverlessrepo:us-east-1:463657938898:applications/NewRelic-log-ingestion\" Actions: \"serverlessrepo:CreateCloudFormationTemplate\" \"serverlessrepo:GetCloudFormationTemplate\" Be sure that the AWS account you use to execute the CLI has all of these permissions. If your AWS account permissions are restrictive and you're unable to use the CLI, you can optionally use a manually managed custom IAM policy. This policy would require, at minimum, the following permissions: Resource: \"*\" Action: \"cloudwatch:GetMetricStatistics\" \"cloudwatch:ListMetrics\" \"cloudwatch:GetMetricData\" \"lambda:GetAccountSettings\" \"lambda:ListFunctions\" \"lambda:ListAliases\" \"lambda:ListTags\" \"lambda:ListEventSourceMappings\" These permissions are the minimum required. We recommend granting a managed ReadOnlyAccess policy as described in Connect AWS to infrastructure monitoring. CLI installation To install the CLI tool: Ensure you have the required permissions for both your New Relic and AWS account. From the command line, run: pip install newrelic-lambda-cli You may need to use pip3 in the command above if you have Python 2.7 installed. The CLI requires Python >=3.3. Step 2. Connect AWS to New Relic You must complete this step, and steps 3 and 4, to enable our Lambda monitoring. This step connects AWS to New Relic and creates a newrelic-log-ingestion Lambda function that sends your instrumented data to New Relic. You can either use the CLI tool or do the steps manually. Use CLI tool When you use the CLI, you have one optional step and one required step: Optional: If you're using multiple AWS profiles or multiple regions, you may want to configure the AWS environment variables: AWS environment variable instructions Setting the region To configure your region, use this environment variable to override the default region: export AWS_DEFAULT_REGION=MY_REGION # us-west-2, for example The CLI tool also allows passing this per-command using --aws-region. Setting profiles If you have multiple AWS profiles and don't want to use the default, use AWS_PROFILE environment variable to set another profile name. Ensure the profile is properly configured (including the default region). Example: export AWS_PROFILE=MY_PROFILE Run the following command using the CLI tool: newrelic-lambda integrations install --nr-account-id YOUR_ACCOUNT_ID \\ --linked-account-name YOUR_LINKED_ACCOUNT_NAME \\ --nr-api-key YOUR_NR_API_KEY This command: Connects your AWS account to New Relic. Installs a newrelic-log-ingestion Lambda that will send your instrumented data to New Relic. More details: This defaults to U.S. region. If your account is in the EU region, add this argument: --nr-region \"eu\". If you're instrumenting functions in multiple AWS regions, this command must be run for each region using the --aws-region argument. YOUR_LINKED_ACCOUNT_NAME is either a new AWS account you want to link to New Relic, or it's the name of the AWS account that you linked to when setting up the AWS Lambda monitoring integration. YOUR_NR_API_KEY refers to your personal API key (not your REST API key). For more on the API key and other arguments, see our Lambda monitoring GitHub repo. Manual procedures Here are the manual procedures performed by the CLI tool: Connect AWS to New Relic The newrelic-lambda integration command connects the AWS account containing your Lambdas to New Relic. If you've already installed one of our AWS integrations, your accounts should be linked to New Relic and you can skip this section. To manually establish this connection, follow the instructions for connecting AWS to Infrastructure monitoring. Configure our log-ingestion Lambda The newrelic-lambda integration command sets up a newrelic-log-ingestion Lambda. This Lambda takes the logs generated by your Lambda functions and pushes those logs to New Relic. If you're configuring this manually, you must configure our Lambda for the regions you want. The CLI, by default, establishes our Lambda in all regions. To manually configure our Lambda, go to the AWS Serverless Application Repository, which is where the newrelic-log-ingestion Lambda is stored. This repo is a collection of serverless applications published by developers, companies, and partners in the serverless community. It allows developers to share their Lambda functions code with customers, who can then find and deploy the corresponding application Lambda function. Each application is packaged with an AWS Serverless Application Model (SAM) template that defines the AWS resources used. To manually configure our Lambda with the AWS Serverless Application Repository: From the AWS console, go to the Lambda section, select Create function, and select Serverless Application Repository. Search for newrelic and find the newrelic-log-ingestion Lambda. Follow the instructions in the Lambda's documentation to deploy it. A SAM template will build the Lambda. In the environment variable section in AWS console, set the LICENSE_KEY environment variable to your New Relic license key. Note: If you have multiple accounts or a master and sub-account hierarchy, make sure the license key you're using matches the same account connected to AWS. Optional: If you want to stream all your logs to New Relic, set the LOGGING_ENABLED environment variable to true. For more on this, see Stream all logs. Step 3. Enable Lambda instrumentation This step enables instrumentation of your Lambda function, which allows detailed monitoring and alerting functionality. Our instrumentation is designed to have minimal impact on your Lambda performance. If you're using Node.js or Python, we recommend the first two options. Option #1: Use Serverless Framework plugin (Node.js and Python) Requirements Available only for Node.js and Python. For other languages, see Manual instrumentation. Serverless Framework version 1.34.0 or higher. Features If you meet the requirements (above), you can use our Serverless Framework plugin, which allows you to add our AWS Lambda Layer to your functions without requiring a code change. Supports Node.js and Python runtimes No code change required to enable Lambda instrumentation Enables our APM agent functionality using a single layer Configures CloudWatch subscription filters automatically Gets the layer into your code base which is useful for redeploys Install To install our Serverless Framework plugin: Choose an install option: NPM: npm install --save-dev serverless-newrelic-lambda-layers yarn: yarn add --dev serverless-newrelic-lambda-layers Add the plugin to your serverless.yml: plugins: - serverless-newrelic-lambda-layers Get your account ID and put it in the serverless.yml: custom: newRelic: accountId: YOUR_ACCOUNT_ID Deploy it: sls deploy You can skip Step 4. Setting up CloudWatch Logs. This is automatically completed on deploy by our Serverless Framework plugin. For the next step, go to What's next? Option #2: Add Lambda Layer with our CLI (Node.js and Python) Available only for Node.js and Python. For other languages, see Manual instrumentation. If you don’t have Serverless Framework and don't intend to redeploy your function frequently, you can use the CLI to add our Lambda Layer: If you haven't already done so, install the CLI: pip install newrelic-lambda-cli List available functions: newrelic-lambda functions list Pass the option -f not-installed to see which functions have not yet been instrumented. Add the layer to your function: newrelic-lambda layers install --function FUNCTION_NAME --nr-account-id NEW_RELIC_ACCOUNT_ID Next, you will configure CloudWatch to send logs to New Relic. Option #3: Manually add our Lambda Layer (Node.js and Python) Available only for Node.js and Python. For other languages, see Manual instrumentation. If you don’t have Serverless Framework, you can manually add our Lambda Layer: Find the layer that matches your runtime and region. Copy the Amazon Resource Name (ARN) of the most recent version and add it in the AWS Lambda console for your function. Update your functions handler to point to the newly attached layer in the console for your function: Python: newrelic_lambda_wrapper.handler Node: newrelic-lambda-wrapper.handler Add these environment variables to your Lambda console: NEW_RELIC_ACCOUNT_ID: Your account ID NEW_RELIC_LAMBDA_HANDLER: Path to your initial handler. If you have Node 8 and get a Lambda can't find file error message, expand this collapser: Node 8 \"can't find file\" error troubleshooting If you have Node 8 and receive a Lambda can't find the file newrelic-lambda-wrapper.js message, it's likely that the Node runtime isn't resolving NPM_PATH for the newrelic-lambda module in /opt/nodejs/node_modules. These steps should fix this problem: Create a newrelic-wrapper-helper.js script in your project's root. The script's contents should be module.exports = require('newrelic-lambda-wrapper');. (That is all that needs to be in that script.) Update the handler for your layer declaration to newrelic-lambda-wrapper.handler. Next, you will configure CloudWatch to send logs to New Relic. Option #4: Manually instrument Lambda code for Go, Java, .NET Core, Node.js, and Python If none of the previous options work for you, you can manually instrument your Lambda code. Choose your language: Go To instrument your Go-language Lambda: Download our Go agent package and place it in the same directory as your function. Install the agent: go get -u github.com/newrelic/go-agent. In your Lambda code, import our components, create an application, and update how you start your Lambda. See our GitHub repo for an example of an instrumented Lambda. Optional: Add custom events that will be associated with your Lambda invocation by using the RecordCustomEvent API. For example: func handler(ctx context.Context) { if txn := newrelic.FromContext(ctx); nil != txn { txn.Application().RecordCustomEvent(\"MyEvent\", map[string]interface{}{ \"zip\": \"zap\", }) } fmt.Println(\"hello world!\") } Build and zip your Lambda function and upload it to AWS. Zip and upload recommendations Here are suggestions for zipping and uploading the Lambda: Build the binary for execution on Linux. This produces a binary file called main. You can use: $ GOOS=linux go build -o main Zip the binary into a deployment package using: $ zip deployment.zip main Upload the zip file to AWS using either the AWS Lambda console or the AWS CLI. Name the handler main (to match the name given during the binary build). The following environment variables are not required for Lambda monitoring to function but they are required if you want your Lambda functions to be included in distributed traces. To enable distributed tracing, set these environment variables in the AWS console: NEW_RELIC_ACCOUNT_ID. Your account ID. NEW_RELIC_TRUSTED_ACCOUNT_KEY. This is also your account ID. If your account is a sub-account, this is the account ID for the root/parent account. Optional: To configure logging, see Go agent logging. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. Our wrapper gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next, you'll configure CloudWatch to send those logs to New Relic. Java Monitoring for AWS Lambda in Java doesn't use our APM Java agent. Instead, it uses these two OpenTracing dependencies: AWS Lambda OpenTracing Java SDK: OpenTracing instrumentation for AWS Lambda RequestHandler and RequestStreamHandler. Our AWS Lambda OpenTracing Tracer: An OpenTracing Tracer implementation designed to monitor AWS Lambda. It generates spans, error events, transaction events, error traces, and provides distributed tracing support. Supported OpenTracing Versions OpenTracing 0.31.0: Lambda Tracer: com.newrelic.opentracing:newrelic-java-lambda:1.1.1 Lambda SDK: com.newrelic.opentracing:java-aws-lambda:1.0.0 OpenTracing 0.32.0, 0.33.0: Lambda Tracer: com.newrelic.opentracing:newrelic-java-lambda:2.1.1 Lambda SDK: com.newrelic.opentracing:java-aws-lambda:2.1.0 To instrument your Java Lambda: In your project’s build.gradle file, include our OpenTracing AWS Lambda Tracer and the AWS Lambda OpenTracing SDK dependencies: dependencies { compile(\"com.newrelic.opentracing:java-aws-lambda:2.1.0\") compile(\"com.newrelic.opentracing:newrelic-java-lambda:2.1.1\") compile(\"io.opentracing:opentracing-util:0.33.0\") } Implement the AWS Lambda RequestHandler interface as shown in the Java Lambda example and override the doHandleRequest method. In the doHandleRequest method, call the LambdaTracing.instrument(...) API to create a root span to trace the lambda function's execution. This is also where you will define your business logic for the lambda function. Register a LambdaTracer.INSTANCE as the OpenTracing Global tracer, as shown in the Java Lambda example. Create a ZIP deployment package and upload it to AWS Lambda. Or deploy it via other means. In the AWS Lambda console, set the handler. For the example Java Lambda, the handler would be com.handler.example.MyLambdaHandler::handleRequest. Because handleRequest is assumed, you could also use com.handler.example.MyLambdaHandler. The following AWS console environment variables are required if you want your Lambda function to be included in distributed tracing. This is recommended. NEW_RELIC_ACCOUNT_ID. Your account ID. NEW_RELIC_PRIMARY_APPLICATION_ID. This is also your account ID. NEW_RELIC_TRUSTED_ACCOUNT_KEY. This is also your account ID. If your account is a sub-account, this must be the account ID for the root/parent account. Optional: In the Lambda console, enable debug logging by adding this environment variable: NEW_RELIC_DEBUG is true. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. Our wrapper gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next, you'll configure CloudWatch to send those logs to New Relic. Please see the AWS Lambda distributed tracing example for a complete project that illustrates common use cases such as: Distributed tracing between Lambda functions Manual span creation (aka custom instrumentation) Tracing external calls Adding custom attributes (aka Tags) to spans .NET Core Our monitoring of .NET Core-based AWS Lambda functions doesn't use our standard .NET Core APM agent. Instead, it uses a NuGet package. To instrument your .NET Core Lambda: In your Lambda Functions project, install the NewRelic.OpenTracing.AmazonLambda.Tracer NuGet package. Import the NuGet package and OpenTracing utils: using OpenTracing.Util; using NewRelic.OpenTracing.AmazonLambda; Instrument your function, as shown in this example: public class Function { static Function() { // Register The NewRelic Lambda Tracer Instance GlobalTracer.Register(NewRelic.OpenTracing.AmazonLambda.LambdaTracer.Instance); } public object FunctionWrapper(ILambdaContext context) { // Instantiate NewRelic TracingWrapper and pass your FunctionHandler as // an argument return new TracingRequestHandler().LambdaWrapper(FunctionHandler, context); } /// <summary> /// A simple function that takes a string and does a ToUpper /// </summary> /// <param name=\"input\"></param> /// <param name=\"context\"></param> /// <returns></returns> public object FunctionHandler(ILambdaContext context) { ... } } The arguments passed to FunctionWrapper must match the signature of FunctionHandler. If your handler function returns a Task, the Lambda wrapper will block on the return task until it completes, so that it can measure the duration and capture exceptions, if any are present. In addition, you may also inherit from the APIGatewayProxyFunction. For an example, see below: Async handler function public override Task<int> FunctionHandlerAsync(ILambdaContext lambdaContext) { // This call will block by calling task.Result Task<int> task = new TracingRequestHandler().LambdaWrapper( ActualFunctionHandlerAsync, lambdaContext); return task; } public Task<APIGatewayProxyResponse> ActualFunctionHandlerAsync(ILambdaContext lambdaContext) { // Function can make other async operations here ... } Inheriting from APIGatewayProxyFunction public class LambdaFunction : APIGatewayProxyFunction { static LambdaFunction() { // Register The NewRelic Lambda Tracer Instance OpenTracing.Util.GlobalTracer.Register(NewRelic.OpenTracing.AmazonLambda.LambdaTracer.Instance); } public override Task<APIGatewayProxyResponse> FunctionHandlerAsync(APIGatewayProxyRequest request, ILambdaContext lambdaContext) { Task<APIGatewayProxyResponse> task = new TracingRequestHandler().LambdaWrapper(ActualFunctionHandlerAsync, request, lambdaContext); return task; } public Task<APIGatewayProxyResponse> ActualFunctionHandlerAsync(APIGatewayProxyRequest request, ILambdaContext lambdaContext) { return base.FunctionHandlerAsync(request, lambdaContext); } } Optional for SQS and SNS: Starting in version 1.0 of our .NET Lambda Tracer, distributed tracing support has been added for SQS and SNS. To enable distributed tracing for SQS or SNS you will need to complete the items in this step as well as setup the environment variables in the step that follows this one. Enabling distributed tracing support for SQS and SNS will disable automatic instrumentation for both of SQS and SNS and require the use of these wrappers to instrument them. Set the NEW_RELIC_USE_DT_WRAPPER environment variable to true. To instrument SQS and SNS calls you will need to use the provided wrappers. Using the SQS Wrapper The SQS wrapper supports wrapping the following methods: Amazon.SQS.AmazonSQSClient.SendMessageAsync(...) Amazon.SQS.AmazonSQSClient.SendMessageBatchAsync(...) Examples // SQS Client AmazonSQSClient client = new AmazonSQSClient(\"AWS_SECRET_ACCESS_KEY\", AWS_REGION); // SendMessageRequest SendMessageRequest sendRequest = new SendMessageRequest(\"QUEUE_URI_STRING\", \"An SQS Message\"); Task<SendMessageResponse> responseOne = SQSWrapper.WrapRequest(client.SendMessageAsync, sendRequest); // String-based Task<SendMessageResponse> responseTwo = SQSWrapper.WrapRequest(client.SendMessageAsync, \"QUEUE_URI_STRING\", \"Another SQS Message\"); // SendMessageBatchRequest List<SendMessageBatchRequestEntry> batchEntries = new List<SendMessageBatchRequestEntry>(); batchEntries.Add(new SendMessageBatchRequestEntry(\"id1\", \"First SQS Message\")); batchEntries.Add(new SendMessageBatchRequestEntry(\"id2\", \"Second SQS Message\")); batchEntries.Add(new SendMessageBatchRequestEntry(\"id3\", \"Third SQS Message\")); SendMessageBatchRequest sendBatchRequest = new SendMessageBatchRequest(QUEUE_URI, batchEntries); Task<SendMessageBatchResponse> response = SQSWrapper.WrapRequest(client.SendMessageBatchAsync, sendBatchRequest); // SendMessageBatchRequestEntry List List<SendMessageBatchRequestEntry> moreBatchEntries = new List<SendMessageBatchRequestEntry>(); batchEntries.Add(new SendMessageBatchRequestEntry(\"id4\", \"Fourth SQS Message\")); batchEntries.Add(new SendMessageBatchRequestEntry(\"id5\", \"Fifth SQS Message\")); batchEntries.Add(new SendMessageBatchRequestEntry(\"id6\", \"Sixth SQS Message\")); Task<SendMessageBatchResponse> response = SQSWrapper.WrapRequest(client.SendMessageBatchAsync, moreBatchEntries); Using the SNS Wrapper The SNS wrapper supports wrapping the following methods: Amazon.SimpleNotificationService.AmazonSimpleNotificationServiceClient.PublishAsync(...) Examples // SNS Client AmazonSimpleNotificationServiceClient client = new Amazon.SimpleNotificationService.AmazonSimpleNotificationServiceClient(\"AWS_SECRET_ACCESS_KEY\", AWS_REGION); // PublishRequest - Phone Number PublishRequest phonePublishRequest = new PublishRequest(); phonePublishRequest.PhoneNumber = +1XXX5555100; phonePublishRequest.Message = \"An SNS Message for phones\"; Task<PublishResponse> phoneResponse = SNSWrapper.WrapRequest(client.PublishAsync, phonePublishRequest); // PublishRequest - ARN PublishRequest publishRequest = new PublishRequest(\"TOPIC_ARN\", \"An SNS Message\"); Task<PublishResponse> publishResponse = SNSWrapper.WrapRequest(client.PublishAsync, publishRequest); // String-based without subject Task<PublishResponse> ResponseOne = SNSWrapper.WrapRequest(client.PublishAsync, \"TOPIC_ARN\", \"Another SNS Message\"); // String-based with subject Task<PublishResponse> ResponseTwo = SNSWrapper.WrapRequest(client.PublishAsync, \"TOPIC_ARN\", \"Yet Another SNS Message\", \"A Subject\"); The following environment variables are not required for Lambda monitoring to function but they are required if you want your Lambda functions to be included in distributed traces. To enable distributed tracing, set these environment variables in the AWS Lambda console: NEW_RELIC_ACCOUNT_ID: The account ID the Lambda is reporting to. NEW_RELIC_TRUSTED_ACCOUNT_KEY: This is also the account ID. If your account is a sub-account, this needs to be the account ID for the root/parent account. Ensure that the wrapper function (FunctionWrapper in above example) is set up as the function handler. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. Our wrapper gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next you'll configure CloudWatch to send those logs to New Relic. Node.js To instrument your Node.js Lambda: Download our Node.js agent package and place it in the same directory as your function, ensuring the agent is installed as a dependency in the node_modules directory. Use the Node Package Manager: npm install newrelic --save Install our AWS SDK module alongside the Node.js agent: npm install @newrelic/aws-sdk --save In your Lambda code, require the agent module and the AWS SDK at the top of the file, and wrap the handler function. For example: const newrelic = require('newrelic'); require('@newrelic/aws-sdk'); <Other module loads go under the two require statements above> module.exports.handler = newrelic.setLambdaHandler((event, context, callback) => { // This is your handler function code console.log('Lambda executed'); callback(); }); Optional: You can also add custom events to your Lambda using the recordCustomEvent API. For example: module.exports.handler = newrelic.setLambdaHandler((event, context, callback) => { newrelic.recordCustomEvent(‘MyEventType’, {foo: ‘bar’}); console.log('Lambda executed'); callback(); }); Zip your Lambda function and the Node.js agent folder together. Requirements and recommendations: The New Relic files outside the New Relic agent folder don't need to be included. If your Lambda function file name is, for example, lambda_function.node, we recommend naming your zip file lambda_function.zip. Do not use a tarball. Your Lambda and its associated modules must all be in the zip file's root directory. This means that if you zip a folder that contains the files, it won't work. Upload the zipped file to your AWS Lambda account. In the AWS console, set these environment variables: NEW_RELIC_NO_CONFIG_FILE. Set to true if not using a configuration file. NEW_RELIC_APP_NAME: Your application name. NEW_RELIC_ACCOUNT_ID. Your account ID. NEW_RELIC_TRUSTED_ACCOUNT_KEY. This is also your account ID. If your account is a sub-account, this needs to be the account ID for the root/parent account. Optional: To run the agent in serverless mode outside of AWS in a local environment, set the environment variable NEW_RELIC_SERVERLESS_MODE_ENABLED to true. (When executing this in an AWS Lambda environment, the agent will automatically run in serverless mode. Do not use this variable if you're running in AWS.) Optional: To enable logging in serverless mode, set these environment variables: Set NEW_RELIC_LOG_ENABLED to true. Set NEW_RELIC_LOG to stdout for output to CloudWatch, or set to any writeable file location. The log level is set to info by default. See other log levels. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. Our wrapper gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next you'll configure CloudWatch to send those logs to New Relic. Python To instrument your Python Lambda: Download our Python agent package and place it in the same directory as your function. To do this, use pip: pip install -t . newrelic If you use Homebrew, you may get this error: DistutilsOptionError: must supply either home or prefix/exec-prefix -- not both. For details, see the Homebrew GitHub post. In your Lambda code, import the Python agent module and decorate the handler function using the New Relic decorator. The New Relic package must be imported first in your code. Here's an example: import newrelic.agent newrelic.agent.initialize() @newrelic.agent.lambda_handler() def handler(event, context): ... Optional: You can also add custom events to your Lambda using the record_custom_event API. Here's an example: @newrelic.agent.lambda_handler() def handler(event, context): newrelic.agent.record_custom_event('CustomEvent', {'foo': 'bar'}) … Zip your lambda_function.py and newrelic/ folder together using these guidelines: The New Relic files outside the newrelic/ folder don't need to be included. If your Lambda function file name is, for example, lambda_function.py, name your zip file lambda_function.zip. Do not use a tarball. Your Lambda and its associated modules must all be in the zip file's root directory. This means that if you zip a folder that contains the files, it won't work. Upload the zipped file to your AWS Lambda account. In the AWS console, set this environment variable: NEW_RELIC_SERVERLESS_MODE_ENABLED. Set to true The following environment variables are not required for Lambda monitoring to function but they are required if you want your Lambda functions to be included in distributed traces. To enable distributed tracing, set these environment variables in the AWS console: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED. Set to true. NEW_RELIC_ACCOUNT_ID. Your account ID. NEW_RELIC_TRUSTED_ACCOUNT_KEY. This is also your account ID. If your account is a sub-account, this needs to be the account ID for the root/parent account. Optional: To configure logging, use the NEW_RELIC_LOG and NEW_RELIC_LOG_LEVEL environment variables in the AWS Console. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. The New Relic decorator gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next, configure CloudWatch to send those logs to New Relic. Step 4. Configure CloudWatch logs to stream to New Relic Lambda In this step, you'll link your Lambda function's CloudWatch Logs stream to the newrelic-log-ingestion Lambda that was configured in Step 2. For Node.js and Python: This step isn't necessary if you used the Serverless Framework plugin option in Step 3. This step can be done using the CLI tool or using manual procedures. Use CLI tool Run this command for every Lambda function you want to monitor: newrelic-lambda subscriptions install --function FUNCTION_NAME_#1 Or to set subscription filters for all supported functions run this command:: newrelic-lambda subscriptions install --function all Notes on this command: You should only need one newrelic-log-ingestion Lambda per AWS account and region. You can subscribe as many functions to it as you like. To see more detail about the arguments, including a region-specifying argument, see our GitHub documentation. You may receive a CloudWatch validation error. This doesn't affect data reporting. If you see data reporting in New Relic, disregard that error message. If you have our Logs and want to send all your log data to us (not just Lambda logs), see Stream all logs. Manual procedures Here are the manual procedures performed by the CLI tool: Manual process: Stream CloudWatch logs to New Relic Lambda In Step 2, you set up a newrelic-log-ingestion Lambda function. After you've instrumented your Lambda function (Step 3), the newrelic-lambda subscriptions command links that function's CloudWatch Logs stream to the newrelic-log-ingestion Lambda. To do this manually: Open CloudWatch and select Logs in the left-hand menu, and then select the log group for the function you are monitoring. Select Actions and choose Stream to AWS Lambda. Under Lambda function, select the newrelic-log-ingestion function. Set the Log format to JSON. Set the Subscription filter pattern to ?REPORT ?NR_LAMBDA_MONITORING ?\"Task timed out\". Alternatively, if you are using the LOGGING_ENABLED environment variable stream all your logs to our Logs, leave this field blank. See notes and caveats about this procedure. Make sure the newrelic-log-ingestion Lambda function you select in the method above is in the same AWS region as your Lambda function. What's next? After you complete these steps, here's what you can do next: See data reporting in the Lambda monitoring UI. If you're having trouble finding your data, see Lambda enable troubleshooting. Use configuration settings to fine-tune your data. Our newrelic-log-ingestion function is not updated automatically. For best results and access to latest features, we recommend you occasionally update our Lambda monitoring. Optional: Stream all logs to New Relic If you have log management enabled and want to report all your logs to New Relic, follow these instructions: Go to our newrelic-log-ingestion Lambda and set the LOGGING_ENABLED environment variable to true. It isn't possible to edit existing filter patterns, so they must be removed and re-added: Set the Subscription filter pattern to \"\". Go to the Log group for each monitored Lambda, and remove the newrelic-log-ingestion subscription. Add the subscription filter back, leaving the Subscription filter pattern field blank. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.46213,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Step 1. Install the <em>newrelic</em>-lambda-<em>cli</em> tool",
        "info": "Read about how to install and enable <em>New</em> <em>Relic</em> monitoring for Amazon AWS Lambda. ",
        "body": " CloudWatch logs to <em>New</em> <em>Relic</em> (required) Step 1. Install the newrelic-lambda-<em>cli</em> tool We provide a <em>command</em> line interface (<em>CLI</em>) tool that&#x27;s used in steps 2 through 4. We recommend the <em>CLI</em> because it simplifies some of the work, but you can also perform those steps manually. If you want to understand"
      },
      "id": "5f6c67a464441f3a75eb72d3"
    }
  ],
  "/explore-docs/nr1-subscription": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-29T01:54:08Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 274.29312,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " extension to build your apps. <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em> This table provides descriptions for the <em>New</em> <em>Relic</em> <em>One</em> <em>commands</em>. For more context, including usage and option details, click any individual <em>command</em> or the <em>command</em> category. For details on user permissions, see Authentication and permissions"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "nodeid": 37686,
      "sections": [
        "AWS Lambda monitoring",
        "Get started",
        "Enable Lambda monitoring",
        "UI and data",
        "Troubleshooting",
        "Update serverless monitoring for AWS Lambda",
        "Update our Lambda integration via CLI",
        "Update Layers via CLI",
        "Update a manual Serverless Application Repository install",
        "Enabling log management",
        "For more help"
      ],
      "title": "Update serverless monitoring for AWS Lambda",
      "category_0": "Serverless function monitoring",
      "type": "docs",
      "category_1": "AWS Lambda monitoring",
      "external_id": "9241e43c2db3e0298407449d530fa8fe601c1833",
      "image": "",
      "url": "https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/update-serverless-monitoring-aws-lambda",
      "published_at": "2020-09-27T17:16:01Z",
      "updated_at": "2020-09-24T13:54:59Z",
      "breadcrumb": "Contents / Serverless function monitoring / AWS Lambda monitoring / Enable Lambda monitoring",
      "document_type": "page",
      "popularity": 1,
      "info": "How to update our Serverless monitoring for AWS Lambda. ",
      "body": "After enabling our monitoring for AWS Lambda, you should occasionally update our Lambda function that's used to report AWS log data: newrelic-log-ingestion. There are two ways to do this: Update via CLI: Use this if you enabled our Lambda monitoring using our CLI tool. Update via AWS Serverless Application Repository: Use this if you enabled using the manual procedure. These update procedures apply to our serverless monitoring for AWS Lambda, and not to our infrastructure monitoring for AWS Lambda integration. Update our Lambda integration via CLI This section describes how to update if your Lambda monitoring was enabled using our recommended CLI tool. Make sure you have the latest version of the CLI: pip install --upgrade newrelic-lambda-cli For each region in which you've installed the newrelic-log-ingestion function, run the following command, replacing YOUR_REGION with your region identifier (for example, us-west-2). newrelic-lambda integrations update \\ --aws-region YOUR_REGION If you do not have our logs enabled, you'll also need to update your AWS CloudWatch log subscription filters with the following command: newrelic-lambda subscriptions install \\ --function installed \\ --aws-region YOUR_REGION Update Layers via CLI This section describes how to update your function's Layer if you installed it with our CLI tool. Make sure you have the latest version of the CLI: pip install --upgrade newrelic-lambda-cli Pass the --upgrade flag to the install command: newrelic-lambda layers install \\ --function installed \\ --nr-account-id NR_ACCOUNT_ID \\ --upgrade Update a manual Serverless Application Repository install If you manually installed the ingest function from the AWS Serverless Application Repository (and didn't use the CLI), update using this procedure: Run the following, replacing YOUR_REGION with your region (for example, us-west-2)​. aws serverlessrepo create-cloud-formation-change-set \\ --application-id arn:aws:serverlessrepo:us-east-1:463657938898:applications/NewRelic-log-ingestion \\ --stack-name NewRelic-log-ingestion \\ --capabilities CAPABILITY_RESOURCE_POLICY \\ --region YOUR_REGION This command outputs several fields, one of which is the ChangeSetId: an ARN for the change set that you just created. Copy that ARN. Use the ARN in this command, which executes the change set: aws cloudformation execute-change-set --change-set-name YOUR_CHANGE_SET_ARN Enabling log management If you currently don't have New Relic's log management enabled, but would like to: Make sure you have the latest version of the CLI: pip install --upgrade newrelic-lambda-cli For each region in which you've installed the newrelic-log-ingestion function, run the following command, replacing YOUR_REGION with your region (for example, us-west-2). newrelic-lambda integrations update \\ --enable-logs \\ --aws-region YOUR_REGION Then update your AWS CloudWatch log subscription filters for each region with the following command: newrelic-lambda subscriptions install \\ --function installed \\ --filter-pattern \"\" \\ --aws-region YOUR_REGION For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.26285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Update our Lambda integration via <em>CLI</em>",
        "body": " YOUR_CHANGE_SET_ARN Enabling log management If you currently don&#x27;t have <em>New</em> <em>Relic</em>&#x27;s log management enabled, but would like to: Make sure you have the latest version of the <em>CLI</em>: pip install --upgrade newrelic-lambda-<em>cli</em> For each region in which you&#x27;ve installed the newrelic-log-ingestion function, run the following"
      },
      "id": "5f6ca534196a67b08750423e"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-09-29T01:52:56Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Copy Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.2712,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "nodeid": 27692,
      "sections": [
        "AWS Lambda monitoring",
        "Get started",
        "Enable Lambda monitoring",
        "UI and data",
        "Troubleshooting",
        "Enable serverless monitoring for AWS Lambda",
        "How Lambda monitoring works",
        "Enable procedure overview",
        "Step 1. Install the newrelic-lambda-cli tool",
        "CLI requirements",
        "CLI installation",
        "Step 2. Connect AWS to New Relic",
        "Use CLI tool",
        "Manual procedures",
        "Step 3. Enable Lambda instrumentation",
        "Step 4. Configure CloudWatch logs to stream to New Relic Lambda",
        "What's next?",
        "Optional: Stream all logs to New Relic",
        "For more help"
      ],
      "title": "Enable serverless monitoring for AWS Lambda",
      "category_0": "Serverless function monitoring",
      "type": "docs",
      "category_1": "AWS Lambda monitoring",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/enable-serverless-monitoring-aws-lambda",
      "external_id": "7992b896d4c35ca29aba34698aedd621dfe0b572",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-lambda-monitoring-architecture.png",
      "url": "https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/enable-serverless-monitoring-aws-lambda",
      "published_at": "2020-09-28T01:01:03Z",
      "updated_at": "2020-09-24T09:32:20Z",
      "breadcrumb": "Contents / Serverless function monitoring / AWS Lambda monitoring / Enable Lambda monitoring",
      "document_type": "page",
      "popularity": 1,
      "info": "Read about how to install and enable New Relic monitoring for Amazon AWS Lambda. ",
      "body": "Serverless monitoring for AWS Lambda offers in-depth performance monitoring for your Lambda functions. Read on to learn how to enable this feature and get started using it. Using this feature may result in AWS charges. For more information, see the Lambda monitoring requirements.​​​ How Lambda monitoring works Before enabling Lambda monitoring, understanding how data flows from your Lambda functions to New Relic may be helpful: Diagram showing how data flows from a Lambda function to New Relic. When our Lambda monitoring is enabled, this is how data moves from your Lambda function to New Relic: The Lambda function is instrumented with our code. When the Lambda is invoked, log data is sent to CloudWatch. CloudWatch collects Lambda log data and sends it to our log-ingestion Lambda. The log-ingestion Lambda sends that data to New Relic. Enable procedure overview If you already have a New Relic account and use Node.js or Python, we recommend you use our automated installer. If you do not use the automated installer, complete these steps to set up monitoring: Install our CLI tool (recommended) Connect AWS and New Relic (required) Enable instrumentation of your Lambda (required) Stream CloudWatch logs to New Relic (required) Step 1. Install the newrelic-lambda-cli tool We provide a command line interface (CLI) tool that's used in steps 2 through 4. We recommend the CLI because it simplifies some of the work, but you can also perform those steps manually. If you want to understand what it does before you install it, see the manual procedures that the CLI tool performs in Step 2, Step 3 (option 2), and Step 4. You can also see the CLI documentation on GitHub. If you prefer a manual install, skip to Step 2. Connect AWS to New Relic. CLI requirements To use the CLI too, you need: Python 3.3 or higher The AWS CLI You must be a user or admin with an infrastructure manager Add-on role. Your AWS account needs permissions for creating IAM resources (Role and Policy) and Lambda functions. These resources are created using CloudFormation stacks, so you'll need permissions to create those. For more on permissions, including setting custom policies, expand this collapser: AWS permissions details Resource: * Actions: \"cloudformation:CreateChangeSet\", \"cloudformation:CreateStack\", \"cloudformation:DescribeStacks\", \"cloudformation:ExecuteChangeSets\", \"iam:AttachRolePolicy\", \"iam:CreateRole\", \"iam:GetRole\", \"iam:PassRole\", \"lambda:AddPermission\", \"lambda:CreateFunction\", \"lambda:GetFunction\", \"logs:DeleteSubscriptionFilter\", \"logs:DescribeSubscriptionFilters\", \"logs:PutSubscriptionFilter\" \"s3:GetObject\" \"serverlessrepo:CreateCloudFormationChangeSet\" Resource: \"arn:aws:serverlessrepo:us-east-1:463657938898:applications/NewRelic-log-ingestion\" Actions: \"serverlessrepo:CreateCloudFormationTemplate\" \"serverlessrepo:GetCloudFormationTemplate\" Be sure that the AWS account you use to execute the CLI has all of these permissions. If your AWS account permissions are restrictive and you're unable to use the CLI, you can optionally use a manually managed custom IAM policy. This policy would require, at minimum, the following permissions: Resource: \"*\" Action: \"cloudwatch:GetMetricStatistics\" \"cloudwatch:ListMetrics\" \"cloudwatch:GetMetricData\" \"lambda:GetAccountSettings\" \"lambda:ListFunctions\" \"lambda:ListAliases\" \"lambda:ListTags\" \"lambda:ListEventSourceMappings\" These permissions are the minimum required. We recommend granting a managed ReadOnlyAccess policy as described in Connect AWS to infrastructure monitoring. CLI installation To install the CLI tool: Ensure you have the required permissions for both your New Relic and AWS account. From the command line, run: pip install newrelic-lambda-cli You may need to use pip3 in the command above if you have Python 2.7 installed. The CLI requires Python >=3.3. Step 2. Connect AWS to New Relic You must complete this step, and steps 3 and 4, to enable our Lambda monitoring. This step connects AWS to New Relic and creates a newrelic-log-ingestion Lambda function that sends your instrumented data to New Relic. You can either use the CLI tool or do the steps manually. Use CLI tool When you use the CLI, you have one optional step and one required step: Optional: If you're using multiple AWS profiles or multiple regions, you may want to configure the AWS environment variables: AWS environment variable instructions Setting the region To configure your region, use this environment variable to override the default region: export AWS_DEFAULT_REGION=MY_REGION # us-west-2, for example The CLI tool also allows passing this per-command using --aws-region. Setting profiles If you have multiple AWS profiles and don't want to use the default, use AWS_PROFILE environment variable to set another profile name. Ensure the profile is properly configured (including the default region). Example: export AWS_PROFILE=MY_PROFILE Run the following command using the CLI tool: newrelic-lambda integrations install --nr-account-id YOUR_ACCOUNT_ID \\ --linked-account-name YOUR_LINKED_ACCOUNT_NAME \\ --nr-api-key YOUR_NR_API_KEY This command: Connects your AWS account to New Relic. Installs a newrelic-log-ingestion Lambda that will send your instrumented data to New Relic. More details: This defaults to U.S. region. If your account is in the EU region, add this argument: --nr-region \"eu\". If you're instrumenting functions in multiple AWS regions, this command must be run for each region using the --aws-region argument. YOUR_LINKED_ACCOUNT_NAME is either a new AWS account you want to link to New Relic, or it's the name of the AWS account that you linked to when setting up the AWS Lambda monitoring integration. YOUR_NR_API_KEY refers to your personal API key (not your REST API key). For more on the API key and other arguments, see our Lambda monitoring GitHub repo. Manual procedures Here are the manual procedures performed by the CLI tool: Connect AWS to New Relic The newrelic-lambda integration command connects the AWS account containing your Lambdas to New Relic. If you've already installed one of our AWS integrations, your accounts should be linked to New Relic and you can skip this section. To manually establish this connection, follow the instructions for connecting AWS to Infrastructure monitoring. Configure our log-ingestion Lambda The newrelic-lambda integration command sets up a newrelic-log-ingestion Lambda. This Lambda takes the logs generated by your Lambda functions and pushes those logs to New Relic. If you're configuring this manually, you must configure our Lambda for the regions you want. The CLI, by default, establishes our Lambda in all regions. To manually configure our Lambda, go to the AWS Serverless Application Repository, which is where the newrelic-log-ingestion Lambda is stored. This repo is a collection of serverless applications published by developers, companies, and partners in the serverless community. It allows developers to share their Lambda functions code with customers, who can then find and deploy the corresponding application Lambda function. Each application is packaged with an AWS Serverless Application Model (SAM) template that defines the AWS resources used. To manually configure our Lambda with the AWS Serverless Application Repository: From the AWS console, go to the Lambda section, select Create function, and select Serverless Application Repository. Search for newrelic and find the newrelic-log-ingestion Lambda. Follow the instructions in the Lambda's documentation to deploy it. A SAM template will build the Lambda. In the environment variable section in AWS console, set the LICENSE_KEY environment variable to your New Relic license key. Note: If you have multiple accounts or a master and sub-account hierarchy, make sure the license key you're using matches the same account connected to AWS. Optional: If you want to stream all your logs to New Relic, set the LOGGING_ENABLED environment variable to true. For more on this, see Stream all logs. Step 3. Enable Lambda instrumentation This step enables instrumentation of your Lambda function, which allows detailed monitoring and alerting functionality. Our instrumentation is designed to have minimal impact on your Lambda performance. If you're using Node.js or Python, we recommend the first two options. Option #1: Use Serverless Framework plugin (Node.js and Python) Requirements Available only for Node.js and Python. For other languages, see Manual instrumentation. Serverless Framework version 1.34.0 or higher. Features If you meet the requirements (above), you can use our Serverless Framework plugin, which allows you to add our AWS Lambda Layer to your functions without requiring a code change. Supports Node.js and Python runtimes No code change required to enable Lambda instrumentation Enables our APM agent functionality using a single layer Configures CloudWatch subscription filters automatically Gets the layer into your code base which is useful for redeploys Install To install our Serverless Framework plugin: Choose an install option: NPM: npm install --save-dev serverless-newrelic-lambda-layers yarn: yarn add --dev serverless-newrelic-lambda-layers Add the plugin to your serverless.yml: plugins: - serverless-newrelic-lambda-layers Get your account ID and put it in the serverless.yml: custom: newRelic: accountId: YOUR_ACCOUNT_ID Deploy it: sls deploy You can skip Step 4. Setting up CloudWatch Logs. This is automatically completed on deploy by our Serverless Framework plugin. For the next step, go to What's next? Option #2: Add Lambda Layer with our CLI (Node.js and Python) Available only for Node.js and Python. For other languages, see Manual instrumentation. If you don’t have Serverless Framework and don't intend to redeploy your function frequently, you can use the CLI to add our Lambda Layer: If you haven't already done so, install the CLI: pip install newrelic-lambda-cli List available functions: newrelic-lambda functions list Pass the option -f not-installed to see which functions have not yet been instrumented. Add the layer to your function: newrelic-lambda layers install --function FUNCTION_NAME --nr-account-id NEW_RELIC_ACCOUNT_ID Next, you will configure CloudWatch to send logs to New Relic. Option #3: Manually add our Lambda Layer (Node.js and Python) Available only for Node.js and Python. For other languages, see Manual instrumentation. If you don’t have Serverless Framework, you can manually add our Lambda Layer: Find the layer that matches your runtime and region. Copy the Amazon Resource Name (ARN) of the most recent version and add it in the AWS Lambda console for your function. Update your functions handler to point to the newly attached layer in the console for your function: Python: newrelic_lambda_wrapper.handler Node: newrelic-lambda-wrapper.handler Add these environment variables to your Lambda console: NEW_RELIC_ACCOUNT_ID: Your account ID NEW_RELIC_LAMBDA_HANDLER: Path to your initial handler. If you have Node 8 and get a Lambda can't find file error message, expand this collapser: Node 8 \"can't find file\" error troubleshooting If you have Node 8 and receive a Lambda can't find the file newrelic-lambda-wrapper.js message, it's likely that the Node runtime isn't resolving NPM_PATH for the newrelic-lambda module in /opt/nodejs/node_modules. These steps should fix this problem: Create a newrelic-wrapper-helper.js script in your project's root. The script's contents should be module.exports = require('newrelic-lambda-wrapper');. (That is all that needs to be in that script.) Update the handler for your layer declaration to newrelic-lambda-wrapper.handler. Next, you will configure CloudWatch to send logs to New Relic. Option #4: Manually instrument Lambda code for Go, Java, .NET Core, Node.js, and Python If none of the previous options work for you, you can manually instrument your Lambda code. Choose your language: Go To instrument your Go-language Lambda: Download our Go agent package and place it in the same directory as your function. Install the agent: go get -u github.com/newrelic/go-agent. In your Lambda code, import our components, create an application, and update how you start your Lambda. See our GitHub repo for an example of an instrumented Lambda. Optional: Add custom events that will be associated with your Lambda invocation by using the RecordCustomEvent API. For example: func handler(ctx context.Context) { if txn := newrelic.FromContext(ctx); nil != txn { txn.Application().RecordCustomEvent(\"MyEvent\", map[string]interface{}{ \"zip\": \"zap\", }) } fmt.Println(\"hello world!\") } Build and zip your Lambda function and upload it to AWS. Zip and upload recommendations Here are suggestions for zipping and uploading the Lambda: Build the binary for execution on Linux. This produces a binary file called main. You can use: $ GOOS=linux go build -o main Zip the binary into a deployment package using: $ zip deployment.zip main Upload the zip file to AWS using either the AWS Lambda console or the AWS CLI. Name the handler main (to match the name given during the binary build). The following environment variables are not required for Lambda monitoring to function but they are required if you want your Lambda functions to be included in distributed traces. To enable distributed tracing, set these environment variables in the AWS console: NEW_RELIC_ACCOUNT_ID. Your account ID. NEW_RELIC_TRUSTED_ACCOUNT_KEY. This is also your account ID. If your account is a sub-account, this is the account ID for the root/parent account. Optional: To configure logging, see Go agent logging. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. Our wrapper gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next, you'll configure CloudWatch to send those logs to New Relic. Java Monitoring for AWS Lambda in Java doesn't use our APM Java agent. Instead, it uses these two OpenTracing dependencies: AWS Lambda OpenTracing Java SDK: OpenTracing instrumentation for AWS Lambda RequestHandler and RequestStreamHandler. Our AWS Lambda OpenTracing Tracer: An OpenTracing Tracer implementation designed to monitor AWS Lambda. It generates spans, error events, transaction events, error traces, and provides distributed tracing support. Supported OpenTracing Versions OpenTracing 0.31.0: Lambda Tracer: com.newrelic.opentracing:newrelic-java-lambda:1.1.1 Lambda SDK: com.newrelic.opentracing:java-aws-lambda:1.0.0 OpenTracing 0.32.0, 0.33.0: Lambda Tracer: com.newrelic.opentracing:newrelic-java-lambda:2.1.1 Lambda SDK: com.newrelic.opentracing:java-aws-lambda:2.1.0 To instrument your Java Lambda: In your project’s build.gradle file, include our OpenTracing AWS Lambda Tracer and the AWS Lambda OpenTracing SDK dependencies: dependencies { compile(\"com.newrelic.opentracing:java-aws-lambda:2.1.0\") compile(\"com.newrelic.opentracing:newrelic-java-lambda:2.1.1\") compile(\"io.opentracing:opentracing-util:0.33.0\") } Implement the AWS Lambda RequestHandler interface as shown in the Java Lambda example and override the doHandleRequest method. In the doHandleRequest method, call the LambdaTracing.instrument(...) API to create a root span to trace the lambda function's execution. This is also where you will define your business logic for the lambda function. Register a LambdaTracer.INSTANCE as the OpenTracing Global tracer, as shown in the Java Lambda example. Create a ZIP deployment package and upload it to AWS Lambda. Or deploy it via other means. In the AWS Lambda console, set the handler. For the example Java Lambda, the handler would be com.handler.example.MyLambdaHandler::handleRequest. Because handleRequest is assumed, you could also use com.handler.example.MyLambdaHandler. The following AWS console environment variables are required if you want your Lambda function to be included in distributed tracing. This is recommended. NEW_RELIC_ACCOUNT_ID. Your account ID. NEW_RELIC_PRIMARY_APPLICATION_ID. This is also your account ID. NEW_RELIC_TRUSTED_ACCOUNT_KEY. This is also your account ID. If your account is a sub-account, this must be the account ID for the root/parent account. Optional: In the Lambda console, enable debug logging by adding this environment variable: NEW_RELIC_DEBUG is true. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. Our wrapper gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next, you'll configure CloudWatch to send those logs to New Relic. Please see the AWS Lambda distributed tracing example for a complete project that illustrates common use cases such as: Distributed tracing between Lambda functions Manual span creation (aka custom instrumentation) Tracing external calls Adding custom attributes (aka Tags) to spans .NET Core Our monitoring of .NET Core-based AWS Lambda functions doesn't use our standard .NET Core APM agent. Instead, it uses a NuGet package. To instrument your .NET Core Lambda: In your Lambda Functions project, install the NewRelic.OpenTracing.AmazonLambda.Tracer NuGet package. Import the NuGet package and OpenTracing utils: using OpenTracing.Util; using NewRelic.OpenTracing.AmazonLambda; Instrument your function, as shown in this example: public class Function { static Function() { // Register The NewRelic Lambda Tracer Instance GlobalTracer.Register(NewRelic.OpenTracing.AmazonLambda.LambdaTracer.Instance); } public object FunctionWrapper(ILambdaContext context) { // Instantiate NewRelic TracingWrapper and pass your FunctionHandler as // an argument return new TracingRequestHandler().LambdaWrapper(FunctionHandler, context); } /// <summary> /// A simple function that takes a string and does a ToUpper /// </summary> /// <param name=\"input\"></param> /// <param name=\"context\"></param> /// <returns></returns> public object FunctionHandler(ILambdaContext context) { ... } } The arguments passed to FunctionWrapper must match the signature of FunctionHandler. If your handler function returns a Task, the Lambda wrapper will block on the return task until it completes, so that it can measure the duration and capture exceptions, if any are present. In addition, you may also inherit from the APIGatewayProxyFunction. For an example, see below: Async handler function public override Task<int> FunctionHandlerAsync(ILambdaContext lambdaContext) { // This call will block by calling task.Result Task<int> task = new TracingRequestHandler().LambdaWrapper( ActualFunctionHandlerAsync, lambdaContext); return task; } public Task<APIGatewayProxyResponse> ActualFunctionHandlerAsync(ILambdaContext lambdaContext) { // Function can make other async operations here ... } Inheriting from APIGatewayProxyFunction public class LambdaFunction : APIGatewayProxyFunction { static LambdaFunction() { // Register The NewRelic Lambda Tracer Instance OpenTracing.Util.GlobalTracer.Register(NewRelic.OpenTracing.AmazonLambda.LambdaTracer.Instance); } public override Task<APIGatewayProxyResponse> FunctionHandlerAsync(APIGatewayProxyRequest request, ILambdaContext lambdaContext) { Task<APIGatewayProxyResponse> task = new TracingRequestHandler().LambdaWrapper(ActualFunctionHandlerAsync, request, lambdaContext); return task; } public Task<APIGatewayProxyResponse> ActualFunctionHandlerAsync(APIGatewayProxyRequest request, ILambdaContext lambdaContext) { return base.FunctionHandlerAsync(request, lambdaContext); } } Optional for SQS and SNS: Starting in version 1.0 of our .NET Lambda Tracer, distributed tracing support has been added for SQS and SNS. To enable distributed tracing for SQS or SNS you will need to complete the items in this step as well as setup the environment variables in the step that follows this one. Enabling distributed tracing support for SQS and SNS will disable automatic instrumentation for both of SQS and SNS and require the use of these wrappers to instrument them. Set the NEW_RELIC_USE_DT_WRAPPER environment variable to true. To instrument SQS and SNS calls you will need to use the provided wrappers. Using the SQS Wrapper The SQS wrapper supports wrapping the following methods: Amazon.SQS.AmazonSQSClient.SendMessageAsync(...) Amazon.SQS.AmazonSQSClient.SendMessageBatchAsync(...) Examples // SQS Client AmazonSQSClient client = new AmazonSQSClient(\"AWS_SECRET_ACCESS_KEY\", AWS_REGION); // SendMessageRequest SendMessageRequest sendRequest = new SendMessageRequest(\"QUEUE_URI_STRING\", \"An SQS Message\"); Task<SendMessageResponse> responseOne = SQSWrapper.WrapRequest(client.SendMessageAsync, sendRequest); // String-based Task<SendMessageResponse> responseTwo = SQSWrapper.WrapRequest(client.SendMessageAsync, \"QUEUE_URI_STRING\", \"Another SQS Message\"); // SendMessageBatchRequest List<SendMessageBatchRequestEntry> batchEntries = new List<SendMessageBatchRequestEntry>(); batchEntries.Add(new SendMessageBatchRequestEntry(\"id1\", \"First SQS Message\")); batchEntries.Add(new SendMessageBatchRequestEntry(\"id2\", \"Second SQS Message\")); batchEntries.Add(new SendMessageBatchRequestEntry(\"id3\", \"Third SQS Message\")); SendMessageBatchRequest sendBatchRequest = new SendMessageBatchRequest(QUEUE_URI, batchEntries); Task<SendMessageBatchResponse> response = SQSWrapper.WrapRequest(client.SendMessageBatchAsync, sendBatchRequest); // SendMessageBatchRequestEntry List List<SendMessageBatchRequestEntry> moreBatchEntries = new List<SendMessageBatchRequestEntry>(); batchEntries.Add(new SendMessageBatchRequestEntry(\"id4\", \"Fourth SQS Message\")); batchEntries.Add(new SendMessageBatchRequestEntry(\"id5\", \"Fifth SQS Message\")); batchEntries.Add(new SendMessageBatchRequestEntry(\"id6\", \"Sixth SQS Message\")); Task<SendMessageBatchResponse> response = SQSWrapper.WrapRequest(client.SendMessageBatchAsync, moreBatchEntries); Using the SNS Wrapper The SNS wrapper supports wrapping the following methods: Amazon.SimpleNotificationService.AmazonSimpleNotificationServiceClient.PublishAsync(...) Examples // SNS Client AmazonSimpleNotificationServiceClient client = new Amazon.SimpleNotificationService.AmazonSimpleNotificationServiceClient(\"AWS_SECRET_ACCESS_KEY\", AWS_REGION); // PublishRequest - Phone Number PublishRequest phonePublishRequest = new PublishRequest(); phonePublishRequest.PhoneNumber = +1XXX5555100; phonePublishRequest.Message = \"An SNS Message for phones\"; Task<PublishResponse> phoneResponse = SNSWrapper.WrapRequest(client.PublishAsync, phonePublishRequest); // PublishRequest - ARN PublishRequest publishRequest = new PublishRequest(\"TOPIC_ARN\", \"An SNS Message\"); Task<PublishResponse> publishResponse = SNSWrapper.WrapRequest(client.PublishAsync, publishRequest); // String-based without subject Task<PublishResponse> ResponseOne = SNSWrapper.WrapRequest(client.PublishAsync, \"TOPIC_ARN\", \"Another SNS Message\"); // String-based with subject Task<PublishResponse> ResponseTwo = SNSWrapper.WrapRequest(client.PublishAsync, \"TOPIC_ARN\", \"Yet Another SNS Message\", \"A Subject\"); The following environment variables are not required for Lambda monitoring to function but they are required if you want your Lambda functions to be included in distributed traces. To enable distributed tracing, set these environment variables in the AWS Lambda console: NEW_RELIC_ACCOUNT_ID: The account ID the Lambda is reporting to. NEW_RELIC_TRUSTED_ACCOUNT_KEY: This is also the account ID. If your account is a sub-account, this needs to be the account ID for the root/parent account. Ensure that the wrapper function (FunctionWrapper in above example) is set up as the function handler. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. Our wrapper gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next you'll configure CloudWatch to send those logs to New Relic. Node.js To instrument your Node.js Lambda: Download our Node.js agent package and place it in the same directory as your function, ensuring the agent is installed as a dependency in the node_modules directory. Use the Node Package Manager: npm install newrelic --save Install our AWS SDK module alongside the Node.js agent: npm install @newrelic/aws-sdk --save In your Lambda code, require the agent module and the AWS SDK at the top of the file, and wrap the handler function. For example: const newrelic = require('newrelic'); require('@newrelic/aws-sdk'); <Other module loads go under the two require statements above> module.exports.handler = newrelic.setLambdaHandler((event, context, callback) => { // This is your handler function code console.log('Lambda executed'); callback(); }); Optional: You can also add custom events to your Lambda using the recordCustomEvent API. For example: module.exports.handler = newrelic.setLambdaHandler((event, context, callback) => { newrelic.recordCustomEvent(‘MyEventType’, {foo: ‘bar’}); console.log('Lambda executed'); callback(); }); Zip your Lambda function and the Node.js agent folder together. Requirements and recommendations: The New Relic files outside the New Relic agent folder don't need to be included. If your Lambda function file name is, for example, lambda_function.node, we recommend naming your zip file lambda_function.zip. Do not use a tarball. Your Lambda and its associated modules must all be in the zip file's root directory. This means that if you zip a folder that contains the files, it won't work. Upload the zipped file to your AWS Lambda account. In the AWS console, set these environment variables: NEW_RELIC_NO_CONFIG_FILE. Set to true if not using a configuration file. NEW_RELIC_APP_NAME: Your application name. NEW_RELIC_ACCOUNT_ID. Your account ID. NEW_RELIC_TRUSTED_ACCOUNT_KEY. This is also your account ID. If your account is a sub-account, this needs to be the account ID for the root/parent account. Optional: To run the agent in serverless mode outside of AWS in a local environment, set the environment variable NEW_RELIC_SERVERLESS_MODE_ENABLED to true. (When executing this in an AWS Lambda environment, the agent will automatically run in serverless mode. Do not use this variable if you're running in AWS.) Optional: To enable logging in serverless mode, set these environment variables: Set NEW_RELIC_LOG_ENABLED to true. Set NEW_RELIC_LOG to stdout for output to CloudWatch, or set to any writeable file location. The log level is set to info by default. See other log levels. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. Our wrapper gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next you'll configure CloudWatch to send those logs to New Relic. Python To instrument your Python Lambda: Download our Python agent package and place it in the same directory as your function. To do this, use pip: pip install -t . newrelic If you use Homebrew, you may get this error: DistutilsOptionError: must supply either home or prefix/exec-prefix -- not both. For details, see the Homebrew GitHub post. In your Lambda code, import the Python agent module and decorate the handler function using the New Relic decorator. The New Relic package must be imported first in your code. Here's an example: import newrelic.agent newrelic.agent.initialize() @newrelic.agent.lambda_handler() def handler(event, context): ... Optional: You can also add custom events to your Lambda using the record_custom_event API. Here's an example: @newrelic.agent.lambda_handler() def handler(event, context): newrelic.agent.record_custom_event('CustomEvent', {'foo': 'bar'}) … Zip your lambda_function.py and newrelic/ folder together using these guidelines: The New Relic files outside the newrelic/ folder don't need to be included. If your Lambda function file name is, for example, lambda_function.py, name your zip file lambda_function.zip. Do not use a tarball. Your Lambda and its associated modules must all be in the zip file's root directory. This means that if you zip a folder that contains the files, it won't work. Upload the zipped file to your AWS Lambda account. In the AWS console, set this environment variable: NEW_RELIC_SERVERLESS_MODE_ENABLED. Set to true The following environment variables are not required for Lambda monitoring to function but they are required if you want your Lambda functions to be included in distributed traces. To enable distributed tracing, set these environment variables in the AWS console: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED. Set to true. NEW_RELIC_ACCOUNT_ID. Your account ID. NEW_RELIC_TRUSTED_ACCOUNT_KEY. This is also your account ID. If your account is a sub-account, this needs to be the account ID for the root/parent account. Optional: To configure logging, use the NEW_RELIC_LOG and NEW_RELIC_LOG_LEVEL environment variables in the AWS Console. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. The New Relic decorator gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next, configure CloudWatch to send those logs to New Relic. Step 4. Configure CloudWatch logs to stream to New Relic Lambda In this step, you'll link your Lambda function's CloudWatch Logs stream to the newrelic-log-ingestion Lambda that was configured in Step 2. For Node.js and Python: This step isn't necessary if you used the Serverless Framework plugin option in Step 3. This step can be done using the CLI tool or using manual procedures. Use CLI tool Run this command for every Lambda function you want to monitor: newrelic-lambda subscriptions install --function FUNCTION_NAME_#1 Or to set subscription filters for all supported functions run this command:: newrelic-lambda subscriptions install --function all Notes on this command: You should only need one newrelic-log-ingestion Lambda per AWS account and region. You can subscribe as many functions to it as you like. To see more detail about the arguments, including a region-specifying argument, see our GitHub documentation. You may receive a CloudWatch validation error. This doesn't affect data reporting. If you see data reporting in New Relic, disregard that error message. If you have our Logs and want to send all your log data to us (not just Lambda logs), see Stream all logs. Manual procedures Here are the manual procedures performed by the CLI tool: Manual process: Stream CloudWatch logs to New Relic Lambda In Step 2, you set up a newrelic-log-ingestion Lambda function. After you've instrumented your Lambda function (Step 3), the newrelic-lambda subscriptions command links that function's CloudWatch Logs stream to the newrelic-log-ingestion Lambda. To do this manually: Open CloudWatch and select Logs in the left-hand menu, and then select the log group for the function you are monitoring. Select Actions and choose Stream to AWS Lambda. Under Lambda function, select the newrelic-log-ingestion function. Set the Log format to JSON. Set the Subscription filter pattern to ?REPORT ?NR_LAMBDA_MONITORING ?\"Task timed out\". Alternatively, if you are using the LOGGING_ENABLED environment variable stream all your logs to our Logs, leave this field blank. See notes and caveats about this procedure. Make sure the newrelic-log-ingestion Lambda function you select in the method above is in the same AWS region as your Lambda function. What's next? After you complete these steps, here's what you can do next: See data reporting in the Lambda monitoring UI. If you're having trouble finding your data, see Lambda enable troubleshooting. Use configuration settings to fine-tune your data. Our newrelic-log-ingestion function is not updated automatically. For best results and access to latest features, we recommend you occasionally update our Lambda monitoring. Optional: Stream all logs to New Relic If you have log management enabled and want to report all your logs to New Relic, follow these instructions: Go to our newrelic-log-ingestion Lambda and set the LOGGING_ENABLED environment variable to true. It isn't possible to edit existing filter patterns, so they must be removed and re-added: Set the Subscription filter pattern to \"\". Go to the Log group for each monitored Lambda, and remove the newrelic-log-ingestion subscription. Add the subscription filter back, leaving the Subscription filter pattern field blank. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.98871,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Step 1. Install the <em>newrelic</em>-lambda-<em>cli</em> tool",
        "info": "Read about how to install and enable <em>New</em> <em>Relic</em> monitoring for Amazon AWS Lambda. ",
        "body": " CloudWatch logs to <em>New</em> <em>Relic</em> (required) Step 1. Install the newrelic-lambda-<em>cli</em> tool We provide a <em>command</em> line interface (<em>CLI</em>) tool that&#x27;s used in steps 2 through 4. We recommend the <em>CLI</em> because it simplifies some of the work, but you can also perform those steps manually. If you want to understand"
      },
      "id": "5f6c67a464441f3a75eb72d3"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2020-09-29T01:52:56Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.02564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em> Here&#x27;s a list of common <em>commands</em> to get you started with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    }
  ]
}