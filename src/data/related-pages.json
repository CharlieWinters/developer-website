{
  "/automate-workflows/5-mins-tag-resources": [
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Get your application details",
        "Add a simple tag to your application",
        "Bonus step: Create a deployment marker",
        "Next steps"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2020-10-24T01:53:25Z",
      "updated_at": "2020-10-24T01:53:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Get started with the New Relic CLI 20 min Access the New Relic platform from the comfort of your terminal: you can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. Our CLI has been designed for automating common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic personal API Key, which you can create from the Account settings of your New Relic account An instrumented application in your New Relic account Step 1 of 10 Install the New Relic CLI The New Relic CLI can be downloaded via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile Now that you've installed the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. To create your first CLI profile, run the profiles add command. Note that you need to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_API_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Step 3 of 10 Get your application details In this example, you are going to add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 The New Relic CLI can retrieve your application details as a JSON object. To search for your APM application use the apm application search command. If you get an error, check that the account ID and application name you provided are correct. bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Step 5 of 10 If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example. When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. [ { accountId: YOUR_ACCOUNT_ID, applicationId: YOUR_APP_ID, domain: 'APM', entityType: 'APM_APPLICATION_ENTITY', guid: 'A_LONG_GUID', name: 'NAME_OF_YOUR_APP', permalink: 'https://one.newrelic.com/redirect/entity/A_LONG_GUID', reporting: true, type: 'APPLICATION', }, ]; Copy Step 6 of 10 Add a simple tag to your application Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Let's suppose that you want to add an environment tag to your application. Go ahead and add the dev:testing tag‚Å† (or any other key-value pair) to your application using the entities tags create command. bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 What if you want to add multiple tags? Tag sets come to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags at once to your application, modify and run the following snippet. bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 You've created and added some tags to your application, but how do you know they're there? You need to retrieve your application's tags. To retrieve your application's tags, use the entity tags get command. newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Step 9 of 10 Bonus step: Create a deployment marker Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same Application ID from your earlier search. bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Notice that the JSON response includes the revision and timestamp of the deployment. This workflow could be built into a continuous integration or continuous deployment (CI/CD) system to help indicate changes in your application's behavior after deployments. Here is an example. { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands. For example, you could create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.3046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " to your application Now that you have the GUID, you can point the <em>New</em> <em>Relic</em> <em>CLI</em> directly at your application. Adding a <em>tag</em> is the simplest way to try out the <em>CLI</em> capabilities (don&#x27;t worry, <em>tags</em> can be deleted by using entity <em>tags</em> delete). Let&#x27;s suppose that you want to add an environment <em>tag</em> to your"
      },
      "id": "5efa999c196a67c4e1766461"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0 EMEA",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-10-24T01:40:08Z",
      "title": "New Relic Developers",
      "updated_at": "2020-10-24T01:38:33Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 EMEA Nerd Days is a FREE engineering conference that kicks off November 10 (EMEA). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 17 Days : 8 Hours : 31 Minutes : 16 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application ¬† Add custom attributes Use custom attributes for deeper analysis Show 21 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.22885,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": ", agents, OS emitters - get any data 20 min Automate common tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application ¬† Add custom"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts"
      ],
      "published_at": "2020-10-24T01:51:46Z",
      "title": "Automate workflows",
      "updated_at": "2020-10-24T01:51:46Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.13232,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly <em>tag</em> resources Add <em>tags</em> to apps for easy filtering 30 min Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up <em>New</em> <em>Relic</em> using"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "Explore NerdGraph using the API Explorer",
        "Before you begin",
        "Build a query to retrieve your name",
        "Click the play button to see the result",
        "Add more fields to your query",
        "Experiment with mutations",
        "Tip",
        "Try your NerdGraph query in the terminal",
        "Next steps"
      ],
      "title": "Explore NerdGraph using the API Explorer",
      "type": "developer",
      "tags": [
        "nerdgraph",
        "mutations",
        "nerdgraph query terminal"
      ],
      "external_id": "df1f04edc2336c69769d946edbaf263a5339bc92",
      "image": "https://developer.newrelic.com/static/0ce8c387a290d7fbd6be155322be9bce/bc8d6/create-account.png",
      "url": "https://developer.newrelic.com/collect-data/get-started-nerdgraph-api-explorer/",
      "published_at": "2020-10-24T01:53:26Z",
      "updated_at": "2020-10-24T01:53:26Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Explore NerdGraph, our GraphQL API, and build the queries you need.",
      "body": "Explore NerdGraph using the API Explorer 25 min NerdGraph is New Relic's GraphQL API. It allows you to get all the information you need in a single request. With NerdGraph API Explorer you don't need to know the query format: using the Query Builder you can browse our entire graph and compose queries just by selecting the items you want and filling out their required values. Before you begin Go to api.newrelic.com/graphiql and log in using your New Relic user ID and password: the NerdGraph API Explorer loads up. Make sure you have a valid New Relic API key. You can create one directly from the NerdGraph API Explorer. Step 1 of 5 Build a query to retrieve your name Time for your first NerdGraph query. Search for your name in the New Relic database: Erase everything in the query editor. Select the following fields in the query explorer in this order: actor, user, name. This GraphQL snippet appears in the editor. { actor { user { name } } } Copy Step 2 of 5 Click the play button to see the result With this query, you're telling NerdGraph to retrieve your name. You're asking for the name field, which is nested within the user field. This refers to the user who owns the API key, which in turn is nested within actor. Click the play button to see the result: It has almost the same shape as the request. All the fields in the Query Builder make up what's called the GraphQL schema, which describes all the available data types and their attributes. To learn more about each field, click the Docs button, or hover over a field in the editor. Step 3 of 5 Add more fields to your query Now you can try adding more fields to your query. The simplest way is clicking the fields in the Query Builder: The API Explorer knows where the attributes should go in the query. In the example, you add the account id and email fields. Once again, running the GraphQL query results in just the data you need, without over or under-fetching data. Notice that the id field has an argument: passing arguments is a powerful way of customizing your NerdGraph queries. Every field and object can contain arguments, so instead of running multiple queries, you just compose the one that you need. { actor { user { name email } account(id: 12345678) } } Copy Step 4 of 5 Experiment with mutations In GraphQL, mutations are a way to execute queries with side effects that can alter the data by creating, updating, or deleting objects (Commonly referred to as CRUD operations in REST APIs). Ready for your first mutation? Erase what's in the editor. Scroll down the Query Builder and expand mutation. Select the fields in the following screenshot: In this case, you're trying to add a custom tag to an entity. Notice that the editor complains if you don't select errors: mutations must have a way of telling you how the operation performed in the backend (failed requests result in null responses). Tip Unlike REST, GraphQL APIs like NerdGraph can return partial responses. For example, if you try adding tags to multiple entities, some mutations can fail and others succeed; all is logged in the GraphQL response you get. Step 5 of 5 Try your NerdGraph query in the terminal Let's say that you've built a NerdGraph query you're happy with and you want to test it elsewhere. To capture code-ready queries and mutations: Select the Tools menu. Copy the query as a curl call or as a New Relic CLI command. bash Copy $ # curl version $ curl https://api.newrelic.com/graphql \\ > -H 'Content-Type: application/json' \\ > -H 'API-Key: API_KEY_REDACTED' \\ > --data-binary '{\"query\":\"{\\n actor {\\n user {\\n name\\n email\\n }\\n account(id: 12345678)\\n }\\n}\\n\", \"variables\":\"\"}' $ $ # New Relic CLI version $ newrelic nerdgraph query '{ $ actor { $ user { $ name $ email $ } $ account(id: 12345678) $ } $ } $ ' Next steps Now you know the basics of composing and testing NerdGraph queries, but how do you turn them into client or server code? Solutions such as GraphQL Code Generator can help you turn the NerdGraph queries into code for your implementation. Try creating more complex queries by clicking fields and expanding objects in the Query Builder (be careful with mutations though, since they could write data to your account). For more information on NerdGraph and explore other projects from the developer community, check out the threads on the Explorer‚Äôs Hub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.93579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Click</em> the play button to see the result",
        "body": " and mutations: Select the Tools menu. Copy the query as a curl call or as a <em>New</em> <em>Relic</em> <em>CLI</em> command. bash Copy $ # curl version $ curl https:&#x2F;&#x2F;api.newrelic.com&#x2F;graphql \\ &gt; -H &#x27;Content-Type: application&#x2F;json&#x27; \\ &gt; -H &#x27;API-Key: API_KEY_REDACTED&#x27; \\ &gt; --data-binary &#x27;{&quot;query&quot;:&quot;{\\n actor {\\n user {\\n name\\n email\\n"
      },
      "id": "5efa9973196a6791f4766402"
    },
    {
      "image": "https://developer.newrelic.com/static/2d91ba8d23ca23b012f2ffb437acc09e/0086b/helloworld-automationdemo.png",
      "url": "https://developer.newrelic.com/automate-workflows/automated-tagging/",
      "sections": [
        "Automate tagging of your entire stack",
        "Before you begin",
        "Collaborate with us",
        "Build the deployer",
        "Configure your credentials",
        "Run the application",
        "Tip",
        "Locating the user configuration files",
        "Understanding the deployment configuration file",
        "Important",
        "Generate some traffic",
        "Check your tags",
        "Tear down your resources",
        "Next steps"
      ],
      "published_at": "2020-10-24T01:53:25Z",
      "title": "Automate tagging of your entire stack",
      "updated_at": "2020-10-24T01:53:25Z",
      "type": "developer",
      "external_id": "0c5d228b6bcee4b456b6ee36920e20da0df962d3",
      "document_type": "page",
      "popularity": 1,
      "info": "A quick demo application that automates the provisioning, deployment, instrumentation, and tagging of a simple app.",
      "body": "Automate tagging of your entire stack 30 min Organizing your services, hosts, and applications in New Relic can be challenging, especially as resources come and go. One strategy to overcome this challenge is to apply tags, consistently, across your stack. In this guide, you: Provision a host on AWS Deploy a small Node.js app on that host Instrument the host and the application with New Relic agents Apply consistent tags across all your entities Tear down everything you make when you're done The next section introduces you to tools for performing tasks in this guide. Before you begin Throughout this guide, you use three open source projects to automatically set up, instrument, and tear down your infrastructure: Demo Deployer: The engine that drives the automation Demo Nodetron: A Node.js app that you run on your host. It presents a web page and an API, which you use to generate traffic. Demo New Relic Instrumentation: A project that instruments your host and application Each project is distinct, and encapsulates its own behavior. This maintains a separation of concerns and allows you to compose complex scenarios using a modular approach. Collaborate with us The Demo Deployer is currently in development. Because of our commitment to open source, we are working in the open early in the process and invite you to collaborate with us. Drop any thoughts and comments in the Build on New Relic support thread, and let us know what you think! The last thing you need before you get started is to install Docker if you don't have it already. Now that you have a high-level understanding of the tools you'll use, you can begin by building the Demo Deployer! Step 1 of 6 Build the deployer To use the deployer, first clone its repository from GitHub. Then, build a Docker image using the local copy of the code. First, clone the repository from GitHub: bash Copy $ git clone https://github.com/newrelic/demo-deployer.git Second, build the deployer Docker image: bash Copy $ docker build -t deployer demo-deployer Now, you have a Docker image, named deployer, which you use throughout the rest of this guide. Step 2 of 6 Configure your credentials In this guide, you provision a host on AWS. The deployer uses a configuration file that contains your credentials for each service it communicates with so that it can invoke the necessary APIs. You can follow the User Config documentation in the deployer repository to set up each account and create your configuration file. In the end, you'll have a JSON file that contains credentials for AWS, New Relic, and GitHub: { \"credentials\": { \"aws\": { \"apiKey\": \"my_aws_api_key\", \"secretKey\": \"my_aws_secret_key\", \"secretKeyPath\": \"/path/to/my/secretkey.pem\", \"region\": \"my_aws_region\" }, \"newrelic\": { \"licenseKey\": \"my_new_relic_license_key\", \"accountId\": \"my_new_relic_account_id\" }, \"git\": { \"username\": \"my_git_access_token\" } } } Copy Name the credentials file creds.json, and store it‚Äîalong with your [keypair filename].pem file‚Äîin a directory called $HOME/configs. Step 3 of 6 Run the application Now that everything is set up, you can run the deployer application in a Docker container: bash Copy $ docker run -it\\ > -v $HOME/configs/:/mnt/deployer/configs/\\ > --entrypoint ruby deployer main.rb -c configs/creds.json -d documentation/tutorial/user_stories/Hello/hello.json With this command, you're running the deployer Docker container with the following options: -v mounts the $HOME/configs volume (where you stored your configuration files) at /mnt/deployer/configs/ in the container --entrypoint sets the default command for Docker to ruby Finally, you pass a list of arguments to the entrypoint, including: -c configs/creds.json: The user credentials configuration file -d documentation/tutorial/user_stories/Hello/hello.json: The deployment configuration file Tip You can specify the log level for the deployer using -l. info is the default, but you can also use debug or error. This is a helpful option to use when something goes wrong. Once you run this command, the deployer will create and instrument some specific resources. This may take a few minutes. In the meantime, read on to learn more about what is actually happening during this process. Locating the user configuration files Notice, in the Docker command, that -c takes configs/creds.json. Also, you referenced your .pem file from configs/, as well. This is because you mounted $HOME/configs to /mnt/deployer/configs/ and /mnt/deployer/ is the working directory, according to the deployer's Dockerfile. So, you can access your user configuration files at configs/, which is a relative path from your working directory. Understanding the deployment configuration file The deployment configuration file, hello.json, which drives the deployer, contains four sections: services global_tags resources instrumentations These sections describe the actions the deployer executes. The first section is services: { \"services\": [ { \"id\": \"app1\", \"display_name\": \"Hello-App1\", \"source_repository\": \"-b main https://github.com/newrelic/demo-nodetron.git\", \"deploy_script_path\": \"deploy/linux/roles\", \"port\": 5001, \"destinations\": [\"host1\"], \"files\": [ { \"destination_filepath\": \"engine/data/index.json\", \"content\": <some content> } ] } ] } Copy services defines one service, app1, which lives on host1 at port 5001. It uses the Demo Nodetron you learned about earlier in this guide as its source. Important In this example, some HTML has been removed for clarity. To run the deployer, you need to use the real content in hello.json. The second section is global_tags: { \"global_tags\": { \"dxOwningTeam\": \"DemoX\", \"dxEnvironment\": \"development\", \"dxDepartment\": \"Area51\", \"dxProduct\": \"Hello\" } } Copy global_tags defines tags for the deployer to apply to all the resources in your stack. These tags are an important part of organizing your New Relic entities. The third section is resources: { \"resources\": [ { \"id\": \"host1\", \"display_name\": \"Hello-Host1\", \"provider\": \"aws\", \"type\": \"ec2\", \"size\": \"t3.micro\" } ], } Copy resources defines one host, host1, which is a small EC2 instance on AWS. This host is referred to in the services section. The fourth, and final, section is instrumentations: { \"instrumentations\": { \"resources\": [ { \"id\": \"nr_infra\", \"resource_ids\": [\"host1\"], \"provider\": \"newrelic\", \"source_repository\": \"-b main https://github.com/newrelic/demo-newrelic-instrumentation.git\", \"deploy_script_path\": \"deploy/linux/roles\", \"version\": \"1.12.1\" } ], \"services\": [ { \"id\": \"nr_node_agent\", \"service_ids\": [\"app1\"], \"provider\": \"newrelic\", \"source_repository\": \"-b main https://github.com/newrelic/demo-newrelic-instrumentation.git\", \"deploy_script_path\": \"deploy/node/linux/roles\", \"version\": \"6.11.0\" } ] } } Copy instrumentations configures, as the name implies, New Relic instrumentations for the host1 infrastructure and the app1 Node.js application. These definitions use the Demo New Relic Instrumentation project you learned about earlier. Step 4 of 6 Generate some traffic When deployer has run successfully, you will see a message that describes the resources deployed and services installed during the process: bash Copy $ [INFO] Executing Deployment $ [‚úî] Parsing and validating Deployment configuration success $ [‚úî] Provisioner success $ [‚úî] Installing On-Host instrumentation success $ [‚úî] Installing Services and instrumentations success $ [INFO] Deployment successful! $ $ Deployed Resources: $ $ host1 (aws/ec2): $ ip: 52.90.86.109 $ services: [\"app1\"] $ instrumentation: $ nr_infra: newrelic v1.12.1 $ $ Installed Services: $ $ app1: $ url: http://52.90.86.109:5001 $ instrumentation: $ nr_node_agent: newrelic v6.11.0 $ $ Completed at 2020-08-20 15:11:14 +0000 Visit your application by navigating to the app1 url in your browser: From there, you can follow the instructions to send traffic to New Relic. Important Your app1 url will be different than the url shown in this guide. Step 5 of 6 Check your tags After you've generated some traffic to your Node.js application, use the New Relic search redirect to find the resources you deployed: Once you have found your resources, select the service you deployed, Hello-App1. Then, click on the 'i' icon next to the name, which opens the metadata and tags modal: Notice that all the tags in the global_tags section of the deployment configuration show up under Tags: If you open the metadata modal for the host, you'll also see the global_tags. Step 6 of 6 Tear down your resources Because you've provisioned resources in your cloud account, you need to decommission them. You can do this with the deployer. Add the teardown flag, -t, to the end of your command: bash Copy $ docker run -it\\ > -v $HOME/configs/:/mnt/deployer/configs/\\ > --entrypoint ruby deployer main.rb -c configs/creds.json -d documentation/tutorial/user_stories/Hello/hello.json -t When the deployer has finished successfully, you'll see output that is similar to what you saw during deployment: bash Copy $ [INFO] Executing Teardown $ [‚úî] Parsing and validating Teardown configuration success $ [‚úî] Provisioner success $ [‚úî] Uninstalling On-Host instrumentation success $ [‚úî] Uninstalling Services and instrumentations success $ [‚úî] Terminating infrastructure success $ [INFO] Teardown successful! Next steps Congratulations! Throughout this guide, you used the Demo Deployer to provision and instrument a host and application in AWS and automatically configured those entities with a list of tags. Next, try creating your own deployment configuration and change the global tags! One cool thing you can do is pass in a configuration file URL to the deployer. Here's one that uses a gist on GitHub: bash Copy $ docker run -it\\ > -v $HOME/configs/:/mnt/deployer/configs/\\ > --entrypoint ruby deployer main.rb -c configs/creds.json -d https://gist.githubusercontent.com/markweitzel/d281fde8ca572ced6346dc25470790a5/raw/373166eb50929a0dd23ba5136abf2fa5caf3d369/MarksHelloDemoConfig.json",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.31774,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Automate <em>tagging</em> of your entire stack",
        "sections": "Automate <em>tagging</em> of your entire stack",
        "info": "A quick demo application that automates the provisioning, deployment, instrumentation, and <em>tagging</em> of a simple app.",
        "body": "Automate tagging of your entire stack 30 min Organizing your services, hosts, and applications in <em>New</em> <em>Relic</em> can be challenging, especially as resources come and go. One strategy to overcome this challenge is to apply <em>tags</em>, consistently, across your stack. In this guide, you: Provision a host on AWS"
      },
      "id": "5f40792e196a6757721cd49c"
    }
  ],
  "/automate-workflows/get-started-terraform": [
    {
      "nodeid": 40926,
      "sections": [
        "Recent Announcements",
        "Issue summary and analysis in Applied Intelligence"
      ],
      "title": "Issue summary and analysis in Applied Intelligence",
      "type": "docs",
      "external_id": "6a03b1c31cb3c9c6f3a9951eb330f64aa85b8898",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/whats_up_ai_summary.png",
      "url": "https://docs.newrelic.com/whats-new/issue-summary-analysis-applied-intelligence",
      "published_at": "2020-10-22T09:19:56Z",
      "updated_at": "2020-10-14T11:08:34Z",
      "breadcrumb": "Contents / What's New",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "When trying to find the root cause of an issue, access to contextual information is crucial. Knowing that, we‚Äôve made it easier to find relevant issue information and analysis. The issue summary provides bottom-line insights to get you information faster. Depending on the issue, it can contain up to four sections: Analysis summary: Surfaces related components and SRE golden signals (for example, error rate, throughput, saturation, and latency) Suggested responder: Suggests the most relevant responders who can help to resolve the issue Impacted entities: Shows a summary of any entities we monitor with one-click access to anomaly analysis if you‚Äôve configured Proactive Detection Labels sets: Shows incidents from third-party sources (for example, PagerDuty, AWS CloudWatch, etc.) With these updates to the issue summary and analysis, more information is always a click away.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.4653,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to four sections: Analysis summary: Surfaces related components and SRE <em>golden</em> <em>signals</em> (for example, error rate, throughput, saturation, and latency) Suggested responder: Suggests the most relevant responders who can help to resolve the issue Impacted entities: Shows a summary of any entities we"
      },
      "id": "5f86dc32196a67fd7cbd5388"
    },
    {
      "nodeid": 40951,
      "sections": [
        "Recent Announcements",
        "New Relic One now has a new UI for OpenTelemetry"
      ],
      "title": "New Relic One now has a new UI for OpenTelemetry",
      "type": "docs",
      "external_id": "50b2de1ac4518571388a57bbe1824f477b7faf8d",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/whats_up_opentelemetry.png",
      "url": "https://docs.newrelic.com/whats-new/new-relic-one-now-has-new-ui-opentelemetry",
      "published_at": "2020-10-22T13:10:30Z",
      "updated_at": "2020-10-14T11:09:53Z",
      "breadcrumb": "Contents / What's New",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "New Relic One now has a UI dedicated to providing full APM functionality for your OpenTelemetry data. With this curated experience, you can find the root cause of incidents quickly, and optimize the performance of your applications and services. Send your OpenTelemetry data to New Relic using one of the OpenTelemetry exporters and quickly discover and analyze your data using one of these key pages: Entity Explorer: The entity explorer gives you a unified view of every entity so you can see everything you monitor in one place and quickly zoom into what you care about most. Summary page: The summary page provides an overview of ‚Äúgolden signals‚Äù for a service or application, such as response time, throughput, and error rate. Transactions page: Use the APM transactions page to identify transactions that might be causing the problem. Distributed Tracing: With distributed tracing, you can get an end-to-end view of a single request across your services and quickly identify slow and error traces. Externals: The external services page captures calls to out-of-process services such as web services, resources in the cloud, and other network entities. Databases: The databases page shows an application‚Äôs database and cache data with charts to view throughput, response time and operations. Metric explorer: Use the metrics explorer to view your metrics and facet by various dimensions and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.7919,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ": The summary page provides an overview of ‚Äú<em>golden</em> <em>signals</em>‚Äù for a service or application, such as response time, throughput, and error rate. Transactions page: Use the APM transactions page to identify transactions that might be causing the problem. Distributed Tracing: With distributed tracing, you can get"
      },
      "id": "5f86dc8128ccbc36e51e676b"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/2q925u10aatdd/promo-image.1602169257.png",
      "url": "https://learn.newrelic.com/effective-alerting-with-new-relic",
      "sections": [
        "In this engaging FREE 2 hour session we move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you. With scenario based labs you‚Äôll create specific policies and conditions for typical use cases across the full stack, use ",
        "About this workshop"
      ],
      "published_at": "2020-10-24T01:40:26Z",
      "title": "Effective Alerting with New Relic",
      "updated_at": "2020-10-24T01:40:25Z",
      "type": "",
      "external_id": "d88dcb753499fcfdcc9677a0c48a6a6866a7c111",
      "popularity": 1,
      "body": "Sign In Effective Alerting with New Relic In this engaging FREE 2 hour session we move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you. With scenario based labs you‚Äôll create specific policies and conditions for typical use cases across the full stack, use dynamic filters and tags, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios. Register | FREE Already registered? Sign In About this workshop Want to know more about alerting? In this highly practical and engaging 2 hour session we delve deeper into how to move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you, and get routed effectively to relevant teams or tools.¬†¬† With scenario based labs you‚Äôll create specific policies and conditions for typical use cases across the full stack, use dynamic filters and tags, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.¬† You'll get to work with Applied Intelligence alerting and learn how to make use of Proactive Detection and Incident Intelligence to reduce alert noise, correlate incidents to understand the root cause more quickly, and resolve and fix incidents faster.¬† The format of this session will include best practices, challenge based labs, discussions and collaborative activities resulting in takeaways you can immediately apply to your accounts or organization's requirements. As these sessions are interactive and highly practical, the number of attendees is limited, Register Now to hold your spot! Agenda Topic and Labs¬† Alerts Concepts and Workflow Effective Alerting strategies¬† Establishing Baselines, SLO‚Äôs and Thresholds Use Cases and labs:¬† Alerting on SLAs and back end services Alerting on new applications or variable performance -Dynamic Baseline Alerting Alerting on Infrastructure conditions and Integration Providers Outlier detection and other NRQL Alerting use cases:¬† Multiple issues (static),¬† Synthetic performance (dynamic),¬† Outlier behaviour (Outlier) Notifying the right team: Channels and Webhooks Lab: Webhook Challenge Alerts and Dashboarding Lab: Charting alerts Muting Alerts with Muting Rules Applied Intelligence¬† Proactive Detection Notifications and Analyzing Anomalies¬† Lab: Configure Anomaly notification channel Incident Intelligence Building Decisions Configuring Sources, Destinations and Pathways Effective Alerting with New Relic Event Date Spaces left Effective Alerting with New Relic - November 3, 2020 (AMER) Nov. 3, 2020, 10 a.m. - Nov. 3, 2020, noon PST 99 Effective Alerting with New Relic - November 17, 2020 (EMEA) Nov. 17, 2020, 10 a.m. - Nov. 17, 2020, noon GMT 110 About this workshop Want to know more about alerting? In this highly practical and engaging 2 hour session we delve deeper into how to move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you, and get routed effectively to relevant teams or tools.¬†¬† With scenario based labs you‚Äôll create specific policies and conditions for typical use cases across the full stack, use dynamic filters and tags, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.¬† You'll get to work with Applied Intelligence alerting and learn how to make use of Proactive Detection and Incident Intelligence to reduce alert noise, correlate incidents to understand the root cause more quickly, and resolve and fix incidents faster.¬† The format of this session will include best practices, challenge based labs, discussions and collaborative activities resulting in takeaways you can immediately apply to your accounts or organization's requirements. As these sessions are interactive and highly practical, the number of attendees is limited, Register Now to hold your spot! Agenda Topic and Labs¬† Alerts Concepts and Workflow Effective Alerting strategies¬† Establishing Baselines, SLO‚Äôs and Thresholds Use Cases and labs:¬† Alerting on SLAs and back end services Alerting on new applications or variable performance -Dynamic Baseline Alerting Alerting on Infrastructure conditions and Integration Providers Outlier detection and other NRQL Alerting use cases:¬† Multiple issues (static),¬† Synthetic performance (dynamic),¬† Outlier behaviour (Outlier) Notifying the right team: Channels and Webhooks Lab: Webhook Challenge Alerts and Dashboarding Lab: Charting alerts Muting Alerts with Muting Rules Applied Intelligence¬† Proactive Detection Notifications and Analyzing Anomalies¬† Lab: Configure Anomaly notification channel Incident Intelligence Building Decisions Configuring Sources, Destinations and Pathways Live events Effective Alerting with New Relic Event Date Spaces left Effective Alerting with New Relic - November 3, 2020 (AMER) Nov. 3, 2020, 10 a.m. - Nov. 3, 2020, noon PST 99 Effective Alerting with New Relic - November 17, 2020 (EMEA) Nov. 17, 2020, 10 a.m. - Nov. 17, 2020, noon GMT 110 ¬© 2020 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.72105,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Effective <em>Alerting</em> with New Relic",
        "sections": "In this engaging FREE 2 hour session we move beyond basic <em>alerts</em> to implementing an effective <em>alerting</em> strategy, and create <em>alerts</em> which surface issues that are important to you. With scenario based labs you‚Äôll create specific policies and conditions for typical use cases across the full stack, use ",
        "body": " and Dashboarding Lab: Charting <em>alerts</em> Muting <em>Alerts</em> with Muting Rules Applied Intelligence¬† Proactive Detection Notifications and Analyzing Anomalies¬† Lab: Configure Anomaly <em>notification</em> <em>channel</em> Incident Intelligence Building Decisions Configuring Sources, Destinations and Pathways Live events Effective"
      },
      "id": "5f7f37f564441f79493f15a1"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts"
      ],
      "published_at": "2020-10-24T01:51:46Z",
      "title": "Automate workflows",
      "updated_at": "2020-10-24T01:51:46Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.10808,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Getting started with New Relic and <em>Terraform</em>",
        "body": "Automate workflows When building today&#x27;s complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including <em>Terraform</em>, AWS"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "image": "https://newrelic.com/content/dam/hercules-qa/platform_appliedintelligence_experience_july2020.png",
      "url": "https://newrelic.com/platform/applied-intelligence",
      "sections": [
        "Applied Intelligence",
        "Applied Intelligence includes:",
        "Proactive Detection",
        "Incident Intelligence",
        "Faster to connect, faster to value",
        "Automatic anomaly detection",
        "See all anomalies in one place with access to deeper analysis",
        "Correlate incidents to reduce alert noise and fatigue",
        "Correlate incidents with your own decision logic",
        "Get transparency into why incidents are correlated",
        "Diagnose and respond faster with incident intelligence",
        "Escalate incidents to the right responders faster",
        "No changes to your existing incident response workflow",
        "Experience Applied Intelligence",
        "Free access to New Relic. Forever.",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-10-24T01:40:31Z",
      "title": "New Relic AI | New Relic",
      "updated_at": "2020-10-08T01:42:46Z",
      "type": "",
      "external_id": "a5a1b6dba51c420ad389a483c040bd729518a2f4",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Applied Intelligence Detect, understand, and resolve incidents faster with the easiest-to-use, most powerful AIOps capabilities that reduce alert noise and find insights in the data that would go unnoticed without machine learning. Sign up for free Applied Intelligence includes: Proactive Detection Detect anomalies before they become incidents. Automatically receive real-time failure warnings delivered straight to the tools where you already work, including your Slack channels. Learn more about what you get with Proactive Detection. ¬† Incident Intelligence Reduce alert fatigue and prioritize the issues that matter most. With a powerful correlation engine that makes alerts more meaningful and actionable, you can fix issues faster and with more confidence. Learn more about what you get with Incident Intelligence. Faster to connect, faster to value Connect the tools you already use with our simple configuration UI, webhooks and APIs, including Slack, PagerDuty, Splunk, Grafana, Prometheus and Amazon CloudWatch. Or you can integrate with your incident management tools of choice. Ingest alerts, incidents and event data from any source, and you'll start seeing the benefits of anomaly detection and automatic noise reduction right away. Automatic anomaly detection Get notified about potential problems in your tools of choice before they turn into incidents. Applied Intelligence proactively monitors your services for anomalies based on SRE golden signals‚Äîsuch as latency, errors, and traffic‚Äîand notifies you with real-time failure warnings and actionable details so you can investigate faster. See all anomalies in one place with access to deeper analysis Visualize and troubleshoot all anomalies across your environment from a single page, with the ability to instantly view critical details for each one. Anomaly analysis includes key attributes that caused spikes, related signals to investigate root cause by looking at what happened around the anomaly, and visibility into upstream and downstream dependencies. Correlate incidents to reduce alert noise and fatigue Automatically group and prioritize your alerts and incident data to decrease noise and focus on what matters most. Applied Intelligence establishes relationships between incidents and includes flapping detection and smart suppression to reduce noise from low-priority alerts by as much as 90 percent. Correlate incidents with your own decision logic Build and gauge the impact of your own correlation logic with an intuitive decision builder that makes it simple to tell New Relic AI what data to compare and correlate, then previews its potential impact. You can create logic based on any event attribute, adjust frequency and duration thresholds, and even choose out-of-the-box similarity algorithms, so you get full flexibility and control. Get transparency into why incidents are correlated AIOps tools shouldn‚Äôt be a black box. Applied Intelligence provides full transparency into why and how issues are correlated, so you have confidence in the ML models that reduce noise while ensuring that critical signals don‚Äôt go unnoticed. Diagnose and respond faster with incident intelligence Applied Intelligence enriches correlated incidents with deeper context and metadata, so you can understand the issue and take action to resolve it. Alerts are automatically classified based on golden signals and related components of your environments are identified, so you can quickly determine the probable cause and isolate the source of the problem. Escalate incidents to the right responders faster Route correlated incidents to the team members best equipped to respond and make noisy, misdirected alerts a thing of the past. Applied Intelligence suggests responders based on your data, and gives you the flexibility to easily determine where and how you send issues to your teams. ¬† No changes to your existing incident response workflow Connect your incident management tools as destinations quickly and easily. Applied Intelligence delivers correlated, enriched incidents into tools like PagerDuty, OpsGenie, ServiceNow, and more, so you don‚Äôt need to reinvent your on-call workflow. ¬† Experience Applied Intelligence Applied Intelligence delivers guidance and analysis that makes it faster and easier than ever to detect, understand and resolve incidents. Free access to New Relic. Forever. Monitoring your stack should never include host-based guessing games or hidden costs‚Äîjust simple pricing with no surprises. Sign up now Customers trust New Relic. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.93494,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Correlate incidents to reduce <em>alert</em> noise and fatigue",
        "body": " you can understand the issue and take action to resolve it. <em>Alerts</em> are automatically classified based on <em>golden</em> <em>signals</em> and related components of your environments are identified, so you can quickly determine the probable cause and isolate the source of the problem. Escalate incidents to the right"
      },
      "id": "5f2275e8196a6707f7b53d24"
    }
  ],
  "/automate-workflows/get-started-new-relic-cli": [
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-10-24T01:53:25Z",
      "updated_at": "2020-10-24T01:53:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 396.9417,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Quickly <em>tag</em> a set of resources",
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Add <em>tags</em> to applications you instrument for easier filtering and organization.",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>CLI</em> to add multiple <em>tags</em> to one of your entities. Before you begin For this guide you need your <em>New</em> <em>Relic</em> personal <em>API</em> <em>Key</em>: Create it at the Account settings screen for your account. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> via Homebrew (macOS), Scoop (Windows"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0 EMEA",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-10-24T01:40:08Z",
      "title": "New Relic Developers",
      "updated_at": "2020-10-24T01:38:33Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 EMEA Nerd Days is a FREE engineering conference that kicks off November 10 (EMEA). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 17 Days : 8 Hours : 31 Minutes : 16 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application ¬† Add custom attributes Use custom attributes for deeper analysis Show 21 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 313.5879,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": ", agents, OS emitters - get any data 20 min Automate common tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application ¬† Add custom"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts"
      ],
      "published_at": "2020-10-24T01:51:46Z",
      "title": "Automate workflows",
      "updated_at": "2020-10-24T01:51:46Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 294.5961,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " the Kubernetes operator Learn how to provision <em>New</em> <em>Relic</em> resources using the Kubernetes operator 20 min Automate common tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> 30 min Getting started with <em>New</em> <em>Relic</em> and Terraform Learn how to provision <em>New</em> <em>Relic</em> resources using Terraform 20 min Set up <em>New</em> <em>Relic</em> using Helm charts Learn how to set up <em>New</em> <em>Relic</em> using Helm charts"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "Explore NerdGraph using the API Explorer",
        "Before you begin",
        "Build a query to retrieve your name",
        "Click the play button to see the result",
        "Add more fields to your query",
        "Experiment with mutations",
        "Tip",
        "Try your NerdGraph query in the terminal",
        "Next steps"
      ],
      "title": "Explore NerdGraph using the API Explorer",
      "type": "developer",
      "tags": [
        "nerdgraph",
        "mutations",
        "nerdgraph query terminal"
      ],
      "external_id": "df1f04edc2336c69769d946edbaf263a5339bc92",
      "image": "https://developer.newrelic.com/static/0ce8c387a290d7fbd6be155322be9bce/bc8d6/create-account.png",
      "url": "https://developer.newrelic.com/collect-data/get-started-nerdgraph-api-explorer/",
      "published_at": "2020-10-24T01:53:26Z",
      "updated_at": "2020-10-24T01:53:26Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Explore NerdGraph, our GraphQL API, and build the queries you need.",
      "body": "Explore NerdGraph using the API Explorer 25 min NerdGraph is New Relic's GraphQL API. It allows you to get all the information you need in a single request. With NerdGraph API Explorer you don't need to know the query format: using the Query Builder you can browse our entire graph and compose queries just by selecting the items you want and filling out their required values. Before you begin Go to api.newrelic.com/graphiql and log in using your New Relic user ID and password: the NerdGraph API Explorer loads up. Make sure you have a valid New Relic API key. You can create one directly from the NerdGraph API Explorer. Step 1 of 5 Build a query to retrieve your name Time for your first NerdGraph query. Search for your name in the New Relic database: Erase everything in the query editor. Select the following fields in the query explorer in this order: actor, user, name. This GraphQL snippet appears in the editor. { actor { user { name } } } Copy Step 2 of 5 Click the play button to see the result With this query, you're telling NerdGraph to retrieve your name. You're asking for the name field, which is nested within the user field. This refers to the user who owns the API key, which in turn is nested within actor. Click the play button to see the result: It has almost the same shape as the request. All the fields in the Query Builder make up what's called the GraphQL schema, which describes all the available data types and their attributes. To learn more about each field, click the Docs button, or hover over a field in the editor. Step 3 of 5 Add more fields to your query Now you can try adding more fields to your query. The simplest way is clicking the fields in the Query Builder: The API Explorer knows where the attributes should go in the query. In the example, you add the account id and email fields. Once again, running the GraphQL query results in just the data you need, without over or under-fetching data. Notice that the id field has an argument: passing arguments is a powerful way of customizing your NerdGraph queries. Every field and object can contain arguments, so instead of running multiple queries, you just compose the one that you need. { actor { user { name email } account(id: 12345678) } } Copy Step 4 of 5 Experiment with mutations In GraphQL, mutations are a way to execute queries with side effects that can alter the data by creating, updating, or deleting objects (Commonly referred to as CRUD operations in REST APIs). Ready for your first mutation? Erase what's in the editor. Scroll down the Query Builder and expand mutation. Select the fields in the following screenshot: In this case, you're trying to add a custom tag to an entity. Notice that the editor complains if you don't select errors: mutations must have a way of telling you how the operation performed in the backend (failed requests result in null responses). Tip Unlike REST, GraphQL APIs like NerdGraph can return partial responses. For example, if you try adding tags to multiple entities, some mutations can fail and others succeed; all is logged in the GraphQL response you get. Step 5 of 5 Try your NerdGraph query in the terminal Let's say that you've built a NerdGraph query you're happy with and you want to test it elsewhere. To capture code-ready queries and mutations: Select the Tools menu. Copy the query as a curl call or as a New Relic CLI command. bash Copy $ # curl version $ curl https://api.newrelic.com/graphql \\ > -H 'Content-Type: application/json' \\ > -H 'API-Key: API_KEY_REDACTED' \\ > --data-binary '{\"query\":\"{\\n actor {\\n user {\\n name\\n email\\n }\\n account(id: 12345678)\\n }\\n}\\n\", \"variables\":\"\"}' $ $ # New Relic CLI version $ newrelic nerdgraph query '{ $ actor { $ user { $ name $ email $ } $ account(id: 12345678) $ } $ } $ ' Next steps Now you know the basics of composing and testing NerdGraph queries, but how do you turn them into client or server code? Solutions such as GraphQL Code Generator can help you turn the NerdGraph queries into code for your implementation. Try creating more complex queries by clicking fields and expanding objects in the Query Builder (be careful with mutations though, since they could write data to your account). For more information on NerdGraph and explore other projects from the developer community, check out the threads on the Explorer‚Äôs Hub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 251.37411,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Explore NerdGraph using the <em>API</em> Explorer",
        "sections": "Explore NerdGraph using the <em>API</em> Explorer",
        "info": "Explore NerdGraph, our GraphQL <em>API</em>, and build the queries you need.",
        "body": " and mutations: Select the Tools menu. Copy the query as a curl call or as a <em>New</em> <em>Relic</em> <em>CLI</em> command. bash Copy $ # curl version $ curl https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;graphql \\ &gt; -H &#x27;Content-Type: application&#x2F;json&#x27; \\ &gt; -H &#x27;<em>API</em>-<em>Key</em>: <em>API_KEY</em>_REDACTED&#x27; \\ &gt; --data-binary &#x27;{&quot;query&quot;:&quot;{\\n actor {\\n user {\\n name\\n email\\n"
      },
      "id": "5efa9973196a6791f4766402"
    },
    {
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps"
      ],
      "title": "Add tables to your New Relic One application",
      "type": "developer",
      "tags": [
        "table in app",
        "Table component",
        "TableHeaderc omponent",
        "TableHeaderCell component",
        "TableRow component",
        "TableRowCell component"
      ],
      "external_id": "7ff7a8426eb1758a08ec360835d9085fae829936",
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/",
      "published_at": "2020-10-24T01:53:24Z",
      "updated_at": "2020-10-24T01:53:23Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a table to your New Relic One app.",
      "body": "Add tables to your New Relic One application 30 min Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git` $ cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet` Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. bash Copy $ nr1 nerdpack:uuid -gf # Update the app unique ID $ npm install # Install dependencies $ nr1 nerdpack:serve # Serve the demo app locally Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the nerdlets/create-a-table-nerdlet subdirectory and open the index.js file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside of the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 207.88396,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add tables to your <em>New</em> <em>Relic</em> One application",
        "sections": "Add tables to your <em>New</em> <em>Relic</em> One application",
        "info": "Add a table to your <em>New</em> <em>Relic</em> One app.",
        "body": " build your own tables into your <em>New</em> <em>Relic</em> One application. In this guide, you are going to build a sample table using various <em>New</em> <em>Relic</em> One components. Before you begin If you haven&#x27;t already installed the <em>New</em> <em>Relic</em> One <em>CLI</em>, step through the quick start in <em>New</em> <em>Relic</em> One. This process also gets you"
      },
      "id": "5efa989ee7b9d2ad567bab51"
    }
  ],
  "/build-apps/add-time-picker-guide": [
    {
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps"
      ],
      "title": "Add tables to your New Relic One application",
      "type": "developer",
      "tags": [
        "table in app",
        "Table component",
        "TableHeaderc omponent",
        "TableHeaderCell component",
        "TableRow component",
        "TableRowCell component"
      ],
      "external_id": "7ff7a8426eb1758a08ec360835d9085fae829936",
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/",
      "published_at": "2020-10-24T01:53:24Z",
      "updated_at": "2020-10-24T01:53:23Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a table to your New Relic One app.",
      "body": "Add tables to your New Relic One application 30 min Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git` $ cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet` Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. bash Copy $ nr1 nerdpack:uuid -gf # Update the app unique ID $ npm install # Install dependencies $ nr1 nerdpack:serve # Serve the demo app locally Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the nerdlets/create-a-table-nerdlet subdirectory and open the index.js file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside of the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 210.18651,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add tables to your New Relic One <em>application</em>",
        "sections": "Add tables to your New Relic One <em>application</em>",
        "info": "Add a table to your New Relic One <em>app</em>.",
        "tags": "table in <em>app</em>",
        "body": " Account ID as shown in the example. export default class Nr1HowtoAdd<em>TimePicker</em> extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application Change the directory back to nr1-how-to&#x2F;create-a-table. Before you can load"
      },
      "id": "5efa989ee7b9d2ad567bab51"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2020-10-24T02:01:31Z",
      "updated_at": "2020-10-14T01:58:45Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "Intro to New Relic One SDK To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.62991,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic One <em>apps</em>",
        "body": " be divided into these categories: <em>PlatformStateContext</em>: provides read access to the platform URL state variables. Example: <em>time</em>Range in the <em>time</em> <em>picker</em>. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add the NerdGraphQuery component to an application",
        "Add a table to your app",
        "Permissions for managing applications",
        "Set up your development environment",
        "Publish and deploy apps",
        "Create a custom map view"
      ],
      "published_at": "2020-10-24T01:53:25Z",
      "title": "Build apps",
      "updated_at": "2020-10-24T01:53:25Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 30 min Add a table to your app Add a table to your New Relic One app ¬† Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 30 min Publish and deploy apps Start sharing the apps you build 30 min Create a custom map view Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.92941,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add a <em>time</em> <em>picker</em> to your <em>app</em>",
        "body": " New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a <em>time</em> <em>picker</em> to your <em>app</em> Add a <em>time</em> <em>picker</em> to a sample application 15 min Create a &quot;Hello, World!&quot; application Build a &quot;Hello, World!&quot; <em>app</em> and publish it to New Relic One 20 minutes Add"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0 EMEA",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-10-24T01:40:08Z",
      "title": "New Relic Developers",
      "updated_at": "2020-10-24T01:38:33Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 EMEA Nerd Days is a FREE engineering conference that kicks off November 10 (EMEA). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 17 Days : 8 Hours : 31 Minutes : 16 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application ¬† Add custom attributes Use custom attributes for deeper analysis Show 21 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.80212,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add a <em>time</em> <em>picker</em> to your <em>app</em>",
        "body": ", agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an <em>app</em> to show page view data on a map 20 min Add a <em>time</em> <em>picker</em> to your <em>app</em> Add a <em>time</em> <em>picker</em> to a sample application ¬† Add custom"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "category_2": "New Relic for iOS release notes",
      "nodeid": 8411,
      "sections": [
        "Mobile apps release notes",
        "New Relic for Android release notes",
        "Insights for tvOS release notes",
        "New Relic for iOS release notes",
        "Insights for Android release notes",
        "Insights for iOS release notes",
        "New Relic for iOS 3.20.3",
        "New Relic for iOS 3.63.0",
        "Notes",
        "New features",
        "Bug fixes",
        "New Relic for iOS 3.62.0",
        "New Relic for iOS 3.61.0",
        "New Relic for iOS 3.59.0",
        "New Relic for iOS 3.58.0",
        "New Relic for iOS 3.57.0",
        "New Relic for iOS 3.56.0",
        "Improvements",
        "New Relic for iOS 3.55.0",
        "New Relic for iOS 3.54.0",
        "New Relic for iOS 3.53.1",
        "Pages"
      ],
      "title": "New Relic for iOS 3.20.3",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "Mobile apps release notes",
      "external_id": "1f422d5b3c5f57579e299bf6f53e03639d48a993",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/mobile-apps-release-notes/new-relic-ios-3203",
      "published_at": "2020-10-24T18:17:33Z",
      "updated_at": "2020-10-23T03:12:28Z",
      "breadcrumb": "Contents / Release notes / Mobile apps release notes / New Relic for iOS release notes",
      "document_type": "release_notes",
      "popularity": -2,
      "body": "[RSS] Items per page 5 10 New Relic for iOS 3.63.0 Thursday, October 22, 2020 - 12:00 Download Notes Added in support to open universal links from New Relic One. New features Support New Relic One links that we have views for within the mobile app Bug fixes Fixed an issue where switching accounts from different regions would not save or show favorites on the Home screen. Potentially fixed a rare crash when trying to show details in a dashboard widget chart New Relic for iOS 3.62.0 Wednesday, August 19, 2020 - 07:00 Download Notes Added support to filter any dashboard! New features Dashboards now support filtering to specified attributes and values New Relic for iOS 3.61.0 Tuesday, July 21, 2020 - 13:30 Download Notes Easier login flow to provide support for our newest customers Bug fixes Fixes a rare crash when a user tries to view some violations on a 32 bit device New Relic for iOS 3.59.0 Wednesday, June 24, 2020 - 10:00 Download Notes Introducing NRQL editing from within the iPad app New features Adds in NRQL query history to the iPad. Adds in the ability to write NRQL queries. Adds in sharing functionality for NRQL queries to both iPad and iPhone Adds in sharing functionality for Dashboards Bug fixes Fixes a crash when trying to share on the iPad Fixes a crash when trying to open a malformed universal link to errors New Relic for iOS 3.58.0 Tuesday, June 16, 2020 - 09:00 Download New features Improved Home screen look and feel Added dashboards to the Home screen Added the ability to filter to specific entity types on the Home screen (iPhone) Updated header colors in light mode New Relic for iOS 3.57.0 Tuesday, June 2, 2020 - 09:15 Download Notes Introducing NRQL editing from within the iPhone app! New features Adds in NRQL query history to the iPhone (iPad will come later). Adds in the ability to write NRQL queries. Links Alert incidents that target a NRQL query to show the in-app NRQL editor. Includes more detail screens on the iPad for APM, Browser, Mobile, and key transactions. New Relic for iOS 3.56.0 Thursday, May 14, 2020 - 09:00 Download Notes Introducing Dashboards on iPad. Now view all your dashboards right from the New Relic mobile app. New features iPad now has support for Dashboards iPad now has an improved Home page with favorites and support for searching across services, apps, hosts and monitors Home on iPhone now shows monitors Improvements Improved cards, and searching on iPad Improved network performance for large lists Improved network calls for filtering by tags (what used to be labels & rollups) in APM and Synthetics New Relic for iOS 3.55.0 Thursday, April 23, 2020 - 06:00 Download Improvements Improved time picker with custom start and end time selection Added time picker to Dashboards Bug fixes Fixed a crash that sometimes occurred in the new Dashboards Fixed a crash that sometimes occurred on the iPad Fixed a crash that occurred sometimes on error charts with no data New Relic for iOS 3.54.0 Thursday, April 9, 2020 - 09:00 Download New features View New Relic dashboards Added detailed pages that include new chart tooltip and legend behavior Landscape support for widgets New Relic for iOS 3.53.1 Friday, February 21, 2020 - 08:49 Download Notes 3.53.1 is a hot fix for 3.53.0 which has an improved Mobile APM Http Errors view, to allow you to facet & filter down to the errors you care about. Bug fixes Fixes crash that sometimes occurred when viewing line charts with multiple elements. Pages 1 2 3 4 5 6 7 8 9 next ‚Ä∫ last ¬ª",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.96569,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Mobile <em>apps</em> release notes",
        "category_1": "Mobile <em>apps</em> release notes",
        "body": " Improvements Improved cards, and searching on iPad Improved network performance for large lists Improved network calls for filtering by tags (what used to be labels &amp; rollups) in APM and Synthetics New Relic for iOS 3.55.0 Thursday, April 23, 2020 - 06:00 Download Improvements Improved <em>time</em> <em>picker</em>"
      },
      "id": "5764a9670711e81ee2a0e97e"
    }
  ],
  "/terms": [
    {
      "category_2": "Developer Edition",
      "nodeid": 39641,
      "sections": [
        "Product or service licenses",
        "New Relic One",
        "APM",
        "Browser",
        "Developer Edition",
        "Infrastructure",
        "Insights",
        "Logs",
        "Mobile",
        "Synthetics",
        "Mobile apps",
        "Plugins",
        "Miscellaneous",
        "Developer Program Resources",
        "For more help"
      ],
      "title": "Developer Program Resources",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "Product or service licenses",
      "external_id": "98308cfffa652e4c25967e1be5b848b9c28ca410",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-developer-edition/developer-program-resources",
      "published_at": "2020-10-22T11:01:39Z",
      "updated_at": "2020-08-08T19:17:02Z",
      "breadcrumb": "Contents / Licenses / Product or service licenses / Developer Edition",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic Developer edition policy",
      "body": "As a customer, you are eligible to participate in New Relic‚Äôs Developer Program. Additional information and resources are available at New Relic‚Äôs Developer Program site. By downloading, accessing, or using the developer resources (including the CLI), you agree that usage of the developer resources is pursuant to the New Relic Developers Terms and Conditions and that you have the authority to bind your organization. Such terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not use these developer resources. If your use of the New Relic developer resources are covered under a separate agreement, the above does not apply to you. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 309.06616,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is pursuant to the New Relic Developers <em>Terms</em> and <em>Conditions</em> and that you have the authority to bind your organization. Such <em>terms</em> do not have to be signed in order to be binding. If you do not agree to these <em>terms</em> and <em>conditions</em>, your sole remedy is to not use these developer resources. If your"
      },
      "id": "5f338507e7b9d2f670c9de83"
    },
    {
      "category_2": "New Relic One",
      "nodeid": 39366,
      "sections": [
        "Product or service licenses",
        "New Relic One",
        "APM",
        "Browser",
        "Developer Edition",
        "Infrastructure",
        "Insights",
        "Logs",
        "Mobile",
        "Synthetics",
        "Mobile apps",
        "Plugins",
        "Miscellaneous",
        "Preview access for New Relic One",
        "For more help"
      ],
      "title": "Preview access for New Relic One",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "Product or service licenses",
      "external_id": "eae3865081d3bd8ad2dd8b6eaf0fe0147355360c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-one/preview-access-new-relic-one",
      "published_at": "2020-10-22T12:17:33Z",
      "updated_at": "2020-07-31T04:41:27Z",
      "breadcrumb": "Contents / Licenses / Product or service licenses / New Relic One",
      "document_type": "page",
      "popularity": 1,
      "body": "As a customer with a paid subscription to New Relic products, you are eligible to participate in preview access of the New Relic One platform (e.g. Telemetry Data Platform, Full Stack Observability, and Applied Intelligence products) for the period beginning July 31, 2020 and ending December 31, 2020 (‚ÄúPreview Access‚Äù). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE TERMS AND CONDITIONS IN LIEU OF ANY OTHER TERMS. These terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not participate in Preview Access. New Relic reserves the right to terminate or restrict Preview Access, in whole or in part, at any time. Notwithstanding the foregoing and any other materials provided by New Relic, select customers are ineligible for the Preview Access. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 304.47305,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", 2020 (‚ÄúPreview Access‚Äù). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE <em>TERMS</em> AND <em>CONDITIONS</em> IN LIEU OF ANY OTHER <em>TERMS</em>. These <em>terms</em> do not have to be signed in order to be binding"
      },
      "id": "5f23a0f7e7b9d29da9c82305"
    },
    {
      "image": "",
      "url": "https://opensource.newrelic.com/cla/",
      "sections": [
        "NEW RELIC, INC.",
        "INDIVIDUAL CONTRIBUTOR LICENSE AGREEMENT",
        "Definitions."
      ],
      "published_at": "2020-10-24T01:48:37Z",
      "title": "New Relic Open Source Contributor License Agreement",
      "updated_at": "2020-09-02T02:08:45Z",
      "type": "opensource",
      "external_id": "478151b2a97835e82c3cd1eaa49610793dc56783",
      "document_type": "page",
      "popularity": 1,
      "info": "",
      "body": "New Relic Open Source External Projects Highlighted Projects New Relic Projects Menu External Projects Highlighted Projects New Relic Projects NEW RELIC, INC. INDIVIDUAL CONTRIBUTOR LICENSE AGREEMENT Thank you for your interest in contributing to the open source projects of New Relic, Inc. (‚ÄúNew Relic‚Äù). In order to clarify the intellectual property license granted with Contributions from any person or entity, New Relic must have a Contributor License Agreement (\"Agreement\") on file that has been signed by each Contributor, indicating agreement to the license terms below. This Agreement is for your protection as a Contributor as well as the protection of New Relic; it does not change your rights to use your own Contributions for any other purpose. You accept and agree to the following terms and conditions for Your present and future Contributions submitted to New Relic. Except for the licenses granted herein to New Relic and recipients of software distributed by New Relic, You reserve all right, title, and interest in and to Your Contributions. Definitions. \"You\" (or \"Your\") shall mean the copyright owner or legal entity authorized by the copyright owner that is entering into this Agreement with New Relic. For legal entities, the entity making a Contribution and all other entities that control, are controlled by, or are under common control with that entity are considered to be a single Contributor. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"Contribution\" shall mean any original work of authorship, including any modifications or additions to an existing work, that is intentionally submitted by You to New Relic for inclusion in, or documentation of, any of the products managed or maintained by New Relic (the \"Work\"). For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to New Relic or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, New Relic for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by You as \"Not a Contribution.\" Grant of Copyright License. Subject to the terms and conditions of this Agreement, You hereby grant to New Relic and to recipients of software distributed by New Relic a perpetual, worldwide, non-exclusive, no-charge, royalty-free, transferable, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense, and distribute Your Contributions and such derivative works. Grant of Patent License. Subject to the terms and conditions of this Agreement, You hereby grant to New Relic and to recipients of software distributed by New Relic a perpetual, worldwide, non-exclusive, no-charge, royalty-free, transferable, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by You that are necessarily infringed by Your Contributions alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that Your Contribution, or the Work to which You have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the date such litigation is filed. You represent that You are legally entitled to grant the above licenses. If Your employer(s) has rights to intellectual property that You create that includes Your Contributions, You represent that You have received permission to make Contributions on behalf of that employer, that Your employer has waived such rights for Your Contributions to New Relic, or that Your employer has executed a separate Agreement with New Relic. You represent that each of Your Contributions is Your original creation (see section 7 for submissions on behalf of others). You represent that Your Contribution submissions include complete details of any third-party license or other restriction (including, but not limited to, related patents and trademarks) of which You are personally aware and which are associated with any part of Your Contributions. You are not expected to provide support for Your Contributions, except to the extent You desire to provide support. You may provide support for free, for a fee, or not at all. Unless required by applicable law or agreed to in writing, You provide Your Contributions on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON- INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. Should You wish to submit work that is not Your original creation, You may submit it to New Relic separately from any Contribution, identifying the complete details of its source and of any license or other restriction (including, but not limited to, related patents, trademarks, and license agreements) of which You are personally aware, and conspicuously marking the work as \"Submitted on behalf of a third-party: [named here] \". You agree to notify New Relic of any facts or circumstances of which You become aware that would make these representations inaccurate in any respect. New Relic Open Source Standards External Projects Highlighted Projects New Relic Projects Edit this page Create an issue Copyright ¬© 2020 New Relic Inc.Version 1.9.2",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 295.63834,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is for your protection as a Contributor as well as the protection of New Relic; it does not change your rights to use your own Contributions for any other purpose. You accept and agree to the following <em>terms</em> and <em>conditions</em> for Your present and future Contributions submitted to New Relic. Except"
      },
      "id": "5f31822264441fcbe056a984"
    },
    {
      "category_2": "Product definitions",
      "nodeid": 39646,
      "sections": [
        "License information",
        "General usage licenses",
        "Special services licenses",
        "Distributed licenses",
        "Referenced policies",
        "Product definitions",
        "Usage plans",
        "FAQ",
        "New Relic One pricing: Definitions",
        "For more help"
      ],
      "title": "New Relic One pricing: Definitions",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "License information",
      "external_id": "097fc095ef18942f3af1845237742340e36416b8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/license-information/product-definitions/new-relic-one-pricing-definitions",
      "published_at": "2020-10-22T12:32:50Z",
      "updated_at": "2020-09-10T14:58:10Z",
      "breadcrumb": "Contents / Licenses / License information / Product definitions",
      "document_type": "page",
      "popularity": 1,
      "info": "This document provides definitions of terminology you may see in New Relic contracts.",
      "body": "This document provides definitions of terminology you may see in the Terms or this site for New Relic One pricing and billing: Account Account refers to the online account or subaccounts that New Relic provides for customers to manage their use of the Products. Commitment Term Commitment Term means the non-cancelable, committed Subscription Term for the Products. Customer Data Customer Data means the data, information, or content that Customer and its users send to an Account from the Software, the Customer Properties, or Third-Party Services. Customer Properties Customer Properties means Customer‚Äôs websites, infrastructure, networks, mobile applications, or other systems, as well as Customer accounts on Third-Party Services. Documentation Documentation means the New Relic technical guides and documentation made available from the dedicated ‚ÄòDocumentation‚Äô page of the New Relic website. GB Ingested A GB Ingested is a measurement of the volume of metrics, events, logs, traces, or other telemetry data sent to or generated by the Products for the benefit of the Customer, including from the Software, the Customer Properties, or Third-Party Services. In this context, a GB is defined as 1 billion bytes. Login Credentials Login Credentials means the username, email address, password, or other personal information that is provided by a Customer user in order to manage an Account. Monthly Provisioned User A Monthly Provisioned User is any user who can log into Customer‚Äôs Account(s) and access the New Relic One Product functionality as specified in an Order and the Documentation. Order Order means the purchasing order for access to the Service or related services that: (1) is either executed by the Parties or entered into by you via self-service, and references this Agreement, or (2) is entered into by you and a Channel Partner. Paid Terms of Service Paid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/paid. Product(s) Product(s) mean the purchase of the New Relic subscription products described in the applicable Order and any updates, corrections, bug fixes, modifications, improvements, related services, new features, and functionality (made generally available to New Relic‚Äôs customer base) thereto. Software Software means the distributed software, APIs, scripts, or other code proprietary to New Relic provided with the Products. Terms Terms means the underlying Customer-New Relic agreement and the Order. Third-Party Services Third-Party Services means any third party platform, add-on, service, or product not provided by New Relic and that a user integrates or enables for use with the Products, including third-party applications and plug-ins. Unpaid Terms of Service Unpaid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/unpaid. Usage Plan Usage Plan refers to the Service or Product pricing, invoicing related information, and product-specific terms (e.g. concurrent user account sessions) contained within the Documentation. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 289.58456,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "This document provides definitions of <em>terminology</em> you may see in New Relic contracts.",
        "body": "This document provides definitions of terminology you may see in the <em>Terms</em> or this site for New Relic One pricing and billing: Account Account refers to the online account or subaccounts that New Relic provides for customers to manage their use of the Products. Commitment <em>Term</em> Commitment <em>Term</em> means"
      },
      "id": "5f23b039196a67030b94f5c4"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/termsandconditions/terms",
      "sections": [
        "Terms of Service",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-10-24T01:40:30Z",
      "title": "Terms of Service Agreement | New Relic",
      "updated_at": "2020-10-08T01:46:05Z",
      "type": "",
      "external_id": "f1539ad0dbd46a29c243907400c646ed11c33bd1",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon New Relic Inc. Terms of Service Paid Accounts Customers that access New Relic‚Äôs platform through a paid subscription are governed by the Terms of Service set forth immediately above. Unpaid Accounts Customers that access New Relic‚Äôs platform on an unpaid (e.g. trials, proof of concepts, New Relic Developer Edition or ‚Äòlite‚Äô) basis are governed by the Terms of Service set forth immediately above. Community Forums Community Forum participants ask and answer questions about New Relic‚Äôs platform.¬† Use of the Community Form is governed by the terms and conditions set forth immediately above. New Relic Data Processing Addendum Customers who currently send, or intend to send, personal data to the New Relic Services for processing should download and complete the Data Processing Addendum set forth immediately¬†above. Data Processing Addendum¬†FAQ ¬†This guide is designed to assist customers in their completion of the New Relic Data Processing Addendum. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 276.09503,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Terms</em> of Service Agreement | New Relic",
        "sections": "<em>Terms</em> of Service",
        "body": ". trials, proof of concepts, New Relic Developer Edition or ‚Äòlite‚Äô) basis are governed by the <em>Terms</em> of Service set forth immediately above. Community Forums Community Forum participants ask and answer questions about New Relic‚Äôs platform.¬† Use of the Community Form is governed by the <em>terms</em> and <em>conditions</em>"
      },
      "id": "5ac68e78c75d077fcb6edc38"
    }
  ],
  "/build-apps/add-query-mutate-data-nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add the NerdGraphQuery component to an application",
        "Add a table to your app",
        "Permissions for managing applications",
        "Set up your development environment",
        "Publish and deploy apps",
        "Create a custom map view"
      ],
      "published_at": "2020-10-24T01:53:25Z",
      "title": "Build apps",
      "updated_at": "2020-10-24T01:53:25Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 30 min Add a table to your app Add a table to your New Relic One app ¬† Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 30 min Publish and deploy apps Start sharing the apps you build 30 min Create a custom map view Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 388.5603,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em>",
        "body": " you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 45 min <em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em> <em>NerdStorage</em> is a document database accessible within"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-10-24T02:00:01Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.36673,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>NerdStorage</em>",
        "sections": "Intro to <em>NerdStorage</em>",
        "info": "Intro to <em>NerdStorage</em> on New Relic One",
        "tags": "<em>nerdstorage</em>",
        "body": " document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of <em>data</em> associated with it. <em>Data</em> associated with a document: <em>NerdStorage</em> accepts any sort of <em>data</em> associated to a documentId. <em>Query</em> and mutation components that are provided work by serializing"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-10-24T02:00:01Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Copy Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.74894,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching <em>data</em> from your laptop while troubleshooting an issue, or adding New Relic into your CI&#x2F;CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "Query and store data",
        "Components overview",
        "Query components",
        "Mutation components",
        "Static methods",
        "NrqlQuery"
      ],
      "title": "Query and store data",
      "type": "developer",
      "tags": [
        "nerdgraph query components",
        "mutation components",
        "static methods"
      ],
      "external_id": "cbbf363393edeefbc4c08f9754b43d38fd911026",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/query-and-store-data/",
      "published_at": "2020-10-23T01:55:11Z",
      "updated_at": "2020-08-01T01:42:02Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Reference guide for SDK query components using NerdGraph",
      "body": "Query and store data 10 min To help you build a New Relic One application, we provide you with the New Relic One SDK. Here you can learn how to use the SDK query components, which allow you to make queries and mutations via NerdGraph, our GraphQL endpoint. Query-related React components can be identified by the Query suffix. Mutation-related components can be identified by the Mutation prefix. Components overview Our data components are based on React Apollo. The most basic component is NerdGraphQuery, which accepts any GraphQL (or GraphQL AST generated by the graphql-tag library as the query parameter, and a set of query variables passed as variables. Over this query, we have created an additional set of queries, which can be divided into four groups: User queries: These allow you to query the current user and its associated accounts. Components in this category: UserStorageQuery and AccountsQuery. Entities queries: Because New Relic One is entity-centric, we use queries to make access to your entities easier. You can count, search, list, query, and favorite them. Components in this category: EntityCountQuery, EntitySearchQuery, EntitiesByDomainTypeQuery, EntitiesByGuidsQuery, EntityByGuidQuery, EntityByNameQuery. Storage queries: New Relic One provides a simple storage mechanism that we call NerdStorage. This can be used by Nerdpack creators to store application configuration setting data, user-specific data, and other small pieces of data. Components in this category: UserStorageQuery, AccountStorageQuery, EntityStorageQuery, UserStorageMutation, AccountStorageMutation, and EntityStorageMutation. For details, see NerdStorage. NRQL queries: To be able to query your New Relic data via NRQL (New Relic Query Language), we provide a NrqlQuery component. This component can return data in different formats, so that you can use it for charting and not only for querying. Query components All query components accept a function as a children prop where the different statuses can be passed. This callback receives an object with the following properties: loading: Boolean that is set to true when data fetching is happening. Our components use the cache-and-network strategy, meaning that after the data has loaded, subsequent data reloads might be triggered first with stale data, then refreshed when the most recent data has arrived. data: Root property where the data requested is retrieved. The structure matches a root structure based on the NerdGraph schema. This is true even for highly nested data structures, which means you‚Äôll have to traverse down to find the desired data. error: Contains an Error instance when the query fails. Set to undefined when data is loading or the fetch was successful. fetchMore: Callback function that can be called when the query is being loaded in chunks. The function will only be present when it‚Äôs feasible to do so, more data is available, and no fetchMore has already been triggered. Data is loaded in batches of 200 by default. Other components provided by the platform (like the Dropdown or the List) are capable of accepting fetchMore, meaning you can combine them easily. Mutation components Mutation components also accept a children as a function, like the query ones. The mutation can be preconfigured at the component level, and a function is passed back that you can use in your component. This is the standard React Apollo approach for performing mutations, but you might find it easier to use our static mutation method added to the component. More on this topic below. Static methods All of the described components also expose a static method so that they can be used imperatively rather than declaratively. All Query components have a static Query method, and all Mutation components have a mutation method. These static methods accept the same props as their query component, but passed as an object. For example: // Declarative way (using components). function renderAccountList() { return ( <ul> <AccountsQuery> ({data, error}) => { if (error) { return <li>Failed to retrieve list: {error.message}</li>; } return data.map((account) => { <li key={account.id}>{account.name}</li> }); }} </AccountsQuery> </ul> ); } // Imperative way (using promises). async function getAccountList() { let data = {}; try { data = await AccountsQuery.query(); } catch (error) { console.log('Failed to retrieve list: ' + error.message); return; } return data.actor.accounts.map((account) => { return account.name; }); } Copy Similarly, a mutation can happen either way; either declaratively or imperatively. NrqlQuery NrqlQuery deserves additional explanation, because there are multiple formats in which you can return data from it. To provide maximum functionality, all three are exposed through a formatType property. You can find its different values under NrqlQuery.formatType: NERD_GRAPH: Returns the format in which it arrives from NerdGraph. RAW: The format exposed by default in Insights and dashboards when being plotted as JSON. This format is useful if you have a pre-existing script in this format that you're willing to migrate to or incorporate with. CHART: The format used by the charting engine that we also expose. You can find a more detailed explanation of how to manipulate this format in the guide to chart components, and some examples. If you are willing to push data, we currently do not expose NrqlMutation. To do that, see the Event API for how to add custom events.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 71.631805,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> and store <em>data</em>",
        "sections": "<em>Query</em> and store <em>data</em>",
        "info": "Reference guide for SDK <em>query</em> components using NerdGraph",
        "tags": "nerdgraph <em>query</em> components",
        "body": ", EntityByGuid<em>Query</em>, EntityByName<em>Query</em>. Storage queries: New Relic One provides a simple storage mechanism that we call <em>NerdStorage</em>. This can be used by Nerdpack creators to store application configuration setting <em>data</em>, user-specific <em>data</em>, and other small pieces of <em>data</em>. Components in this category"
      },
      "id": "5efa989e28ccbc2f15307deb"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Collect data - any source",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL"
      ],
      "published_at": "2020-10-24T01:53:24Z",
      "title": "Collect data",
      "updated_at": "2020-10-24T01:53:24Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Collect data Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data ¬† Add custom attributes Use custom attributes for deeper analysis 15 min Collect data - any source APIs, agents, OS emitters - get any data 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events 25 min Build queries with NerdGraph Try NerdGraph and build the queries you need 10 min Query data with NRQL Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.64671,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Collect <em>data</em>",
        "sections": "<em>Query</em> <em>data</em> with NRQL",
        "body": " <em>data</em> ¬† <em>Add</em> custom attributes Use custom attributes for deeper analysis 15 min Collect <em>data</em> - any source APIs, agents, OS emitters - get any <em>data</em> 5 min Create custom events Define, visualize, and get alerts on the <em>data</em> you want using custom events 25 min Build queries with NerdGraph Try NerdGraph and build the queries you need 10 min <em>Query</em> <em>data</em> with NRQL <em>Query</em> default <em>data</em>, custom events, and attributes"
      },
      "id": "5efa997328ccbc768c307de2"
    }
  ],
  "/collect-data/custom-attributes": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Collect data - any source",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL"
      ],
      "published_at": "2020-10-24T01:53:24Z",
      "title": "Collect data",
      "updated_at": "2020-10-24T01:53:24Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Collect data Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data ¬† Add custom attributes Use custom attributes for deeper analysis 15 min Collect data - any source APIs, agents, OS emitters - get any data 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events 25 min Build queries with NerdGraph Try NerdGraph and build the queries you need 10 min Query data with NRQL Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.6761,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>custom</em> <em>attributes</em>",
        "body": " data ¬† Add <em>custom</em> <em>attributes</em> Use <em>custom</em> <em>attributes</em> for deeper analysis 15 min Collect data - any source APIs, agents, OS emitters - get any data 5 min Create <em>custom</em> events Define, visualize, and get alerts on the data you want using <em>custom</em> events 25 min Build queries with NerdGraph Try NerdGraph and build the queries you need 10 min Query data with <em>NRQL</em> Query default data, <em>custom</em> events, and <em>attributes</em>"
      },
      "id": "5efa997328ccbc768c307de2"
    },
    {
      "category_2": "Custom events",
      "nodeid": 7551,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "New Relic Mobile: Report custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations",
        "For more help"
      ],
      "title": "New Relic Mobile: Report custom events and attributes",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "external_id": "506199adb1861d0327f1a701144d767ad9c5c546",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/insert-custom-events-attributes-new-relic-mobile-data",
      "published_at": "2020-10-22T09:02:21Z",
      "updated_at": "2020-10-18T10:17:10Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "How to query your New Relic Mobile events and attributes, and how to create custom events and attributes.",
      "body": "New Relic Mobile sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default Mobile events using the New Relic Mobile SDK. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple Mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb & MobileHandledException events. These events are available for querying and also displayed in the Mobile crash event trail. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create custom events. The recordEvent methods for Android and iOS are deprecated. The deprecated recordEvent events do not have their own event type; they are recorded as a Mobile event type with a category attribute value of custom. recordCustomEvent creates an event with an eventType you can assign. But the eventType should only be used for one or two high-level event types, not for naming events. For example, you might have one event type Gestures, with many different names under that one type. For more context on this, see the recordCustomEvent query example. Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Size limits and restricted characters Limits for custom attributes added to default Mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Privacy considerations Should you want to collect personal data via custom attributes, please consult with your privacy or legal teams with regards to your notice and consent regulatory obligations. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.10498,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic Mobile: Report <em>custom</em> events and <em>attributes</em>",
        "sections": "New Relic Mobile: Report <em>custom</em> events and <em>attributes</em>",
        "info": "How to query your New Relic Mobile events and <em>attributes</em>, and how to create <em>custom</em> events and <em>attributes</em>.",
        "category_2": "<em>Custom</em> events",
        "body": " are available for querying and also displayed in the Mobile crash event trail. For more on creating <em>custom</em> <em>attributes</em> and <em>custom</em> events, see: Android SDK API guide iOS SDK API guide <em>NRQL</em> query examples MobileRequestError examples MobileRequest examples Limits and restricted characters As of Android",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; Event data sources &#x2F; <em>Custom</em> events"
      },
      "id": "5e8cf77ee7b9d2062d2cf14d"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0 EMEA",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-10-24T01:40:08Z",
      "title": "New Relic Developers",
      "updated_at": "2020-10-24T01:38:33Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 EMEA Nerd Days is a FREE engineering conference that kicks off November 10 (EMEA). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 17 Days : 8 Hours : 31 Minutes : 16 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application ¬† Add custom attributes Use custom attributes for deeper analysis Show 21 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 85.848335,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>custom</em> <em>attributes</em>",
        "body": " <em>attributes</em> Use <em>custom</em> <em>attributes</em> for deeper analysis Show 21 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "category_2": "Default events",
      "nodeid": 7636,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Events reported by New Relic Mobile",
        "For more help"
      ],
      "title": "Events reported by New Relic Mobile ",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/insights-data-sources/default-data/mobile-default-events-insights",
      "external_id": "f31a2707a47d15fb1899968ddde7859637591bf7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/default-data/mobile-default-events-insights",
      "published_at": "2020-10-22T17:27:05Z",
      "updated_at": "2020-10-18T15:19:24Z",
      "breadcrumb": "Contents / Insights / Event data sources / Default events",
      "document_type": "page",
      "popularity": 1,
      "info": "The events and attributes reported by New Relic Mobile. ",
      "body": "New Relic Mobile reports event data that is displayed in some UI displays and is also available for querying and charting. The events reported by Mobile are in the table below. Select an event name to see its attributes. Attributes with incorrectly formatted values will not be sent up to New Relic with the rest of the associated event. Event Description Mobile A Mobile event is created when a crash occurs, when an interaction ends or has run for 1 second, or if a session completes after the app is closed, backgrounded, or has run for 10 minutes. Mobile events were once the only event type and were generated for every event, but now there are several specialized event types. Recommendation: Upgrade to the most recent New Relic Mobile agent version to take full advantage of the new event types. MobileBreadcrumb There are no attributes listed for this event because it's a custom event; attributes will include the session attributes and any custom attributes added. MobileCrash The MobileCrash event is created when an app crashes. MobileCrash includes attributes such as crash line number, class, and crash message. MobileHandledException MobileHandledException is sent when an exception is caught and is used for non-fatal exceptions reported to New Relic using the recordHandledException API call for Android or iOS. The exceptions will be visible in queries of this event and on the Handled exceptions UI page, including stack traces. MobileRequest A MobileRequest event is created when an HTTP request successfully completes, resulting in a response code below 400. To use this event type, you must have Mobile agent version 5.14.0 or higher for Android or iOS. New Relic MobileRequest data is enabled by default for: Android version 5.15.2 or higher iOS version 6.0.0 or higher For earlier versions, starting with Android version 5.14.0 or iOS version 5.14.0, you must enable the feature. Upgrade to the latest Android or iOS version, or enable the NetworkRequests feature flag by using the Android or iOS configuration settings. MobileRequestError A MobileRequestError is used for HTTP errors or network failures. HTTP errors are HTTP requests that have a status code greater than 400. A network failure is an HTTP request that results in no response. The event is sent when the HTTP request completes. For best results, use New Relic Mobile agent 5.14.0 or higher for Android or iOS. With lower agent versions, some attributes may be missing, and you will not have access to MobileRequest events. MobileSession A MobileSession event is sent when an app is closed, backgrounded, or when 10 minutes of active use has elapsed. This is the source of the general session data used by the other New Relic Mobile events. MobileSession captures attributes such as device type, device OS, and geographical information. Custom events There is no attribute list for this event type because it is a custom event; attributes will include the session attributes and any custom attributes that you add. Related documentation: Report custom events Extend data retention See example NRQL queries For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 85.12793,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Custom</em> events",
        "info": "The events and <em>attributes</em> reported by New Relic Mobile. ",
        "body": " and were generated for every event, but now there are several specialized event types. Recommendation: Upgrade to the most recent New Relic Mobile agent version to take full advantage of the new event types. MobileBreadcrumb There are no <em>attributes</em> listed for this event because it&#x27;s a <em>custom</em> event"
      },
      "id": "5d49bc7064441fb4c5084569"
    },
    {
      "category_2": "NRQL query tutorials",
      "nodeid": 11451,
      "sections": [
        "NRQL: New Relic Query Language",
        "Get started",
        "NRQL query tools",
        "NRQL query tutorials",
        "Simulate SQL JOIN functions in Insights",
        "Simulate SQL JOIN with custom attributes",
        "For more help"
      ],
      "title": "Simulate SQL JOIN functions in Insights",
      "category_0": "Query your data",
      "type": "docs",
      "category_1": "NRQL: New Relic Query Language",
      "external_id": "9ace89658c3020db08f87be5f031a1eadc742b27",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/simulate-sql-join-functions-insights",
      "published_at": "2020-10-24T01:55:32Z",
      "updated_at": "2020-10-09T11:48:22Z",
      "breadcrumb": "Contents / Query your data / NRQL: New Relic Query Language / NRQL query tutorials",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic NRQL: simulating SQL-like JOIN functions using custom attributes.",
      "body": "NRQL does not have an equivalent SQL-like JOIN function. You can simulate a JOIN by using custom attributes in a query's WHERE or FACET clause. Simulate SQL JOIN with custom attributes To gain more in-depth data, you can add custom attributes to some data types. For example, you want to know which browser types are experiencing the highest web duration for a specific product purchase. You could add a custom attribute named Product to your application's purchase transaction method. Then you could run this NRQL query: SELECT max(duration), average(duration), max(backendDuration), average(backendDuration) FROM PageView WHERE Product = 'Hat' FACET userAgentName SINCE 7 days ago For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.589294,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Simulate SQL JOIN with <em>custom</em> <em>attributes</em>",
        "info": "New Relic <em>NRQL</em>: simulating SQL-like JOIN functions using <em>custom</em> <em>attributes</em>.",
        "category_1": "<em>NRQL</em>: New Relic Query Language",
        "category_2": "<em>NRQL</em> query tutorials",
        "body": "<em>NRQL</em> does not have an equivalent SQL-like JOIN function. You can simulate a JOIN by using <em>custom</em> <em>attributes</em> in a query&#x27;s WHERE or FACET clause. Simulate SQL JOIN with <em>custom</em> <em>attributes</em> To gain more in-depth data, you can add <em>custom</em> <em>attributes</em> to some data types. For example, you want to know which",
        "breadcrumb": "Contents &#x2F; Query your data &#x2F; <em>NRQL</em>: New Relic Query Language &#x2F; <em>NRQL</em> query tutorials"
      },
      "id": "5f306fd3196a67d6a4fbd6d1"
    }
  ],
  "/automate-workflows/kubernetes-helm-deployment": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts"
      ],
      "published_at": "2020-10-24T01:51:46Z",
      "title": "Automate workflows",
      "updated_at": "2020-10-24T01:51:46Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 6188.992,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em>",
        "body": " the Kubernetes operator Learn how to provision <em>New</em> <em>Relic</em> resources <em>using</em> the Kubernetes operator 20 min Automate common tasks <em>Use</em> the <em>New</em> <em>Relic</em> CLI to tag apps and create deployment markers 30 min Getting started with <em>New</em> <em>Relic</em> and Terraform Learn how to provision <em>New</em> <em>Relic</em> resources <em>using</em> Terraform 20 min <em>Set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em> Learn how to <em>set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em>"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "image": "https://developer.newrelic.com/static/kubecon-europe-2020-b989ec0e7b4ed71a89666c35fe934433.jpg",
      "url": "https://developer.newrelic.com/kubecon-europe-2020/",
      "sections": [
        "KubeCon and CloudNativeCon Europe 2020",
        "New Relic welcomes you at Virtual Kubecon and CloudNativeCon Europe 2020!",
        "Attend one of our lightning talks",
        "Important",
        "We handle Prometheus, you keep Grafana",
        "How to use and customize Helm charts",
        "Kubernetes observability with context",
        "What is OpenTelemetry and how to get started?",
        "OpenTelemetry Architecture",
        "Kubernetes in the wild: best practices",
        "Want some action now? Check out the following videos!",
        "How to use the Kubernetes cluster explorer",
        "What is OpenTelemetry?",
        "Connecting Prometheus and Grafana to New Relic"
      ],
      "published_at": "2020-10-24T01:51:45Z",
      "title": "New Relic Developers",
      "updated_at": "2020-10-24T01:51:45Z",
      "type": "developer",
      "external_id": "53cb6afa4f4062ba359559e9fb3bb2406ece2ad4",
      "document_type": "page",
      "popularity": 1,
      "body": "KubeCon and CloudNativeCon Europe 2020 New Relic welcomes you at Virtual Kubecon and CloudNativeCon Europe 2020! Learn more about the New Relic One platform, the only observability platform that provides open, connected and programmable observability for cloud-native environments. Join us to dive into the New Relic One platform and our Kubernetes cluster explorer. Register here Attend one of our lightning talks Important Go to the virtual expo tab, and find New Relic in Silver Hall B to attend a lightning talk. We handle Prometheus, you keep Grafana Mon Aug 17 @ 14:35 CEST Samuel Vandamme How to use and customize Helm charts Mon Aug 17 @ 16:25 CEST Douglas Camata Kubernetes observability with context Tue Aug 18 @ 15:05 CEST Stijn Polfliet What is OpenTelemetry and how to get started? Tue Aug 18 @ 17:15 CEST Lavanya Chockaligam How to use and customize Helm charts Wed Aug 19 @ 15:05 CEST Douglas Camata OpenTelemetry Architecture Wed Aug 19 @ 16:25 CEST John Watson Kubernetes in the wild: best practices Thu Aug 20 @ 15:05 CEST Martin Fuentes Kubernetes observability with context Thu Aug 20 @ 16:50 CEST Stijn Polfliet Want some action now? Check out the following videos! How to use the Kubernetes cluster explorer What is OpenTelemetry? Connecting Prometheus and Grafana to New Relic",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 213.44862,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "How to <em>use</em> and customize <em>Helm</em> <em>charts</em>",
        "body": " to <em>use</em> and customize <em>Helm</em> <em>charts</em> Mon Aug 17 @ 16:25 CEST Douglas Camata Kubernetes observability with context Tue Aug 18 @ 15:05 CEST Stijn Polfliet What is OpenTelemetry and how to get started? Tue Aug 18 @ 17:15 CEST Lavanya Chockaligam How to <em>use</em> and customize <em>Helm</em> <em>charts</em> Wed Aug 19 @ 15:05 CEST"
      },
      "id": "5f373dcae7b9d20949909274"
    },
    {
      "category_2": "Link apps and services",
      "nodeid": 37376,
      "sections": [
        "Kubernetes integration",
        "Get started",
        "Installation",
        "Understand and use data",
        "Link apps and services",
        "Kubernetes events",
        "Logs",
        "Troubleshooting",
        "Monitor services running on Kubernetes",
        "What you need",
        "Enable monitoring of services",
        "Monitor services in our Kubernetes integration installed with Helm",
        "Learn more",
        "Manually configure service monitoring",
        "How the service-specific YAML config works",
        "Add a service YAML to the Kubernetes integration config",
        "Add multiple services to the same config",
        "For more help"
      ],
      "title": "Monitor services running on Kubernetes",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Kubernetes integration",
      "external_id": "09cf3758339bee685c768262e6b13d1187cb7c24",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/link-apps-services/monitor-services-running-kubernetes",
      "published_at": "2020-10-22T14:28:13Z",
      "updated_at": "2020-10-22T14:28:12Z",
      "breadcrumb": "Contents / Integrations / Kubernetes integration / Link apps and services",
      "document_type": "page",
      "popularity": 1,
      "info": "How to enable New Relic monitoring of services (like NGINX, Redis, MySQL, Apache) that run on Kubernetes. ",
      "body": "With New Relic's Kubernetes integration you can monitor both Kubernetes and the services running on it, such as Cassandra, Redis, MySQL, and other supported services. Get started Our Kubernetes integration comes bundled with some of our on-host integrations (like Cassandra, MySQL, and Apache). This lets you get data for those supported services by adding a section to the Kubernetes integration's configuration, which lives as a ConfigMap inside a manifest. What you need Enable this feature for a service Details about how configuration works For an example of how to monitor Redis running on a Kubernetes PHP Guestbook, see this tutorial. What you need To monitor services running on Kubernetes, you only need a Kubernetes cluster running the Kubernetes integration, version 1.13.0 or higher (install | check version | update). We support the following services running on Kubernetes: Apache (does not report inventory data) Cassandra Couchbase Elasticsearch HAProxy HashiCorp Consul JMX Kafka Memcached MongoDB MySQL NGINX PostgreSQL RabbitMQ (does not report inventory data) Redis SNMP Enable monitoring of services To enable our Kubernetes integration to monitor one or more services: Expand this dropdown and get the YAML snippets for the service(s) you want to monitor: Get the config YAML for the integration For the services you want to monitor, follow the links to GitHub to get the YAML snippets you'll need for the next step: Apache Cassandra Couchbase Elasticsearch HAProxy HashiCorp Consul JMX Kafka Memcached MongoDB MySQL NGINX PostgreSQL RabbitMQ Redis SNMP Add the snippet to the Kubernetes integration's ConfigMap, after the data: section: Example configuration This example shows the YAML config for the Apache integration ( highlighted ) added to the Kubernetes integration's config. Respect the indentation levels. --- apiVersion: v1 kind: ConfigMap metadata: name: nri-integration-cfg namespace: default data: apache-config.yaml: | --- # Run auto discovery to find pods with label \"app=apache\" # https://docs.newrelic.com/docs/integrations/host-integrations/installation/container-auto-discovery discovery: command: # Use the optional arguments: # --namespaces: Comma separated namespaces to discover pods on # --tls: Use secure (TLS) connection # --port: Port used to connect to the kubelet. Default is 10255 exec: /var/db/newrelic-infra/nri-discovery-kubernetes --port PORT --tls match: label.app: apache integrations: - name: nri-apache env: # Use the discovered IP as the host address STATUS_URL: http://${discovery.ip}/server-status?auto METRICS: 1 You can add snippets for multiple services to the same config file. See an example. Depending on your environment, you may need or want to set additional config options. Expand the dropdown below for links to configuration options. Configuration options for each integration Select a service to see available config options: Apache Cassandra Couchbase Elasticsearch HAProxy HashiCorp Consul JMX Kafka Memcached MongoDB MySQL NGINX PostgreSQL RabbitMQ Redis SNMP Verify monitoring is enabled: Go to one.newrelic.com > Infrastructure, select Third party services, and then select the service's dashboard. You should see data being reported. Additional notes about enabling services: Enabling multiple services may use more resources than what is set in the resource limits of the Kubernetes integration config file. If this becomes an issue, raise the limit in the resources section. The Kubernetes integration does not automatically update. For best results, regularly update. Monitor services in our Kubernetes integration installed with Helm If you installed our Kubernetes integration using Helm, to monitor services you need to update the existing installation with the new configuration, which contains the services to monitor: helm upgrade --reuse-values -f values.yaml [RELEASE] [CHART] If you use nri-bundle charts, you need to update the children's chart values. Find some examples here. Learn more More resources for learning about configuration: Learn technical details about how configuration works. Learn how to configure monitoring of multiple services with the same config file. See a step-by-step tutorial showing how to monitor a Redis service on Kubernetes. Manually configure service monitoring The enable procedure should be all you need to get monitoring working, but if you run into problems, understanding some technical details about configuration can be helpful. This section goes into more detail about how configuration works. For each service you wish to monitor, you must add a configuration file for that integration to our Kubernetes integration's configuration. This document will cover these subjects: How the service-specific configuration YAML snippet works Adding the service-specific YAML in the Kubernetes integration's config file Adding multiple services to the Kubernetes integration's config file How the service-specific YAML config works Our Kubernetes integration's configuration follows the ConfigMap format. Using a ConfigMap allows us to decouple the configuration for the integrations from the Kubernetes image. The other benefit is that a ConfigMap can be updated automatically without reloading the running container. Because the infrastructure agent uses YAML to configure its associated integrations, ConfigMaps are a good choice for storing YAML. (For more information on config file format, see the Integration config file format.) The Kubernetes integration image comes with an auto-discovery feature that simplifies the configuration of multiple instances of services using a single configuration file. For example, if you have several NGINX instances running, creating an NGINX integration configuration file for every instance would be hard to implement and hard to update. With our auto-discovery option, you can discover and monitor all your NGINX instances with a single configuration file. Each integration has its own specific configuration YAML. Our NGINX integration default config file looks like this: nginx-config.yml: | --- discovery: command: exec: /var/db/newrelic-infra/nri-discovery-kubernetes match: label.app: nginx integrations: - name: nri-nginx env: STATUS_URL: http://${discovery.ip}/status STATUS_MODULE: discover METRICS: 1 The above config enables the following: Runs nri-discovery-kubernetes to query the data for the node we are currently on. Parses the data that comes back and looks for any Kubernetes pod that has a Kubernetes container with an app= label with value nginx. For any matches, it attempts to run the NGINX integration. The status URL is built from: The pod's IP address The status page is pulled from the label on K8s pod called status_url This automatic discovery works the same as the container auto-discovery used by the infrastructure agent. For more advanced options, see Container auto-discovery. Add a service YAML to the Kubernetes integration config It's best practice to configure enabled integrations alongside the Kubernetes integration configuration. This is easier than maintaining configuration files for every single service/integration instance. Below is an example of a Kubernetes integration's ConfigMap. The highlighted section shows where an integration configuration YAML (in this case, NGINX) is placed. For more information on discovery:, see Container auto-discovery for on-host integrations. --- apiVersion: v1 kind: ConfigMap metadata: name: nri-integration-cfg namespace: default data: nginx-config.yml: | --- # Run auto discovery to find pods with label \"app=nginx\" # https://docs.newrelic.com/docs/integrations/host-integrations/installation/container-auto-discovery discovery: command: # Use the following optional arguments : # --namespaces: Comma separated list of namespaces to discover pods on # --tls: Use secure (TLS) connection # --port: Port used to connect to the kubelet. Default is 10255 exec: /var/db/newrelic-infra/nri-discovery-kubernetes --port PORT --tls match: label.app: nginx integrations: - name: nri-nginx env: # If you're using ngx_http_api_module be certain to use the full path up to and including the version number # Use the discovered IP as the host address STATUS_URL: http://${discovery.ip}/status # Comma separated list of ngx_http_api_module, NON PARAMETERIZED, Endpoints # endpoints: /nginx,/processes,/connections,/ssl,/slabs,/http,/http/requests,/http/server_zones,/http/caches,/http/upstreams,/http/keyvals,/stream,/stream/server_zones,/stream/upstreams,/stream/keyvals,/stream/zone_sync # Name of Nginx status module OHI is to query against. discover | ngx_http_stub_status_module | ngx_http_status_module | ngx_http_api_module STATUS_MODULE: discover METRICS: 1 This configuration map can then be referenced in the DaemonSet, the same as the one that was generated via the command line. Make sure the namespace used is the same one used by the Kubernetes integration manifest. If you haven't changed it in the downloaded manifest file, the value is default. Add multiple services to the same config You can monitor several services using the same Kubernetes integration config file. To do this, add another integration configuration YAML to the same Kubernetes integration config file. Below is the Kubernetes config created in the last section, with a new section for the Cassandra integration's config (highlighted). --- apiVersion: v1 kind: ConfigMap metadata: name: nri-integration-cfg namespace: default data: nginx-config.yml: | --- # Run auto discovery to find pods with label \"app=nginx\" # https://docs.newrelic.com/docs/integrations/host-integrations/installation/container-auto-discovery discovery: command: # Run discovery for Kubernetes. Use the following optional arguments : # --namespaces: Comma separated list of namespaces to discover pods on # --tls: Use secure (TLS) connection # --port: Port used to connect to the kubelet. Default is 10255 exec: /var/db/newrelic-infra/nri-discovery-kubernetes --port PORT --tls match: label.app: nginx integrations: - name: nri-nginx env: # If you're using ngx_http_api_module be certain to use the full path up to and including the version number # Use the discovered IP as the host address STATUS_URL: http://${discovery.ip}/status # Comma separated list of ngx_http_api_module, NON PARAMETERIZED, Endpoints # endpoints: /nginx,/processes,/connections,/ssl,/slabs,/http,/http/requests,/http/server_zones,/http/caches,/http/upstreams,/http/keyvals,/stream,/stream/server_zones,/stream/upstreams,/stream/keyvals,/stream/zone_sync # Name of Nginx status module OHI is to query against. discover | ngx_http_stub_status_module | ngx_http_status_module | ngx_http_api_module STATUS_MODULE: discover METRICS: 1 cassandra-configuration.yml: | --- # Run auto discovery to find pods with label \"app=cassandra\" # https://docs.newrelic.com/docs/integrations/host-integrations/installation/container-auto-discovery discovery: command: # Run discovery for Kubernetes. Use the following optional arguments : # --namespaces: Comma separated list of namespaces to discover pods on # --tls: Use secure (TLS) connection # --port: Port used to connect to the kubelet. Default is 10255 exec: /var/db/newrelic-infra/nri-discovery-kubernetes --port PORT --tls match: label.app: cassandra integrations: - name: nri-cassandra env: # Use the discovered IP as the host address HOSTNAME: ${discovery.ip} PORT: 7199 USERNAME: cassandra PASSWORD: cassandra METRICS: 1/mark The Kubernetes integration config is now set up to monitor these two services. Additionally, depending on your environment, there may be some additional service-specific configuration you must do. When you've completed configuration, our infrastructure agent looks for any pod with a label cassandra and runs the integration against it. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.892,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Understand and <em>use</em> data",
        "info": "How to enable <em>New</em> <em>Relic</em> monitoring of services (like NGINX, Redis, MySQL, Apache) that run on Kubernetes. ",
        "body": " integration installed with <em>Helm</em> If you installed our Kubernetes integration <em>using</em> <em>Helm</em>, to monitor services you need to update the existing installation with the <em>new</em> configuration, which contains the services to monitor: <em>helm</em> upgrade --reuse-values -f values.yaml [RELEASE] [<em>CHART</em>] If you <em>use</em> nri-bundle"
      },
      "id": "5e34ac28e7b9d21c094958dd"
    },
    {
      "category_2": "Get started",
      "nodeid": 38331,
      "sections": [
        "Kubernetes integration",
        "Get started",
        "Installation",
        "Understand and use data",
        "Link apps and services",
        "Kubernetes events",
        "Logs",
        "Troubleshooting",
        "Kubernetes integration: compatibility and requirements",
        "Compatibility",
        "Requirements",
        "Install using Helm",
        "For more help"
      ],
      "title": "Kubernetes integration: compatibility and requirements",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Kubernetes integration",
      "external_id": "dd40c3bef40e68d873d909dbff75708e20a1141e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/get-started/kubernetes-integration-compatibility-requirements",
      "published_at": "2020-10-22T11:29:09Z",
      "updated_at": "2020-10-14T15:35:38Z",
      "breadcrumb": "Contents / Integrations / Kubernetes integration / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "Compatibility and requirements of the New Relic Kubernetes integration.",
      "body": "New Relic's Kubernetes integration can be installed directly on a server or VM, or through several cloud platforms, such as GKE, EKS, AKS, or OpenShift. Each has a different compatibility with our integration. Compatibility Our Kubernetes integration is compatible with the following versions, depending on the installation mode: Install mode or feature Kubernetes versions Kubernetes cluster Currently tested with versions 1.10 to 1.18 Kubernetes cluster GKE Currently tested with versions 1.10 and 1.17 Kubernetes cluster EKS Compatible with version 1.11 or higher Kubernetes cluster AKS Compatible with version 1.11 or higher Kubernetes cluster OpenShift Currently tested with versions 3.7, 3.9, 4.2, 4.3, 4.4 and 4.5 Control plane monitoring Compatible with version 1.11 or higher Service monitoring Compatible with version 1.13 or higher Requirements The New Relic Kubernetes integration has the following requirements: Linux distribution compatible with New Relic infrastructure agent. kube-state-metrics version 1.9.5 running on the cluster. When using CRI-O as the container runtime, the processes inside containers are not reported. Performance data is collected at the container level. Install using Helm For compatibility and requirements when installing the Kubernetes integration using Helm, see Alternative install using Helm. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.97676,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install <em>using</em> <em>Helm</em>",
        "info": "Compatibility and requirements of the <em>New</em> <em>Relic</em> Kubernetes integration.",
        "body": " the following requirements: Linux distribution compatible with <em>New</em> <em>Relic</em> infrastructure agent. kube-state-metrics version 1.9.5 running on the cluster. When <em>using</em> CRI-O as the container runtime, the processes inside containers are not reported. Performance data is collected at the container level"
      },
      "id": "5ea87c3be7b9d2c533748090"
    },
    {
      "category_2": "New Relic for iOS release notes",
      "nodeid": 8411,
      "sections": [
        "Mobile apps release notes",
        "New Relic for Android release notes",
        "Insights for tvOS release notes",
        "New Relic for iOS release notes",
        "Insights for Android release notes",
        "Insights for iOS release notes",
        "New Relic for iOS 3.20.3",
        "New Relic for iOS 3.53.0",
        "Notes",
        "New features",
        "Improvements",
        "Bug fixes",
        "New Relic for iOS 3.52.1",
        "New Relic for iOS 3.51.1",
        "New Relic for iOS 3.50.0",
        "New Relic for iOS 3.49.0",
        "New Relic for iOS 3.48.0",
        "New Relic for iOS 3.47.0",
        "New Relic for iOS 3.46.1",
        "New Relic for iOS 3.46.0",
        "Pages"
      ],
      "title": "New Relic for iOS 3.20.3",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "Mobile apps release notes",
      "external_id": "a266a331e9c78e3af9160c97be2d58be684a96cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/mobile-apps-release-notes/new-relic-ios-3203?page=0%2C1",
      "published_at": "2020-10-24T08:12:13Z",
      "updated_at": "2020-10-24T08:12:13Z",
      "breadcrumb": "Contents / Release notes / Mobile apps release notes / New Relic for iOS release notes",
      "document_type": "release_notes",
      "popularity": -2,
      "body": "[RSS] Items per page 5 10 New Relic for iOS 3.53.0 Wednesday, November 20, 2019 - 15:30 Download Notes We now have an improved Mobile APM Http Errors view, to allow you to facet & filter down to the errors you care about. New features New Mobile APM HTTP Errors view Improvements Added support for Radar in context 'event' anomalies Bug fixes Fixed a crash that sometimes occurred when viewing charts Fixed a crash that sometimes appeared when trying to login Fixed a crash that occurred rarely in the monitors page New Relic for iOS 3.52.1 Tuesday, November 12, 2019 - 09:00 Download Notes Support for iOS 13 dark mode!!! New features Dark mode support for iOS 13 New crashes tab in Mobile APM, with improved grouping, searching and filtering Added in Synthetics monitors to the iPad Improvements Fix for showing a retry login popup when we shouldn't be Enable auto resizing of the y axis in charts, to scale to the visible time window Update APM app error rate to reflect the web New Relic for iOS 3.51.1 Friday, September 13, 2019 - 14:30 Download Notes The New Relic app is even better with an improved home screen, displaying all your favorite services, hosts, mobile and browser apps, key transactions, and more. This enhanced landing page also allows you to search across services, apps and hosts! New features Added new home screen with favorite APM, Mobile, and Browser apps, Infrastructure hosts, key transactions, and plugin instances. Added search to the home screen, to quickly search across APM, Mobile, Browser apps, hosts and key transactions. Improvements Updated Infrastructure, when viewing a filter set, to show all hosts in the charts (up to 20) by default. New Relic for iOS 3.50.0 Wednesday, July 31, 2019 - 12:00 Download Notes Improved and redesigned Browser product within the app! New features New Browser single page app (SPA) overview charts Added support to display in progress Browser violations and recent events Added support to display Browser page views Added support to display Browser JS errors Improvements Improved real agents call in APM Added link in app to license documentation New Relic for iOS 3.49.0 Wednesday, May 15, 2019 - 10:00 Download Notes Synchronizes app favorites with New Relic One for a consistent way to get access to those APM apps, Browser apps, Mobile apps, and Synthetics monitors wherever you might be. Improvements Uses the same data source for favorites as New Relic One Merges any iPhone / iPad specific favorites into your New Relic One favorites Updates Apdex charts to zoom in on the y axis to better show smaller variations Update Transaction trace bar to closer match the web in some edge cases Bug fixes Fixed an issue where searching in the APM Error attributes or stack traces would result in strange behavior Fixes an issue in the host / instance popup where the web response time was off by an order of magnitude New Relic for iOS 3.48.0 Thursday, April 11, 2019 - 09:00 Download New features Additional information for Java instances and Elixir hosts in the APM application detail section. New host / instance drop down for APM applications showing summary information, and allowing you to filter the APM page to a specific host or instance. Improvements Update to the Mobile APM summary page to allow the view to load for more customers New Relic for iOS 3.48.0 Thursday, April 11, 2019 - 09:00 Download Notes Our new APM memory / threads section now works with Java & Elixir agents! Improvements Additional information for Java instances and Elixir hosts in the APM application detail section. New host / instance drop down for APM applications showing summary information, and allowing you to filter the APM page to a specific host or instance. Update to the Mobile APM summary page, so that some edge cases will now load. New Relic for iOS 3.47.0 Monday, March 18, 2019 - 09:00 Download New features Additional information for hosts of Ruby, Node.js, and Go APM applications. Bug fixes Fixed a crash when tapping logout on the iPad Fixed for some Synthetics monitors not loading Fixed a few other infrequent crashes New Relic for iOS 3.46.1 Monday, February 11, 2019 - 09:00 Download Bug fixes Fixed the problem with muting, and enabling / disabling Synthetics monitors New Relic for iOS 3.46.0 Tuesday, January 29, 2019 - 14:15 Download Improvements Updated account settings screen enables seamless transition between users and accounts Bug fixes Fixed rare crash when saml users return from authenticating Pages ¬´ first ‚Äπ previous 1 2 3 4 5 6 7 8 9 next ‚Ä∫ last ¬ª",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.24211,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> for iOS 3.20.3",
        "sections": "<em>New</em> <em>Relic</em> for Android release notes",
        "category_2": "<em>New</em> <em>Relic</em> for iOS release notes",
        "body": " across APM, Mobile, Browser apps, hosts and key transactions. Improvements Updated Infrastructure, when viewing a filter <em>set</em>, to show all hosts in the <em>charts</em> (<em>up</em> to 20) by default. <em>New</em> <em>Relic</em> for iOS 3.50.0 Wednesday, July 31, 2019 - 12:00 Download Notes Improved and redesigned Browser product within",
        "breadcrumb": "Contents &#x2F; Release notes &#x2F; Mobile apps release notes &#x2F; <em>New</em> <em>Relic</em> for iOS release notes"
      },
      "id": "5b6b67d5827a6614c852ffd6"
    }
  ],
  "/explore-docs/newrelic-cli": [
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-10-24T01:53:25Z",
      "updated_at": "2020-10-24T01:53:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1125.7458,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the <em>New</em> <em>Relic</em> <em>CLI</em> is a good candidate for automation. In this 5-minute guide, you use the <em>New</em> <em>Relic</em>"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "sections": [
        "Explore NerdGraph using the API Explorer",
        "Before you begin",
        "Build a query to retrieve your name",
        "Click the play button to see the result",
        "Add more fields to your query",
        "Experiment with mutations",
        "Tip",
        "Try your NerdGraph query in the terminal",
        "Next steps"
      ],
      "title": "Explore NerdGraph using the API Explorer",
      "type": "developer",
      "tags": [
        "nerdgraph",
        "mutations",
        "nerdgraph query terminal"
      ],
      "external_id": "df1f04edc2336c69769d946edbaf263a5339bc92",
      "image": "https://developer.newrelic.com/static/0ce8c387a290d7fbd6be155322be9bce/bc8d6/create-account.png",
      "url": "https://developer.newrelic.com/collect-data/get-started-nerdgraph-api-explorer/",
      "published_at": "2020-10-24T01:53:26Z",
      "updated_at": "2020-10-24T01:53:26Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Explore NerdGraph, our GraphQL API, and build the queries you need.",
      "body": "Explore NerdGraph using the API Explorer 25 min NerdGraph is New Relic's GraphQL API. It allows you to get all the information you need in a single request. With NerdGraph API Explorer you don't need to know the query format: using the Query Builder you can browse our entire graph and compose queries just by selecting the items you want and filling out their required values. Before you begin Go to api.newrelic.com/graphiql and log in using your New Relic user ID and password: the NerdGraph API Explorer loads up. Make sure you have a valid New Relic API key. You can create one directly from the NerdGraph API Explorer. Step 1 of 5 Build a query to retrieve your name Time for your first NerdGraph query. Search for your name in the New Relic database: Erase everything in the query editor. Select the following fields in the query explorer in this order: actor, user, name. This GraphQL snippet appears in the editor. { actor { user { name } } } Copy Step 2 of 5 Click the play button to see the result With this query, you're telling NerdGraph to retrieve your name. You're asking for the name field, which is nested within the user field. This refers to the user who owns the API key, which in turn is nested within actor. Click the play button to see the result: It has almost the same shape as the request. All the fields in the Query Builder make up what's called the GraphQL schema, which describes all the available data types and their attributes. To learn more about each field, click the Docs button, or hover over a field in the editor. Step 3 of 5 Add more fields to your query Now you can try adding more fields to your query. The simplest way is clicking the fields in the Query Builder: The API Explorer knows where the attributes should go in the query. In the example, you add the account id and email fields. Once again, running the GraphQL query results in just the data you need, without over or under-fetching data. Notice that the id field has an argument: passing arguments is a powerful way of customizing your NerdGraph queries. Every field and object can contain arguments, so instead of running multiple queries, you just compose the one that you need. { actor { user { name email } account(id: 12345678) } } Copy Step 4 of 5 Experiment with mutations In GraphQL, mutations are a way to execute queries with side effects that can alter the data by creating, updating, or deleting objects (Commonly referred to as CRUD operations in REST APIs). Ready for your first mutation? Erase what's in the editor. Scroll down the Query Builder and expand mutation. Select the fields in the following screenshot: In this case, you're trying to add a custom tag to an entity. Notice that the editor complains if you don't select errors: mutations must have a way of telling you how the operation performed in the backend (failed requests result in null responses). Tip Unlike REST, GraphQL APIs like NerdGraph can return partial responses. For example, if you try adding tags to multiple entities, some mutations can fail and others succeed; all is logged in the GraphQL response you get. Step 5 of 5 Try your NerdGraph query in the terminal Let's say that you've built a NerdGraph query you're happy with and you want to test it elsewhere. To capture code-ready queries and mutations: Select the Tools menu. Copy the query as a curl call or as a New Relic CLI command. bash Copy $ # curl version $ curl https://api.newrelic.com/graphql \\ > -H 'Content-Type: application/json' \\ > -H 'API-Key: API_KEY_REDACTED' \\ > --data-binary '{\"query\":\"{\\n actor {\\n user {\\n name\\n email\\n }\\n account(id: 12345678)\\n }\\n}\\n\", \"variables\":\"\"}' $ $ # New Relic CLI version $ newrelic nerdgraph query '{ $ actor { $ user { $ name $ email $ } $ account(id: 12345678) $ } $ } $ ' Next steps Now you know the basics of composing and testing NerdGraph queries, but how do you turn them into client or server code? Solutions such as GraphQL Code Generator can help you turn the NerdGraph queries into code for your implementation. Try creating more complex queries by clicking fields and expanding objects in the Query Builder (be careful with mutations though, since they could write data to your account). For more information on NerdGraph and explore other projects from the developer community, check out the threads on the Explorer‚Äôs Hub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 800.625,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Click</em> the play button to see the result",
        "body": " and mutations: Select the Tools menu. Copy the query as a curl call or as a <em>New</em> <em>Relic</em> <em>CLI</em> command. bash Copy $ # curl version $ curl https:&#x2F;&#x2F;api.newrelic.com&#x2F;graphql \\ &gt; -H &#x27;Content-Type: application&#x2F;json&#x27; \\ &gt; -H &#x27;API-Key: API_KEY_REDACTED&#x27; \\ &gt; --data-binary &#x27;{&quot;query&quot;:&quot;{\\n actor {\\n user {\\n name\\n email\\n"
      },
      "id": "5efa9973196a6791f4766402"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts"
      ],
      "published_at": "2020-10-24T01:51:46Z",
      "title": "Automate workflows",
      "updated_at": "2020-10-24T01:51:46Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 783.2733,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " CloudFormation, and a command-line interface. These tools enable you to integrate <em>New</em> <em>Relic</em> into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and <em>CLI</em> guides below, find more automation"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0 EMEA",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-10-24T01:40:08Z",
      "title": "New Relic Developers",
      "updated_at": "2020-10-24T01:38:33Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 EMEA Nerd Days is a FREE engineering conference that kicks off November 10 (EMEA). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 17 Days : 8 Hours : 31 Minutes : 16 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application ¬† Add custom attributes Use custom attributes for deeper analysis Show 21 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 782.6975,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": ", agents, OS emitters - get any data 20 min Automate common tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application ¬† Add custom"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-10-24T01:54:36Z",
      "updated_at": "2020-10-24T01:54:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: bash Copy $ my-nerdlet $ ‚îú‚îÄ‚îÄ README.md $ ‚îú‚îÄ‚îÄ launchers $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ nerdlets $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss $ ‚îú‚îÄ‚îÄ node_modules $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler $ ‚îú‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ package-lock.json $ ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 706.4127,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> One <em>CLI</em>",
        "body": " How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the <em>New</em> <em>Relic</em> One <em>CLI</em> command nr1 create and select Nerdpack to create"
      },
      "id": "5efa989e196a671300766404"
    }
  ],
  "/explore-docs/intro-to-sdk": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-10-24T02:00:01Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1286.6157,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use NerdStorage in your <em>apps</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "Intro to Nerd<em>Storage</em> 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em>. On this page, you‚Äôll learn how to use Nerd<em>Storage</em> <em>SDK</em> <em>components</em>. Use Nerd<em>Storage</em> in your <em>apps</em> Nerd<em>Storage</em> is used to store and retrieve simple sets of data, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "Intro to NerdStorageVault",
        "Using NerdStorageVault in your apps",
        "Tip",
        "Usage considerations",
        "Component library",
        "NerdGraph queries",
        "Write",
        "Delete",
        "Fetch a single secret",
        "Fetch a list of secrets",
        "Limits",
        "Permissions for working with NerdStorageVault"
      ],
      "title": "Intro to NerdStorageVault",
      "type": "developer",
      "tags": [
        "nerdstoragevault",
        "nerdstoragevault components",
        "new relic one apps",
        "data access",
        "encrypted storage"
      ],
      "external_id": "8355de4bf337963434c4d3b90f5d9c32f58e4bcc",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstoragevault/",
      "published_at": "2020-10-24T01:54:35Z",
      "updated_at": "2020-10-24T01:54:35Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorageVault on New Relic One",
      "body": "Intro to NerdStorageVault 15 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data such as: personal access tokens license keys API keys other third party secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorageVault can currently only be used within the context of a Nerdpack. You cannot make a direct query or mutation to NerdStorageVault. You can explore the fields and response types via the NerdGraph API explorer. The only supported scope is ACTOR, or data that relates to a particular user. Component library Currently NerdStorageVault is available in the alpha release of Nr1 Community component library and is not available in the Nr1 core components library. Open source components can be use to augment Nr1 core components for additional functionality. NerdGraph queries Below are examples of the queries used by the components to interact with NerdStorageVault. Tip NerdStorageVault can currently only be used within the context of a Nerdpack. Write mutation { nerdStorageVaultWriteSecret(scope: { actor: CURRENT_USER } , secret: { key: \"test\", value: \"secret_test\" } ) { status errors { message type } } } Copy Delete mutation { nerdStorageVaultDeleteSecret(scope: { actor: CURRENT_USER } , key: \"test_key\" ) { status errors { message type } } } Copy Fetch a single secret { actor { nerdStorageVault { secret(key: \"test_key\") { key value } } } } Copy Fetch a list of secrets { actor { nerdStorageVault { secrets { key value } } } } Copy Limits A maximum of 10 secrets can be stored per ACTOR. A secret value is limited to 5000 characters. A key value is limited to 64 characters. Permissions for working with NerdStorageVault In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1224.2521,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Using NerdStorageVault in your <em>apps</em>",
        "info": "Intro to NerdStorageVault on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "Intro to Nerd<em>Storage</em>Vault 15 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em>. On this page, you‚Äôll learn how to use Nerd<em>Storage</em>Vault to store data in an encrypted <em>storage</em> solution. Using Nerd<em>Storage</em>Vault in your <em>apps</em> Nerd<em>Storage</em>Vault is used to store"
      },
      "id": "5f865b55196a675792bd5340"
    },
    {
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps"
      ],
      "title": "Add tables to your New Relic One application",
      "type": "developer",
      "tags": [
        "table in app",
        "Table component",
        "TableHeaderc omponent",
        "TableHeaderCell component",
        "TableRow component",
        "TableRowCell component"
      ],
      "external_id": "7ff7a8426eb1758a08ec360835d9085fae829936",
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/",
      "published_at": "2020-10-24T01:53:24Z",
      "updated_at": "2020-10-24T01:53:23Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a table to your New Relic One app.",
      "body": "Add tables to your New Relic One application 30 min Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git` $ cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet` Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. bash Copy $ nr1 nerdpack:uuid -gf # Update the app unique ID $ npm install # Install dependencies $ nr1 nerdpack:serve # Serve the demo app locally Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the nerdlets/create-a-table-nerdlet subdirectory and open the index.js file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside of the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1008.1584,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add tables to your <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "sections": "Add tables to your <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "info": "Add a table to your <em>New</em> <em>Relic</em> <em>One</em> <em>app</em>.",
        "tags": "table in <em>app</em>",
        "body": " hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You&#x27;ve built a table into a <em>New</em> <em>Relic</em> <em>One</em> application, using <em>components</em> to format data automatically and provide contextual actions. Well done! Keep exploring the Table <em>components</em>, their properties, and how to use them, in our <em>SDK</em> documentation."
      },
      "id": "5efa989ee7b9d2ad567bab51"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add the NerdGraphQuery component to an application",
        "Add a table to your app",
        "Permissions for managing applications",
        "Set up your development environment",
        "Publish and deploy apps",
        "Create a custom map view"
      ],
      "published_at": "2020-10-24T01:53:25Z",
      "title": "Build apps",
      "updated_at": "2020-10-24T01:53:25Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 30 min Add a table to your app Add a table to your New Relic One app ¬† Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 30 min Publish and deploy apps Start sharing the apps you build 30 min Create a custom map view Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 843.69403,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Publish <em>and</em> deploy <em>apps</em>",
        "body": " the NerdGraph<em>Query</em> component to an application The NerdGraph<em>Query</em> component allows you to <em>query</em> data from your account and add it to a dropdown menu in an application 30 min Add a table to your <em>app</em> Add a table to your <em>New</em> <em>Relic</em> <em>One</em> <em>app</em> ¬† Permissions for managing applications Learn about permissions"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-10-24T01:54:36Z",
      "updated_at": "2020-10-24T01:54:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: bash Copy $ my-nerdlet $ ‚îú‚îÄ‚îÄ README.md $ ‚îú‚îÄ‚îÄ launchers $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ nerdlets $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss $ ‚îú‚îÄ‚îÄ node_modules $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler $ ‚îú‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ package-lock.json $ ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 803.2062,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Generate Nerdpack <em>components</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> CLI",
        "body": " <em>components</em>, see our <em>app</em> building guides and the <em>New</em> <em>Relic</em> <em>One</em> CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: bash Copy $ my-nerdlet $ ‚îú‚îÄ‚îÄ README.md $ ‚îú‚îÄ‚îÄ launchers $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher"
      },
      "id": "5efa989e196a671300766404"
    }
  ],
  "/build-apps/publish-deploy": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add the NerdGraphQuery component to an application",
        "Add a table to your app",
        "Permissions for managing applications",
        "Set up your development environment",
        "Publish and deploy apps",
        "Create a custom map view"
      ],
      "published_at": "2020-10-24T01:53:25Z",
      "title": "Build apps",
      "updated_at": "2020-10-24T01:53:25Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 30 min Add a table to your app Add a table to your New Relic One app ¬† Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 30 min Publish and deploy apps Start sharing the apps you build 30 min Create a custom map view Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.39577,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "<em>Publish</em> and <em>deploy</em> <em>apps</em>",
        "body": " for subscribing to <em>apps</em> 20 min Set up your development environment Prepare to build <em>apps</em> and contribute to this site 30 min <em>Publish</em> and <em>deploy</em> <em>apps</em> Start sharing the <em>apps</em> you build 30 min Create a custom map view Build an <em>app</em> to show page view data on a map"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Permissions for managing applications",
        "New Relic One pricing plan",
        "Original product-based pricing"
      ],
      "title": "Permissions for managing applications",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2020-10-24T01:56:11Z",
      "updated_at": "2020-09-02T02:04:41Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for subscribing to apps",
      "body": "Permissions for managing applications When you create an app, you'll likely want to share it. From New Relic One's Apps page, you can subscribe to apps you create, publish, and deploy, and to other publicly available apps. You must have the Nerdpack manager role to subcribe accounts to apps. Read on to learn about permissions and versions. Permissions for managing applications The Nerdpack manager role is a New Relic add-on role. When you create a Nerdpack, you have the Nerdpack manager role for handling that Nerdpack. New Relic account administrators have the Nerdpack manager role automatically, and can subscribe their accounts to available Nerdpacks. User permissions vary depending on which pricing plan you are on. New Relic One pricing plan For accounts with New Relic One pricing, there are permissions differences for basic users and full users: Full users have the Nerdpack manager role and have full capabilities for creating and managing New Relic One applications, as well as accessing all types of applications in the New Relic One catalog. A basic user can develop and view their own local New Relic One apps, but they cannot: Subscribe other users to apps they‚Äôve created. Access or manage apps in the New Relic One catalog. Access apps in the entity explorer sidebar. Original product-based pricing For accounts on our original product-based pricing, here are access details: Subscribe to publicly available applications To subscribe to publicly available applications, you must have the Nerdpack manager role. Nerdpack manager permissions are automatically assigned to New Relic account owners and admins and can be assigned to individual users. If you aren‚Äôt an owner or admin, you can request Nerdpack manager permission, or ask your New Relic admin or owner to subscribe the apps to your account for you. You can add any of the publicly available applications to master accounts or separate sub-accounts on which you have the Nerdpack manager role, or to separate sub-accounts under a master account you own or administer. If you add the application to a master account, the access flows to all of its sub-accounts as well. Subscribe to applications that you create You also must have the Nerdpack manager role to subscribe the applications you create to accounts. Applications that you publish and deploy can only be subscribed to the master account that was used to publish them, or to its sub-accounts. This means you might want a New Relic admin to deploy your applications for you if they need to be available across the organization.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 52.749912,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Permissions for managing <em>applications</em>",
        "sections": "Permissions for managing <em>applications</em>",
        "info": "Learn about permissions for <em>subscribing</em> to <em>apps</em>",
        "tags": "managing <em>apps</em>",
        "body": "Permissions for managing applications When you create an <em>app</em>, you&#x27;ll likely want to share it. From New Relic One&#x27;s <em>Apps</em> page, you can <em>subscribe</em> to <em>apps</em> you create, <em>publish</em>, and <em>deploy</em>, and to other publicly available <em>apps</em>. You must have the Nerdpack manager role to subcribe accounts to <em>apps</em>. Read"
      },
      "id": "5f45bf2864441ffb4dfdcdbb"
    },
    {
      "category_2": "Hosting services",
      "nodeid": 13151,
      "sections": [
        "Node.js agent",
        "Getting started",
        "Installation and configuration",
        "Supported features",
        "Attributes",
        "API guides",
        "Hosting services",
        "Troubleshooting",
        "Install New Relic Node.js agent in GAE flexible environment",
        "Use native deploy",
        "Build a custom runtime",
        "Optional: Disable health checks",
        "Get New Relic agent troubleshooting logs from GAE",
        "For more help"
      ],
      "title": "Install New Relic Node.js agent in GAE flexible environment",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Node.js agent",
      "external_id": "92a838b215a23bd47fcc8b45abdf347c56f720db",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/hosting-services/install-new-relic-nodejs-agent-gae-flexible-environment",
      "published_at": "2020-10-24T01:59:09Z",
      "updated_at": "2020-08-18T06:29:37Z",
      "breadcrumb": "Contents / APM agents / Node.js agent / Hosting services",
      "document_type": "page",
      "popularity": 1,
      "info": "How to install your APM's Node.js app in the Google App Engine (GAE) flexible environment. ",
      "body": "With New Relic's Node.js agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. This document explains how to add New Relic to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Use native deploy To use Google App Engine's \"native mode\" installation with your Node.js app: Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. Optional: Set environment variables to configure the Node.js agent's GAE app.yaml file. Use the Google Cloud SDK's gcloud command line tool to deploy GAE apps. To deploy your Node.js app to your initialized GAE flexible environment, run the following command: gcloud --project new-relic-apm-nodejs app deploy Google App Engine automatically includes your Node.js app's newrelic.js configuration file in the deployed package. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by building a custom runtime for Docker. You can deploy the app without any special configuration. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Google App Engine's documentation for Node.js Google App Engine's tutorial to deploy a Node.js app 1. Set up the GAE project and install dependencies Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Optional: Set environment variables. 3. Configure and deploy The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. To create the Dockerfile, build the container, and deploy your app, follow the GAE procedures for Node.js. Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Optional: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in New Relic APM. If you notice performance issues, disable GAE health checks. In your app.yaml, add: health_check: enable_health_check: False Get New Relic agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect New Relic Node.js agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.js configuration file to: log_file_name: STDOUT To view the logs, use the Cloud Platform Console's Log Viewer. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 28.645435,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use native <em>deploy</em>",
        "info": "How to install your APM&#x27;s Node.js <em>app</em> in the Google <em>App</em> Engine (GAE) flexible environment. ",
        "body": ". This document explains how to <em>add</em> New Relic to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime Use native <em>deploy</em> To use Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with your"
      },
      "id": "5972fea707552313d3f9ba8d"
    },
    {
      "category_2": "Additional installation",
      "nodeid": 12861,
      "sections": [
        "Java agent",
        "Getting started",
        "Installation",
        "Additional installation",
        "Heroku",
        "Configuration",
        "Attributes",
        "Features",
        "Instrumentation",
        "Custom instrumentation",
        "API guides",
        "Async instrumentation",
        "Troubleshooting",
        "Install New Relic Java agent in GAE flexible environment",
        "Build a custom runtime using Docker",
        "GAE flex example with Tomcat",
        "Recommendation: Disable health checks",
        "Get Java agent troubleshooting logs from GAE",
        "For more help"
      ],
      "title": "Install New Relic Java agent in GAE flexible environment",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Java agent",
      "external_id": "2498db081bf9645f5d8bb111f0da5b22287c2ee9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-gae-flexible-environment",
      "published_at": "2020-10-22T17:38:33Z",
      "updated_at": "2020-10-09T07:26:09Z",
      "breadcrumb": "Contents / APM agents / Java agent / Additional installation",
      "document_type": "page",
      "popularity": 1,
      "info": "How to set up the New Relic Java agent with an app on the Google App Engine (GAE) flexible environment.",
      "body": "With APM's Java agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM, Browser, and dashboards. This document explains how to add New Relic to your GAE flex app by configuring a custom runtime, and gives an example of deploying a Tomcat app with Docker. The New Relic Java agent can run in a GAE flexible environment using a custom runtime. Due to limitations of other environments, do not use the GAE standard environment or Google App Engine's \"native mode\" installation. Build a custom runtime using Docker See Google's documentation for building custom runtimes. There are many ways to build a custom runtime that contains the New Relic Java agent (for example, using Tomcat). In general, to build a custom runtime: Set up your application and install necessary GAE-related dependencies for custom runtimes. Include the New Relic Java agent in the project. Configure Maven or Gradle as applicable. Configure the app.yaml file. Configure the Dockerfile. Build the Docker image. Deploy the Docker image to the initialized GAE flexible environment. Recommendation: Disable GAE health checks. For more information about deploying and configuring your Java app in the GAE flexible environment, see: Google App Engine's documentation for Java Google App Engine's tutorials to deploy a Java app GAE flex example with Tomcat This example describes how to add New Relic to your GAE flex app by installing the New Relic Java agent, building a custom runtime, and deploying an application WAR to Tomcat. Be sure to install the Java agent as necessary for your specific app server. 1. Set up GAE flexible project and install dependencies Follow standard procedures to install the Java agent as necessary for your specific app server, and obtain your license key. Follow Google App Engine procedures for Java to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. Install any necessary dependencies, such as the Maven or Gradle App Engine plugin, and Java. The Google Cloud SDKprovides the gcloud command line tool to manage and deploy GAE apps. 2. Configure Maven pom.xml to include Java agent and build project This example uses Maven to build the project, a Docker Tomcat image to run it, and the gcloud command line tool to deploy the Docker image to a GAE flexible environment. Add the Java agent dependencies to the project's target directory when the project is built, when you download and unzip all Java agent components. After adding the Java agent dependencies to the pom.xml, build your application by running: mvn clean install Check your project's target directory to find the app's WAR file and an unzipped newrelic directory. These files will be incorporated into a Docker image. You can also add the App Engine Maven or Jetty Maven plugin to your pom.xml. This will allow you to use Maven to deploy your app to a GAE flexible environment. 3. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: env: flex runtime: custom 4. Configure the Dockerfile The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. In the following Dockerfile example code, the newrelic.yml and catalina.sh files have been configured locally, to replace those already copied to the Docker image. (You can add your New Relic license key directly to your Dockerfile, or use an environment variable in your docker run command.) # base Tomcat image to build Docker image from FROM tomcat:8.5.14-jre8 MAINTAINER Jane Doe <janedoe@mail.com> # Tomcat directory to copy Java agent files to ENV NEWRELIC_HOME /usr/local/tomcat/newrelic # copy application war from target to Tomcat webapps ADD target/*.war /usr/local/tomcat/webapps # copy Java agent files from target to Tomcat NEWRELIC_HOME ADD target/newrelic ${NEWRELIC_HOME} # update Java agent yml with license_key and app_name and copy to image ADD newrelic.yml ${NEWRELIC_HOME} # update catalina.sh with -javaagent:/path/to/newrelic.jar and copy to image ADD catalina.sh /usr/local/tomcat/bin/ 5. Build the Docker image To build a Docker image that runs Tomcat with the New Relic Java agent monitoring your deployed application WAR, run the following command. Be sure to include the period at the end of the code, to indicate the current directory contains the build files. docker build -f Dockerfile -t newrelic-tomcat . After running this command, verify that you have a Docker image named newrelic-tomcat. 6. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud app deploy Wait until the deployment completes. To open the app in the browser, run the following command: gcloud app browse To view your GAE flex app data in New Relic, go to the APM Summary page. Recommendation: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in APM. To avoid adding additional instrumentation overhead and skewing throughput for your application, we recommend that you disable the health check. Recommendation: Configure your app.yaml to disable health checks by adding: health_check: enable_health_check: False Get Java agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an Instance. To redirect New Relic Java agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.ymlfile to: log_file_name: STDOUT To view the logs, use the Cloud Platform Console's Log Viewer. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 19.466562,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Additional</em> installation",
        "info": "How to set up the New Relic Java agent with an <em>app</em> on the Google <em>App</em> Engine (GAE) flexible environment.",
        "category_2": "<em>Additional</em> installation",
        "body": " prerequisites for the Google Cloud SDK. Install any necessary dependencies, such as the Maven or Gradle <em>App</em> Engine plugin, and Java. The Google Cloud SDKprovides the gcloud command line tool to manage and <em>deploy</em> GAE <em>apps</em>. 2. Configure Maven pom.xml to include Java agent and build project This example uses"
      },
      "id": "5948a1d64bb81c60a3a3fc42"
    },
    {
      "category_2": "Hosting services",
      "nodeid": 13866,
      "sections": [
        "Python agent",
        "Getting started",
        "Installation",
        "Configuration",
        "Supported features",
        "Back-end services",
        "Custom instrumentation",
        "API guides",
        "Python agent API",
        "Web frameworks and servers",
        "Async instrumentation",
        "Hosting services",
        "Attributes",
        "Troubleshooting",
        "Install the Python agent in GAE flexible environment",
        "Deploy using GAE's native support",
        "Build a custom runtime using Docker",
        "Recommendation: Disable health checks",
        "Get agent troubleshooting logs from GAE",
        "For more help"
      ],
      "title": "Install the Python agent in GAE flexible environment",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Python agent",
      "external_id": "c1ce9a74f2eccba9cf0cd509a6f15f2d02fabb16",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/hosting-services/install-python-agent-gae-flexible-environment",
      "published_at": "2020-10-24T01:50:22Z",
      "updated_at": "2020-08-30T17:24:26Z",
      "breadcrumb": "Contents / APM agents / Python agent / Hosting services",
      "document_type": "page",
      "popularity": 1,
      "info": "How to install your Python app in the Google App Engine (GAE) flexible environment. ",
      "body": "With the Python agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding agent data to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in New Relic One. This document explains how to add agent data to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Deploy using GAE's native support When using Google App Engine \"native mode\" installation, you provide your app code and an app.yaml file. Google App Engine then deploys to a standard prebuilt Docker image. For example, to deploy with native support for a Flask/Django app: Follow standard procedures to install the Python agent, including your license key. Set the NEW_RELIC_CONFIG_FILE as an environment variable pointing to newrelic.ini. Once the agent and configuration file have been installed, the Python agent can automatically monitor applications that reside in the GAE flexible environment. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime using Docker See Google's documentation for building custom runtimes. This example describes how to add agent data to your GAE flex app by building a custom runtime for Docker. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Our GAE flex examples on Github for Python Google App Engine's documentation for Python Google App Engine's tutorials to deploy a Python app 1. Set up the GAE project and install dependencies When building a custom runtime using Docker, set the NEW_RELIC_CONFIG_FILE as an environment variable pointing to the Dockerfile instead of to your Python app's newrelic.ini. Follow standard procedures to install the Python agent, including your license key. Follow Google App Engine procedures Python to create a Google Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK also provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: env: flex runtime: custom 3. Configure a Dockerfile The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. The following Dockerfile example shows the Python agent installed for an application served with gunicorn. These procedures are similar to the Python quick start guide. The Dockerfile will contain customer-specific code, including Python version, installation requirements, etc). # [START dockerfile] FROM gcr.io/google_appengine/python # Install the fortunes binary from the debian repositories. RUN apt-get update && apt-get install -y fortunes # Optional: Change the -p argument to use Python 2.7. RUN virtualenv /env -p python3.5 # Set virtualenv environment variables. This is equivalent to running # source /env/bin/activate. ENV VIRTUAL_ENV /env ENV PATH /env/bin:$PATH ADD requirements.txt /app/ RUN pip install -r requirements.txt ADD . /app/ CMD NEW_RELIC_CONFIG_FILE=newrelic.ini newrelic-admin run-program gunicorn -b :$PORT main:app # [END dockerfile] 4. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud app deploy Wait until the deployment completes. To open the app in the browser, run the following command: gcloud app browse To view your GAE flex app data, go to the APM Summary page. Recommendation: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in APM. Recommendation: Configure your app.yaml to disable health checks by adding: health_check: enable_health_check: False Get agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect Python agent logs to Stackdriver in the Cloud Platform Console, add the following statement to the newrelic.ini configuration: log_file = stderr To view the logs, use the Cloud Platform Console's Log Viewer. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 18.883987,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Deploy</em> using GAE&#x27;s native support",
        "info": "How to install your Python <em>app</em> in the Google <em>App</em> Engine (GAE) flexible environment. ",
        "body": " explains how to <em>add</em> agent data to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime <em>Deploy</em> using GAE&#x27;s native support When using Google <em>App</em> Engine &quot;native mode&quot; installation, you provide"
      },
      "id": "5f3fb624196a672fda1cd4a3"
    }
  ],
  "/explore-docs/nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add the NerdGraphQuery component to an application",
        "Add a table to your app",
        "Permissions for managing applications",
        "Set up your development environment",
        "Publish and deploy apps",
        "Create a custom map view"
      ],
      "published_at": "2020-10-24T01:53:25Z",
      "title": "Build apps",
      "updated_at": "2020-10-24T01:53:25Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 30 min Add a table to your app Add a table to your New Relic One app ¬† Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 30 min Publish and deploy apps Start sharing the apps you build 30 min Create a custom map view Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 400.59833,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "body": " the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query <em>data</em> from your account and add it to a dropdown menu in an application 30 min Add a table to your <em>app</em> Add a table to your <em>New</em> <em>Relic</em> <em>One</em> <em>app</em> ¬† Permissions for managing applications Learn about permissions"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Intro to NerdStorageVault",
        "Using NerdStorageVault in your apps",
        "Tip",
        "Usage considerations",
        "Component library",
        "NerdGraph queries",
        "Write",
        "Delete",
        "Fetch a single secret",
        "Fetch a list of secrets",
        "Limits",
        "Permissions for working with NerdStorageVault"
      ],
      "title": "Intro to NerdStorageVault",
      "type": "developer",
      "tags": [
        "nerdstoragevault",
        "nerdstoragevault components",
        "new relic one apps",
        "data access",
        "encrypted storage"
      ],
      "external_id": "8355de4bf337963434c4d3b90f5d9c32f58e4bcc",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstoragevault/",
      "published_at": "2020-10-24T01:54:35Z",
      "updated_at": "2020-10-24T01:54:35Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorageVault on New Relic One",
      "body": "Intro to NerdStorageVault 15 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data such as: personal access tokens license keys API keys other third party secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorageVault can currently only be used within the context of a Nerdpack. You cannot make a direct query or mutation to NerdStorageVault. You can explore the fields and response types via the NerdGraph API explorer. The only supported scope is ACTOR, or data that relates to a particular user. Component library Currently NerdStorageVault is available in the alpha release of Nr1 Community component library and is not available in the Nr1 core components library. Open source components can be use to augment Nr1 core components for additional functionality. NerdGraph queries Below are examples of the queries used by the components to interact with NerdStorageVault. Tip NerdStorageVault can currently only be used within the context of a Nerdpack. Write mutation { nerdStorageVaultWriteSecret(scope: { actor: CURRENT_USER } , secret: { key: \"test\", value: \"secret_test\" } ) { status errors { message type } } } Copy Delete mutation { nerdStorageVaultDeleteSecret(scope: { actor: CURRENT_USER } , key: \"test_key\" ) { status errors { message type } } } Copy Fetch a single secret { actor { nerdStorageVault { secret(key: \"test_key\") { key value } } } } Copy Fetch a list of secrets { actor { nerdStorageVault { secrets { key value } } } } Copy Limits A maximum of 10 secrets can be stored per ACTOR. A secret value is limited to 5000 characters. A key value is limited to 64 characters. Permissions for working with NerdStorageVault In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 292.0106,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>NerdStorageVault</em>",
        "sections": "Using <em>NerdStorageVault</em> in your <em>apps</em>",
        "info": "Intro to <em>NerdStorageVault</em> on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "Intro to NerdStorageVault 15 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you‚Äôll learn how to use NerdStorageVault to store <em>data</em> in an encrypted storage solution. Using NerdStorageVault in your <em>apps</em> NerdStorageVault is used to store"
      },
      "id": "5f865b55196a675792bd5340"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2020-10-24T02:01:31Z",
      "updated_at": "2020-10-14T01:58:45Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "Intro to New Relic One SDK To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 270.83167,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "sections": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "info": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>",
        "body": ", or user-specific <em>data</em>. For more on this, see <em>NerdStorage</em>. Platform APIs The Platform API <em>components</em> of the SDK enable your application to interact with different parts of the <em>New</em> <em>Relic</em> <em>One</em> platform, by reading and writing state from and to the URL, setting the configuration, etc. They can"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps"
      ],
      "title": "Add, query, and mutate data using NerdStorage",
      "type": "developer",
      "tags": [
        "add data",
        "query data",
        "mutate data",
        "nerdstorage"
      ],
      "external_id": "97cc9637edea35ecd68683f1010f67a5f8c79038",
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/",
      "published_at": "2020-10-24T01:54:36Z",
      "updated_at": "2020-08-30T01:49:16Z",
      "document_type": "page",
      "popularity": 1,
      "info": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next.",
      "body": "Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: cd / nr1 - how - to / use - nerdstorage; Copy Update the UUID and serve the application: nr1 nerdpack:uuid -gf nr1 nerdpack:serve Copy Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application‚Äôs ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application‚Äôs index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application‚Äôs ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you‚Äôve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.4144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "sections": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "info": "<em>NerdStorage</em> is a document <em>database</em> <em>accessible</em> within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next.",
        "tags": "<em>nerdstorage</em>",
        "body": " will return the URL to view your running application on <em>New</em> <em>Relic</em> <em>One</em>. Load the URL. Click <em>Apps</em> and under Your <em>apps</em> you&#x27;ll see the Use <em>Nerdstorage</em> <em>app</em> listed. Click to launch the <em>app</em>. Add <em>data</em> to <em>NerdStorage</em> Once the <em>app</em> is up and running on <em>New</em> <em>Relic</em> <em>One</em>, you can prepare the <em>app</em> and start adding <em>data</em>"
      },
      "id": "5efa98d4e7b9d26d6b7bab74"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-10-24T02:00:01Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Copy Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.76952,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> CLI Reference",
        "sections": "<em>New</em> <em>Relic</em> CLI Reference",
        "info": "The command line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> cli",
        "body": "<em>New</em> <em>Relic</em> CLI Reference The <em>New</em> <em>Relic</em> CLI enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching <em>data</em> from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> CLI commands Find details for the <em>New</em> <em>Relic</em> CLI command docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    }
  ],
  "/explore-docs/nr1-subscription": [
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-10-24T01:53:25Z",
      "updated_at": "2020-10-24T01:53:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.3826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>CLI</em> to add multiple tags to <em>one</em> of your entities. Before you begin For this guide you need your <em>New</em> <em>Relic</em> personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> via Homebrew (macOS), Scoop (Windows"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-10-24T01:54:36Z",
      "updated_at": "2020-10-24T01:54:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: bash Copy $ my-nerdlet $ ‚îú‚îÄ‚îÄ README.md $ ‚îú‚îÄ‚îÄ launchers $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ nerdlets $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss $ ‚îú‚îÄ‚îÄ node_modules $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler $ ‚îú‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ package-lock.json $ ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.03566,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>command</em> nr1 create and select Nerdpack to create"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Get your application details",
        "Add a simple tag to your application",
        "Bonus step: Create a deployment marker",
        "Next steps"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2020-10-24T01:53:25Z",
      "updated_at": "2020-10-24T01:53:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Get started with the New Relic CLI 20 min Access the New Relic platform from the comfort of your terminal: you can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. Our CLI has been designed for automating common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic personal API Key, which you can create from the Account settings of your New Relic account An instrumented application in your New Relic account Step 1 of 10 Install the New Relic CLI The New Relic CLI can be downloaded via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile Now that you've installed the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. To create your first CLI profile, run the profiles add command. Note that you need to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_API_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Step 3 of 10 Get your application details In this example, you are going to add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 The New Relic CLI can retrieve your application details as a JSON object. To search for your APM application use the apm application search command. If you get an error, check that the account ID and application name you provided are correct. bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Step 5 of 10 If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example. When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. [ { accountId: YOUR_ACCOUNT_ID, applicationId: YOUR_APP_ID, domain: 'APM', entityType: 'APM_APPLICATION_ENTITY', guid: 'A_LONG_GUID', name: 'NAME_OF_YOUR_APP', permalink: 'https://one.newrelic.com/redirect/entity/A_LONG_GUID', reporting: true, type: 'APPLICATION', }, ]; Copy Step 6 of 10 Add a simple tag to your application Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Let's suppose that you want to add an environment tag to your application. Go ahead and add the dev:testing tag‚Å† (or any other key-value pair) to your application using the entities tags create command. bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 What if you want to add multiple tags? Tag sets come to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags at once to your application, modify and run the following snippet. bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 You've created and added some tags to your application, but how do you know they're there? You need to retrieve your application's tags. To retrieve your application's tags, use the entity tags get command. newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Step 9 of 10 Bonus step: Create a deployment marker Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same Application ID from your earlier search. bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Notice that the JSON response includes the revision and timestamp of the deployment. This workflow could be built into a continuous integration or continuous deployment (CI/CD) system to help indicate changes in your application's behavior after deployments. Here is an example. { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands. For example, you could create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.39917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " that you&#x27;ve installed the <em>New</em> <em>Relic</em> <em>CLI</em>, it&#x27;s time to create your first profile. Profiles contain credentials and settings that you can apply to any <em>CLI</em> <em>command</em>, which is useful when switching between accounts. To create your first <em>CLI</em> profile, run the profiles add <em>command</em>. Note that you need"
      },
      "id": "5efa999c196a67c4e1766461"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-10-24T02:01:31Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.65427,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " extension to build your apps. <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em> This table provides descriptions for the <em>New</em> <em>Relic</em> <em>One</em> <em>commands</em>. For more context, including usage and option details, click any individual <em>command</em> or the <em>command</em> category. For details on user permissions, see¬†Authentication and permissions"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-10-24T02:00:01Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.77377,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> apps",
        "body": "Intro to NerdStorage 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    }
  ],
  "/explore-docs/nr1-catalog": [
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-10-24T01:53:25Z",
      "updated_at": "2020-10-24T01:53:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.3826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>CLI</em> to add multiple tags to <em>one</em> of your entities. Before you begin For this guide you need your <em>New</em> <em>Relic</em> personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> via Homebrew (macOS), Scoop (Windows"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-10-24T02:01:31Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.71426,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": "¬†<em>CLI</em> <em>commands</em>¬†to: Generate Nerdpack&#x2F;Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the <em>catalog</em> Installing the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> In <em>New</em> <em>Relic</em>, click Apps and then in the <em>New</em> <em>Relic</em> <em>One</em> <em>catalog</em> area, click the¬†Build"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-10-24T01:54:36Z",
      "updated_at": "2020-10-24T01:54:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: bash Copy $ my-nerdlet $ ‚îú‚îÄ‚îÄ README.md $ ‚îú‚îÄ‚îÄ launchers $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ nerdlets $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss $ ‚îú‚îÄ‚îÄ node_modules $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler $ ‚îú‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ package-lock.json $ ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.03566,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>command</em> nr1 create and select Nerdpack to create"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Get your application details",
        "Add a simple tag to your application",
        "Bonus step: Create a deployment marker",
        "Next steps"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2020-10-24T01:53:25Z",
      "updated_at": "2020-10-24T01:53:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Get started with the New Relic CLI 20 min Access the New Relic platform from the comfort of your terminal: you can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. Our CLI has been designed for automating common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic personal API Key, which you can create from the Account settings of your New Relic account An instrumented application in your New Relic account Step 1 of 10 Install the New Relic CLI The New Relic CLI can be downloaded via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile Now that you've installed the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. To create your first CLI profile, run the profiles add command. Note that you need to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_API_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Step 3 of 10 Get your application details In this example, you are going to add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 The New Relic CLI can retrieve your application details as a JSON object. To search for your APM application use the apm application search command. If you get an error, check that the account ID and application name you provided are correct. bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Step 5 of 10 If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example. When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. [ { accountId: YOUR_ACCOUNT_ID, applicationId: YOUR_APP_ID, domain: 'APM', entityType: 'APM_APPLICATION_ENTITY', guid: 'A_LONG_GUID', name: 'NAME_OF_YOUR_APP', permalink: 'https://one.newrelic.com/redirect/entity/A_LONG_GUID', reporting: true, type: 'APPLICATION', }, ]; Copy Step 6 of 10 Add a simple tag to your application Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Let's suppose that you want to add an environment tag to your application. Go ahead and add the dev:testing tag‚Å† (or any other key-value pair) to your application using the entities tags create command. bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 What if you want to add multiple tags? Tag sets come to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags at once to your application, modify and run the following snippet. bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 You've created and added some tags to your application, but how do you know they're there? You need to retrieve your application's tags. To retrieve your application's tags, use the entity tags get command. newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Step 9 of 10 Bonus step: Create a deployment marker Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same Application ID from your earlier search. bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Notice that the JSON response includes the revision and timestamp of the deployment. This workflow could be built into a continuous integration or continuous deployment (CI/CD) system to help indicate changes in your application's behavior after deployments. Here is an example. { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands. For example, you could create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.39917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " that you&#x27;ve installed the <em>New</em> <em>Relic</em> <em>CLI</em>, it&#x27;s time to create your first profile. Profiles contain credentials and settings that you can apply to any <em>CLI</em> <em>command</em>, which is useful when switching between accounts. To create your first <em>CLI</em> profile, run the profiles add <em>command</em>. Note that you need"
      },
      "id": "5efa999c196a67c4e1766461"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0 EMEA",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-10-24T01:40:08Z",
      "title": "New Relic Developers",
      "updated_at": "2020-10-24T01:38:33Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 EMEA Nerd Days is a FREE engineering conference that kicks off November 10 (EMEA). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 17 Days : 8 Hours : 31 Minutes : 16 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application ¬† Add custom attributes Use custom attributes for deeper analysis Show 21 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.04448,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local <em>New</em> <em>Relic</em> <em>One</em> <em>Catalog</em> Start the guide Get inspired 30 min Add a table to your app Add a table to your <em>New</em> <em>Relic</em> <em>One</em> app 15 min Collect data - any source APIs"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    }
  ],
  "/explore-docs/nr1-cli": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-10-24T02:00:01Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.53003,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use NerdStorage in your <em>apps</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "Intro to NerdStorage 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "Intro to NerdStorageVault",
        "Using NerdStorageVault in your apps",
        "Tip",
        "Usage considerations",
        "Component library",
        "NerdGraph queries",
        "Write",
        "Delete",
        "Fetch a single secret",
        "Fetch a list of secrets",
        "Limits",
        "Permissions for working with NerdStorageVault"
      ],
      "title": "Intro to NerdStorageVault",
      "type": "developer",
      "tags": [
        "nerdstoragevault",
        "nerdstoragevault components",
        "new relic one apps",
        "data access",
        "encrypted storage"
      ],
      "external_id": "8355de4bf337963434c4d3b90f5d9c32f58e4bcc",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstoragevault/",
      "published_at": "2020-10-24T01:54:35Z",
      "updated_at": "2020-10-24T01:54:35Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorageVault on New Relic One",
      "body": "Intro to NerdStorageVault 15 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data such as: personal access tokens license keys API keys other third party secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorageVault can currently only be used within the context of a Nerdpack. You cannot make a direct query or mutation to NerdStorageVault. You can explore the fields and response types via the NerdGraph API explorer. The only supported scope is ACTOR, or data that relates to a particular user. Component library Currently NerdStorageVault is available in the alpha release of Nr1 Community component library and is not available in the Nr1 core components library. Open source components can be use to augment Nr1 core components for additional functionality. NerdGraph queries Below are examples of the queries used by the components to interact with NerdStorageVault. Tip NerdStorageVault can currently only be used within the context of a Nerdpack. Write mutation { nerdStorageVaultWriteSecret(scope: { actor: CURRENT_USER } , secret: { key: \"test\", value: \"secret_test\" } ) { status errors { message type } } } Copy Delete mutation { nerdStorageVaultDeleteSecret(scope: { actor: CURRENT_USER } , key: \"test_key\" ) { status errors { message type } } } Copy Fetch a single secret { actor { nerdStorageVault { secret(key: \"test_key\") { key value } } } } Copy Fetch a list of secrets { actor { nerdStorageVault { secrets { key value } } } } Copy Limits A maximum of 10 secrets can be stored per ACTOR. A secret value is limited to 5000 characters. A key value is limited to 64 characters. Permissions for working with NerdStorageVault In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.13313,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Using NerdStorageVault in your <em>apps</em>",
        "info": "Intro to NerdStorageVault on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "Intro to NerdStorageVault 15 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you‚Äôll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store"
      },
      "id": "5f865b55196a675792bd5340"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-nerdpack/",
      "sections": [
        "New Relic One CLI Nerdpack commands",
        "Command details",
        "nr1 nerdpack:build",
        "Builds a Nerdpack",
        "Usage",
        "Options",
        "nr1 nerdpack:clone",
        "Clone an existing Nerdpack",
        "nr1 nerdpack:serve",
        "Serve your Nerdpack locally",
        "nr1 nerdpack:uuid",
        "Get your Nerdpack's UUID",
        "nr1 nerdpack:publish",
        "Publish your Nerdpack",
        "nr1 nerdpack:deploy",
        "Deploy your Nerdpack to a channel",
        "nr1 nerdpack:undeploy",
        "Undeploy your Nerdpack",
        "nr1 nerdpack:clean",
        "Removes all built artifacts",
        "nr1 nerdpack:validate",
        "Validates artifacts inside your Nerdpack",
        "nr1 nerdpack:Info",
        "Shows the state of your Nerdpack in the New Relic's registry"
      ],
      "published_at": "2020-10-24T02:01:31Z",
      "title": "New Relic One CLI Nerdpack commands",
      "updated_at": "2020-10-14T01:58:45Z",
      "type": "developer",
      "external_id": "7c1050a6a8624664b90c15111f7c72e96b2fbe17",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI commands you can use to set up your New Relic One Nerdpacks.",
      "body": "New Relic One CLI Nerdpack commands To set up your Nerdpacks, use the commands below. You can click any command to see its usage options and additional details about the command. Command Description nr1 nerdpack:build Assembles your Nerdpack into bundles nr1 nerdpack:clone Clones a Nerdpack from a git repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your development folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Command details nr1 nerdpack:build Builds a Nerdpack Runs a webpack process to assemble your Nerdpack into javascript and CSS bundles. As many other CLI commands, it should be run at the package.json level of your Nerdpack. Usage $ nr1 nerdpack:build OPTION Options --extra-metadata-path=extra-metadata-path Specify a json file path with extra metadata. [default: extra-metadata.json] --prerelease=prerelease If specififed, the value will be appended to the current version of generated files. ie: --prerelease=abc. Then the version will be \"1.2.3-abc\". --profile=profile The authencation profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:clone Clone an existing Nerdpack Duplicates an existing Nerdpack onto your local computer. You can clone an open source Nerdpack from our Open Source GitHub repositories. After choosing a git repository, this command performs the following actions so that you can start using the Nerdpack: Clones the repository. Sets the repository as remote upstream. Installs all of its dependencies (using npm). Generates a new UUID using your profile, and commits it. Usage $ nr1 nerdpack:clone OPTION Options -r, --repo=REPO Repository location (either an HTTPS or SSH path). (Required) -p, --path=PATH Determines the directory to clone to (defaults to the repository name). -f, --force Replaces destination folder if it exists. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:serve Serve your Nerdpack locally Launches a server with your Nerdpack locally on the New Relic One platform, where it can be tested live. To learn more about working with apps locally, see our guide on how to serve, publish, and deploy documentation. Usage $ nr1 nerdpack:serve Options --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:uuid Get your Nerdpack's UUID Prints the UUID (Universal Unique ID) of your Nerdpack, by default. The UUID determines what data the Nerdpack can access and who can subscribe to the Nerdpack. To deploy a Nerdpack you didn't make, you'll have to assign it a new UUID by using the -g or --generate option. For more details, see our GitHub workshop on GitHub. Usage $ nr1 nerdpack:uuid Options --profile=PROFILE The authentication profile you want to use. -f, --force If present, it will override the existing UUID without asking. -g, --generate Generates a new UUID if not available. --verbose Adds extra information to the output. nr1 nerdpack:publish Publish your Nerdpack Publishes your Nerdpack to New Relic. Please note: If no additional parameters are passed in, this command will automatically deploy the Nerdpack onto the DEV channel. If you want to specify your own list of deploy channels, add the --channel option. For example, $ nr1 nerdpack:publish --channel BETA --channel STABLE. If you want to disable this behavior, add -D or --skip-deploy to the command. Then, you can use nr1 nerdpack:deploy to perform a deploy manually. For more on publishing and deploying, see Deploy to New Relic One. Usage $ nr1 nerdpack:publish Options -B, --skip-build Skips the previous build process. -D, --skip-deploy Skips the following deploy process. -c, --channel=DEV/BETA/STABLE Specifies the channel to deploys to. [default: STABLE] -f, --force Forces the publish, overriding any existing version in the registry. --dry-run Undergoes publishing process without actually publishing anything. --extra-metadata-path=extra-metadata-path Specifies a json file .path with extra metadata. [default: extra-metadata.json] --prerelease=STRING The value you enter will be appended to the current version of generated files. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:deploy Deploy your Nerdpack to a channel Deploys a Nerdpack version to a specific channel (DEV, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. For more on publishing and deploying, see Deploy to New Relic One. Usage $ nr1 nerdpack:deploy OPTION Options -c, --channel=DEV/BETA/STABLE Specifies the channel to deploy to. (required) -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to deploy. By default, the command will use the one in package.json. --from-version=VERSION Specifies which version to deploy. By default, the command will use the one in package.json. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:undeploy Undeploy your Nerdpack Undeploys a Nerdpack version from a specific channel (for example, DEV, BETA, or STABLE). Usage $ nr1 nerdpack:undeploy OPTION Options -c, --channel=DEV/BETA/STABLE Specifies the channel to undeploy from. (required) -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to undeploy. By default, the command will use the one in package.json. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:clean Removes all built artifacts Cleans and removes the content and the developtment folders (dist/, tmp/). Usage $ nr1 nerdpack:clean OPTION Options --profile=profile The authentication profile you want to use --verbose Adds extra information to the output. nr1 nerdpack:validate Validates artifacts inside your Nerdpack Validates artifacts inside your Nerdpack. Usage $ nr1 nerdpack:validate OPTION Options -l, --force-local The authentication profile you want to use. -r, --force-remote Force download of new schema files. --profile=profile The authentication profile you want to uset. --verbose Adds extra information to the output. nr1 nerdpack:Info Shows the state of your Nerdpack in the New Relic's registry Shows the state of your Nerdpack in the New Relic's registry. The default amount of versions shown is 10 but all versions can be shown if the --all (or -a) flag is used Usage $ nr1 nerdpack:info OPTION Options -a, --all Show all versions. -i, --nerdpack-id=nerdpack-id Get info from the specified Nerdpack instead of local one. --profile=profile The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.87279,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> CLI <em>Nerdpack</em> <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> CLI <em>Nerdpack</em> <em>commands</em>",
        "info": "An overview of the CLI <em>commands</em> you can use to set up your <em>New</em> <em>Relic</em> <em>One</em> <em>Nerdpacks</em>.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> CLI <em>Nerdpack</em> <em>commands</em> To set up your Nerdpacks, use the <em>commands</em> below. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 <em>nerdpack</em>:build Assembles your <em>Nerdpack</em> into bundles nr1 <em>nerdpack</em>:clone Clones a <em>Nerdpack</em> from"
      },
      "id": "5f28bd6a64441f9817b11a38"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-10-24T01:54:36Z",
      "updated_at": "2020-10-24T01:54:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: bash Copy $ my-nerdlet $ ‚îú‚îÄ‚îÄ README.md $ ‚îú‚îÄ‚îÄ launchers $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ nerdlets $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss $ ‚îú‚îÄ‚îÄ node_modules $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler $ ‚îú‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ package-lock.json $ ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.212715,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> file structure",
        "sections": "<em>Nerdpack</em> file structure",
        "info": "An overview of the <em>Nerdpack</em> File Structure",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> CLI",
        "body": " components, see our <em>app</em> building guides and the <em>New</em> <em>Relic</em> <em>One</em> CLI <em>command</em> reference. <em>Nerdpack</em> file structure When you generate a <em>Nerdpack</em> template using the nr1 create <em>command</em>, it has the following file structure: bash Copy $ my-nerdlet $ ‚îú‚îÄ‚îÄ README.md $ ‚îú‚îÄ‚îÄ launchers $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2020-10-24T02:01:31Z",
      "updated_at": "2020-10-14T01:58:45Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "Intro to New Relic One SDK To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.908035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "sections": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "info": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>",
        "body": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK To help you build <em>New</em> <em>Relic</em> <em>One</em> applications, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch <em>New</em>"
      },
      "id": "5efa989e28ccbc4071307de5"
    }
  ],
  "/explore-docs/nr1-nerdpack": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-subscription/",
      "sections": [
        "New Relic One CLI subscription commands",
        "Command details",
        "nr1 subscription:set",
        "Subscribe to a Nerdpack",
        "Usage",
        "Options",
        "Aliases",
        "nr1 subscription:list",
        "See your subscription",
        "nr1 subscription:unset",
        "Unsubscribe from a Nerdpack"
      ],
      "published_at": "2020-10-24T02:01:32Z",
      "title": "New Relic One CLI subscription commands",
      "updated_at": "2020-08-06T01:44:54Z",
      "type": "developer",
      "external_id": "12d2e1b06dede5b1272527f95a14518010aecc58",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI commands you can use to manage your Nerdpack subscriptions.",
      "body": "New Relic One CLI subscription commands To manage your Nerdpack subscriptions, use the commands below. You can click any command to see its usage options and additional details about the command. Command Description nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Command details nr1 subscription:set Subscribe to a Nerdpack Subscribes your account to a specific Nerdpack and channel. This command can be run with a Nerdpack UUID or within a specific Nerdpack folder. By default, the command uses the Nerdpack ID in package.json and subscribes to the STABLE channel. An account can only be subscribed to one Nerdpack and channel at a time. Usage $ nr1 subscription:set Options -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to subscribe to. By default, the command will use the one in package.json. -c, --channel=DEV/BETA/STABLE Specifies the channel to subscribe to. [default: STABLE] --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. Aliases $ nr1 nerdpack:subscribe nr1 subscription:list See your subscription Lists all the Nerdpacks your account is subscribed to. Your account is linked to your API key. Usage $ nr1 subscription:list Options --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 subscription:unset Unsubscribe from a Nerdpack Unsubscribes your account from a specific Nerdpack. When this command is executed within a Nerdpack folder, the Nerdpack ID from package.json is used by default. Usage $ nr1 subscription:unset Options -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to subscribe to. By default, the command will use the one in package.json. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. Aliases $ nr1 nerdpack:unsubscribe $ nr1 subscription:delete $ nr1 subscription:remove $ nr1 subscription:rm",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 717.93933,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> subscription <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> subscription <em>commands</em>",
        "info": "An overview of the <em>CLI</em> <em>commands</em> you can use to manage your <em>Nerdpack</em> subscriptions.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> subscription <em>commands</em> To manage your <em>Nerdpack</em> subscriptions, use the <em>commands</em> below. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 subscription:set Subscribes your account to a <em>Nerdpack</em> and channel. nr1"
      },
      "id": "5f2b6096e7b9d225ebc9de6f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2020-10-24T01:54:37Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 501.3226,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": "¬†(<em>New</em> <em>Relic</em> query language). See our other <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> docs for <em>commands</em> specific to <em>Nerdpack</em> set-up, <em>Nerdpack</em> subscriptions, <em>CLI</em> configuration, plugins, or catalogs. <em>Command</em> details nr1 help See <em>commands</em> and get details Shows all nr1 <em>commands</em> by default. To get details about a specific <em>command</em>"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-10-24T01:54:36Z",
      "updated_at": "2020-10-24T01:54:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: bash Copy $ my-nerdlet $ ‚îú‚îÄ‚îÄ README.md $ ‚îú‚îÄ‚îÄ launchers $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ nerdlets $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss $ ‚îú‚îÄ‚îÄ node_modules $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler $ ‚îú‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ package-lock.json $ ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 328.7312,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> file structure",
        "sections": "<em>Nerdpack</em> file structure",
        "info": "An overview of the <em>Nerdpack</em> File Structure",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " How to link your application with a monitored entity For basic component definitions, see our component reference. Generate <em>Nerdpack</em> components There are two ways to generate a <em>Nerdpack</em> template: Generate a <em>Nerdpack</em>: Use the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>command</em> nr1 create and select <em>Nerdpack</em> to create"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-10-24T01:53:25Z",
      "updated_at": "2020-10-24T01:53:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.3826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>CLI</em> to add multiple tags to <em>one</em> of your entities. Before you begin For this guide you need your <em>New</em> <em>Relic</em> personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> via Homebrew (macOS), Scoop (Windows"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-10-24T02:01:31Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 224.46277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": ". For more on how to serve and publish your application, see¬†our guide on Deploying your <em>New</em> <em>Relic</em> <em>One</em> app. Get started nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1 update Updates to the latest version of the <em>CLI</em>. nr1 create Creates a <em>new</em> component from a template (<em>Nerdpack</em>, Nerdlet"
      },
      "id": "5efa989e28ccbc535a307dd0"
    }
  ],
  "/explore-docs/nr1-plugins": [
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-10-24T01:53:25Z",
      "updated_at": "2020-10-24T01:53:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.54451,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>CLI</em> to add multiple tags to <em>one</em> of your entities. Before you begin For this guide you need your <em>New</em> <em>Relic</em> personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> via Homebrew (macOS), Scoop (Windows"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-10-24T01:54:36Z",
      "updated_at": "2020-10-24T01:54:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: bash Copy $ my-nerdlet $ ‚îú‚îÄ‚îÄ README.md $ ‚îú‚îÄ‚îÄ launchers $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ nerdlets $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss $ ‚îú‚îÄ‚îÄ node_modules $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler $ ‚îú‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ package-lock.json $ ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 221.9575,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>command</em> nr1 create and select Nerdpack to create"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Get your application details",
        "Add a simple tag to your application",
        "Bonus step: Create a deployment marker",
        "Next steps"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2020-10-24T01:53:25Z",
      "updated_at": "2020-10-24T01:53:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Get started with the New Relic CLI 20 min Access the New Relic platform from the comfort of your terminal: you can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. Our CLI has been designed for automating common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic personal API Key, which you can create from the Account settings of your New Relic account An instrumented application in your New Relic account Step 1 of 10 Install the New Relic CLI The New Relic CLI can be downloaded via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile Now that you've installed the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. To create your first CLI profile, run the profiles add command. Note that you need to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_API_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Step 3 of 10 Get your application details In this example, you are going to add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 The New Relic CLI can retrieve your application details as a JSON object. To search for your APM application use the apm application search command. If you get an error, check that the account ID and application name you provided are correct. bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Step 5 of 10 If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example. When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. [ { accountId: YOUR_ACCOUNT_ID, applicationId: YOUR_APP_ID, domain: 'APM', entityType: 'APM_APPLICATION_ENTITY', guid: 'A_LONG_GUID', name: 'NAME_OF_YOUR_APP', permalink: 'https://one.newrelic.com/redirect/entity/A_LONG_GUID', reporting: true, type: 'APPLICATION', }, ]; Copy Step 6 of 10 Add a simple tag to your application Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Let's suppose that you want to add an environment tag to your application. Go ahead and add the dev:testing tag‚Å† (or any other key-value pair) to your application using the entities tags create command. bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 What if you want to add multiple tags? Tag sets come to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags at once to your application, modify and run the following snippet. bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 You've created and added some tags to your application, but how do you know they're there? You need to retrieve your application's tags. To retrieve your application's tags, use the entity tags get command. newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Step 9 of 10 Bonus step: Create a deployment marker Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same Application ID from your earlier search. bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Notice that the JSON response includes the revision and timestamp of the deployment. This workflow could be built into a continuous integration or continuous deployment (CI/CD) system to help indicate changes in your application's behavior after deployments. Here is an example. { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands. For example, you could create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.4144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " that you&#x27;ve installed the <em>New</em> <em>Relic</em> <em>CLI</em>, it&#x27;s time to create your first profile. Profiles contain credentials and settings that you can apply to any <em>CLI</em> <em>command</em>, which is useful when switching between accounts. To create your first <em>CLI</em> profile, run the profiles add <em>command</em>. Note that you need"
      },
      "id": "5efa999c196a67c4e1766461"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-10-24T02:01:31Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.276,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " extension to build your apps. <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em> This table provides descriptions for the <em>New</em> <em>Relic</em> <em>One</em> <em>commands</em>. For more context, including usage and option details, click any individual <em>command</em> or the <em>command</em> category. For details on user permissions, see¬†Authentication and permissions"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-10-24T02:00:01Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.34662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> apps",
        "body": "Intro to NerdStorage 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    }
  ],
  "/explore-docs/nr1-config": [
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-10-24T01:53:25Z",
      "updated_at": "2020-10-24T01:53:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.54451,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>CLI</em> to add multiple tags to <em>one</em> of your entities. Before you begin For this guide you need your <em>New</em> <em>Relic</em> personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> via Homebrew (macOS), Scoop (Windows"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-10-24T01:54:36Z",
      "updated_at": "2020-10-24T01:54:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: bash Copy $ my-nerdlet $ ‚îú‚îÄ‚îÄ README.md $ ‚îú‚îÄ‚îÄ launchers $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ nerdlets $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss $ ‚îú‚îÄ‚îÄ node_modules $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler $ ‚îú‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ package-lock.json $ ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.86246,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>command</em> nr1 create and select Nerdpack to create"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Get your application details",
        "Add a simple tag to your application",
        "Bonus step: Create a deployment marker",
        "Next steps"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2020-10-24T01:53:25Z",
      "updated_at": "2020-10-24T01:53:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Get started with the New Relic CLI 20 min Access the New Relic platform from the comfort of your terminal: you can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. Our CLI has been designed for automating common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic personal API Key, which you can create from the Account settings of your New Relic account An instrumented application in your New Relic account Step 1 of 10 Install the New Relic CLI The New Relic CLI can be downloaded via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile Now that you've installed the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. To create your first CLI profile, run the profiles add command. Note that you need to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_API_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Step 3 of 10 Get your application details In this example, you are going to add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 The New Relic CLI can retrieve your application details as a JSON object. To search for your APM application use the apm application search command. If you get an error, check that the account ID and application name you provided are correct. bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Step 5 of 10 If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example. When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. [ { accountId: YOUR_ACCOUNT_ID, applicationId: YOUR_APP_ID, domain: 'APM', entityType: 'APM_APPLICATION_ENTITY', guid: 'A_LONG_GUID', name: 'NAME_OF_YOUR_APP', permalink: 'https://one.newrelic.com/redirect/entity/A_LONG_GUID', reporting: true, type: 'APPLICATION', }, ]; Copy Step 6 of 10 Add a simple tag to your application Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Let's suppose that you want to add an environment tag to your application. Go ahead and add the dev:testing tag‚Å† (or any other key-value pair) to your application using the entities tags create command. bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 What if you want to add multiple tags? Tag sets come to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags at once to your application, modify and run the following snippet. bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 You've created and added some tags to your application, but how do you know they're there? You need to retrieve your application's tags. To retrieve your application's tags, use the entity tags get command. newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Step 9 of 10 Bonus step: Create a deployment marker Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same Application ID from your earlier search. bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Notice that the JSON response includes the revision and timestamp of the deployment. This workflow could be built into a continuous integration or continuous deployment (CI/CD) system to help indicate changes in your application's behavior after deployments. Here is an example. { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands. For example, you could create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.4144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and <em>configuration</em> to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " that you&#x27;ve installed the <em>New</em> <em>Relic</em> <em>CLI</em>, it&#x27;s time to create your first profile. Profiles contain credentials and settings that you can apply to any <em>CLI</em> <em>command</em>, which is useful when switching between accounts. To create your first <em>CLI</em> profile, run the profiles add <em>command</em>. Note that you need"
      },
      "id": "5efa999c196a67c4e1766461"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-10-24T02:01:31Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.84201,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " extension to build your apps. <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em> This table provides descriptions for the <em>New</em> <em>Relic</em> <em>One</em> <em>commands</em>. For more context, including usage and option details, click any individual <em>command</em> or the <em>command</em> category. For details on user permissions, see¬†Authentication and permissions"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-10-24T02:00:01Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.34662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> apps",
        "body": "Intro to NerdStorage 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    }
  ],
  "/explore-docs/nr1-common": [
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Get your application details",
        "Add a simple tag to your application",
        "Bonus step: Create a deployment marker",
        "Next steps"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2020-10-24T01:53:25Z",
      "updated_at": "2020-10-24T01:53:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Get started with the New Relic CLI 20 min Access the New Relic platform from the comfort of your terminal: you can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. Our CLI has been designed for automating common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic personal API Key, which you can create from the Account settings of your New Relic account An instrumented application in your New Relic account Step 1 of 10 Install the New Relic CLI The New Relic CLI can be downloaded via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile Now that you've installed the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. To create your first CLI profile, run the profiles add command. Note that you need to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_API_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Step 3 of 10 Get your application details In this example, you are going to add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 The New Relic CLI can retrieve your application details as a JSON object. To search for your APM application use the apm application search command. If you get an error, check that the account ID and application name you provided are correct. bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Step 5 of 10 If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example. When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. [ { accountId: YOUR_ACCOUNT_ID, applicationId: YOUR_APP_ID, domain: 'APM', entityType: 'APM_APPLICATION_ENTITY', guid: 'A_LONG_GUID', name: 'NAME_OF_YOUR_APP', permalink: 'https://one.newrelic.com/redirect/entity/A_LONG_GUID', reporting: true, type: 'APPLICATION', }, ]; Copy Step 6 of 10 Add a simple tag to your application Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Let's suppose that you want to add an environment tag to your application. Go ahead and add the dev:testing tag‚Å† (or any other key-value pair) to your application using the entities tags create command. bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 What if you want to add multiple tags? Tag sets come to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags at once to your application, modify and run the following snippet. bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 You've created and added some tags to your application, but how do you know they're there? You need to retrieve your application's tags. To retrieve your application's tags, use the entity tags get command. newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Step 9 of 10 Bonus step: Create a deployment marker Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same Application ID from your earlier search. bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Notice that the JSON response includes the revision and timestamp of the deployment. This workflow could be built into a continuous integration or continuous deployment (CI/CD) system to help indicate changes in your application's behavior after deployments. Here is an example. { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands. For example, you could create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 243.84525,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em> 20 min Access the <em>New</em> <em>Relic</em> platform from the comfort of your terminal: you can use the <em>New</em> <em>Relic</em> <em>CLI</em> to manage entity tags, define workloads, record deployment markers, and much more. Our <em>CLI</em> has been designed for automating <em>common</em> tasks in your DevOps workflow"
      },
      "id": "5efa999c196a67c4e1766461"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-10-24T01:53:25Z",
      "updated_at": "2020-10-24T01:53:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.54451,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>CLI</em> to add multiple tags to <em>one</em> of your entities. Before you begin For this guide you need your <em>New</em> <em>Relic</em> personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> via Homebrew (macOS), Scoop (Windows"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-10-24T01:54:36Z",
      "updated_at": "2020-10-24T01:54:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: bash Copy $ my-nerdlet $ ‚îú‚îÄ‚îÄ README.md $ ‚îú‚îÄ‚îÄ launchers $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ nerdlets $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss $ ‚îú‚îÄ‚îÄ node_modules $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler $ ‚îú‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ package-lock.json $ ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 221.9575,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>command</em> nr1 create and select Nerdpack to create"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-10-24T02:00:01Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.34662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> apps",
        "body": "Intro to NerdStorage 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts"
      ],
      "published_at": "2020-10-24T01:51:46Z",
      "title": "Automate workflows",
      "updated_at": "2020-10-24T01:51:46Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.5798,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " CloudFormation, and a <em>command</em>-line interface. These tools enable you to integrate <em>New</em> <em>Relic</em> into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and <em>CLI</em> guides below, find more automation"
      },
      "id": "5efa999c196a67dfb4766445"
    }
  ],
  "/collect-data/custom-events": [
    {
      "sections": [
        "Collect data from any source",
        "Agent APIs",
        "Telemetry SDK",
        "Trace API",
        "Metric API",
        "Event API",
        "Log API"
      ],
      "title": "Collect data from any source",
      "type": "developer",
      "tags": [
        "Agent API",
        "Telemetry SDK",
        "Trace API",
        "Metric API",
        "Event API"
      ],
      "external_id": "5bfb043fffe42ea4a78d5a90bf8e92aa8b8f8c33",
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/collect-data-from-any-source/",
      "published_at": "2020-10-24T01:51:46Z",
      "updated_at": "2020-10-24T01:51:46Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Open source emitters. APIs. New Relic agents. Get data from anywhere. ",
      "body": "Collect data from any source 15 min New Relic products report a lot of data ‚Äúout of the box.‚Äù When you use products like APM, Browser, Mobile, Infrastructure monitoring, or an integration, by default you receive performance data. But you may want to bring data into New Relic that isn't collected by default. Maybe you want an API-based solution that doesn't require install of an agent. Maybe you want to bring telemetry data from another analysis service into New Relic. This page describes several ways to get data into New Relic. Step 1 of 6 Agent APIs If you use our APM, Browser, or Mobile agents to report data, you can use their associated APIs to report custom data. For example, if you monitor your application with the our APM Python agent, you can use the Python agent API to set up custom instrumentation. See the agent APIs. Step 2 of 6 Telemetry SDK Our Telemetry SDKs are language wrappers for our Trace API and Metric API (and eventually our Log API and Event API). These SDKs let you easily send metrics and trace data to New Relic without needing to install an agent. For customers, we offer open-source exporters and integrations that use the Telemetry SDKs to send metrics and trace data: Istio adaptor Prometheus OpenMetrics (for Docker | for Kubernetes) OpenCensus exporter (for Go | for Python) DropWizard exporter Micrometer exporter Want to build your own solution? See our Telemetry SDK docs. Step 3 of 6 Trace API Our Trace API lets you send distributed tracing data to New Relic and consolidate tracing data from multiple sources in one place. We accept trace data in two formats: Zipkin format New Relic format (if you don‚Äôt have Zipkin-format data, you‚Äôd use this) bash Copy $ curl -i -X POST https://trace-api.newrelic.com/trace/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -H 'Data-Format: newrelic' \\ > -H 'Data-Format-Version: 1' \\ > -d '[ $ { $ \"common\": { $ \"attributes\": { $ \"service.name\": \"Test Service A\", $ \"host\": \"host123.test.com\" $ } $ }, $ \"spans\": [ $ { $ \"trace.id\": \"123456\", $ \"id\": \"ABC\", $ \"attributes\": { $ \"duration.ms\": 12.53, $ \"name\": \"/home\" $ } $ }, $ { $ \"trace.id\": \"123456\", $ \"id\": \"DEF\", $ \"attributes\": { $ \"service.name\": \"Test Service A\", $ \"host\": \"host456.test.com\", $ \"duration.ms\": 2.97, $ \"name\": \"/auth\", $ \"parent.id\": \"ABC\" $ } $ } $ ] $ } $ ]' Step 4 of 6 Metric API You can use our Metric API to send metric data to New Relic from any source. bash Copy $ curl -i -X POST https://metric-api.newrelic.com/metric/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ { $ \"metrics\": [ $ { $ \"name\": \"memory.heap\", $ \"type\": \"gauge\", $ \"value\": 2.3, $ \"timestamp\": 1531414060739, $ \"attributes\": { $ \"host.name\": \"dev.server.com\" $ } $ } $ ] $ } $ ]' Step 5 of 6 Event API For sending arbitrary events to New Relic, you can use our Event API. We save these events as a new event type, which can then be queried via NRQL. (Eventually, the Telemetry SDKs will support the Event API.) bash Copy $ curl -i -X POST https://insights-collector.newrelic.com/v1/accounts/$ACCOUNT_ID/events \\ > -H \"Content-Type: application/json\" \\ > -H \"x-insert-key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ { $ \"eventType\": \"LoginEvent\", $ \"service\": \"login-service\", $ \"customerId\": \"xyz\" $ } $ ]' Step 6 of 6 Log API If our existing logging integrations don‚Äôt meet your needs, you can use our Log API to send any arbitrary log data to New Relic. (Eventually, the Telemetry SDKs will support the Log API.) bash Copy $ curl -i -X POST https://log-api.newrelic.com/log/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ \"logs\": [ $ { $ \"timestamp\": 1593538496000, $ \"message\": \"User xyz logged in\", $ \"service\": \"login-service\", $ \"hostname\": \"login.example.com\" $ } $ ] $ ]'",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.48926,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> <em>APIs</em>",
        "info": "Open source emitters. <em>APIs</em>. New Relic <em>agents</em>. Get data from anywhere. ",
        "tags": "<em>Agent</em> <em>API</em>",
        "body": " agents to report data, you can use their associated <em>APIs</em> to report <em>custom</em> data. For example, if you monitor your application with the our APM Python <em>agent</em>, you can use the Python <em>agent</em> <em>API</em> to set up <em>custom</em> instrumentation. See the <em>agent</em> <em>APIs</em>. Step 2 of 6 Telemetry SDK Our Telemetry SDKs are language"
      },
      "id": "5efa997128ccbc3c9a307dfd"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13661,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Data requirements and limits for custom event data",
        "General requirements",
        "Reserved words",
        "Additional Browser PageAction requirements",
        "Additional Event API requirements",
        "Event type limits",
        "For more help"
      ],
      "title": "Data requirements and limits for custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "external_id": "f5beef0d09bb5918be3f8a1a3ece98c09947cd1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "published_at": "2020-10-22T18:01:30Z",
      "updated_at": "2020-10-18T07:41:12Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic, general limits and requirements for reporting custom events and attributes. ",
      "body": "You can report custom events to New Relic in several ways, including the New Relic Event API, APM agent APIs, Browser agent APIs, and the Mobile SDK. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. General requirements How long custom data is retained depends on your Insights subscription and its associated data retention. When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. This is not a complete list. In general, it's a good practice to avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Additional Browser PageAction requirements For additional requirements for using New Relic Browser's custom PageAction event, see Insert custom data via New Relic Browser agent. Additional Event API requirements For more requirements and details for the Event API, see Event API. Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.191025,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data requirements and limits for <em>custom</em> <em>event</em> data",
        "sections": "<em>Custom</em> <em>events</em>",
        "info": "For New Relic, general limits and requirements for reporting <em>custom</em> <em>events</em> and attributes. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "<em>Custom</em> <em>events</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;insights-data-sources&#x2F;<em>custom</em>-data&#x2F;insights-<em>custom</em>-data-requirements-limits",
        "body": "You can report <em>custom</em> <em>events</em> to New Relic in several ways, including the New Relic <em>Event</em> <em>API</em>, APM <em>agent</em> <em>APIs</em>, Browser <em>agent</em> <em>APIs</em>, and the Mobile SDK. This document contains general requirements and rules for inserting and using <em>custom</em> <em>events</em> and their associated attributes. Additional requirements",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; <em>Custom</em> <em>events</em>"
      },
      "id": "59f4354f4bb81c2ea8b80d0a"
    },
    {
      "category_2": "Custom events",
      "nodeid": 6256,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "APM: Report custom events",
        "Data considerations",
        "Record a custom event",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words",
        "For more help"
      ],
      "title": "APM: Report custom events",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/event-data-sources/custom-events/apm-report-custom-events",
      "external_id": "0c3f09d0d0e04ad50bedcdf7088eed7c171001d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/apm-report-custom-events",
      "published_at": "2020-10-22T18:19:18Z",
      "updated_at": "2020-10-18T15:16:18Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic APM: how to report custom events and attributes.",
      "body": "If you have APM, you can report custom event data, which is then available for querying in New Relic. Related documentation: Add custom attributes to existing events Send custom events using the Event API (without need for APM) Custom events sent with the agent APIs are not compatible with high security mode. Data considerations The New Relic agents sends event data to New Relic as part of its normal harvest cycle every 5 seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. For more information, check out New Relic University‚Äôs tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record a custom event To record a custom event, follow the procedure for your New Relic language agent: C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see Limits and restricted characters and Reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 To disable custom events entirely, add the following to your newrelic.yml:‚Äã custom_insights_events: enabled: false For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see Limits and restricted characters and Reserved words. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see Limits and restricted characters and Reserved words. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see Limits and restricted characters and Reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see Limits and restricted characters and Reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see Limits and restricted characters and Reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.399826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> <em>events</em>",
        "sections": "<em>Custom</em> <em>events</em>",
        "info": "New Relic APM: how to report <em>custom</em> <em>events</em> and attributes.",
        "category_1": "<em>Event</em> data sources",
        "category_2": "<em>Custom</em> <em>events</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;<em>event</em>-data-sources&#x2F;<em>custom</em>-<em>events</em>&#x2F;apm-report-<em>custom</em>-<em>events</em>",
        "body": "If you have APM, you can report <em>custom</em> <em>event</em> data, which is then available for querying in New Relic. Related documentation: Add <em>custom</em> attributes to existing <em>events</em> Send <em>custom</em> <em>events</em> using the <em>Event</em> <em>API</em> (without need for APM) <em>Custom</em> <em>events</em> sent with the <em>agent</em> <em>APIs</em> are not compatible with high",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; <em>Custom</em> <em>events</em>"
      },
      "id": "5f480a5a64441f578bfdcdb1"
    },
    {
      "category_2": "Logs in context with agent APIs",
      "nodeid": 36921,
      "sections": [
        "Enable log management",
        "New Relic Logs",
        "Enable log monitoring",
        "Configure logs in context",
        "Logs in context for Go",
        "Logs in context for Java",
        "Logs in context for .NET",
        "Logs in context for Node.js",
        "Logs in context for PHP",
        "Logs in context for Python",
        "Logs in context for Ruby",
        "Logs in context with agent APIs",
        "Annotate logs for logs in context using APM agent APIs",
        "APM agent trace metadata and linking metadata APIs",
        "Resources for correctly annotating logs",
        "For more help"
      ],
      "title": "Annotate logs for logs in context using APM agent APIs",
      "category_0": "Log management",
      "type": "docs",
      "category_1": "Enable log management",
      "external_id": "9d737d9f02561f18b47103b62ce11ada3dfae106",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/enable-log-management-new-relic/logs-context-agent-apis/annotate-logs-logs-context-using-apm-agent-apis",
      "published_at": "2020-10-22T14:33:51Z",
      "updated_at": "2020-09-27T21:36:25Z",
      "breadcrumb": "Contents / Log management / Enable log management / Logs in context with agent APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic's  log management: How to use APM agent APIs to manually set up your own logs in context solution. ",
      "body": "If you use log management and APM, you can configure logs in context to correlate log data with other New Relic features. If you use a logging framework not covered by our existing logs in context solutions, we provide a way for you to configure your logging libraries to achieve annotated logs necessary for logs in context. APM agent trace metadata and linking metadata APIs To get properly annotated logs for logs in context, use APM agent API calls (listed below). These APIs pass metadata required for linking log data to other New Relic data. This metadata is referred to as trace metadata and linking metadata. For tips on using these, see Resources for correct annotation. APM agent APIs: Go agent APIs: GetTraceMetadata GetLinkingMetadata Java agent APIs: getTraceMetadata getLinkingMetadata .NET agent APIs: TraceMetadata GetLinkingMetadata Node.js agent APIs: getTraceMetadata getLinkingMetadata PHP agent APIs: GetTraceMetadata GetLinkingMetadata Python agent API: get_linking_metadata Ruby agent APIs: linking_metadata current_trace_id current_span_id Resources for correctly annotating logs For more information on using the trace metadata and linking metadata APIs to annotate logs for logs in context, see the following resources: Review the APM agent specifications for getting properly formatted annotated logs for logs in context functionality, which include the required fields and properly formatted output. View the source code for our own logs in context extensions to see how we use these APIs: Go: Logrus extension Java: Log4j2 extension .NET: Serilog extension Node.js: Winston extension Python: see Python agent logging configuration PHP: Monolog extension Ruby: Logging extension For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 54.911224,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Annotate logs for logs in context using APM <em>agent</em> <em>APIs</em>",
        "sections": "Logs in context with <em>agent</em> <em>APIs</em>",
        "info": "New Relic&#x27;s  log management: How to use APM <em>agent</em> <em>APIs</em> to manually set up your own logs in context solution. ",
        "category_2": "Logs in context with <em>agent</em> <em>APIs</em>",
        "body": " necessary for logs in context. APM <em>agent</em> trace metadata and linking metadata <em>APIs</em> To get properly annotated logs for logs in context, use APM <em>agent</em> <em>API</em> calls (listed below). These <em>APIs</em> pass metadata required for linking log data to other New Relic data. This metadata is referred to as trace metadata",
        "breadcrumb": "Contents &#x2F; Log management &#x2F; Enable log management &#x2F; Logs in context with <em>agent</em> <em>APIs</em>"
      },
      "id": "5f37535c196a67c8c055e5ff"
    },
    {
      "category_2": "Intro to APIs",
      "nodeid": 15691,
      "sections": [
        "Get started",
        "Intro to APIs",
        "Introduction to New Relic APIs",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "See APIs in action",
        "For more help"
      ],
      "title": "Introduction to New Relic APIs",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "Get started",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/apis/get-started/intro-apis/introduction-new-relic-apis",
      "external_id": "bb3a7314b2407cfa765425553484cb364e27e7e3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/get-started/intro-apis/introduction-new-relic-apis",
      "published_at": "2020-10-23T01:43:11Z",
      "updated_at": "2020-10-17T01:44:46Z",
      "breadcrumb": "Contents / APIs / Get started / Intro to APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to all of the available New Relic APIs. ",
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This section of the docs provides examples and reference documentation for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. While typical REST APIs require loading from multiple URLs, NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. New Relic provides a powerful GraphQL tool to explore the API with embedded schema definitions. To get started, go to api.newrelic.com/graphiql. For sample queries and mutations, use our NerdGraph tutorials. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The Browser API resources include: Resource Details Browser agent API Use the Browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve Mobile data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. If you implemented the REST API for querying subscription usage data prior to July 10, 2018, those usage-related REST APIs are now deprecated. You should use the Query API, which requires creating an API key. For more on switching to the new API format, see the transition guide. Partner API To retrieve information about your New Relic partner account, sub-accounts, and users, use the Partner API. Other APIs Insights API resources for Insights include: Resource Details Insert events API To report custom data use the Event insertion API. Query API To query your Insights data using NRQL-formatted queries, use the Query API. This API can also be used to retrieve subscription usage data. Dashboard API To create, read, update, and delete dashboards, use the Dashboard API. Other New Relic product APIs You can also report custom data from other New Relic features. For more information, see the API sections for other products. NerdGraph You can use NerdGraph (our GraphQL API) to query data with NRQL. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 51.81759,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>APIs</em>",
        "sections": "Intro to <em>APIs</em>",
        "info": "An introduction to all of the available New Relic <em>APIs</em>. ",
        "category_0": "<em>APIs</em>",
        "category_2": "Intro to <em>APIs</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;<em>apis</em>&#x2F;get-started&#x2F;intro-<em>apis</em>&#x2F;introduction-new-relic-<em>apis</em>",
        "body": ". Telemetry <em>APIs</em> for core data types We offer several <em>APIs</em> that allow you to get our core data types (metrics, logs, traces, and <em>events</em>) into New Relic without the use of an installed <em>agent</em>. Data type Description Trace <em>API</em> Send distributed tracing data to New Relic. <em>Event</em> <em>API</em> Send <em>event</em> data to New",
        "breadcrumb": "Contents &#x2F; <em>APIs</em> &#x2F; Get started &#x2F; Intro to <em>APIs</em>"
      },
      "id": "5d4ae71be7b9d211b4d535a4"
    }
  ],
  "/collect-data/get-started-nerdgraph-api-explorer": [
    {
      "nodeid": 37711,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "NerdGraph API: NRQL condition alerts",
        "Steps to create a NRQL condition",
        "NRQL static condition",
        "NRQL baseline condition",
        "NRQL outlier condition",
        "Update a condition",
        "Update mutations",
        "List and filter NRQL conditions",
        "Singular NRQL condition queries",
        "Update the description",
        "Delete conditions",
        "For more help"
      ],
      "title": "NerdGraph API: NRQL condition alerts ",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "86591bd20017930f1e4eef1b1a76e3806298dbb9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-nrql-condition-alerts",
      "published_at": "2020-10-22T08:36:30Z",
      "updated_at": "2020-10-22T08:36:30Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alerts and Nerdgraph",
      "document_type": "page",
      "popularity": 1,
      "info": "Examples of how to use the NerdGraph API explorer to create alert conditions, queries, and mutations.",
      "body": "You can manage alerts conditions using our GraphQL NerdGraph API. Here are some conditions queries and mutations you can develop in our NerdGraph API explorer. See the NerdGraph introduction for help getting started with NerdGraph API explorer. This document covers the following: Steps to create a NRQL condition NRQL static condition NRQL baseline condition NRQL outlier condition Update a condition Update mutations List and filter NRQL conditions Singular NRQL condition queries Create a description Delete conditions Steps to create a NRQL condition Follow these steps: Decide which condition type you want to create (see NRQL Condition threshold types). Find your relevant policyID by doing one of the following: Use the NerdGraph policies API. Go to one.newrelic.com, in the top nav click Alerts & AI, then click Policies. Choose a policy. Find the ID under the policy name. Provide the appropriate mutation for your NRQL condition type and the relevant values. The NerdGraph GraphiQL explorer is the best place to find up-to-date documentation about the per-field specifics of the NerdGraph NRQL Conditions API. For example, questions like \"What does the valueFunction field accept?\" are best answered with the inline NerdGraph documentation. NRQL static condition Here's an example of creating a static condition: mutation { alertsNrqlConditionStaticCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Low Host Count - Catastrophic\" enabled: true nrql: { query: \"SELECT uniqueCount(host) from Transaction where appName='my-app-name'\" } signal { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 2 thresholdOccurrences: AT_LEAST_ONCE thresholdDuration: 600 operator: BELOW priority: CRITICAL } valueFunction: SINGLE_VALUE violationTimeLimitSeconds: 86400 }) { id name } } NRQL baseline condition Here's an example of creating a baseline condition: mutation { alertsNrqlConditionBaselineCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Baseline Condition\" enabled: true baselineDirection: UPPER_ONLY nrql: { query: \"SELECT average(duration) FROM Transaction\" } signal { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 13 thresholdDuration: 180 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 86400 }) { id name baselineDirection } } NRQL outlier condition Here's an example of creating an outlier condition: mutation { alertsNrqlConditionOutlierCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Outlier Condition\" enabled: true expectedGroups: 4 openViolationOnGroupOverlap: false nrql: { query: \"SELECT average(duration) FROM Transaction FACET httpResponseCode\" } signal { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 1 thresholdDuration: 300 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 86400 }) { id name expectedGroups openViolationOnGroupOverlap } } Update a condition Complete the following: Determine the type of your existing condition by requesting the type field in a nrqlConditionsSearch query like this: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nrqlConditions { id type } } } } } } The type returned is what you use for your update mutation. For example, if the type returned is STATIC, use alertsNrqlConditionStaticUpdate. If the type returned is BASELINE, use alertsNrqlConditionBaselineUpdate. If the type returned is OUTLIER, use alertsNrqlConditionOutlierUpdate. Provide the id of your condition to your relevant condition type mutation. Note that you can only update conditions of the relevant type. Only provide update mutations for the fields you want to update. Fields you don't provide in the update are not touched. Update mutations Only fields that you provide in the update are changed. In the following example, baselineDirection returns unchanged, but name is updated. mutation { alertsNrqlConditionBaselineUpdate(id: YOUR_CONDITION_ID, accountId: YOUR_ACCOUNT_ID, condition: { name: \"Your updated name\" }) { id name baselineDirection } } List and filter NRQL conditions To list or filter your NRQL conditions, use the nrqlConditionsSearch query in NerdGraph. Use cursor pagination The basic of list functionality for NRQL conditions allows you to paginate through your NRQL conditions as well as request the total count of conditions per account. The nrqlConditionsSearch query utilizes cursor pagination to paginate through resources. The idea behind cursor pagination is that the client will request a cursor in a programmatic loop until the cursor comes back empty. An initial list response will look something like this: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nextCursor nrqlConditions { id name type } totalCount } } } } } This example returns a JSON response like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlConditionsSearch\": { \"nextCursor\": \"WOwfJ4+TWm9QTFeKMGyg+w==:QqkI8S4+Wwnpno6z+uk8kQ==\", \"nrqlConditions\": [ { \"id\": \"4432\", \"name\": \"Baseline Condition\", \"type\": \"BASELINE\" }, { \"id\": \"443\", \"name\": \"A static condition\", \"type\": \"STATIC\" }, // more conditions here in reality ], \"totalCount\": 435 } } } } }, } In order to paginate through conditions in the response, have the client request the cursor to be returned until the nextCursor returns from the response as null: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch(cursor: \"WOwfJ4+TWm9QTFeKMGyg+w==:QqkI8S4+Wwnpno6z+uk8kQ==\", ) { nextCursor nrqlConditions { id name type } totalCount } } } } } Request type-specific fields Certain fields are only available on specific NRQL condition types. The main reason that mutations are split between the different condition types is because they have minor differences between the fields they accept. For example, valueFunction is only relevant for static NRQL conditions and baselineDirection is only relevant on baseline NRQL conditions. But if these fields are only available on these certain condition types, how do we return them in a list of all of our condition types? The answer is a GraphQL convention known as inline fragments. Inline fragments allow you to access the data on a specific type of NRQL condition: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nrqlConditions { id name type ...on AlertsNrqlStaticCondition { valueFunction } ...on AlertsNrqlBaselineCondition { baselineDirection } ...on AlertsNrqlOutlierCondition { expectedGroups } } } } } } } In the previous example query, we are asking GraphQL to do the hard work for us to determine which NRQL conditions are the correct type. So, when the returned type is a static condition, it will return the valueFunction in the object. When the returned type is a baseline condition, it will return baselineDirection instead, and when the type is an outlier condition, it will return expectedGroups. Here is an example response: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlConditionsSearch\": { \"nrqlConditions\": [ { \"baselineDirection\": \"UPPER_ONLY\", \"id\": \"342\", \"name\": \"My baseline condition\", \"type\": \"BASELINE\" }, { \"id\": \"553\", \"name\": \"My static condition\", \"type\": \"STATIC\", \"valueFunction\": \"SINGLE_VALUE\" }, { \"expectedGroups\": 4, \"id\": \"802\", \"name\": \"My outlier condition\", \"type\": \"OUTLIER\" } ] } } } } } } Filter NRQL conditions You can filter NRQL conditions with the searchCriteria argument of the nrqlConditionsSearch query: Here's an example of filtering NRQL conditions with matching by name. This query returns NRQL conditions that match the provided name. Note that this match is case insensitive. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch(searchCriteria: { name: \"Baseline Condition\" }) { nrqlConditions { id name type } } } } } } Singular NRQL condition queries You can use the NRQL condition API to query for a singular condition. Run the nrqlCondition query in the alerts namespace. Similar to type specific fields on the nrqlConditionSearch query, you can also use these inline fragments to request fields that are restricted to a NRQL condition type. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: YOUR_CONDITION_ID) { id name ...on AlertsNrqlStaticCondition { valueFunction } } } } } } Update the description This will walk you through the procedure to create a description for a NRQL alert condition. 1. Get all the conditions for a policy: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditions(policyId: YOUR_POLICY_ID) { nextCursor results { id name description enabled nrql { query } signal { aggregationWindow evaluationOffset } policyId runbookUrl terms { duration operator priority timeFunction threshold } type violationTimeLimitSeconds } } } } } } 2. Get the details for a single condition: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: \"YOUR_CONDITION_ID\") { description id enabled name nrql { query } signal { aggregationWindow evaluationOffset } policyId runbookUrl terms { operator priority threshold thresholdDuration thresholdOccurrences } type violationTimeLimitSeconds } } } } } 3. Create a mutation with the description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { description } } Here's an example mutation with an included example description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tag.commandLine}} \\n entityGuid : {{tag.entityGuid}} \\n entityName : {{tag.entityName}} \\n fullHostname : {{tag.fullHostname}} \\n instanceType : {{tag.instanceType}} \\n processDisplayName : {{tag.processDisplayName}}\"}) { description } } Delete conditions You can use the alertsConditionDelete mutation to delete any type of condition. You can only request the id field on a delete mutation; for example: mutation { alertsConditionDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CONDITION_ID) { id } } For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 246.04514,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> API: NRQL condition alerts ",
        "sections": "Update <em>mutations</em>",
        "info": "Examples of how to use the <em>NerdGraph</em> API explorer to create alert conditions, <em>queries</em>, and <em>mutations</em>.",
        "body": "You can manage alerts conditions using our GraphQL <em>NerdGraph</em> API. Here are some conditions queries and <em>mutations</em> you can develop in our <em>NerdGraph</em> API explorer. See the <em>NerdGraph</em> introduction for help getting started with <em>NerdGraph</em> API explorer. This document covers the following: Steps to create",
        "breadcrumb": "Contents &#x2F; Alerts and Applied Intelligence &#x2F; New Relic Alerts &#x2F; Alerts and <em>Nerdgraph</em>"
      },
      "id": "5f2dee1128ccbc562e88dfc1"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-10-24T02:00:01Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.81763,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run <em>NerdGraph</em> queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorage<em>Query</em>"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "category_2": "Examples",
      "nodeid": 39021,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "Use NerdGraph to manage license keys and personal API keys",
        "Overview of feature description",
        "Before using examples",
        "Create keys",
        "Update keys",
        "Delete keys",
        "Query keys",
        "For more help"
      ],
      "title": "Use NerdGraph to manage license keys and personal API keys",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "f4b228fbc3fdc408adc6d7e10a93edd0464b7762",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-personal-api-keys",
      "published_at": "2020-10-22T11:58:05Z",
      "updated_at": "2020-10-14T08:01:58Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic NerdGraph (our GraphQL API) to create and manage your New Relic license keys, browser license keys, and personal API keys. ",
      "body": "This document contains tutorials on how to use NerdGraph to programmatically create and manage several types of New Relic keys. To build queries and see responses, use our GraphiQL explorer. For more information on our API keys, see API keys. Overview of feature description NerdGraph's ApiAccess field can be used to programmatically create and manage the following types of keys: Personal API keys License keys, including: General license key used for APM Browser license key One common use case for this feature is the ability to create and manage license keys to let you rotate keys for security purposes. Note that you can't use this NerdGraph functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you've created. General notes about this functionality: All mutations can accept multiple keys as arguments, and will return details about successful changes and errors. See examples below for details. All mutations (create, update and delete) will result in an NrAuditEvent that can be queried for auditing purposes. For details, see Audit events. Some notes about license keys: In the context of using NerdGraph, the license keys are referred to as ingest keys. This feature allows you to create up to 1,000 keys of each license key type, which allows for key rotation. You can't use this NerdGraph functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you've created. License keys created through NerdGraph can't be found in the New Relic UI. They're only queryable via the API. Some notes about personal API keys: In the context of using NerdGraph, personal API keys are referred to as user keys. User keys are displayed in various UI locations (for example: the User settings UI page). Before using examples Things to note before using these example queries: The examples below use license keys (aka ingest keys), but you can query personal API keys (user keys) in similar ways, replacing the ingest-specific fields with fields specific to the API. To understand the structure of these objects, you can experiment with queries using the GraphiQL explorer. You can also create, view, and delete personal API keys using the UI. Create keys You can create multiple keys in a single mutation, for multiple accounts and key types. Note that the mutation can return successfully created keys as well as any errors encountered trying to create keys. Example of creating a key: mutation { apiAccessCreateKeys(keys: {ingest: {accountId: YOUR_ACCOUNT_ID, ingestType: BROWSER, name: \"Browser Key\", notes: \"A note.\"}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Here's an example of using this query to create a personal API key: Create a personal API key To create a personal API key, you'd change the above query slightly, in the keys section: mutation { apiAccessCreateKeys(keys: {user: {accountId: YOUR_ACCOUNT_ID, userId: YOUR_USER_ID}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Update keys The update mutation takes the key ID, not the key string, to identify keys. mutation { apiAccessUpdateKeys(keys: {ingest: {keyId: KEY_ID, name: \"Updated name\", notes: \"A new note!\"}}) { updatedKeys { id key type name notes } errors { message } } } Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Delete keys The delete mutation takes the key ID, not the key string, to identify keys. Deleted keys will no longer grant access to New Relic systems and will no longer be returned by queries to the API access GraphQL API. mutation { apiAccessDeleteKeys(keys: {ingestKeyIds: INGEST_KEY_ID}) { deletedKeys { id } errors { message } } } Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Query keys You can access ingest and user keys by querying a single key or all keys, scoped to the actor. If querying for a single key, you must provide the key ID and type (INGEST or USER). Querying for multiple keys is done via a key search, which uses a mandatory types list and an optional scope to filter results. User keys belonging to other users will be obfuscated in the results. Single key example query: query { actor { apiAccess { key(id: INGEST_KEY_ID, keyType: INGEST) { key name type ... on ApiAccessIngestKey { ingestType } } } } } Key search example query: query { actor { apiAccess { keySearch(query: {types: INGEST, scope: {ingestTypes: BROWSER}}) { keys { name key type ... on ApiAccessIngestKey { ingestType } } } } } } Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.47064,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>NerdGraph</em> to manage license keys and personal API keys",
        "sections": "<em>NerdGraph</em>",
        "info": "Use New Relic <em>NerdGraph</em> (our GraphQL API) to create and manage your New Relic license keys, browser license keys, and personal API keys. ",
        "category_1": "<em>NerdGraph</em>",
        "body": " purposes. Note that you can&#x27;t use this <em>NerdGraph</em> functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you&#x27;ve created. General notes about this functionality: All <em>mutations</em> can accept multiple keys as arguments, and will return",
        "breadcrumb": "Contents &#x2F; APIs &#x2F; <em>NerdGraph</em> &#x2F; Examples"
      },
      "id": "5efe0487196a6710b1766452"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2020-10-24T02:01:31Z",
      "updated_at": "2020-10-14T01:58:45Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "Intro to New Relic One SDK To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.49889,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Query</em> and storage components",
        "tags": "<em>query</em> and storage components",
        "body": ", our GraphQL endpoint. This can be queried using NerdGraph<em>Query</em>. To simplify use of <em>NerdGraph</em> queries, we provide some components with pre-defined queries. For more on using <em>NerdGraph</em>, see Queries and <em>mutations</em>. We also provide storage for storing small data sets, such as configuration settings data"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "category_2": "Intro to APIs",
      "nodeid": 15691,
      "sections": [
        "Get started",
        "Intro to APIs",
        "Introduction to New Relic APIs",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "See APIs in action",
        "For more help"
      ],
      "title": "Introduction to New Relic APIs",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "Get started",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/apis/get-started/intro-apis/introduction-new-relic-apis",
      "external_id": "bb3a7314b2407cfa765425553484cb364e27e7e3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/get-started/intro-apis/introduction-new-relic-apis",
      "published_at": "2020-10-23T01:43:11Z",
      "updated_at": "2020-10-17T01:44:46Z",
      "breadcrumb": "Contents / APIs / Get started / Intro to APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to all of the available New Relic APIs. ",
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This section of the docs provides examples and reference documentation for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. While typical REST APIs require loading from multiple URLs, NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. New Relic provides a powerful GraphQL tool to explore the API with embedded schema definitions. To get started, go to api.newrelic.com/graphiql. For sample queries and mutations, use our NerdGraph tutorials. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The Browser API resources include: Resource Details Browser agent API Use the Browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve Mobile data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. If you implemented the REST API for querying subscription usage data prior to July 10, 2018, those usage-related REST APIs are now deprecated. You should use the Query API, which requires creating an API key. For more on switching to the new API format, see the transition guide. Partner API To retrieve information about your New Relic partner account, sub-accounts, and users, use the Partner API. Other APIs Insights API resources for Insights include: Resource Details Insert events API To report custom data use the Event insertion API. Query API To query your Insights data using NRQL-formatted queries, use the Query API. This API can also be used to retrieve subscription usage data. Dashboard API To create, read, update, and delete dashboards, use the Dashboard API. Other New Relic product APIs You can also report custom data from other New Relic features. For more information, see the API sections for other products. NerdGraph You can use NerdGraph (our GraphQL API) to query data with NRQL. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.50601,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>NerdGraph</em> (GraphQL)",
        "body": " developer.newrelic.com. <em>NerdGraph</em> (GraphQL) <em>NerdGraph</em> is New Relic&#x27;s GraphQL API, an efficient and flexible <em>query</em> language that lets you request exactly the data you need, without over-fetching or under-fetching. While typical REST APIs require loading from multiple URLs, <em>NerdGraph</em> calls get all"
      },
      "id": "5d4ae71be7b9d211b4d535a4"
    }
  ],
  "/automate-workflows/get-started-kubernetes": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts"
      ],
      "published_at": "2020-10-24T01:51:46Z",
      "title": "Automate workflows",
      "updated_at": "2020-10-24T01:51:46Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.26608,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up New Relic using the <em>Kubernetes</em> <em>operator</em>",
        "body": " the <em>Kubernetes</em> <em>operator</em> Learn how to provision New Relic resources using the <em>Kubernetes</em> <em>operator</em> 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Get started",
      "nodeid": 40836,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Streaming Alerts: key terms and concepts",
        "Streaming Alerts terms and concepts",
        "For more help"
      ],
      "title": "Streaming Alerts: key terms and concepts",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "01517529fcf70c4c598d2f06638e3afea8ab4837",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/get-started/streaming-alerts-key-terms-concepts",
      "published_at": "2020-10-22T13:07:40Z",
      "updated_at": "2020-10-08T16:10:36Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Get started",
      "document_type": "page",
      "popularity": 1,
      "body": "NRQL Condition alerts are processed entirely using streaming analytics with the New Relic One Streaming Alerts platform. This means that we are not querying the at-rest data in NRDB at all when processing NRQL Condition alerts. While we use NRQL as a consistent language across the product, there are differences between how NRQL is executed against streaming analytics and how it is executed against the NRDB data store. Below are some key concepts around Streaming Alerts that will help you to better understand how they work with NRQL alert conditions. You can find additional information in our how-to resource, Create NRQL alert conditions. Streaming Alerts terms and concepts signal The signal is the stream of telemetry data that you have identified to watch and alert on. We use NRQL queries as the language to define the signal. signal filter After New Relic receives your data, it gets routed to the streaming alerts platform. The WHERE clause in the NRQL query serves as a filter that defines the signal that streams through the alerts platform. When we discuss gaps in a signal, or loss of signal, the data stream that results from this filter is the signal that we are discussing. aggregation window The streaming alerts platform works by moving time-bound windows of data through a pipeline. Data points are accumulated into a specific aggregation window based on the timestamp on the data point. aggregation function The NRQL query contains a function, such as sum(), average(), or latest() that specifies how the data points accumulated into an aggregation window should be processed, or calculated, to create a single data point. That aggregated data point is then passed to the alert evaluation process. streaming algorithm The streaming algorithm determines when the data in the aggregation window is processed submitted to Alert Evaluation. At this point, the streaming algorithm uses the server clock time to determine when to trigger an aggregation window to be processed. alert evaluation Alert evaluation assess a set of aggregation windows, based on the condition settings, to determine if an alert condition is violating, or recovering. Based on the threshold duration you set (for example, 5 minutes), it determines how many aggregation windows are contained within that duration. From there, it evaluates the aggregated data points within each time window. Any windows without data points are treated as a gap. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.73787,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Streaming <em>Alerts</em>: key terms and concepts",
        "sections": "<em>Alert</em> <em>conditions</em>",
        "category_0": "<em>Alerts</em> and Applied Intelligence",
        "category_1": "New Relic <em>Alerts</em>",
        "body": ", there are differences between how <em>NRQL</em> is executed against streaming analytics and how it is executed against the NRDB data store. Below are some key concepts around Streaming Alerts that will help you to better understand how they work with <em>NRQL</em> <em>alert</em> <em>conditions</em>. You can find additional information in our"
      },
      "id": "5f7f39fc28ccbc39853cd100"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 9231,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Create NRQL alert conditions",
        "Create a NRQL alert condition",
        "Alert threshold types",
        "NRQL alert syntax",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Evaluation offset",
        "Fill data gaps",
        "NRQL alert threshold examples",
        "Nested Aggregation NRQL Alerts",
        "Create a description",
        "For more help"
      ],
      "title": "Create NRQL alert conditions",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "external_id": "956a7a0b84d2afac5e6236df3143085ebc4f7459",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/signal-loss-ui.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "published_at": "2020-10-22T21:28:31Z",
      "updated_at": "2020-10-14T21:48:04Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "How to define thresholds that trigger alert notifications based on your NRQL queries.",
      "body": "You can create alert conditions using NRQL queries. This resource contains information about creating NRQL alert conditions. For more information on key concepts relating to NRQL alert conditions and Streaming Alerts, see Streaming Alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition: When you start to create a condition, where it prompts you to Select a product, click NRQL. Tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. Query results Queries must return a number. The condition works by evaluating that returned number against the thresholds you set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use it to ensure that violations for sporadic data, such as error counts, are closed when no signal is coming in. To learn more about signal loss and how to request access to it, see this announcement. Advanced signal settings You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. The default streaming aggregation window duration is 1 minute. The minimum aggregation window is 30 seconds and the maximum is 15 minutes. Note: Baseline thresholds don't support configurable aggregation window durations. They use the 1 minute default. You can adjust the evaluation offset to coordinate the streaming algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. If your data is sporadic or has aggregation windows that may not have data, you can fill those gaps with a custom value or the lask known value. The default value is None. To learn more about gap filling and how to request access to it, see this announcement Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to the condition to include your organization's procedures for handling the incident. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions do not affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type, except you cannot use a FACET clause. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. NRQL alert syntax Here is the basic syntax for creating all NRQL alert conditions. Depending on the threshold type, also include a FACET clause as applicable. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Optional Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Static: Optional Baseline: Not allowed Outlier: Required Including a FACET clause in your NRQL syntax depends on the threshold type: static, baseline, or outlier. Use the FACET clause to separate your results by attribute and alert on each attribute independently. Faceted queries can return a maximum of 5000 values for static conditions and a maximum of 500 values for outlier conditions. If the query returns more than this number of values, the alert condition cannot be created. If you create the condition and the query returns more than this number later, the alert will fail. Sum of query results (limited or intermittent data) Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of the one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum, and the preview chart will update accordingly. Set the loss of signal threshold Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Create a condition. Loss of signal is only available for NRQL conditions. A loss of signal is a period of time when no data is received by the New Relic One Streaming Alerts platform. This can be because no data is being sent to New Relic, or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. This often indicates that a service or entity is no longer online, or that a periodic job failed to run. You can use loss of signal detection to be notified when an signal is lost, or to ensure that violations for ephemeral services or sporadic data, such as error counts, close when there is no longer data being sent to New Relic. Loss of signal settings: Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration This is a timer that starts, and resets, when we receive a data point in the streaming alerts pipeline. If we do not receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic, or the \"where\" clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline Loss of signal expiration time is independent of the threshold duration, and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we caution you against setting this value below 3-5 minutes. Loss of signal actions Once a signal is considered lost, there are two options. You may choose one option or both. Close all current open violations: This will close all open violations that are related to this specific signal. It will not necessarily close all violations for a condition. If you are alerting on an ephemeral service, or on a sporadic signal, you will want to chose this action to ensure that violations are closed properly. The graphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to loss of signal. Based on your Incident Preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we will close all open violations first, then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: When creating a condition, under Select a product, click NRQL, then click Next, define thresholds. Create a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in the field labeled \"Signal is lost after\" in minutes or seconds. Choose which action(s) to take when the signal is lost. Check the boxes to Close all current open violations and/or Open new \"lost signal\" violation to indicate how loss of signal violations should be handled for this condition. Make sure you name your condition and then save it. You may also manage these settings using the GraphQL API (recommended), or the REST API. See this document for GraphQL API Examples. Please note, loss of signal detection does not work on NRQL queries that use Nested Aggregation (aka sub queries). Evaluation offset The streaming alerts platform works by moving time-bound windows of data, referred to as \"aggregation windows\" through a pipeline. You may configure the duration, or size, of an aggregation window. The default is 1 minute. When we receive a data point in the streaming alerts pipeline, we use the timestamp on the data point to map it to the correct aggregation window. The streaming algorithm uses the server's clock time to advance the aggregation windows forward, and triggers the data to be aggregated using the function in the NRQL query. When a data point arrives at New Relic with a timestamp that is older than the duration of the aggregation window (1 minute by default), the data point may get dropped, and not evaluated by the alert condition. Evaluation Offset defines the number of aggregation windows that we keep in the queue, before we trigger aggregation, to increase the likelihood that the incoming data point will be matched to a waiting aggregation window. If there is a lot of latency before your data arrives, you will have to increase the number of aggregation windows in the evaluation offset. The current default is 3. Aggregation window and Offset evaluation toggles As indicated on the UI, the total supported latency is the multiple of the aggregation window duration times the evaluation offset. In this example, the allowed latency is 15 minutes (5 minute aggregation window X 3). If the event type is sourced from an APM language agent and aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3, with 1 minute aggregation windows. For cloud data, such as AWS integrations, you may need an offset longer than 3 minutes. Check our AWS polling intervals documentation to determine your best setting. Fill data gaps Sometimes a signal will have one or more aggregation windows that does not contain data. This may happen for a variety or reasons, both expected and unexpected. There may be an issue with the network or the host that causes data not to be sent, or the signal may be sparse. Some signals, such as error counts, may only contain data when there are errors. The alert evaluation process needs to know how to process these gaps, and how these gaps should affect the threshold duration. We provide you with 3 gap filling options to choose from : none, last value, and static value. The default is 'none'. How to edit: In the UI, under NRQL Conditions, this control is located under condition settings > advanced signal settings > fill data gaps with . In the Nerdgraph API (preferred), you will find this node located at : actor : account : alerts : nrqlCondition : signal : fillOption | fillValue In the REST API Explorer, you will see this under the the \"signal\" section of the Alert NRQL Conditions API. Gap filling options: None : This is the default. With this option, we do not take any action on empty aggregation windows. When evaluation occurs, an empty aggregation window will reset the threshold duration timer. If the condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition will not be in violation. Custom static value : This option inserts the static value that you specify into the empty windows before evaluation. This option has an additional, required parameter of \"fillValue\" (as named in the API) that specifies what static value should be used. This defaults to \"0\". Last Known Value : This option inserts the last seen value in the gaps before evaluation occurs. We maintain the state of the last seen value for 2 hours. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction SELECT percentile(databaseDuration, 75) FROM Transaction Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction SELECT average(duration) FROM Transaction Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Nested Aggregation NRQL Alerts Nested aggregation queries are a powerful way to query your data and open up new possibilities to alert on. However, they have a few restrictions that are important to note. Nested queries with a non-faceted innermost query are not currently supported Without a FACET, the inner query will produce a single result thus giving the outer query nothing to aggregate. Registering the inner query alone would be equivalent. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu) ‚Äã‚Äã‚Äã‚Äã‚Äã Queries at all levels must have the same aggregation window Assuming the alert is registered with an aggregation window of 1 minute, this inner query would produce 2 smaller windows of width 30 seconds which could be aggregated by the outer query. However, this is not currently supported. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)‚Äã‚Äã Signal loss is not yet supported for nested queries For more information on signal loss, see NerdGraph API: Loss of signal and gap filling. Create a description You can define a description that passes useful information downstream for better violation responses or for use by downstream systems. For details, see Description. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 71.42082,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "sections": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "info": "How to define thresholds that trigger <em>alert</em> notifications based on your <em>NRQL</em> queries.",
        "category_0": "<em>Alerts</em> and Applied Intelligence",
        "category_1": "New Relic <em>Alerts</em>",
        "category_2": "<em>Alert</em> <em>conditions</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;<em>alerts</em>-applied-intelligence&#x2F;new-relic-<em>alerts</em>&#x2F;<em>alert</em>-<em>conditions</em>&#x2F;create-<em>nrql</em>-<em>alert</em>-<em>conditions</em>",
        "body": "You can create <em>alert</em> <em>conditions</em> using <em>NRQL</em> queries. This resource contains information about creating <em>NRQL</em> <em>alert</em> <em>conditions</em>. For more information on key concepts relating to <em>NRQL</em> <em>alert</em> <em>conditions</em> and Streaming Alerts, see Streaming Alerts: key terms and concepts. Create a <em>NRQL</em> <em>alert</em> condition",
        "breadcrumb": "Contents &#x2F; Alerts and Applied Intelligence &#x2F; New Relic Alerts &#x2F; <em>Alert</em> <em>conditions</em>"
      },
      "id": "5f2d992528ccbc489d88dfc1"
    },
    {
      "category_2": "On-host integrations list",
      "nodeid": 38406,
      "sections": [
        "On-host integrations",
        "Get started",
        "Installation",
        "On-host integrations list",
        "Understand and use data",
        "Troubleshooting",
        "StatsD monitoring integration (version 2)",
        "Features",
        "Requirements",
        "Install",
        "Install for Kubernetes",
        "Configure",
        "Metric format",
        "Metric types",
        "Add tags (attributes)",
        "Create alerts",
        "Find and use data",
        "Check the source code",
        "For more help"
      ],
      "title": "StatsD monitoring integration (version 2) ",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "On-host integrations",
      "external_id": "5d94989a9004778a43aba9fc5187b7904affc412",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/statsd-nrql-alert-condition-example-2.png",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/statsd-monitoring-integration-version-2",
      "published_at": "2020-10-22T11:31:52Z",
      "updated_at": "2020-10-22T11:31:52Z",
      "breadcrumb": "Contents / Integrations / On-host integrations / On-host integrations list",
      "document_type": "page",
      "popularity": 1,
      "body": "The second version of our StatsD integration was released on May 25 2020. It's an improvement on our first StatsD integration. Improvements include: simpler configuration, and a simpler method for adding tags (key-value pairs). Features Our StatsD integration (version 2) lets you easily get StatsD-format data into New Relic. You can also add any arbitrary tags (key-value pairs) to your data. Once your metrics are in New Relic, you can query your data and create custom charts and dashboards. Requirements This integration uses our Metric API and our Event API to ingest data. To use these APIs, you'll need an Insert API key. The integration adheres to the Metric API requirements and data limits. The default rate limit is 100,000 data points per minute (DPM). If you think you're missing metrics or sending more than 100K DPM, see Request data changes. To see if you're account is hitting the rate limit, run the following NRQL query: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature ='Metrics' FACET category, message LIMIT 100 since 1 day ago Install This section will explain how to do a standard install. If you want to run StatsD in Kubernetes, see Kubernetes install. To install the StatsD integration, run the following command and include your New Relic account ID and New Relic Insert API key. This generates a TOML configuration file used by gostatsd. docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 If your account is in the EU data center region, add this to the above command: -e NR_EU_REGION=true \\ After installing, you can: Do optional additional configuration Define your metrics Add custom tags to your data Create alerts Install for Kubernetes Here are examples of Kubernetes manifests for deployment and service objects: Kubernetes manifest examples Below are examples of Kubernetes manifests to deploy StatsD in a Kubernetes environment and create a StatsD service named newrelic-statsd. You need to insert your account ID and your license key. deployment.yml: apiVersion: apps/v1 kind: Deployment metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: selector: matchLabels: app: newrelic-statsd replicas: 2 revisionHistoryLimit: 2 template: metadata: labels: app: newrelic-statsd spec: containers: - name: newrelic-statsd image: newrelic/nri-statsd:2.0.0 env: - name: NR_ACCOUNT_ID value: \"NEW_RELIC_ACCOUNT_ID\" - name: NR_API_KEY value: \"NEW_RELIC_LICENSE_KEY\" service.yml: apiVersion: v1 kind: Service metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: type: ClusterIP ports: - name: newrelic-statsd port: 80 targetPort: 8125 protocol: UDP selector: app: newrelic-statsd For configuration details, see Kubernetes configuration. Configure In the install procedure, you run nri-statsd with environment variables, and this generates a TOML configuration file. Additionally, you can set these configuration options: Configuration options Description expiry-interval string If a metric is not updated for this amount of time, we stop reporting that metric. Default is 5m. If you want to send the metrics only if the value was updated between the flush intervals, configure this to 1ms. To never expire metrics, set it to 0. percent-threshold list of integers Specifies the percentiles used for metrics aggregation. Default: 90. metrics-addr string Indicates address on which to listen for metrics. Default: :8125. To ensure FedRAMP compliance when using the StatsD integration you must define the following endpoints in the custom configuration: address = 'https://gov-insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://gov-infra-api.newrelic.com/metric/v1' Here are some examples of customizing configuration by overwriting the default configuration: Example of custom configuration # Specify after how long do we expire metrics, default:5m expiry-interval = '1ms' # percent-threshold specify a list of percentiles for metrics aggregation, default:90 percent-threshold = [90, 99] backends='newrelic' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Disable timer sub-metrics: By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. If you want to disable those metrics you can do it by adding a disabled-sub-metrics configuration section and set true for the ones you want disabled. Here's an example: # disabled-sub-metrics configuration section allows disabling timer sub-metrics [disabled-sub-metrics] # Regular metrics count=false count-per-second=false mean=false median=false lower=false upper=false stddev=false sum=false sum-squares=false # Percentile metrics count-pct=false mean-pct=false sum-pct=false sum-squares-pct=false lower-pct=false upper-pct=false Docker: overwrite default configuration To overwrite the default nri-statsd configuration while running in a container, you can mount a configuration file inside the container. You can adopt the following template as needed for your situation. Example: backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' To run the container with the file mounted in the appropriate path: docker run \\ ... -v ${PWD}/nri-statsd.toml:/etc/opt/newrelic/nri-statsd.toml \\ ... newrelic/nri-statsd:2.0.0 Kubernetes: overwrite default configuration The best approach to configure nri-statsd running in Kubernetes is to use a configMap and mount the configMap into the container. (This is a similar process to mounting the configuration file in Docker.) Example: apiVersion: v1 kind: ConfigMap metadata: name: nri-statsd-config namespace: default data: nri-statsd.toml: | backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://metric-api.newrelic.com/metric/v1' api-key = '$NEW_RELIC_API_KEY' To use the configMap, declare a volume on your deployment spec template and then declare a volumeMount on your container spec. Example: apiVersion: apps/v1 kind: Deployment spec: template: spec: containers: .... volumeMounts: - mountPath: /etc/opt/newrelic/ name: nri-statsd-config volumes: - name: nri-statsd-config configMap: name: nri-statsd-config Metric format The integration receives metrics using the StatsD protocol. Optionally, the sample rate can be configured and tags can be added. Here's the metric data format we use: <metric name>:<value>|<type>|@<sample rate>|#<tags> Here are explanations of these fields: Field name Description <metric name> string Required. Name of the metric. <value> string Required. The metric type: c = counter g = gauge ms = timer @<sample rate> float Optional for simple counters or timer counters. When many metrics must be sent, you can use sampling to reduce network traffic. The downside is a reduction in the resolution of the data. An example of how this would work for sample rates below 1: If you set this to 0.1, the counter would send a measurement one out of every 10 times. #<tags> string Optional. Tags attached to your metrics are converted into attributes (key-value pairs). For more on tagging options, see Tags. Metric types Here are the types of metrics and how to format them: Counter A counter measures the number of occurrences of an event. Examples include cache hits per reporting interval and the number of threads created per reporting interval. A counter can be incremented or decremented during the same flush interval by adding a sign to the value. In the following example, the counter value will be 2: counter:4|c counter:-2|c At each flush, the current count is sent and reset to 0. If the count is not updated, at the next flush it will send the value 0. You can opt to disable this behavior by setting expiry-interval to 1ms. Here‚Äôs an example of a counter that is being sampled 1 out of 10 times: counter:4|c@0.1 Gauge A gauge represents a value that can increase or decrease with time. Examples of gauges include temperature, CPU usage, and memory. Here's an example: temperature:40|g If the gauge is not updated, at the next flush it will send the previous value. You can opt to disable this behavior by setting expiry-interval to 1ms. Timer The timer metric type measures timing data. By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. These are sent as sub-metrics in the following format: <metric_base_name>.std_dev <metric_base_name>.median <metric_base_name>.summary <metric_base_name>.sum_squares <metric_base_name>.mean <metric_base_name>.per_second The configured percentiles will generate the following metrics. The percentile threshold value will be attached as a tag. <metric_base_name>.sum_squares.percentiles <metric_base_name>.sum.percentiles <metric_base_name>.count.percentiles <metric_base_name>.upper.percentiles <metric_base_name>.mean.percentiles The percentile threshold can be tweaked with the percent-threshold config option. These can be controlled through the disabled-sub-metrics configuration section. Add tags (attributes) You can add tags to your data, which we save as attributes (key-value pairs). There are two options for adding tags: Add default tags that apply to all metrics: These apply to all metrics. They are fixed and don't change over time. Add metric-level tags: These apply to specific metrics and allow the value to be changed between two submits. Add default tags that apply to all metrics Add tags to metrics and events by defining an environment variable in the startup command. Here's an example that would create two tags: -e TAGS=\"environment:production region:us\" Here's that environment variable used in the startup command: docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -e TAGS=\"environment:production region:us\" \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Add metric-level tags When defining the metric format, you can add tags using this format: <bucket name>:<value>|<type>|#<tags> In this example, <tags> is a comma-separated list of tags. Tags format is: simple or key:value. Here's an example NRQL query that includes a custom tag: SELECT count(*) FROM Metric WHERE environment = 'production' Create alerts You can alert on StatsD data using NRQL alert conditions. Alert example This procedure walks you through sending some sample data and then creating an alert condition using that data. First, send this data to New Relic‚Äôs StatsD container: echo \"prod.test.num:32|g\" | nc -v -w 1 -u localhost 8125 Next, create a NRQL alert condition using this query: SELECT latest(prod.test.num) FROM Metric WHERE metricName = 'prod.test.num' Here's an image showing creating this NRQL alert condition. Notice that the sample data sent in is represented by the blue dot on the upper right of the chart. Now we can create the alert condition with these settings: Remember to set the Condition name. If a metric with a value above 50 is sent, then an incident is created and notified. The incident is closed automatically after 24 hours. To test that the alert is working, run this command: echo \"prod.test.num:60|g\" | nc -v -w 1 -u localhost 8125 Find and use data To query your data, you'd use any New Relic query option. For example, you might run a NRQL query like: SELECT count(*) FROM Metric WHERE metricName = 'myMetric' and environment = 'production' For more on how to query the Metric data type, see Query metric data. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 56.68347,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install for <em>Kubernetes</em>",
        "body": ". Here&#x27;s an example <em>NRQL</em> query that includes a custom tag: SELECT count(*) FROM Metric WHERE environment = &#x27;production&#x27; Create alerts You can <em>alert</em> on StatsD data using <em>NRQL</em> <em>alert</em> <em>conditions</em>. <em>Alert</em> example This procedure walks you through sending some sample data and then creating an <em>alert</em> condition"
      },
      "id": "5ece854928ccbc9dbdc13573"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 7391,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "View entity health status and find entities without alert conditions",
        "Exceptions",
        "Color-coded health status",
        "Example: App without conditions",
        "Example: App with conditions",
        "For more help"
      ],
      "title": "View entity health status and find entities without alert conditions",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "16c3fc543366aed467c2219a18774c5220117948",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/view-entity-health-status-find-entities-without-alert-conditions",
      "published_at": "2020-10-22T08:47:29Z",
      "updated_at": "2020-10-08T16:26:47Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "The color-coded health status indicates whether app or other entity has any alerts policies assigned to it.",
      "body": "With alerts you can easily tell whether an entity (the target for the notification) has one or more conditions associated with it: If yes, its health status indicator on the selected index (APM, Browser, etc.) will be color-coded to the current state. To view a summary of current alert violations, mouse over its health status indicator. If no, its health status indicator on the selected index will appear grey. To learn more about how conditions and policies work together, see Introduction to important concepts. Exceptions The health status indicator doesn't apply for: NRQL alert conditions Infrastructure entities Dashboards Entities targeted by labels Color-coded health status The index automatically appears when you select the product from the New Relic menu bar. For example, to view the index of APM apps, go to one.newrelic.com, then click APM. The Applications index lists all APM product entities and their current health status. Color Health status Green The entity is operational. We are collecting data that you can view in the appropriate UI. No alert violations are currently reported for it. Yellow The entity is degraded. A warning threshold has been violated. Red A critical threshold has been violated: Notifications have been sent based on the selected incident rollup preference. The incident appears in the Incidents index. Gray The entity's status is unknown. We're not receiving alerts data for the entity. This could mean alerts are muted, not set up, or the reporting system is down. Example: App without conditions Here's an example of an app listed on the APM index that is not associated with any conditions. Its color-coded health status is light grey, which indicates no alert conditions are set up for that entity. Go to one.newrelic.com, then click Entity explorer: This example shows an app that currently isn't associated with any alerts conditions. Its grey status icon means it doesn't have any conditions. Follow standard procedures to add it to an existing condition or to create a new condition for it. Example: App with conditions Here's an example of an app listed on the APM index that is associated with one or more conditions. Its color-coded health status is green, because we are collecting data for it, and currently there are no Warning (yellow) or Critical (red) violations. Go to one.newrelic.com, then click Entity explorer: This example shows an app that has one or more conditions. Its color-coded health status (green) shows the app hasn't reached any threshold violations. To view the index listing currently open incidents across all products, not just this entity, select View all violations. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 56.562557,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View entity health status and find entities without <em>alert</em> <em>conditions</em>",
        "sections": "<em>Alert</em> <em>conditions</em>",
        "info": "The color-coded health status indicates whether app or other entity has any <em>alerts</em> policies assigned to it.",
        "category_0": "<em>Alerts</em> and Applied Intelligence",
        "category_1": "New Relic <em>Alerts</em>",
        "category_2": "<em>Alert</em> <em>conditions</em>",
        "body": ", mouse over its health status indicator. If no, its health status indicator on the selected index will appear grey. To learn more about how <em>conditions</em> and policies work together, see Introduction to important concepts. Exceptions The health status indicator doesn&#x27;t apply for: <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "breadcrumb": "Contents &#x2F; Alerts and Applied Intelligence &#x2F; New Relic Alerts &#x2F; <em>Alert</em> <em>conditions</em>"
      },
      "id": "5f2edf54e7b9d2f64ec9de88"
    }
  ],
  "/automate-workflows/automated-tagging": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Set up New Relic using the Kubernetes operator",
        "Automate common tasks",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts"
      ],
      "published_at": "2020-10-24T01:51:46Z",
      "title": "Automate workflows",
      "updated_at": "2020-10-24T01:51:46Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Getting started with New Relic and Terraform Learn how to provision New Relic resources using Terraform 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.34016,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Automate</em> workflows",
        "sections": "<em>Automatically</em> <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em>",
        "body": " solutions in our Developer Toolkit. Guides to <em>automate</em> workflows 5 min Quickly <em>tag</em> resources Add tags to apps for easy filtering 30 min Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em> See how easy it is to leverage automation in <em>your</em> DevOps environment! 20 min Set up New Relic using"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Full-stack observability",
      "nodeid": 14056,
      "sections": [
        "Best practices guides",
        "Telemetry data platform",
        "Full-stack observability",
        "Alerts and Applied Intelligence",
        "APM best practices guide",
        "1. Standardize application names",
        "How to do it",
        "2. Add tags to your applications",
        "3. Create and evaluate alert policies",
        "4. Identify and set up key transactions",
        "5. Track deployment history",
        "6. Review APM reports",
        "7. Review your environment with service maps",
        "8. Keep current",
        "9. Manage user access",
        "For more help"
      ],
      "title": "APM best practices guide",
      "category_0": "Solutions and best practices",
      "type": "docs",
      "category_1": "Best practices guides",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/new-relic-solutions/best-practices-guides/full-stack-observability/apm-best-practices-guide",
      "external_id": "7c83791f0021bce381d9095b37b90259b9115c32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/apm-best-practices-guide",
      "published_at": "2020-10-22T21:32:37Z",
      "updated_at": "2020-10-22T20:23:00Z",
      "breadcrumb": "Contents / Solutions and best practices / Best practices guides / Full-stack observability",
      "document_type": "page",
      "popularity": 1,
      "info": "Here are some best practices designed to help you become a New Relic APM master and a key asset to your team.",
      "body": "Application Monitoring Tips You Need To Know It's one thing to know how to use APM, but it's another thing to know how to use New Relic's application performance monitoring software well. Here are some best practices designed to help you become an APM master‚Äîand a key asset to your team! To get a high-level overview of all your applications and services, use the entity explorer in New Relic One. 1. Standardize application names Most New Relic agents provide a default application name, such as \"My Application\" or \"PHP Application,\" if you don't specify one in your New Relic configuration file. You don't want to end up with 20 identically named applications, be sure to select a descriptive identifier for your apps as soon you deploy them. To keep things consistent and easy to navigate, New Relic recommends standardizing your application naming (for example, all apps in Staging append [Staging] or the like at the end of their names). Ideally, you want your new Java applications to be named automatically to reduce the chances of typographical errors and misnaming. How to do it For Java applications, automatic application naming can come from the following sources: Request attribute Servlet init parameter Filter init parameter Web app context parameter Web app context name (display name) Web app context path Choose the method that fits best your needs and follow these steps. For non-Java applications, there are no automatic naming methods, so refer to the documentation for your APM agent. 2. Add tags to your applications When several different applications use the same account, and each application spans multiple environments (for example, development, test, pre-production, production), it can be hard to find a specific application in your overview dashboard. That's why we recommend adding tags to your apps so that you can segment them into logical groups. The two most common tags that mature APM customers use are application name and environment. So, for example, if you wanted to view the billing application in Test, you could simply filter by \"billing app\" (name label) and \"test\" (environment label). APM is designed so that apps can roll up into an unlimited number of meaningful categories. How to do it Read the overview: Use tags to organize and group what you monitor. Follow these instructions for creating tags: NerdGraph tagging API tutorial. 3. Create and evaluate alert policies When key performance indicators spike or drop, individuals and teams in your organization need to be notified. Alerting in New Relic provides a set of tools including dynamic baselines that allow you to detect problems before they impact your end users. Alert policies can be set up in two primary ways: Static threshold alerts are great when you already know the nature of an application and its normal behaviors aren't likely to change anytime soon. Apdex score, response time, error rate, throughput are some of the static thresholds you can create alert policies on. Dynamic baseline alerts make it easy to determine and set dynamic alert thresholds for applications with varying seasonal patterns and growth trends (which make it difficult to set thresholds that define normal behavior). These alerts use baselines modeled from your application‚Äôs historical metric data. Each alert policy can contain as many conditions as you need, and each alert condition includes three components: Type of condition (metric, external service, and so on) Entities that the policy targets (for example, apps monitored by New Relic APM or New Relic Browser, hosts monitored by New Relic Infrastructure, and so on) Thresholds that escalate into alerting situations with increasing severity Once you have your alerting set up, you then want to make sure you're taking advantage of all viable notification channels. After all, what good are alerts if no one knows about them? You can manage alerts by creating specific user groups and by leveraging New Relic's integrated alert channels, including Slack, PagerDuty, webhooks, and email. Be sure to evaluate alert policies on a regular basis to ensure that they are always valid. How to do it See the detailed documentation: To set up dynamic baseline alerts and choose an application, follow standard procedures. You will see a preview of the metric with the predicted baseline You can select a metric for that application and see the corresponding baseline. Then, using the threshold sliders, you can set how closely you want your threshold to follow the baseline prediction. To set up static threshold alerts for your Apdex settings, follow standard procedures. To set up your alert notification channels, follow standard procedures. 4. Identify and set up key transactions Depending on the nature of your application, some transactions may be more important to you than others. New Relic's key transactions feature is designed to help you closely monitor what you consider to be your app's most business-critical transactions, whether that's end-user or app response time, call counts, error rates, or something else. You can also set alert threshold levels for notifications when your key transactions are performing poorly. How to do it In the menu bar, select More > Key transactions, and then select Add more. Then select the app and web transaction or, from the selected transaction, select Track as key transaction. Type a name for the key transaction, and select Track key transaction. Optional: If the agent for the selected app supports custom alerting, use the default values that New Relic automatically fills, or select Edit key alert transaction policy to set the Apdex and alert threshold values. To view the key transactions dashboard details, select View new key transaction. 5. Track deployment history When development teams are pushing new code out as frequently as possible, it can be hard to measure the impact that each deployment is having on performance. One way to stay in tune with how these changes are affecting your application is with deployment reports. These reports list recent deployments and their impact on end-users and app servers' Apdex scores, along with response times, throughput, and errors. You can also view and drill down into the details to catch errors related to recent deployments, or file a ticket and share details with your team. How to do it From the New Relic menu bar, select APM > (selected app) > Events > Deployments. To view performance after a deployment, go to the selected app's Overview dashboard in the Recent events section. A blue vertical bar on a chart indicates a deployment. To view summary information about the deployment, point to the blue bar. 6. Review APM reports From SLA, deployment, and capacity to scalability, host usage reports, and more, New Relic APM offers a variety of downloadable reporting tools surfacing historical trends‚Äîall great ways to report to senior executive teams or customers. Take a look at the full list of reports and use them to your advantage. How to do it From the New Relic APM menu bar, select Applications > (selected app) > Reports. Select the report you'd like to see. If you want to save or export a report to share, select Download this report as .csv, which will create a report with comma-separated values. 7. Review your environment with service maps Use New Relic service maps, a feature included in APM, to understand how apps and services in your architecture connect and talk to each other. Service maps are visual, customizable representations of your application architecture. Maps automatically show you your app's connections and dependencies, including databases and external services. Health indicators and performance metrics show you the current operational status for every part of your architecture. How to do it Go to one.newrelic.com > More > service maps. To get started, read the instructions in Introduction to service maps. 8. Keep current With New Relic‚Äôs SaaS platform, getting new features is as easy as updating your agent. Most likely your organization already has a set of scripts for deploying application upgrades into your environment. In a similar fashion, you can also automate your New Relic agent deployment to ensure that your systems are up to date. Both Puppet and Chef scripts are great examples of deployment frameworks that make life easier by allowing you to automate your entire deployment and management process. How to do it Regularly review which version of the agent you're using so that you know when an update is needed. If the latest agent release contains a needed fix or added functionality, download it. To deploy the agent automatically (preferred as a method to avoid errors): Use existing deployment scripts, provided they can be adapted to handle the deployment. OR Create and maintain a script that specifically deploys and configures the New Relic agent. Ideally, the script would pull the agent files from a repository where the files are versioned (for rollback purposes). Once the script has been created, shut down the application (unless script handles this). Run the deployment script. Start the application (unless script handles this). If problems arise, run the script to roll back to the previous version. To deploy the agent manually: Back up the current agent directory. Deploy the updated agent into the existing agent directory. Modify configuration files by comparing new files with existing files. In particular, make sure things like license key and custom extensions are copied over to the new configuration. Restart the application. If problems arise, restore the old agent using the backup and restart. 9. Manage user access This is available only for accounts on our original product-based pricing plan. Enable role-based access control (RBAC) and single sign-on (SSO) New Relic allows authorized individuals to access the broadest possible amount of data, regardless of their assigned role. As an Owner or Administrator of your New Relic account, you can control the permissions of individual users or entire roles with RBAC. To find out what is possible and how to make changes, see Users and roles. Security is no doubt of utmost concern to your organization. To simplify password management for your employees and strengthen security, you may already be using SSO with your other systems. You should do the same with New Relic. Using New Relic's SSO integration feature, account administrators will be able to enforce strong passwords and restrict login via a corporate authentication mechanism. This way, New Relic users who have already authenticated using a corporate SSO system will be able to bypass the New Relic login prompt. How to do it Log in to New Relic as an admin and go to the SSO configuration page. From the New Relic title bar, select (your account name) > Account Settings > Integrations > Single Sign On. From the SAML Single Sign On page, review your New Relic SAML Service Provider details. To upload your SAML Identity Provider certificate, select Choose File, and then follow standard procedures to select and save the file. Copy and paste in (or type) the Remove login URL that your users will use for Single Sign-On. If your organization‚Äôs SAML integration provides a redirect URL for logout, copy and paste in (or type) the Logout landing URL; otherwise leave blank. Save, test, and enable. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.57358,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "2. Add <em>tags</em> to <em>your</em> applications",
        "info": "Here are some best practices designed to help you become a New Relic APM master and a key asset to <em>your</em> team.",
        "category_2": "Full-<em>stack</em> observability",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;new-relic-solutions&#x2F;best-practices-guides&#x2F;full-<em>stack</em>-observability&#x2F;apm-best-practices-guide",
        "body": " application upgrades into <em>your</em> environment. In a similar fashion, you can also <em>automate</em> <em>your</em> New Relic agent deployment to ensure that <em>your</em> systems are up to date. Both Puppet and Chef scripts are great examples of deployment frameworks that make life easier by allowing you to <em>automate</em> <em>your</em> <em>entire</em>",
        "breadcrumb": "Contents &#x2F; Solutions and best practices &#x2F; Best practices guides &#x2F; Full-<em>stack</em> observability"
      },
      "id": "5f91fa75e7b9d20b7d3c9f80"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0 EMEA",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-10-24T01:40:08Z",
      "title": "New Relic Developers",
      "updated_at": "2020-10-24T01:38:33Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 EMEA Nerd Days is a FREE engineering conference that kicks off November 10 (EMEA). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 17 Days : 8 Hours : 31 Minutes : 16 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application ¬† Add custom attributes Use custom attributes for deeper analysis Show 21 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.79786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Automate</em> common tasks",
        "body": ", agents, OS emitters - get any data 20 min <em>Automate</em> common tasks Use the New Relic CLI to <em>tag</em> apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to <em>your</em> app Add a time picker to a sample application ¬† Add custom"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "https://newrelic.com/dam/new-relic/opengraph/newrelic_og_image.png",
      "url": "https://newrelic.com/resources/articles/aws-monitoring-tips",
      "sections": [
        "Here are five best practices that can help you boost end-user experiences, simplify performance management, and optimize your AWS environment to suit your applications.",
        "Links",
        "1. Right-size your AWS instances",
        "2. Monitor all the (AWS) things",
        "3. Set up auto-scaling alerts and dashboards",
        "4. Automate your setup",
        "5. Keep an eye on the entire stack",
        "Performance monitoring for AWS",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-10-22T03:46:28Z",
      "title": "Tips and Tricks for Monitoring AWS with New Relic",
      "updated_at": "2020-10-08T14:54:44Z",
      "type": "storefront",
      "external_id": "acb339bf22ae7152efd7d58a16b9edc2e274cdc5",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Article Tips and Tricks for Monitoring AWS with New Relic Here are five best practices that can help you boost end-user experiences, simplify performance management, and optimize your AWS environment to suit your applications. Links Download PDF Whether you‚Äôre a seasoned New Relic user or are just starting to understand how the New Relic platform works, there‚Äôs always a new tip or trick you can use to improve the performance of your cloud-hosted applications. Here are five best practices that can help you boost end-user experiences, simplify performance management, and optimize your AWS environment to suit your applications: 1. Right-size your AWS instances The transient nature of EC2 instances can make it difficult to get an accurate view of your AWS ecosystem. Your company may have many different individuals or groups who are spinning up EC2 instances for various purposes. Because of this, a complete view of the current state of your AWS environment is essential. A decommissioned host is not a ‚Äúdead‚Äù server; rather, it has merely served its purpose. Using New Relic Infrastructure, you instantly get an accurate snapshot of your EC2 instances, which allows you to then dissect them by the AWS tags you already use. Ultimately, this 360-degree view of your infrastructure allows you to optimize (or right-size) your AWS instances for maximum ROI. 2. Monitor all the (AWS) things While EC2 powers most AWS workloads, it‚Äôs by no means the only AWS service used to power modern applications. To fully understand how your AWS ecosystem is performing, you need to monitor the other services you use. New Relic Infrastructure Professional allows you to monitor the performance health of many popular AWS services, such as CloudFront, DynamoDB, EBS, ElastiCache, Elastic Load Balancing (ELB), IAM, Kinesis, RDS, SNS, SQS, and VPC, to name just a few of the services New Relic can monitor. To use these services effectively, you need context. For example, AWS ELB automatically distributes incoming application traffic across multiple Amazon EC2 instances, which you don‚Äôt always have visibility into. But by tracking ELB requests per second as well as write and read volume in New Relic Insights, you can understand exactly how that load is being balanced to make sure you‚Äôre using the service as effectively as possible. 3. Set up auto-scaling alerts and dashboards Ops teams depend on critical alerts and custom dashboards to tell the whole story about infrastructure performance. That‚Äôs why New Relic makes it easy for you to set thresholds for alerts on various metrics relating to your applications, servers, and key transactions. As EC2 instances come and go, your alerts and dashboards need to auto-scale with them. You can manage alerts by creating specified user groups and by leveraging New Relic‚Äôs integrated alert channels, including OpsGenie, PagerDuty, Slack, VictorOps, and Campfire. If you‚Äôre using a different alerting solution, use our Webhook feature to send a JSON Object anywhere you choose. New Relic also gives you the option to create customized dashboards for a curated view of what you care about most when running your applications in an AWS ecosystem. 4. Automate your setup When you‚Äôre operating in a dynamic AWS environment, your underlying infrastructure is constantly shifting. While AWS CloudFormation takes care of provisioning the resources, it raises the obvious question of how your application software is deployed, configured, and executed on your Amazon EC2 instances. That‚Äôs why you should consider using an automation solution like Chef or Puppet, which can automatically configure your systems and apps that sit on top of your infrastructure. Both tools make life easier by allowing you to automate your entire deployment and management process. When these config management tools are combined with New Relic Infrastructure, you get an instant view of your EC2 metrics, as well as the change events associated with their configuration. 5. Keep an eye on the entire stack The great thing about using New Relic to monitor your AWS applications is that it doesn‚Äôt just give you visibility into a certain portion of your application stack, but lets you see the entire thing‚Äîeven if you‚Äôre running in a hybrid cloud, on-premise, or both. If you spot a performance problem in New Relic APM, for example, you can easily correlate to issues with your infrastructure using New Relic Infrastructure. You can test your application from outside the firewall using New Relic Synthetics, see what‚Äôs going on at the interaction level using New Relic Browser, and also organize, query, and visualize all this data using New Relic Insights to answer key questions about application and customer experience‚Äîall in real time. Performance monitoring for AWS Build, migrate, and deploy your applications and infrastructure faster with AWS monitoring from New Relic. Get Started COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.99254,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "4. <em>Automate</em> <em>your</em> setup",
        "body": " an automation solution like Chef or Puppet, which can automatically configure <em>your</em> systems and apps that sit on top of <em>your</em> infrastructure. Both tools make life easier by allowing you to <em>automate</em> <em>your</em> <em>entire</em> deployment and management process. When these config management tools are combined with New Relic"
      },
      "id": "5ece930ee7b9d2bb5cc7071a"
    },
    {
      "category_2": "Examples",
      "nodeid": 34236,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "NerdGraph tagging API tutorial",
        "Read tags for an entity",
        "Add tags for an entity",
        "Remove a tag from an entity",
        "Delete specific tag values for an entity",
        "Replace all tag values for an entity",
        "For more help"
      ],
      "title": "NerdGraph tagging API tutorial",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "c4b8fbf4f75b862f2b6e3caad723935febb89815",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-tagging-api-tutorial",
      "published_at": "2020-10-22T06:07:06Z",
      "updated_at": "2020-07-26T05:41:24Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic's NerdGraph (our GraphQL API) to manage tags attached to your entities.  ",
      "body": "New Relic One provides unified access to all the entities you monitor with New Relic. Tags are used to organize and group all your entities in a way that's useful for troubleshooting and understanding your environment. To add, delete, or modify your tags, use the NerdGraph GraphiQL explorer. NerdGraph allows you to tag your entities with a key and an associated list of values. You can also use NerdGraph to query entities. Read tags for an entity To construct these queries and see responses: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to find the entity and then fetch its tags. Use NerdGraph's tag API to read the existing tags and their values. In this example, our entity is a browser app called Cookie Checkout: { actor { entitySearch (query: \"name like 'Cookie Checkout'\") { results { entities { tags { key values } } } } } } The actual values vary depending on your data. Use the New Relic GraphiQL explorer to experiment with queries. Add tags for an entity To add new tags for an entity: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity you want to tag. Use the taggingAddTagsToEntity mutation to add a tag with a value to the entity. In this example, we have a browser application called Cookie Checkout owned by a UI team. We want to add a team tag with a ui value to this instance. Once the tag is added, we can filter by the tag team:ui and find the Cookie Checkout app in the New Relic One UI. mutation { taggingAddTagsToEntity ( guid: \"ENTITY_GUID\", tags: { key: \"team\", values: [\"ui\"]}) { errors { message } } } Remove a tag from an entity To delete a tag and all of its associated values from an entity: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagFromEntity mutation. The following example mutation removes the team tag from an entity: mutation { taggingDeleteTagFromEntity ( guid: \"ENTITY_GUID\", tagKeys: [\"team\"]) { errors { message } } } Delete specific tag values for an entity Instead of deleting an entire tag and all of its values, you can delete a single tag value. Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagValuesFromEntity mutation. The following example mutation deletes the ui value from the tag key: mutation { taggingDeleteTagValuesFromEntity ( guid: \"ENTITY_GUID\", tagValues : [{key: \"team\" value: \"ui\"}]) { errors { message } } } Because tagValues is an array, you can delete multiple specific values from a single entity in one mutation. Replace all tag values for an entity To replace all the existing values for a tag with new ones: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingReplaceTagsOnEntity mutation. In this example, the Cookie Checkout browser application was transferred from the ui team to the cookie-dev team. You can replace the tag values for team with the following mutation: mutation { taggingReplaceTagsOnEntity ( guid: \"ENTITY_GUID\", tags: {key: \"team\" values: [\"cookie-dev\"]}) { errors { message } } } For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.8029,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NerdGraph <em>tagging</em> API tutorial",
        "sections": "NerdGraph <em>tagging</em> API tutorial",
        "info": "Use New Relic&#x27;s NerdGraph (our GraphQL API) to manage <em>tags</em> attached to <em>your</em> entities.  ",
        "body": ". NerdGraph allows you to <em>tag</em> <em>your</em> entities with a key and an associated list of values. You can also use NerdGraph to query entities. Read tags for an entity To construct these queries and see responses: Go to the NerdGraph GraphiQL explorer at https:&#x2F;&#x2F;api.newrelic.com&#x2F;graphiql. Use entitySearch() to find"
      },
      "id": "5d8024fc28ccbcc5e9499cf1"
    }
  ],
  "/build-apps/set-up-dev-env": [
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Get your application details",
        "Add a simple tag to your application",
        "Bonus step: Create a deployment marker",
        "Next steps"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2020-10-24T01:53:25Z",
      "updated_at": "2020-10-24T01:53:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Get started with the New Relic CLI 20 min Access the New Relic platform from the comfort of your terminal: you can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. Our CLI has been designed for automating common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic personal API Key, which you can create from the Account settings of your New Relic account An instrumented application in your New Relic account Step 1 of 10 Install the New Relic CLI The New Relic CLI can be downloaded via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile Now that you've installed the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. To create your first CLI profile, run the profiles add command. Note that you need to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_API_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Step 3 of 10 Get your application details In this example, you are going to add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 The New Relic CLI can retrieve your application details as a JSON object. To search for your APM application use the apm application search command. If you get an error, check that the account ID and application name you provided are correct. bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Step 5 of 10 If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example. When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. [ { accountId: YOUR_ACCOUNT_ID, applicationId: YOUR_APP_ID, domain: 'APM', entityType: 'APM_APPLICATION_ENTITY', guid: 'A_LONG_GUID', name: 'NAME_OF_YOUR_APP', permalink: 'https://one.newrelic.com/redirect/entity/A_LONG_GUID', reporting: true, type: 'APPLICATION', }, ]; Copy Step 6 of 10 Add a simple tag to your application Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Let's suppose that you want to add an environment tag to your application. Go ahead and add the dev:testing tag‚Å† (or any other key-value pair) to your application using the entities tags create command. bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 What if you want to add multiple tags? Tag sets come to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags at once to your application, modify and run the following snippet. bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 You've created and added some tags to your application, but how do you know they're there? You need to retrieve your application's tags. To retrieve your application's tags, use the entity tags get command. newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Step 9 of 10 Bonus step: Create a deployment marker Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same Application ID from your earlier search. bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Notice that the JSON response includes the revision and timestamp of the deployment. This workflow could be built into a continuous integration or continuous deployment (CI/CD) system to help indicate changes in your application's behavior after deployments. Here is an example. { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands. For example, you could create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 275.80838,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": ". This guide walks you through the essentials of <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage. Before you begin For this guide you just need: Your <em>New</em> <em>Relic</em> personal <em>API</em> <em>Key</em>, which you can create from the <em>Account</em> settings of your <em>New</em> <em>Relic</em> <em>account</em> An instrumented application in your"
      },
      "id": "5efa999c196a67c4e1766461"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-10-24T01:54:36Z",
      "updated_at": "2020-10-24T01:54:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: bash Copy $ my-nerdlet $ ‚îú‚îÄ‚îÄ README.md $ ‚îú‚îÄ‚îÄ launchers $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ nerdlets $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss $ ‚îú‚îÄ‚îÄ node_modules $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler $ ‚îú‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ package-lock.json $ ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 258.669,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> command nr1 create and select Nerdpack to create"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-10-24T01:53:25Z",
      "updated_at": "2020-10-24T01:53:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.64606,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>CLI</em> to add multiple tags to <em>one</em> of your entities. Before you begin For this guide you need your <em>New</em> <em>Relic</em> personal <em>API</em> <em>Key</em>: Create it at the <em>Account</em> settings screen for your <em>account</em>. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> via Homebrew (macOS), Scoop (Windows"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps"
      ],
      "title": "Add tables to your New Relic One application",
      "type": "developer",
      "tags": [
        "table in app",
        "Table component",
        "TableHeaderc omponent",
        "TableHeaderCell component",
        "TableRow component",
        "TableRowCell component"
      ],
      "external_id": "7ff7a8426eb1758a08ec360835d9085fae829936",
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/",
      "published_at": "2020-10-24T01:53:24Z",
      "updated_at": "2020-10-24T01:53:23Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a table to your New Relic One app.",
      "body": "Add tables to your New Relic One application 30 min Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git` $ cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet` Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. bash Copy $ nr1 nerdpack:uuid -gf # Update the app unique ID $ npm install # Install dependencies $ nr1 nerdpack:serve # Serve the demo app locally Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the nerdlets/create-a-table-nerdlet subdirectory and open the index.js file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside of the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.86002,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add tables to your <em>New</em> <em>Relic</em> <em>One</em> application",
        "sections": "Add tables to your <em>New</em> <em>Relic</em> <em>One</em> application",
        "info": "Add a table to your <em>New</em> <em>Relic</em> <em>One</em> app.",
        "body": " build your own tables into your <em>New</em> <em>Relic</em> <em>One</em> application. In this guide, you are going to build a sample table using various <em>New</em> <em>Relic</em> <em>One</em> components. Before you begin If you haven&#x27;t already installed the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>, step through the quick start in <em>New</em> <em>Relic</em> <em>One</em>. This process also gets you"
      },
      "id": "5efa989ee7b9d2ad567bab51"
    },
    {
      "sections": [
        "Explore NerdGraph using the API Explorer",
        "Before you begin",
        "Build a query to retrieve your name",
        "Click the play button to see the result",
        "Add more fields to your query",
        "Experiment with mutations",
        "Tip",
        "Try your NerdGraph query in the terminal",
        "Next steps"
      ],
      "title": "Explore NerdGraph using the API Explorer",
      "type": "developer",
      "tags": [
        "nerdgraph",
        "mutations",
        "nerdgraph query terminal"
      ],
      "external_id": "df1f04edc2336c69769d946edbaf263a5339bc92",
      "image": "https://developer.newrelic.com/static/0ce8c387a290d7fbd6be155322be9bce/bc8d6/create-account.png",
      "url": "https://developer.newrelic.com/collect-data/get-started-nerdgraph-api-explorer/",
      "published_at": "2020-10-24T01:53:26Z",
      "updated_at": "2020-10-24T01:53:26Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Explore NerdGraph, our GraphQL API, and build the queries you need.",
      "body": "Explore NerdGraph using the API Explorer 25 min NerdGraph is New Relic's GraphQL API. It allows you to get all the information you need in a single request. With NerdGraph API Explorer you don't need to know the query format: using the Query Builder you can browse our entire graph and compose queries just by selecting the items you want and filling out their required values. Before you begin Go to api.newrelic.com/graphiql and log in using your New Relic user ID and password: the NerdGraph API Explorer loads up. Make sure you have a valid New Relic API key. You can create one directly from the NerdGraph API Explorer. Step 1 of 5 Build a query to retrieve your name Time for your first NerdGraph query. Search for your name in the New Relic database: Erase everything in the query editor. Select the following fields in the query explorer in this order: actor, user, name. This GraphQL snippet appears in the editor. { actor { user { name } } } Copy Step 2 of 5 Click the play button to see the result With this query, you're telling NerdGraph to retrieve your name. You're asking for the name field, which is nested within the user field. This refers to the user who owns the API key, which in turn is nested within actor. Click the play button to see the result: It has almost the same shape as the request. All the fields in the Query Builder make up what's called the GraphQL schema, which describes all the available data types and their attributes. To learn more about each field, click the Docs button, or hover over a field in the editor. Step 3 of 5 Add more fields to your query Now you can try adding more fields to your query. The simplest way is clicking the fields in the Query Builder: The API Explorer knows where the attributes should go in the query. In the example, you add the account id and email fields. Once again, running the GraphQL query results in just the data you need, without over or under-fetching data. Notice that the id field has an argument: passing arguments is a powerful way of customizing your NerdGraph queries. Every field and object can contain arguments, so instead of running multiple queries, you just compose the one that you need. { actor { user { name email } account(id: 12345678) } } Copy Step 4 of 5 Experiment with mutations In GraphQL, mutations are a way to execute queries with side effects that can alter the data by creating, updating, or deleting objects (Commonly referred to as CRUD operations in REST APIs). Ready for your first mutation? Erase what's in the editor. Scroll down the Query Builder and expand mutation. Select the fields in the following screenshot: In this case, you're trying to add a custom tag to an entity. Notice that the editor complains if you don't select errors: mutations must have a way of telling you how the operation performed in the backend (failed requests result in null responses). Tip Unlike REST, GraphQL APIs like NerdGraph can return partial responses. For example, if you try adding tags to multiple entities, some mutations can fail and others succeed; all is logged in the GraphQL response you get. Step 5 of 5 Try your NerdGraph query in the terminal Let's say that you've built a NerdGraph query you're happy with and you want to test it elsewhere. To capture code-ready queries and mutations: Select the Tools menu. Copy the query as a curl call or as a New Relic CLI command. bash Copy $ # curl version $ curl https://api.newrelic.com/graphql \\ > -H 'Content-Type: application/json' \\ > -H 'API-Key: API_KEY_REDACTED' \\ > --data-binary '{\"query\":\"{\\n actor {\\n user {\\n name\\n email\\n }\\n account(id: 12345678)\\n }\\n}\\n\", \"variables\":\"\"}' $ $ # New Relic CLI version $ newrelic nerdgraph query '{ $ actor { $ user { $ name $ email $ } $ account(id: 12345678) $ } $ } $ ' Next steps Now you know the basics of composing and testing NerdGraph queries, but how do you turn them into client or server code? Solutions such as GraphQL Code Generator can help you turn the NerdGraph queries into code for your implementation. Try creating more complex queries by clicking fields and expanding objects in the Query Builder (be careful with mutations though, since they could write data to your account). For more information on NerdGraph and explore other projects from the developer community, check out the threads on the Explorer‚Äôs Hub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.85675,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Explore NerdGraph using the <em>API</em> Explorer",
        "sections": "Explore NerdGraph using the <em>API</em> Explorer",
        "info": "Explore NerdGraph, our GraphQL <em>API</em>, and build the queries you need.",
        "body": " queries just by selecting the items you want and filling out their required values. Before you begin Go to <em>api</em>.newrelic.com&#x2F;graphiql and log in using your <em>New</em> <em>Relic</em> user ID and password: the NerdGraph <em>API</em> Explorer loads up. Make sure you have a valid <em>New</em> <em>Relic</em> <em>API</em> <em>key</em>. You can create <em>one</em> directly from"
      },
      "id": "5efa9973196a6791f4766402"
    }
  ],
  "/explore-docs/query-and-store-data": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-10-24T02:00:01Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 268.6034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "nerdstorage <em>components</em>",
        "body": " and UserStorage<em>Mutation</em> Account access: AccountStorage<em>Query</em> and AccountStorage<em>Mutation</em> Entity access: EntityStorage<em>Query</em> and EntityStorage<em>Mutation</em> Each of these <em>components</em> can operate declaratively (for example, as part of your React rendering <em>methods</em>) or imperatively (by using the <em>static</em> <em>methods</em> for <em>query</em>"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "category_2": "Java agent release notes",
      "nodeid": 11976,
      "sections": [
        "APM agent release notes",
        "Go agent release notes",
        "Java agent release notes",
        ".NET agent release notes",
        "Node.js agent release notes",
        "PHP agent release notes",
        "Python agent release notes",
        "Ruby agent release notes",
        "C SDK release notes",
        "Java Agent 3.36.0",
        "Improvements",
        "Fixes"
      ],
      "title": "Java Agent 3.36.0",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "APM agent release notes",
      "external_id": "f94f5c53e522a9835ea42514e90d9a39e81fd050",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/java-release-notes/java-agent-3360",
      "published_at": "2020-10-22T18:27:23Z",
      "updated_at": "2018-04-14T23:39:35Z",
      "breadcrumb": "Contents / Release notes / APM agent release notes / Java agent release notes",
      "document_type": "release_notes",
      "popularity": -2,
      "body": "[RSS] Released on:¬† Wednesday, February 15, 2017 - 09:55 Download Improvements APIs This release adds a number of APIs that will allow you to instrument and get expanded visibility into frameworks, libraries, and any custom code that New Relic does not automatically instrument. In addition to instrumenting your web frameworks, you can also instrument calls to and from messaging systems, database calls, and external calls! By passing context about your code to the APIs, you will get the same reporting, including cross application tracing, that you get with New Relic‚Äôs built-in instrumentation. Solr This release adds support for Solr versions 5 and 6 (up to and including version 6.3.0). Fixes Fixes a bug that prevents an application from starting up when a JAX-RS annotated method contains more than 8 parameters. Fixes an issue that affected Spring and JAX-RS applications compiled with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using static methods. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page for customers injecting the X-Queue-Start or X-Request-Start HTTP headers. This fix brings the Java Agent into compliance with the behavior of other New Relic Agents. Fixes an issue in which custom Hystrix Commands that are subclassed multiple times in Groovy cause an application to throw an exception on startup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 45.19683,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using <em>static</em> <em>methods</em>. The agent now reports WildFly dispatcher name and version. Fixes a bug"
      },
      "id": "58a53cf38e9c0f755a81db4e"
    },
    {
      "category_2": "API guides",
      "nodeid": 11521,
      "sections": [
        "Java agent",
        "Getting started",
        "Installation",
        "Additional installation",
        "Heroku",
        "Configuration",
        "Attributes",
        "Features",
        "Instrumentation",
        "Custom instrumentation",
        "API guides",
        "Async instrumentation",
        "Troubleshooting",
        "Guide to using the Java agent API",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Implement distributed tracing",
        "Implement cross application tracing",
        "Obtain references to New Relic entities",
        "Additional API functionality",
        "Additional API usage examples",
        "For more help"
      ],
      "title": "Guide to using the Java agent API ",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Java agent",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/agents/java-agent/api-guides/guide-using-java-agent-api",
      "external_id": "a31c751c7c29dd46effac2e568f7c0a92b033b18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api",
      "published_at": "2020-10-22T17:33:12Z",
      "updated_at": "2020-09-03T11:06:02Z",
      "breadcrumb": "Contents / APM agents / Java agent / API guides",
      "document_type": "page",
      "popularity": 1,
      "info": "A goal-focused guide to New Relic's Java agent API, with links to relevant sections of the complete API documentation on GitHub.",
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 3.36.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Implement distributed tracing These APIs require distributed tracing to be enabled. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() For more on obtaining references to the current transaction and other entities, see Obtain references. Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) For more on obtaining references to the current transaction and other entities, see Obtain references. Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Implement cross application tracing To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Also refer to the information in this document about using Transaction to obtain references to New Relic entities. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic entities. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic entities. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic entities. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic entities. Obtain references to New Relic entities Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events to Insights. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the first call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic entities. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 28.38638,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: <em>Static</em> <em>methods</em> on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "5a3137f4e621f4576cf1e35f"
    },
    {
      "category_2": "PHP agent API",
      "nodeid": 11821,
      "sections": [
        "PHP agent",
        "Getting started",
        "Installation",
        "Advanced installation",
        "Configuration",
        "API guides",
        "PHP agent API",
        "Attributes",
        "Features",
        "Frameworks and libraries",
        "Troubleshooting",
        "newrelic_add_custom_tracer",
        "Requirements",
        "Description",
        "Parameters",
        "Return value(s)",
        "Example(s)",
        "Instrument a function",
        "Instrument a method within a class",
        "Instrument a method within a namespaced class",
        "For more help"
      ],
      "title": "newrelic_add_custom_tracer (PHP agent API)",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "PHP agent",
      "external_id": "12242c1e6fe8cb70e2d42ff670cad04c01e9317e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_add_custom_tracer",
      "published_at": "2020-10-22T17:33:12Z",
      "updated_at": "2019-09-30T22:55:59Z",
      "breadcrumb": "Contents ¬ª APM agents / PHP agent / PHP agent API",
      "document_type": "api_doc",
      "popularity": 1,
      "info": "New Relic PHP agent API call to add custom instrumentation to particular methods in your app code. ",
      "body": "newrelic_add_custom_tracer(string $function_name) Specify functions or methods for the agent to instrument with custom instrumentation. Requirements Compatible with all agent versions. Description Specify functions or methods for the agent to target for custom instrumentation. This is the API equivalent of the newrelic.transaction_tracer.custom setting. You cannot apply custom tracing to internal PHP functions. Parameters Parameter Description $function_name string Required. The name can be formatted either as function_name for procedural functions, or as \"ClassName::method\" for methods. Both static and instance methods will be instrumented if the method syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return value(s) Returns true if the tracer was added successfully. Example(s) Instrument a function function example_function() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"example_function\"); } } Instrument a method within a class class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"ExampleClass::example_method\"); } } } Instrument a method within a namespaced class namespace Foo\\Bar; class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"Foo\\\\Bar\\\\ExampleClass::example_method\"); } } } Alternatively, on PHP 5.5 or later, the ::class syntax can be used instead: namespace Foo\\Bar { class ExampleClass { function example_method() { // ... } } } namespace { use Foo\\Bar; if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(Bar::class . \"::example_method\"); } } }",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 25.322763,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Instrument a <em>method</em> within a class",
        "info": "New Relic PHP agent API call to add custom instrumentation to particular <em>methods</em> in your app code. ",
        "body": " <em>static</em> and instance <em>methods</em> will be instrumented if the <em>method</em> syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return value(s) Returns true if the tracer was added successfully. Example(s) Instrument"
      },
      "id": "58ca4191e621f45edd466e7a"
    },
    {
      "nodeid": 9691,
      "sections": [
        "Introduction to New Relic Mobile (Unity)",
        "Contents",
        "Monitor mobile app performance",
        "Install and configure",
        "Use Unity SDK API",
        "Send custom events and attributes to Insights",
        "Track custom network requests",
        "Uninstall plugin",
        "Unity release notes",
        "For more help"
      ],
      "title": "Introduction to New Relic Mobile (Unity)",
      "type": "docs",
      "external_id": "9e03a54ec6df360532302d4dfe7484070f8ba80c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/introduction-new-relic-mobile-unity",
      "published_at": "2020-10-22T15:47:45Z",
      "updated_at": "2020-07-25T00:44:01Z",
      "breadcrumb": "Contents",
      "document_type": "page",
      "popularity": 1,
      "body": "Legacy feature This document is for historical reference. Unity is no longer supported for new customers. Contents Monitor mobile app performance The New Relic Unity plugin allows Unity developers to embed a New Relic Mobile agent (iOS or Android) in a Unity app build for mobile devices to monitor your app's performance. The plugin is written in C#, but it includes the native iOS and Android agents that embed the appropriate files for your build. Features New Relic Mobile Features Comprehensive performance data View your mobile app's performance Overview page for summary information about active sessions, or drill down to detailed information, including (note limitations below): Interaction times and trace details Crash reporting Devices Operating systems Detailed network views Available by using the API to track custom network requests For iOS apps, receive automatic instrumentation for networking for any parts of the app that are native and non-Unity (using standard Apple networking components such as NSURLConnection) Examine HTTP errors and network failures (such as DNS lookups, timeouts, SSL errors, etc.) and server error traces. Usage details at a glance Compare performance between versions of your app with detailed information for memory, CPU (iOS only), interaction speed, network requests per minute, and network failures. View a monthly report with a bar chart tracking the number of devices running your app for each month over the last year. Mobile SDK API options Use the Unity API to: Create and complete interactions Record custom metrics Send custom events to Insights Track custom network requests Known limitations The New Relic Unity plugin does not automatically instrument interactions. You must use the Unity API to track specific interactions. The New Relic Unity plugin does not automatically instrument network requests. You must use the Unity API to track network calls. Android builds: Unity still generates an Eclipse project, but Android Studio can import the Eclipse project. Install and configure The Unity plugin includes iOS and Android agent files that will embed the appropriate files for your build. To instrument interactions and network requests, you must use the Unity API to manually instrument your code. Install the Unity plugin As part of the installation process, New Relic Mobile automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile project you monitor in New Relic Mobile. For Admins with existing New Relic accounts, follow these steps to install and configure your Unity application. (If you do not have a New Relic account, see New Relic Mobile.) Go to rpm.newrelic.com/mobile. From the mobile apps index, select Add a new app. From the Get started page, select Unity as the platform for mobile monitoring. Type a name for your mobile project, then select Continue. Continue with the procedures to configure the Unity plugin. Configure the Unity plugin These procedures to configure your app also appear on the Get started page in the New Relic UI. Install NewRelic-Unity-Plugin.unitypackage into your project by going to Assets > Import package > Custom package... and selecting NewRelic-Unity-Plugin.unitypackage. Create a new GameObject in your project's initial scene by going to GameObject > Create empty and naming it NewRelicAgent. Add NewRelicAgent.cs script (located in Assets/Plugins) to the NewRelicAgent GameObject: Drag it on top of NewRelicAgent in the Hierarchy tab. OR Click Add Component button, then select New Relic Agent from the Scripts option. In the Inspector tab, set the iOS or Android application token from your New Relic Mobile apps. (Recommendation: Keep New Relic Mobile apps on separate platforms.) Build for your platform (iOS or Android), then open the resulting project (Xcode or Eclipse). For Eclipse, import the generated project into Android Studio. Android only: Ensure that your app requests the INTERNET permission through the Player Settings inspector window. In Other Settings, Configuration, ensure the Internet access dropdown is set to Required. This will result in the following permission added to the app's manifest: <uses-permission android:name=\"android.permission.INTERNET\" /> Run your app in an emulator or device to generate data. Check New Relic Mobile to ensure the data is reporting to your account. Configure crash reporting The New Relic Unity plugin cannot automatically upload dSYMs for iOS crash reporting. You must manually upload dSYMs once your iOS unity app is built for release. If the application is bitcode enabled, follow the procedures for bitcode enabled apps once the your iOS app is submitted to Apple. If you are building an Android app with ProGuard enabled, you must follow similar steps. The ProGuard mapping must be uploaded to New Relic so crash reports can be de-obfuscated. For more information, see Android agent crash reporting. Optional: Change the logging level Six logging levels are available for mobile apps monitoring: NONE ERROR WARNING INFO VERBOSE DEBUG Recommendation: Set the logging level from the Unity Inspector tab. Use Unity SDK API Use the New Relic Unity SDK API to further configure and extend the plugin's instrumentation. Create and complete interactions To start an interaction: string interactionIdentifier = NewRelicAgent.StartInteractionWithName(\"new interaction\"); To stop the current interaction: NewRelicAgent.StopCurrentInteraction(interactionIdentifier); Interactions work in conjuction with method tracing. To trace a method insert startTracingMethod, insert at the start of the method to trace, and insert endTracingMethodWithTimer at each exit point of the method. To start tracing a method: Timer methodTimer = new Timer(); NewRelicAgent.StartTracingMethod(\"MethodName\",\"ClassName\",methodTimer,NewRelicAgent.NRTraceType.None); To end tracing a method, use the same timer as the startTracingMethod:> NewRelicAgent.EndTracingMethodWithTimer(methodTimer); Set a custom build identifier Custom build identifiers are set as the Application Build property in the inspector pane for the NewRelicAgent game object, under the New Relic Agent (Script) settings. Execute a demo crash If you have trouble getting your project to crash, use the New Relic Unity plugin API to execute a demo crash. Recommendation: Add this line of code to a button click event handler as applicable: NewRelicAgent.CrashNow(\"message\")> Record custom metrics With the custom metric API, you can record arbitrary numerical data and named events. Custom metrics can help to track high level events specific to your application. You can use several API calls to record custom metrics that provide different levels of detail. To create a custom metric, use this method: NewRelicAgent.RecordMetricWithName(String name, String category) The name parameter is the textual name of the metric that will appear in the user interface for New Relic Mobile. Using clear, concise metric names will help you get the most out of the metrics. The guidelines for naming a custom metric include: Use case and white space characters appropriate for display in the user interface. Metric names are rendered as-is. Capitalize the metric name. Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. If you want to specify more details about a custom metric, three other API methods are available: NewRelicAgent.RecordMetricWithName(String name, String category, double value) NewRelicAgent.RecordMetricWithName(string name, string category, double value, string valueUnits) NewRelicAgent.RecordMetricWithName(string name, string category, double value, string valueUnits, string countUnits) With these methods, you can record additional details: Parameter Description count The number of times the event has happened totalValue The total value of the recording exclusiveValue The exclusive value of the recording; for example, if the total value contains measurements accounted for elsewhere countUnit Unit of measurement for the metric count, including PERCENT, BYTES, SECONDS, BYTES_PER_SECOND, or OPERATIONS valueUnit Unit of measurement for the metric value, including PERCENT, BYTES, SECONDS, BYTES_PER_SECOND, or OPERATIONS To view the custom metrics you collect, follow standard procedures to create custom dashboards. Send custom events and attributes to Insights The SDK can store up to 64 user-defined attributes at a time. If you attempt to store more than 64 attributes, the SDK returns false. Use the following static methods in the NewRelicAgent namespace to send custom attributes and events to New Relic Insights. Methods that return boolean results return true if they succeed, or false if the operation did not complete. The following methods are available for custom attributes and events: RecordEvent (name, attributes) NewRelicAgent.RecordEvent (string name, string dictionary attributes) Records a custom Insights event. Includes a list of attributes specified as a map. SetAttribute (name, value) NewRelicAgent.SetAttribute (string name, string value) NewRelicAgent.SetAttribute (string name, double value) Creates an attribute with the specified text name and text/float value. SetAttribute overwrites its previous value and type each time it is called. Examples boolean attributeSet = NewRelicAgent.SetAttribute(\"username\", \"SampleUserName\"); boolean attributeSet = NewRelicAgent.SetAttribute(\"rate\", 9999.99); IncrementAttribute (name [, value]) public static boolean IncrementAttribute(String name); public static boolean incrementAttribute(String name, double value) If value is not specified, this method increments the count for the specified attribute by 1. If the attribute does not exist, it creates the attribute with a value of 1. If value is specified, the method will increment the attribute by the specified amount. Examples boolean incremented = NewRelicAgent.IncrementAttribute(\"rate\"); boolean incremented = NewRelicAgent.IncrementAttribute(\"rate\", 9999.99, false); RemoveAttribute (name) NewRelicAgent.RemoveAttribute(String name) Removes the specified attribute. Example boolean attributeRemoved = NewRelicAgent.RemoveAttribute(\"rate\"); removeAllAttributes NewRelicAgent.removeAllAttributes() Removes all attributes from the session. Example boolean attributesRemoved = NewRelicAgent.RemoveAllAttributes(); Track custom network requests New Relic Mobile's API provides several methods to track network requests and network failures. For example, use the noticeHttpTransaction family of methods to record HTTP transactions with several available levels of detail. If a network request fails, you can record details about the failure with noticeNetworkFailure. NoticeNetworkRequest NewRelicAgent.NoticeNetworkRequest (\"http://newrelic.com\", \"GET\", timer, null, 200, 1024, 8192, bytes, httpParameters); Parameter Description url The URL of the request httpMethod The HTTP method used, such as GET or POST statusCode The statusCode of the HTTP response, such as 200 for OK timer A timer created when the network request was started bytesSent The number of bytes sent in the request bytesReceived The number of bytes received in the response responseBody The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. params Additional parameters included in an HTTP Error metric if the HTTP transaction is an error. NoticeNetworkFailure NewRelicAgent.NoticeNetworkFailure(String url, String httpMethod, Timer timer, NewRelicAgent.NetworkFailureCode failureCode, String message) Parameter Description url The URL of the request httpMethod The HTTP method used, such as GET or POST timer A timer created when the network request was started exception The exception that occurred. New Relic Mobile can automatically translate many common exceptions into network failure types. failure The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Uninstall plugin To uninstall the Unity plugin, use the project console to remove all related files and resources that were installed with the Unity package: Delete NewRelicAgent object from the Hierarchy pane of the Unity project console. From All Scripts, delete all the scripts that start with newrelic. Then do the following as applicable: From Assets > Plugin > iOS, delete the NewRelicIos, NewRelicUnityPlugin, post-build, and restore-framework files. Then remove the mod_pbxproj and NewRelicAgent.framework directories. From Assets > Plugin > Android, delete the newrelic.android and NewRelicAndroid files. Then remove the LICENSE and README directories. Unity release notes These release notes are for historical reference. Unity is no longer supported for new customers. Unity plugin 1.2.0 Released on: Monday, March 13, 2017 - 13:00 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.2.0.zip Notes: Updated Unity plugin to iOS agent 5.9.0 and Android agent 5.9.0 Unity plugin 1.1.0 Released on: Tuesday, September 6, 2016 - 14:53 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.1.0.zip Notes: Updated Unity plugin to iOS agent 5.8.0 and Android agent 5.7.1 Unity plugin 1.0.1 Released on: Monday, August 8, 2016 - 14:00 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.0.1.zip Notes: Bundle Android class rewriter JAR file (version 5.6.1) into the Unity package. Unity plugin 1.0.0 Released on: Wednesday, May 25, 2016 - 14:00 Download URL: http://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.0.0.zip Notes: This plugin provides New Relic Mobile agent support for iOS and Android applications built with Unity. It also gives Unity developers access to New Relic crash reporting. It provides information about app performance, sessions, devices, operating systems, and more. It also includes APIs for custom instrumentation to gain deeper insights into specific areas of your app. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 16.220858,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " The SDK can store up to 64 user-defined attributes at a time. If you attempt to store more than 64 attributes, the SDK returns false. Use the following <em>static</em> <em>methods</em> in the NewRelicAgent namespace to send custom attributes and events to New Relic Insights. <em>Methods</em> that return boolean results return"
      },
      "id": "5c52cbec8e9c0f0b286080ec"
    }
  ],
  "/collect-data/collect-data-from-any-source": [
    {
      "category_2": "Ingest APIs",
      "nodeid": 35471,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Convert event data to metrics",
        "Ingest APIs",
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs",
        "For more help"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "47a4c8f38c1b1674504ea302d865fd499e90ea39",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-started/capabilities/telemetry-sdks-send-custom-telemetry-data-new-relic",
      "published_at": "2020-10-22T04:34:35Z",
      "updated_at": "2020-10-09T17:23:34Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Ingest APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Report custom telemetry data with New Relic's open-source Telemetry SDKs.",
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send metrics and trace data to the New Relic platform. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility To build with the Telemetry SDKs, you will need an Event API insert key. New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported data types Java Java library on GitHub New Relic Metrics New Relic Events New Relic Logs New Relic Traces Node/TypeScript NodeJS library on GitHub New Relic Metrics New Relic Traces Python Python library on GitHub New Relic Metrics New Relic Events New Relic Traces Go Go library on Github New Relic Metrics New Relic Traces .NET .NET library on GitHub .NET package in NuGet New Relic Metrics New Relic Traces C C library on Github New Relic Traces Rust Rust library on Github New Relic Traces For more on the supported data types: Metrics: see the Metric API Traces: see the Trace API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.26602,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "sections": "Convert <em>event</em> data to <em>metrics</em>",
        "info": "Report custom <em>telemetry</em> data with New Relic&#x27;s open-source <em>Telemetry</em> <em>SDKs</em>.",
        "category_0": "<em>Telemetry</em> Data Platform",
        "category_2": "Ingest <em>APIs</em>",
        "body": " integrations) don&#x27;t meet your needs, you can use the <em>Telemetry</em> SDKs to create your own <em>telemetry</em> data solutions. Requirements and compatibility To build with the <em>Telemetry</em> SDKs, you will need an <em>Event</em> <em>API</em> insert key. New Relic has contributed the <em>Telemetry</em> <em>SDK</em> to the open source community under",
        "breadcrumb": "Contents &#x2F; <em>Telemetry</em> Data Platform &#x2F; Ingest and manage data &#x2F; Ingest APIs"
      },
      "id": "5d89fefbe7b9d2537ed30dc1"
    },
    {
      "category_2": "Intro to APIs",
      "nodeid": 15691,
      "sections": [
        "Get started",
        "Intro to APIs",
        "Introduction to New Relic APIs",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "See APIs in action",
        "For more help"
      ],
      "title": "Introduction to New Relic APIs",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "Get started",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/apis/get-started/intro-apis/introduction-new-relic-apis",
      "external_id": "bb3a7314b2407cfa765425553484cb364e27e7e3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/get-started/intro-apis/introduction-new-relic-apis",
      "published_at": "2020-10-23T01:43:11Z",
      "updated_at": "2020-10-17T01:44:46Z",
      "breadcrumb": "Contents / APIs / Get started / Intro to APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to all of the available New Relic APIs. ",
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This section of the docs provides examples and reference documentation for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. While typical REST APIs require loading from multiple URLs, NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. New Relic provides a powerful GraphQL tool to explore the API with embedded schema definitions. To get started, go to api.newrelic.com/graphiql. For sample queries and mutations, use our NerdGraph tutorials. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The Browser API resources include: Resource Details Browser agent API Use the Browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve Mobile data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. If you implemented the REST API for querying subscription usage data prior to July 10, 2018, those usage-related REST APIs are now deprecated. You should use the Query API, which requires creating an API key. For more on switching to the new API format, see the transition guide. Partner API To retrieve information about your New Relic partner account, sub-accounts, and users, use the Partner API. Other APIs Insights API resources for Insights include: Resource Details Insert events API To report custom data use the Event insertion API. Query API To query your Insights data using NRQL-formatted queries, use the Query API. This API can also be used to retrieve subscription usage data. Dashboard API To create, read, update, and delete dashboards, use the Dashboard API. Other New Relic product APIs You can also report custom data from other New Relic features. For more information, see the API sections for other products. NerdGraph You can use NerdGraph (our GraphQL API) to query data with NRQL. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.29161,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>APIs</em>",
        "sections": "<em>Telemetry</em> <em>APIs</em> for core data types",
        "info": "An introduction to all of the available New Relic <em>APIs</em>. ",
        "category_0": "<em>APIs</em>",
        "category_2": "Intro to <em>APIs</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;<em>apis</em>&#x2F;get-started&#x2F;intro-<em>apis</em>&#x2F;introduction-new-relic-<em>apis</em>",
        "body": ". <em>Telemetry</em> APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed <em>agent</em>. Data type Description <em>Trace</em> <em>API</em> Send distributed tracing data to New Relic. <em>Event</em> <em>API</em> Send <em>event</em> data to New"
      },
      "id": "5d4ae71be7b9d211b4d535a4"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13806,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Report custom event data",
        "Overview of reporting custom events and attributes",
        "Send custom events and attributes",
        "Extend data retention",
        "For more help"
      ],
      "title": "Report custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "external_id": "afb5f5a81ae06b22935d98c470ed9cabd7c9da6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/report-custom-event-data",
      "published_at": "2020-10-22T20:43:39Z",
      "updated_at": "2020-07-26T05:52:23Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the options for sending custom event data to New Relic. ",
      "body": "New Relic products report a variety of default event data to your account. This document will explain how to report your own custom events and attributes. Overview of reporting custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. Reporting custom events allows you to create more useful and customized queries and charts of your data, and is a key part of optimizing how New Relic works for you. Before beginning, it's important to know that reporting a large number of custom events and/or attributes can cause degraded query performance, or cause you to approach or pass data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile agent Use the mobile agent API to send custom events and attributes. Synthetics Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn about how to extend how long events are retained in your account, see Event data retention. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.28183,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report custom <em>event</em> data",
        "sections": "<em>Event</em> data sources",
        "info": "An overview of the options for sending custom <em>event</em> data to New Relic. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "Custom <em>events</em>",
        "body": " the Flex integration tool to report your own custom <em>event</em> data. Mobile <em>agent</em> Use the mobile <em>agent</em> <em>API</em> to send custom events and attributes. Synthetics Add custom attributes to the SyntheticCheck <em>event</em> via the $util.insights tools. For ways to report other types of custom data, see: <em>Metric</em> <em>API</em> Logs <em>Trace</em>",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; Custom events"
      },
      "id": "5e8e7f9de7b9d2aa122cf0f6"
    },
    {
      "category_2": "Get started",
      "nodeid": 36051,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Convert event data to metrics",
        "Ingest APIs",
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Agent APIs",
        "Telemetry SDKs",
        "APIs for sending metrics, traces, logs, and events",
        "New Relic One applications",
        "For more help"
      ],
      "title": "Get data into New Relic",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "7a413b4d7e5bd81088a08507ae4bad64c7e24b2d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-data-new-relic/getting-started/introduction-new-relic-data-ingest-apis-sdks",
      "published_at": "2020-10-22T08:17:33Z",
      "updated_at": "2020-08-10T23:16:39Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to how to get data into New Relic. ",
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our Telemetry Data Platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. To browse all New Relic-built tools and solutions, see New Relic integrations. Agent APIs Some of our monitoring solutions come with APIs and/or SDKs that allow you to customize the data reported and how it reports. For more information, see the relevant product: APM agent APIs Browser API Mobile API Infrastructure monitoring: the Flex integration tool Telemetry SDKs If our more curated solutions don't work for you, our open source Telemetry SDKs let you build your own solution. These SDKs are language wrappers for our data-ingest APIs (below) that let you send telemetry data to New Relic without requiring install of an agent. APIs for sending metrics, traces, logs, and events If our more curated solutions don't work for you, we also have data-ingest APIs: Trace API Event API Metric API Log API To learn about the differences between these data types, see Data types. New Relic One applications You can build entirely custom applications that reside in New Relic One and make use of any data you want. You can use existing open source New Relic One apps, or share your own with the open source community. For details, see New Relic One applications. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.99941,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>APIs</em> for sending <em>metrics</em>, <em>traces</em>, logs, and <em>events</em>",
        "category_0": "<em>Telemetry</em> Data Platform",
        "body": " also have data-ingest APIs: <em>Trace</em> <em>API</em> <em>Event</em> <em>API</em> <em>Metric</em> <em>API</em> Log <em>API</em> To learn about the differences between these data types, see Data types. New Relic One applications You can build entirely custom applications that reside in New Relic One and make use of any data you want. You can use existing open",
        "breadcrumb": "Contents &#x2F; <em>Telemetry</em> Data Platform &#x2F; Ingest and manage data &#x2F; Get started"
      },
      "id": "5f24aa60196a67ede394f5f3"
    },
    {
      "category_2": "On-host integrations list",
      "nodeid": 38406,
      "sections": [
        "On-host integrations",
        "Get started",
        "Installation",
        "On-host integrations list",
        "Understand and use data",
        "Troubleshooting",
        "StatsD monitoring integration (version 2)",
        "Features",
        "Requirements",
        "Install",
        "Install for Kubernetes",
        "Configure",
        "Metric format",
        "Metric types",
        "Add tags (attributes)",
        "Create alerts",
        "Find and use data",
        "Check the source code",
        "For more help"
      ],
      "title": "StatsD monitoring integration (version 2) ",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "On-host integrations",
      "external_id": "5d94989a9004778a43aba9fc5187b7904affc412",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/statsd-nrql-alert-condition-example-2.png",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/statsd-monitoring-integration-version-2",
      "published_at": "2020-10-22T11:31:52Z",
      "updated_at": "2020-10-22T11:31:52Z",
      "breadcrumb": "Contents / Integrations / On-host integrations / On-host integrations list",
      "document_type": "page",
      "popularity": 1,
      "body": "The second version of our StatsD integration was released on May 25 2020. It's an improvement on our first StatsD integration. Improvements include: simpler configuration, and a simpler method for adding tags (key-value pairs). Features Our StatsD integration (version 2) lets you easily get StatsD-format data into New Relic. You can also add any arbitrary tags (key-value pairs) to your data. Once your metrics are in New Relic, you can query your data and create custom charts and dashboards. Requirements This integration uses our Metric API and our Event API to ingest data. To use these APIs, you'll need an Insert API key. The integration adheres to the Metric API requirements and data limits. The default rate limit is 100,000 data points per minute (DPM). If you think you're missing metrics or sending more than 100K DPM, see Request data changes. To see if you're account is hitting the rate limit, run the following NRQL query: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature ='Metrics' FACET category, message LIMIT 100 since 1 day ago Install This section will explain how to do a standard install. If you want to run StatsD in Kubernetes, see Kubernetes install. To install the StatsD integration, run the following command and include your New Relic account ID and New Relic Insert API key. This generates a TOML configuration file used by gostatsd. docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 If your account is in the EU data center region, add this to the above command: -e NR_EU_REGION=true \\ After installing, you can: Do optional additional configuration Define your metrics Add custom tags to your data Create alerts Install for Kubernetes Here are examples of Kubernetes manifests for deployment and service objects: Kubernetes manifest examples Below are examples of Kubernetes manifests to deploy StatsD in a Kubernetes environment and create a StatsD service named newrelic-statsd. You need to insert your account ID and your license key. deployment.yml: apiVersion: apps/v1 kind: Deployment metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: selector: matchLabels: app: newrelic-statsd replicas: 2 revisionHistoryLimit: 2 template: metadata: labels: app: newrelic-statsd spec: containers: - name: newrelic-statsd image: newrelic/nri-statsd:2.0.0 env: - name: NR_ACCOUNT_ID value: \"NEW_RELIC_ACCOUNT_ID\" - name: NR_API_KEY value: \"NEW_RELIC_LICENSE_KEY\" service.yml: apiVersion: v1 kind: Service metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: type: ClusterIP ports: - name: newrelic-statsd port: 80 targetPort: 8125 protocol: UDP selector: app: newrelic-statsd For configuration details, see Kubernetes configuration. Configure In the install procedure, you run nri-statsd with environment variables, and this generates a TOML configuration file. Additionally, you can set these configuration options: Configuration options Description expiry-interval string If a metric is not updated for this amount of time, we stop reporting that metric. Default is 5m. If you want to send the metrics only if the value was updated between the flush intervals, configure this to 1ms. To never expire metrics, set it to 0. percent-threshold list of integers Specifies the percentiles used for metrics aggregation. Default: 90. metrics-addr string Indicates address on which to listen for metrics. Default: :8125. To ensure FedRAMP compliance when using the StatsD integration you must define the following endpoints in the custom configuration: address = 'https://gov-insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://gov-infra-api.newrelic.com/metric/v1' Here are some examples of customizing configuration by overwriting the default configuration: Example of custom configuration # Specify after how long do we expire metrics, default:5m expiry-interval = '1ms' # percent-threshold specify a list of percentiles for metrics aggregation, default:90 percent-threshold = [90, 99] backends='newrelic' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Disable timer sub-metrics: By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. If you want to disable those metrics you can do it by adding a disabled-sub-metrics configuration section and set true for the ones you want disabled. Here's an example: # disabled-sub-metrics configuration section allows disabling timer sub-metrics [disabled-sub-metrics] # Regular metrics count=false count-per-second=false mean=false median=false lower=false upper=false stddev=false sum=false sum-squares=false # Percentile metrics count-pct=false mean-pct=false sum-pct=false sum-squares-pct=false lower-pct=false upper-pct=false Docker: overwrite default configuration To overwrite the default nri-statsd configuration while running in a container, you can mount a configuration file inside the container. You can adopt the following template as needed for your situation. Example: backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' To run the container with the file mounted in the appropriate path: docker run \\ ... -v ${PWD}/nri-statsd.toml:/etc/opt/newrelic/nri-statsd.toml \\ ... newrelic/nri-statsd:2.0.0 Kubernetes: overwrite default configuration The best approach to configure nri-statsd running in Kubernetes is to use a configMap and mount the configMap into the container. (This is a similar process to mounting the configuration file in Docker.) Example: apiVersion: v1 kind: ConfigMap metadata: name: nri-statsd-config namespace: default data: nri-statsd.toml: | backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://metric-api.newrelic.com/metric/v1' api-key = '$NEW_RELIC_API_KEY' To use the configMap, declare a volume on your deployment spec template and then declare a volumeMount on your container spec. Example: apiVersion: apps/v1 kind: Deployment spec: template: spec: containers: .... volumeMounts: - mountPath: /etc/opt/newrelic/ name: nri-statsd-config volumes: - name: nri-statsd-config configMap: name: nri-statsd-config Metric format The integration receives metrics using the StatsD protocol. Optionally, the sample rate can be configured and tags can be added. Here's the metric data format we use: <metric name>:<value>|<type>|@<sample rate>|#<tags> Here are explanations of these fields: Field name Description <metric name> string Required. Name of the metric. <value> string Required. The metric type: c = counter g = gauge ms = timer @<sample rate> float Optional for simple counters or timer counters. When many metrics must be sent, you can use sampling to reduce network traffic. The downside is a reduction in the resolution of the data. An example of how this would work for sample rates below 1: If you set this to 0.1, the counter would send a measurement one out of every 10 times. #<tags> string Optional. Tags attached to your metrics are converted into attributes (key-value pairs). For more on tagging options, see Tags. Metric types Here are the types of metrics and how to format them: Counter A counter measures the number of occurrences of an event. Examples include cache hits per reporting interval and the number of threads created per reporting interval. A counter can be incremented or decremented during the same flush interval by adding a sign to the value. In the following example, the counter value will be 2: counter:4|c counter:-2|c At each flush, the current count is sent and reset to 0. If the count is not updated, at the next flush it will send the value 0. You can opt to disable this behavior by setting expiry-interval to 1ms. Here‚Äôs an example of a counter that is being sampled 1 out of 10 times: counter:4|c@0.1 Gauge A gauge represents a value that can increase or decrease with time. Examples of gauges include temperature, CPU usage, and memory. Here's an example: temperature:40|g If the gauge is not updated, at the next flush it will send the previous value. You can opt to disable this behavior by setting expiry-interval to 1ms. Timer The timer metric type measures timing data. By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. These are sent as sub-metrics in the following format: <metric_base_name>.std_dev <metric_base_name>.median <metric_base_name>.summary <metric_base_name>.sum_squares <metric_base_name>.mean <metric_base_name>.per_second The configured percentiles will generate the following metrics. The percentile threshold value will be attached as a tag. <metric_base_name>.sum_squares.percentiles <metric_base_name>.sum.percentiles <metric_base_name>.count.percentiles <metric_base_name>.upper.percentiles <metric_base_name>.mean.percentiles The percentile threshold can be tweaked with the percent-threshold config option. These can be controlled through the disabled-sub-metrics configuration section. Add tags (attributes) You can add tags to your data, which we save as attributes (key-value pairs). There are two options for adding tags: Add default tags that apply to all metrics: These apply to all metrics. They are fixed and don't change over time. Add metric-level tags: These apply to specific metrics and allow the value to be changed between two submits. Add default tags that apply to all metrics Add tags to metrics and events by defining an environment variable in the startup command. Here's an example that would create two tags: -e TAGS=\"environment:production region:us\" Here's that environment variable used in the startup command: docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -e TAGS=\"environment:production region:us\" \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Add metric-level tags When defining the metric format, you can add tags using this format: <bucket name>:<value>|<type>|#<tags> In this example, <tags> is a comma-separated list of tags. Tags format is: simple or key:value. Here's an example NRQL query that includes a custom tag: SELECT count(*) FROM Metric WHERE environment = 'production' Create alerts You can alert on StatsD data using NRQL alert conditions. Alert example This procedure walks you through sending some sample data and then creating an alert condition using that data. First, send this data to New Relic‚Äôs StatsD container: echo \"prod.test.num:32|g\" | nc -v -w 1 -u localhost 8125 Next, create a NRQL alert condition using this query: SELECT latest(prod.test.num) FROM Metric WHERE metricName = 'prod.test.num' Here's an image showing creating this NRQL alert condition. Notice that the sample data sent in is represented by the blue dot on the upper right of the chart. Now we can create the alert condition with these settings: Remember to set the Condition name. If a metric with a value above 50 is sent, then an incident is created and notified. The incident is closed automatically after 24 hours. To test that the alert is working, run this command: echo \"prod.test.num:60|g\" | nc -v -w 1 -u localhost 8125 Find and use data To query your data, you'd use any New Relic query option. For example, you might run a NRQL query like: SELECT count(*) FROM Metric WHERE metricName = 'myMetric' and environment = 'production' For more on how to query the Metric data type, see Query metric data. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.95896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Metric</em> format",
        "body": "-format data into New Relic. You can also add any arbitrary tags (key-value pairs) to your data. Once your metrics are in New Relic, you can query your data and create custom charts and dashboards. Requirements This integration uses our <em>Metric</em> <em>API</em> and our <em>Event</em> <em>API</em> to ingest data. To use these APIs"
      },
      "id": "5ece854928ccbc9dbdc13573"
    }
  ],
  "/build-apps/permission-manage-apps": [
    {
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Subscribe or unsubscribe apps",
        "Handle duplicate applications"
      ],
      "title": "Serve, publish, and deploy your New Relic One app",
      "type": "developer",
      "tags": [
        "publish apps",
        "deploy apps",
        "subscribe apps",
        "add metadata apps"
      ],
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "published_at": "2020-10-24T01:54:36Z",
      "updated_at": "2020-10-14T01:58:45Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Start sharing and using the custom New Relic One apps you build",
      "body": "Serve, publish, and deploy your New Relic One app 30 min When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. nr1 update Copy Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. nr1 catalog:submit Copy Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Subscribe or unsubscribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.39673,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and deploy your New Relic One <em>app</em>",
        "sections": "Add images and metadata to your <em>apps</em>",
        "info": "Start sharing and using the custom New Relic One <em>apps</em> you build",
        "tags": "publish <em>apps</em>",
        "body": " to the <em>app</em> Handle duplicate applications Before you begin This guide requires the following: A New Relic One <em>app</em> or <em>Nerdpack</em> New Relic One CLI A <em>Nerdpack</em> <em>manager</em> role for publishing, deploying, and subscribing <em>apps</em>. Serve your <em>app</em> locally You can locally serve the <em>app</em> you create to New Relic One to test"
      },
      "id": "5efa999de7b9d283e67bab8f"
    },
    {
      "category_2": "Original users and roles",
      "nodeid": 1101,
      "sections": [
        "Original accounts and billing",
        "Original product-based pricing",
        "Original users and roles",
        "SAML SSO (original users)",
        "Original data retention",
        "Original pricing plan usage",
        "Users and roles (original user model)",
        "Who are these docs for?",
        "View and manage users",
        "User types: basic user and full user",
        "Account roles",
        "Add-on roles",
        "Account permissions",
        "Alert permissions",
        "APM permissions",
        "Browser permissions",
        "Infrastructure permissions",
        "Insights permissions",
        "Mobile permissions",
        "Synthetics permissions",
        "Workloads",
        "For more help"
      ],
      "title": "Users and roles (original user model)",
      "category_0": "New Relic accounts",
      "type": "docs",
      "category_1": "Original accounts and billing",
      "external_id": "39c7440fe944f68b4de943d2c9619cbcc85408d2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/original-accounts-billing/original-users-roles/users-roles-original-user-model",
      "published_at": "2020-10-22T18:24:41Z",
      "updated_at": "2020-10-09T04:47:17Z",
      "breadcrumb": "Contents / New Relic accounts / Original accounts and billing / Original users and roles",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic original user model: explanation of how to manage users, and how user roles work. ",
      "body": "Original user model For users on our original user model, an introduction to how the user model works, including user roles and permissions. Who are these docs for? This doc and the surrounding section of docs shows you how to manage users who are on our original user model. If you were a New Relic customer before July 30 2020, you very likely have users on our original user model (and not the New Relic One user model). One way to quickly check the user model: if you can see users in the Users and roles UI, these users are on our original user model. Want to learn more about user model changes? See Overview of pricing plan and user models. View and manage users To see the users on your New Relic account and their current roles: select the account dropdown, select Account settings, and select Users and roles. Some features in the UI are visible only to account Owners and Admins. User types: basic user and full user On the Users and roles UI page, users are categorized as either full users or basic users. This only affects your account once you've switched to the New Relic One pricing plan, released July 2020. Once you've changed your pricing plan, the number of full users is a factor in your billing. Your users on our original user model remain on that user model (and use these original user docs) and additionally have the new full/basic categorization. To learn more, see Transition to new pricing. You can also bulk update changes to user type. Account roles A New Relic account can have only one Owner. To share an account with other users in your organization, create Admins, Users, or Restricted Users. Account role Description Owner The person who initially creates the New Relic account and receives all billing queries. The Owner has complete access to all of the account information. Admin Can add, edit, and delete users, and can enable or set up features. User Can use (and optionally set up) New Relic features. In general, Admins take responsibility for setting up features, and Users and Restricted Users can use them. Restricted User One or more individuals who can view (but not set up or change) any New Relic features. The Restricted User role is useful, for example, for demos. You can change your New Relic session settings so that Restricted User logins do not time out, and then set the user interface to Kiosk mode. Add-on roles With add-on roles, you can grant variable levels of access to all users in your account, across the entire platform of New Relic products. This allows you to tailor your account permissions levels to suit the needs of Users and Restricted Users within your account. Giving a User or Restricted User add-on manager access to a product grants them the equivalent of Admin capabilities within the product. They will continue to have User or Restricted User capabilities for all other New Relic products. For example, you could make a software engineer in your company a User in most products, but assign Admin-level access to APM. For another example, you might assign the Nerdpack manager role to a user, and that gives them the ability to subscribe and unsubscribe New Relic One applications to an account. There are two types of add-on roles: Add-on Manager roles are available to grant permissions on a per-product basis. Giving a User or Restricted User managed add-on access to a product grants them the equivalent of Admin capabilities within the product. Custom add-on roles can grant feature-specific permissions across different New Relic products. For example, a group of Users could have the ability to acknowledge incidents and close violations in New Relic Alerts, but not have the ability to modify your existing alert preferences. Individuals on a master account that has sub-accounts automatically have the same level of access for all sub-accounts. Below are options for managing both managed add-on roles and custom add-on roles: View roles To view the list of individuals assigned to your account and their current roles: Go to account dropdown > Account settings > Users and roles. Assign a managed role Owner and Admins Managed add-on roles are available by default for each New Relic product. Adding a managed role for a user grants them Admin-level permissions for the assigned product. They cannot be edited or deleted. To assign a managed add-on role for a User or Restricted User in your account: Go to account dropdown > Account settings > Users and roles. From the list of users associated with your account, select their name. Under Add-on roles, select the type of manager role for the user. To understand which capabilities may be added, use the Capabilities preview chart. Features in the Capabilities preview chart may not exactly match what features are available for your subscription level. You can also add, update, or delete users in bulk by using a CSV file. Create a custom role To create a custom add-on role for your account: Go to account dropdown > Account settings > Users and roles > Roles. Select plus-circle New custom add-on role. Select the capabilities necessary for the new custom role, then Create role. Assign a custom role Owners and Admins You must create a custom role before assigning it to a user. To assign a custom add-on role for a User or Restricted User in your account: Go to account dropdown > Account settings > Users and roles > Users. From the list of users associated with your account, select their name ]. Under Add-on roles, select a custom role for the user. Click Update user. Edit or delete a custom role Owners and Admins You cannot edit or delete New Relic's default roles. However, you can edit or delete custom add-on roles for your account: Go to account dropdown > Account settings > Users and roles > Roles. From the Add-on roles list, select the custom add-on role, then select pencil Edit role or trash-o Delete role as appropriate. Account permissions Here is a summary of basic user rights for your New Relic account. Individuals on a master account with sub-accounts automatically have the same level of access for all sub-accounts. However, they will not receive email notifications for alerts or weekly reports for sub-accounts unless they are explicitly granted permission on these sub-accounts. Function Owner Admin User Restricted Maintain billing information. fa-check Change the account Owner. fa-check Add, update, and delete account Admins, Users, and Restricted Users. When the account Owner and Admins add individuals to the account, New Relic automatically sends them an email message. fa-check fa-check Update users' job titles and roles from Account settings in the New Relic UI. fa-check fa-check Create, modify and delete sub-accounts from Account settings in the New Relic UI. fa-check fa-check Update your own account information (name, password change or password reset request, default account, email preferences, etc.) from User preferences in the New Relic UI. fa-check fa-check fa-check fa-check Change someone else's password. You cannot reset passwords for anyone else on the account, even if you are an Owner or Admin. Instead, follow standard procedures to request a password reset from New Relic. View the list of individuals on the account from (account dropdown) > Account settings > Account > Summary in the New Relic UI. fa-check fa-check fa-check fa-check Manage flexible data retention. fa-check Subscribe and unsubscribe applications to New Relic One fa-check fa-check Alert permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Alerts. To allow a User or Restricted User to execute any of these functions in New Relic Alerts, assign an Alerts add-on manager role. Admin and manager capabilities for Alerts include: Create or name alert policies. Specify incident preferences. Disable or define alert conditions. Provide runbook instructions. Select product targets. Alter alert condition thresholds. Create, modify, or delete notification channels. APM permissions Here is a summary of Admin and Add-on manager capabilities with New Relic APM. To allow a User or Restricted User to execute any of these functions in New Relic APM, assign an APM add-on manager role. Admin and manager capabilities for APM include: Remove applications from the New Relic UI. Delete app traces and error traces. Browser permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Browser. To allow a User or Restricted User to execute any of these functions in New Relic Browser, assign a Browser add-on manager role. Admin and manager capabilities for Browser include: Add, rename, or delete applications. Manage whitelists. Manage domain conditions. Infrastructure permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Infrastructure. To allow a User or Restricted User to execute any of these functions in New Relic Infrastructure, assign an Infrastructure manager role. Admin and manager capabilities for Infrastructure include: Create alert conditions in New Relic Infrastructure, including conditions for host not reporting. Add or modify integrations. Insights permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Insights. To allow a User or Restricted User to execute any of these functions in New Relic Insights, assign an Insights manager role. These functions include: Create, view, modify, or delete Query API keys or Insert API keys. New Relic Insights includes permission levels to share your Insights dashboards with others. Mobile permissions To give permission to delete a mobile app from New Relic, you can assign an Admin or Mobile manager role. ‚Äã‚Äã‚Äã Synthetics permissions Here's a summary of Admin and Add-on manager capabilities with New Relic Synthetics. To allow a User or Restricted User to execute any of these functions in New Relic Synthetics, assign a Synthetics add-on manager role. Admin and manager capabilities for Synthetics include: Create, edit, or delete monitors. Edit monitor scripts. Create, edit, or delete private locations. Create, edit, or delete monitor downtimes. Create, view, edit, or delete secure credentials. For more information, see User roles in Synthetics. Workloads Here's a summary of Admin and Add-on manager capabilities with New Relic One workloads: Create, duplicate, modify, or delete workloads. Link dashboards to workloads and save filters. To allow a User or Restricted User to execute these functions, assign the workloads manager add-on role. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.081924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Account <em>permissions</em>",
        "info": "For New Relic original user model: explanation of how to <em>manage</em> users, and how user roles work. ",
        "body": ". For another example, you might assign the <em>Nerdpack</em> <em>manager</em> role to a user, and that gives them the ability to subscribe and unsubscribe New Relic One applications to an account. There are two types of add-on roles: Add-on <em>Manager</em> roles are available to grant <em>permissions</em> on a per-product basis"
      },
      "id": "5f3e194028ccbc18c7f56de3"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add the NerdGraphQuery component to an application",
        "Add a table to your app",
        "Permissions for managing applications",
        "Set up your development environment",
        "Publish and deploy apps",
        "Create a custom map view"
      ],
      "published_at": "2020-10-24T01:53:25Z",
      "title": "Build apps",
      "updated_at": "2020-10-24T01:53:25Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 30 min Add a table to your app Add a table to your New Relic One app ¬† Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 30 min Publish and deploy apps Start sharing the apps you build 30 min Create a custom map view Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.92482,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "<em>Permissions</em> for <em>managing</em> <em>applications</em>",
        "body": " the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 30 min Add a table to your <em>app</em> Add a table to your New Relic One <em>app</em> ¬† <em>Permissions</em> for <em>managing</em> applications Learn about <em>permissions</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "image": "https://newrelic.com/dam/new-relic/opengraph/newrelic_og_image.png",
      "url": "https://newrelic.com/resources/webinars/NR-One-Programmability-191126",
      "sections": [
        "During this session we will review the following topics:",
        "Related Links",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-10-22T03:42:06Z",
      "title": "New Relic One Programmability Online Training",
      "updated_at": "2020-10-08T15:12:34Z",
      "type": "storefront",
      "external_id": "f583edb88ca2d2430ca297364eac839705311616",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Video New Relic One Programmability Online Training 46:59 ¬† Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. Prerequisites This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications.¬† Must have: Permissions to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager role to deploy Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests JavaScript layouts ¬† During this session we will review the following topics: Installation of New Relic CLI and Environment setup Familiarisation with New Relic One Application component model and lifecycle Advanced UI construction and data processing Individual self paced experimentation and Open Source example deployment Request a Demo Related Links Case Study La plus grande brasserie au monde se tourne vers New Relic pour que la bi√®re continue de couler √† flots dans l‚Äô√®re num√©rique Webinar Introduction to Custom Apps on New Relic One eBook Understanding the 3 Phases of DevOps Maturity Article Black Friday Is Coming: Are Your Sites and Apps Ready? eBook DevOps ‚Äì so geht es richtig : Best Practices zur √úberwindung von Erfolgshindernissen eBook DevOps Done Right: Best Practices to Knock Down Barriers to Success eBook Creating a Framework for Digital Media Success Article 7 Requirements for Monitoring Cloud Apps and Infrastructure COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.05316,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " developer; this training will provide important context to start you on the journey of developing New Relic Applications.¬† Must have: <em>Permissions</em> to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) <em>Nerdpack</em> <em>manager</em> role to deploy Technical exercises"
      },
      "id": "5ece92cb28ccbc3012c1356a"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/2g790g7la1iot/promo-image.1573253956.png",
      "url": "https://learn.newrelic.com/live-learncast-new-relic-one-programmability",
      "sections": [
        "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications.",
        "About this Learncast",
        "Prerequisites",
        "Virtual Training Session List"
      ],
      "published_at": "2020-10-24T01:40:25Z",
      "title": "Live Learncast: New Relic One Programmability",
      "updated_at": "2020-07-31T01:40:49Z",
      "type": "",
      "external_id": "053510b559767dbde34e3f1ee9a73bbf813a5a83",
      "popularity": 1,
      "body": "Sign In Live Learncast: New Relic One Programmability Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. Not currently available Available until July 10, 2020, 3:30 p.m. PDT. Already registered? Sign In About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. ¬† During this session we will review the following topics: ¬† 1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites ¬† This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications. ¬† Must have: ¬† Permissions to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. ¬† During this session we will review the following topics: ¬† 1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites ¬† This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications. ¬† Must have: ¬† Permissions to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) ¬© 2020 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.625275,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic <em>Applications</em>.",
        "body": " A text editor or IDE of your choice (we will be using VS Code) <em>Nerdpack</em> <em>manager</em> roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials"
      },
      "id": "5dc618cbe7b9d2a0a8e4649c"
    }
  ],
  "/explore-docs/nerdstoragevault": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-10-24T02:00:01Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 342.59702,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Data</em> <em>access</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "Intro to Nerd<em>Storage</em> 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you‚Äôll learn how to use Nerd<em>Storage</em> SDK <em>components</em>. Use Nerd<em>Storage</em> in your <em>apps</em> Nerd<em>Storage</em> is used to store and retrieve simple sets of <em>data</em>, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-10-24T01:54:36Z",
      "updated_at": "2020-10-24T01:54:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: bash Copy $ my-nerdlet $ ‚îú‚îÄ‚îÄ README.md $ ‚îú‚îÄ‚îÄ launchers $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ nerdlets $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss $ ‚îú‚îÄ‚îÄ node_modules $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler $ ‚îú‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ package-lock.json $ ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.453705,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Generate Nerdpack <em>components</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> CLI",
        "body": " <em>components</em>, see our <em>app</em> building guides and the <em>New</em> <em>Relic</em> <em>One</em> CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: bash Copy $ my-nerdlet $ ‚îú‚îÄ‚îÄ README.md $ ‚îú‚îÄ‚îÄ launchers $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "image": "https://developer.newrelic.com/static/AaronSoto-d72d9bb5f5e6165751e67367612525f4.jpg",
      "url": "https://developer.newrelic.com/nerd-days/",
      "sections": [
        "Nerd Days is a free 1-day event focused on building more perfect software",
        "Register for Nerd Days 1.0",
        "What‚Äôs is Nerd Days exactly‚Ä¶",
        "Save the date & join us online",
        "Upcoming Nerd Days",
        "Speaker line up",
        "Aaron Soto",
        "Caitlin Halla",
        "David Shanker",
        "Jeremy Cooper",
        "Joel Worrall",
        "John Vajda",
        "Jon Thurman",
        "Justin Eveland",
        "Leon Chapman",
        "Lindsy Farina",
        "Talia Nassi",
        "Thomas Martin",
        "Alec Swanson",
        "Brian Thomason",
        "Chris Trombley",
        "Sander Blue",
        "Gabe O'Brien",
        "Liam Hurrell",
        "Michael Caron",
        "Phil Weber",
        "Sebastian Remirez",
        "Jewels Nocera",
        "Nica Fee",
        "Stijn Polfliet",
        "Brad Schmitt",
        "Eric Mittelhammer",
        "Colin MacNaughton",
        "Tracks",
        "Observability",
        "Cloud migration",
        "Open source",
        "Devops journey",
        "Fundamentals",
        "Nerd Days AMER Agenda",
        "DevOps journey",
        "Keynote: Jemiah Sius, Lew Cirne, and Special Guest Announcements",
        "Instrumenting your service using agents",
        "New Relic CLI Wizardry",
        "5 Steps to Kubernetes Observability",
        "Delivering SRE as a Service",
        "Building applications on New Relic One",
        "Exploring your data using NRQL",
        "New Relic AI",
        "Going Serverless: Chipping at the monolith",
        "Logging for Modern Organizations",
        "Power up your Prometheus metrics with the Telemetry Data Platform",
        "Lunch with Lew",
        "Custom Instrumentation",
        "Exploring Data with NerdGraph",
        "Consolidating Your Data with New Relic‚Äôs Telemetry Data Platform",
        "Testing in Production",
        "How Open Source powers the New Relic One Catalog",
        "Alerts Best Practices",
        "The Art & Science of Deciphering Perceived Performance: A look at how user behavior affects your data",
        "Monitoring your Cloud Usage and Spend",
        "Scaling the Developer Toolkit Team: Writing Code that Writes Code",
        "Reducing toil with Terraform",
        "True availability using Synthetics",
        "How Observability-Driven Development accelerates DevOps transformations",
        "AWS Modernization",
        "Writing Reliably Bad Software, AKA 'How to get paid to write memory leaks'",
        "NerdStorageVault: ThirdParty Secrets",
        "Closing + Swag",
        "Engage with the developer community"
      ],
      "published_at": "2020-10-24T02:01:31Z",
      "title": "New Relic Developers",
      "updated_at": "2020-10-20T01:49:53Z",
      "type": "developer",
      "external_id": "0b8374051901a77e242ce296c00eeb3c760439d1",
      "document_type": "page",
      "popularity": 1,
      "body": "Nerd Days is a free 1-day event focused on building more perfect software Register for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region) What‚Äôs is Nerd Days exactly‚Ä¶ A FREE developer focused live digital conference covering a broad range of topics at varying levels for all skill sets. Including: Live workshops Live coding and demos Customer examples Panel / Q&A sessions Presented by Relics, partners, Developer Champions, and customers Save the date & join us online Whether you‚Äôre new or a data nerd, there‚Äôs an interactive session for you. Choose the sessions you're interested in and add Nerd Days to your calendar. Date: October 13, 2020 Time: 9AM PST - 3PM PST We look forward to building with you during Nerd Days! If you have any questions about Nerd Days please emails deco@newrelic.com. Upcoming Nerd Days EMEA RegistrationNov 10, 2020 APJ RegistrationOct 22, 2020 Speaker line up Get hands on with sessions presented by the following Relics, partners, Developer Champions, and customers. Aaron Soto Sr. Partner Solutions Architect AWS Caitlin Halla Software Engineer New Relic David Shanker Director, Platform Engineering Kinect Consulting Jeremy Cooper Sr. TechOps Strategy Consultant New Relic Joel Worrall Director, Open Source and Developer Advocacy New Relic John Vajda Senior Product Manager New Relic Jon Thurman Senior Solutions Consultant New Relic Justin Eveland Software Engineer New Relic Leon Chapman Senior TechOps Strategy Consultant New Relic Lindsy Farina Senior Product Manager New Relic Talia Nassi Developer Advocate Split Software Thomas Martin Director, Site Reliability 27 Global Alec Swanson Software Engineer New Relic Brian Thomason Senior Partner Solutions Consultant New Relic Chris Trombley Senior Software Engineer New Relic Sander Blue Senior Software Engineer New Relic Gabe O'Brien Senior Software Engineer New Relic Liam Hurrell Senior Technical Training Specialist New Relic Michael Caron Senior Technical Training Specialist New Relic Phil Weber Senior Technical Training Specialist New Relic Sebastian Remirez Lead Software Engineer New Relic Jewels Nocera Senior Software Engineer New Relic Nica Fee Developer Advocate New Relic Stijn Polfliet Principal TechOps Strategy Consultant New Relic Brad Schmitt Senior TechOps Strategy Consultant New Relic Eric Mittelhammer Senior TechOps Strategy Consultant New Relic Colin MacNaughton Lead Software Engineer New Relic Tracks Tracks will vary by region. All sessions will be recorded and distributed after the event. Observability Cloud migration Open source Devops journey Fundamentals Nerd Days AMER Agenda We‚Äôve got a packed schedule with thought-leaders of their respective industries Fundamentals Observability Cloud migration DevOps journey Open source 9:00AM PST Keynote: Jemiah Sius, Lew Cirne, and Special Guest Announcements Lew Cirne 10:00AM PST Instrumenting your service using agents Michael Caron New Relic CLI Wizardry Jon Thurman 5 Steps to Kubernetes Observability Stijn Polfliet & Brad Schmitt Delivering SRE as a Service Thomas Martin Building applications on New Relic One Joel Worrall 11:00AM PST Exploring your data using NRQL Phil Weber New Relic AI Sebastian Ramirez Going Serverless: Chipping at the monolith Nica Fee Logging for Modern Organizations Jeremy Cooper & Leon Chapman Power up your Prometheus metrics with the Telemetry Data Platform Liam Hurrell & Colin MacNaughton 12:00PM PST Lunch with Lew Lew Cirne & Jemiah Sius 1:00PM PST Custom Instrumentation Michael Caron Exploring Data with NerdGraph Caitlin Halla Consolidating Your Data with New Relic‚Äôs Telemetry Data Platform Eric Mittelhammer Testing in Production Talia Nassi How Open Source powers the New Relic One Catalog Justin Eveland 2:00PM PST Alerts Best Practices Phil Weber The Art & Science of Deciphering Perceived Performance: A look at how user behavior affects your data Lindsy Farina Monitoring your Cloud Usage and Spend Jewels Nocera Scaling the Developer Toolkit Team: Writing Code that Writes Code Sander Blue Reducing toil with Terraform Jon Thurman 3:00PM PST True availability using Synthetics Michael Caron How Observability-Driven Development accelerates DevOps transformations Dave Shanker AWS Modernization Aaron Soto & Brian Thomason Writing Reliably Bad Software, AKA 'How to get paid to write memory leaks' Gabe O‚ÄôBrien & Alec Swanson NerdStorageVault: ThirdParty Secrets John Vajda 4:00PM PST Closing + Swag Jemiah Sius Engage with the developer community @newrelic New Relic Forum Developers Hopin logo Event powered by Hopin",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.93501,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "Building <em>applications</em> on <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " Steps to Kubernetes Observability Stijn Polfliet &amp; Brad Schmitt Delivering SRE as a Service Thomas Martin Building applications on <em>New</em> <em>Relic</em> <em>One</em> Joel Worrall 11:00AM PST Exploring your <em>data</em> using NRQL Phil Weber <em>New</em> <em>Relic</em> AI Sebastian Ramirez Going Serverless: Chipping at the monolith Nica Fee"
      },
      "id": "5f3dd5bf28ccbc2349f56e4e"
    },
    {
      "category_2": "New Relic One pricing and users",
      "nodeid": 39356,
      "sections": [
        "Accounts and billing",
        "Account setup",
        "Account structure",
        "New Relic One pricing and users",
        "General account settings",
        "Automated user management",
        "Partner install",
        "New Relic One user model",
        "User type: basic and full",
        "User groups",
        "Roles and capabilities",
        "Standard roles",
        "Roles and user groups",
        "Roles and user type",
        "Custom roles and capabilities",
        "Capability limitations",
        "For more help"
      ],
      "title": "New Relic One user model ",
      "category_0": "New Relic accounts",
      "type": "docs",
      "category_1": "Accounts and billing",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/accounts/accounts-billing/new-relic-one-pricing-users/new-relic-one-user-model",
      "external_id": "d1c76849a14121403f5a7170efb89ba0d26d9240",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-pricing-users/new-relic-one-user-model",
      "published_at": "2020-10-22T12:16:04Z",
      "updated_at": "2020-10-22T12:16:04Z",
      "breadcrumb": "Contents / New Relic accounts / Accounts and billing / New Relic One pricing and users",
      "document_type": "page",
      "popularity": 1,
      "info": "An explanation of the structure and options available when creating a New Relic user (on our newer New Relic One user model). ",
      "body": "New Relic One user model In mid-2020, New Relic released a newer user model, referred to as the New Relic One user model. Here are the users on this user model: Users on New Relic organizations created on or after July 30 2020. Users on older accounts who were added via automated user management. If you were a New Relic customer before July 30 2020, your users are very likely on our original user model. For more on this, see Pricing and user model changes. This doc will explain the structure of the New Relic One user model, including: User type (basic user vs full user) User groups User roles Capability limitations For how to add and manage users, see User management. User type: basic and full The user type determines the monitoring and analysis features a user has access to, and is a key factor in billing. (Note that user type does not control account admin-related permissions; that's determined by the user group.) There are two user types: Basic user: These users are free and have access to basic features like setting up reporting of data, running queries of data, making custom charts and dashboards, and setting up alerts. They do not have access to Full-Stack Observability features. For details, see Capabilities. No matter what group a basic user is assigned to, they always have the capabilities of a basic user: no more and no less. Basic users can upgrade on their own to become full users (with exception of users on original user model). Basic users are prompted to upgrade themselves when they attempt to access a feature available only to full users. Full user: These users are billable and have access to our Full-Stack Observability features, which includes our curated UI experiences, like APM, infrastructure monitoring, browser monitoring, mobile monitoring, and synthetic monitors. For details, see Capabilities. The Standard pricing tier includes one free full user and up to five total. Are you switching from original pricing to New Relic One pricing? Learn about updating your users. Or learn more about user-related billing calculation. To understand more about basic users and full users: Compare full vs basic capabilities Below is a detailed table showing differences between basic user and full user capabilities. In short, basic users have access to our Telemetry Data Platform and Applied Intelligence (read-only) features, while full users have access to that plus Full-Stack Observability features. Features Full user Basic user Full-Stack Observability (New Relic-built UI experiences) Application performance monitoring (APM) UI fa-check Infrastructure monitoring UI fa-check Digital Experience Monitoring (Browser, Mobile, Synthetics) UI fa-check Serverless monitoring UI fa-check Logs in context with other UI experiences fa-check Synthetics checks fa-check New Relic Edge with Infinite Tracing (tail-based sampling) fa-check (Pro and Enterprise) Subscribe to New Relic One catalog apps fa-check Assorted curated UI experiences (distributed tracing, Kubernetes cluster explorer, workloads, etc.) fa-check Applied Intelligence (AI) Proactive Detection fa-check fa-check (read-only) Incident Intelligence fa-check fa-check (read-only) Telemetry Data Platform Data ingest from any source (Metrics, Events, Logs, Traces) fa-check fa-check Alerts and notifications fa-check fa-check Interactive query interface fa-check fa-check Custom charts and dashboards (not New Relic-built) fa-check fa-check Encryption at rest fa-check fa-check Standard data retention fa-check fa-check NerdGraph (GraphQL) API fa-check fa-check Security and compliance fa-check fa-check Integrations fa-check fa-check Data management fa-check fa-check Logs UI fa-check fa-check Build custom New Relic One apps fa-check fa-check Learn more about how user type (basic vs full) relates to roles and capabilities. Learn more about user-related billing calculations. Tips on choosing user type Reasons to make someone a full user: They play a key role in the development, testing, deployment, and maintenance phases of the application development lifecycle. They break/fix code regularly; they are responsible for triaging workflows, troubleshooting, or managing users and roles for their team. They have DevOps practices (i.e. version control systems and implement CI/CD). They need to use New Relic's curated dashboards and experiences (not just the ability to create their own custom queries and charts); in other words, they need full access to our platform. They need to be able to manage users. Reasons to make someone a basic user: They play a key role in the planning phase of the application development lifecycle. They use and configure New Relic agents, APIs, and integrations to send us data, and access, configure, and use alerts on such data (not necessarily responsible for triaging workflows, troubleshooting, or managing users and roles for their team). They want to see high-level analytics and business metrics for future planning (such as C-Suite executives). They do not need to use our curated experiences and dashboards, but would benefit from the ability to create their own custom queries and charts of data; in other words, they don't need full access to the platform. They don't manage users. Are you switching from our original pricing plan to New Relic One pricing? Learn about how to convert your users. Learn more about user-related billing calculations. Understand user-related billing For user-related billing calculation details, see Calculations. For how to query and alert on usage data, see Query usage data. User groups This applies to users on our New Relic One user model. For users on our original user model, see Original user docs. A user group allows managing multiple users at the same time. Your New Relic users are assigned to a group and that group is granted access to specific roles and specific accounts. We have two default user groups you can add users to: User: Adding someone to this group allows them to use and configure monitoring/analysis features but not perform account-related tasks like managing billing or users. Admin: Adding someone to this group gives them the abilities of the User group and also gives them access to account/organization-related abilities like managing billing-related settings and managing users. See the roles and capabilities these default groups have. Pro and Enterprise tier accounts can create their own custom roles and custom groups. Roles and capabilities This applies to users on our New Relic One user model. For users on our original user model, see Original user docs. Roles are a set of capabilities. A capability is defined as the ability to do a specific New Relic task, like 'Delete alert conditions' (see more examples). We provide some default standard roles (below). Pro and Enterprise tier accounts can also create custom roles. Standard roles Our standard roles are default sets of capabilities that satisfy some commonly needed use cases. These standard roles are assigned to our default Admin and User groups, but you can also assign these roles to a custom group. Most standard roles have capabilities that are unique and that can't be replicated with a custom role. For example, to assign billing management capabilities to a user, you'd need to assign them the Billing user role. You wouldn't be able to assign billing management capability using a custom role. The only standard roles that can be replicated with custom roles are Read only, Standard user, and All product admin (this role is the equivalent of choosing all available capabilities). Standard roles include: Standard roles Description Read only Provides read-only access to the New Relic platform (except for synthetic monitor secure credentials). Standard user Provides standard access to the platform, including the ability to configure most monitoring tools, but does not include the ability to configure more sensitive settings, including account-level configuration and synthetic monitor secure credentials. All product admin Provides admin-level access to the platform. This includes all New Relic capabilities with the exception of managing users (Organization manager and Authentication domain manager) and managing billing-related settings (Billing user). A basic user is defined as having the All product admin role but without access to Full-Stack Observability features. Billing user Provides ability to manage subscriptions and billing, and read-only access to the rest of the platform. Organization manager Provides the ability to manage users, including managing user groups, roles, and access grants. For how to grant this via the UI, see Add user management capability. Authentication domain manager Provides the ability to manage authentication domains. Authentication domains control how users are authenticated, whether via manual username/password or using SAML SSO, and SCIM provisioning (also called automated user management). For how to grant this via the UI, see Add user management capability. More features that this role controls will be released soon. Manage v1 users For New Relic organizations that existed before July 30 2020 and have users on our original user model, this role lets you manage those \"v1\" users. Roles and user groups There are two default user groups available: User and Admin. These groups have our standard roles applied in these ways: User: this group has only the All product admin standard role, which grants general platform access and some basic admin capabilities. Admin: this group has all the standard roles, giving it complete admin capabilities. Custom groups can be assigned standard roles or custom roles. Roles and user type User type refers to whether a user is a basic user or a full user. A basic user can be defined as having the All product admin standard role but without access to Full-Stack Observability features (learn more). A basic user always has basic user capabilities, no more and no less, regardless of what group they're assigned to. One nonintuitive impact of this is that a group's basic users could have more capabilities than its full users have. For example, if you created a custom group with very minimal capabilities, the full users in that group would have those minimal capabilities, but any basic users in that group would have more capabilities than the full users because the capabilities of a basic user trump group capabilities. A full user's capabilities will depend on its assigned group; it has theoretical access to all roles and capabilities. For more on this, see User type. Custom roles and capabilities For tips on setting up custom roles and capabilities, see Add custom role. Capability limitations For users on the New Relic One user model, there are some limitations, mainly around API access. For details, see Limitations. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 72.4579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> user model ",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> pricing and users",
        "info": "An explanation of the structure and options available when creating a <em>New</em> <em>Relic</em> user (on our <em>newer</em> <em>New</em> <em>Relic</em> <em>One</em> user model). ",
        "category_0": "<em>New</em> <em>Relic</em> accounts",
        "category_2": "<em>New</em> <em>Relic</em> <em>One</em> pricing and users",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;accounts&#x2F;accounts-billing&#x2F;<em>new</em>-<em>relic</em>-<em>one</em>-pricing-users&#x2F;<em>new</em>-<em>relic</em>-<em>one</em>-user-model",
        "body": " fa-check Integrations fa-check fa-check <em>Data</em> management fa-check fa-check Logs UI fa-check fa-check Build custom <em>New</em> <em>Relic</em> <em>One</em> <em>apps</em> fa-check fa-check Learn more about how user type (basic vs full) relates to roles and capabilities. Learn more about user-related billing calculations. Tips",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> accounts &#x2F; Accounts and billing &#x2F; <em>New</em> <em>Relic</em> <em>One</em> pricing and users"
      },
      "id": "5f8c3b65e7b9d246ad641390"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-10-24T02:01:31Z",
      "updated_at": "2020-09-17T01:51:10Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 67.54258,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> CLI reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> CLI reference",
        "info": "An overview of the CLI to help you build, deploy, and manage <em>New</em> <em>Relic</em> <em>apps</em>.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>app</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> CLI reference To build a¬†<em>New</em> <em>Relic</em> <em>One</em> <em>app</em>, you must install the <em>New</em> <em>Relic</em> <em>One</em> CLI. The CLI helps you build, publish, and manage your <em>New</em> <em>Relic</em> <em>app</em>. We provide a variety of tools for building <em>apps</em>, including the <em>New</em> <em>Relic</em> <em>One</em> CLI (command line interface). This page explains how to use"
      },
      "id": "5efa989e28ccbc535a307dd0"
    }
  ],
  "/build-apps/build-hello-world-app": [
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-10-24T01:54:36Z",
      "updated_at": "2020-10-24T01:54:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: bash Copy $ my-nerdlet $ ‚îú‚îÄ‚îÄ README.md $ ‚îú‚îÄ‚îÄ launchers $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ nerdlets $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss $ ‚îú‚îÄ‚îÄ node_modules $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom $ ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler $ ‚îú‚îÄ‚îÄ nr1.json $ ‚îú‚îÄ‚îÄ package-lock.json $ ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 404.43344,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "sections": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "info": "An overview of the <em>Nerdpack</em> <em>File</em> <em>Structure</em>",
        "tags": "<em>file</em> <em>structure</em>",
        "body": " components, see our app building guides and the New Relic <em>One</em> <em>CLI</em> command reference. <em>Nerdpack</em> <em>file</em> <em>structure</em> When you generate a <em>Nerdpack</em> template using the <em>nr1</em> create command, it has the following <em>file</em> <em>structure</em>: bash Copy $ my-nerdlet $ ‚îú‚îÄ‚îÄ README.md $ ‚îú‚îÄ‚îÄ launchers $ ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2020-10-24T02:01:31Z",
      "updated_at": "2020-10-14T01:58:45Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "Intro to New Relic One SDK To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 275.41498,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to New Relic <em>One</em> SDK",
        "sections": "Intro to New Relic <em>One</em> SDK",
        "info": "Intro to New Relic <em>One</em> SDK",
        "tags": "New Relic <em>One</em> apps",
        "body": " Relic or third-party data. Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2020-10-24T01:54:37Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.30666,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>One</em> <em>CLI</em> common commands",
        "sections": "New Relic <em>One</em> <em>CLI</em> common commands",
        "info": "An overview of common commands you can use with the New Relic <em>One</em> <em>CLI</em>.",
        "body": " Nerdpacks and their <em>file</em> <em>structure</em>, see <em>Nerdpack</em> <em>file</em> <em>structure</em>. For more on how to set up your Nerdpacks, see our <em>Nerdpack</em> <em>CLI</em> commands. Usage $ <em>nr1</em> create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "Permissions for managing applications",
        "New Relic One pricing plan",
        "Original product-based pricing"
      ],
      "title": "Permissions for managing applications",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2020-10-24T01:56:11Z",
      "updated_at": "2020-09-02T02:04:41Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for subscribing to apps",
      "body": "Permissions for managing applications When you create an app, you'll likely want to share it. From New Relic One's Apps page, you can subscribe to apps you create, publish, and deploy, and to other publicly available apps. You must have the Nerdpack manager role to subcribe accounts to apps. Read on to learn about permissions and versions. Permissions for managing applications The Nerdpack manager role is a New Relic add-on role. When you create a Nerdpack, you have the Nerdpack manager role for handling that Nerdpack. New Relic account administrators have the Nerdpack manager role automatically, and can subscribe their accounts to available Nerdpacks. User permissions vary depending on which pricing plan you are on. New Relic One pricing plan For accounts with New Relic One pricing, there are permissions differences for basic users and full users: Full users have the Nerdpack manager role and have full capabilities for creating and managing New Relic One applications, as well as accessing all types of applications in the New Relic One catalog. A basic user can develop and view their own local New Relic One apps, but they cannot: Subscribe other users to apps they‚Äôve created. Access or manage apps in the New Relic One catalog. Access apps in the entity explorer sidebar. Original product-based pricing For accounts on our original product-based pricing, here are access details: Subscribe to publicly available applications To subscribe to publicly available applications, you must have the Nerdpack manager role. Nerdpack manager permissions are automatically assigned to New Relic account owners and admins and can be assigned to individual users. If you aren‚Äôt an owner or admin, you can request Nerdpack manager permission, or ask your New Relic admin or owner to subscribe the apps to your account for you. You can add any of the publicly available applications to master accounts or separate sub-accounts on which you have the Nerdpack manager role, or to separate sub-accounts under a master account you own or administer. If you add the application to a master account, the access flows to all of its sub-accounts as well. Subscribe to applications that you create You also must have the Nerdpack manager role to subscribe the applications you create to accounts. Applications that you publish and deploy can only be subscribed to the master account that was used to publish them, or to its sub-accounts. This means you might want a New Relic admin to deploy your applications for you if they need to be available across the organization.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.933105,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Permissions for managing <em>applications</em>",
        "sections": "Permissions for managing <em>applications</em>",
        "info": "Learn about permissions for <em>subscribing</em> to apps",
        "tags": "<em>nerdpack</em> manager",
        "body": "Permissions for managing <em>applications</em> When you create an app, you&#x27;ll likely want to share it. From New Relic <em>One</em>&#x27;s Apps page, you can <em>subscribe</em> to apps you create, publish, and deploy, and to other publicly available apps. You must have the <em>Nerdpack</em> manager role to subcribe accounts to apps. Read"
      },
      "id": "5f45bf2864441ffb4dfdcdbb"
    },
    {
      "sections": [
        "Map page views by region in a custom app",
        "Before you begin",
        "New Relic terminology",
        "Build a custom app with a table chart",
        "Query your browser data",
        "Create and serve a new Nerdpack",
        "Review your app files and view your app locally",
        "Hard code your account ID",
        "Import the TableChart component",
        "Add a table with a single row",
        "Customize the look of your table (optional)",
        "Get your data into that table",
        "Make your app interactive with a text field",
        "Import the TextField component",
        "Add a row for your text field",
        "Build the text field object",
        "Get your data on a map",
        "Install Leaflet",
        "Add a webpack config file for Leaflet",
        "Import modules from Leaflet",
        "Import additional modules from New Relic One",
        "Get data for the map",
        "Customize the map marker colors",
        "Set your map's default center point",
        "Add a row for your map",
        "Replace \"Hello\" with the Leaflet code"
      ],
      "title": "Map page views by region in a custom app",
      "type": "developer",
      "tags": [
        "custom app",
        "map",
        "page views",
        "region",
        "nerdpack"
      ],
      "external_id": "6ff5d696556512bb8d8b33fb31732f22bab455cb",
      "image": "https://developer.newrelic.com/static/d87a72e8ee14c52fdfcb91895567d268/0086b/pageview.png",
      "url": "https://developer.newrelic.com/build-apps/map-pageviews-by-region/",
      "published_at": "2020-10-24T01:51:47Z",
      "updated_at": "2020-10-24T01:51:46Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a New Relic app showing page view data on a world map.",
      "body": "Map page views by region in a custom app 30 min New Relic has powerful and flexible tools for building custom apps and populating them with data. This guide shows you how to build a custom app and populate it with page view data using New Relic's Query Language (NRQL - pronounced 'nurkle'). Then you make your data interactive. And last, if you have a little more time and want to install a third-party React library, you can display the page view data you collect on a map of the world. In this guide, you build an app to display page view data in two ways: In a table On a map Please review the Before you begin section to make sure you have everything you need and don't get stuck halfway through. Before you begin In order to get the most out of this guide, you must have: A New Relic developer account, API key, and the command-line tool. If you don't have these yet, see the steps in Setting up your development environment New Relic Browser page view data to populate the app. Without this data, you won't be able to complete this guide. To add your data to a world map in the second half of the guide: npm, which you'll use during this section of the guide to install Leaflet, a third-party JavaScript React library used to build interactive maps. If you're new to React and npm, you can go here to install Node.js and npm. New Relic terminology The following are some terms used in this guide: New Relic application: The finished product where data is rendered in New Relic One. This might look like a series of interactive charts or a map of the world. Nerdpack: New Relic's standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see Nerdpack file structure. Launcher: The button on New Relic One that launches your application. Nerdlets: New Relic React components used to build your application. The three default files are index.js, nr1.json, and styles.scss, but you can customize and add your own. Build a custom app with a table chart Step 1 of 8 Query your browser data Use Query builder to write a NRQL query to see your page view data, as follows. On New Relic One, select Query your data (in the top right corner). That puts you in NRQL mode. You'll use NRQL to test your query before dropping the data into your table. Copy and paste this query into a clear query field, and then select Run. FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000 Copy If you have PageView data, this query shows a week of average page views broken down by country and limited to a thousand items. The table will be full width and use the \"chart\" class defined in the CSS. If you don't have any results at this point, ensure your query doesn't have any errors. If your query is correct, you might not have the Browser agent installed. Step 2 of 8 Create and serve a new Nerdpack To get started, create a new Nerdpack, and serve it up to New Relic from your local development environment: Create a new Nerdpack for this app: bash Copy $ nr1 create --type nerdpack --name pageviews-app ‚úî Component created successfully! nerdpack pageviews-app is available at \"./pageviews-app\" Serve the project up to New Relic: bash Copy $ cd pageviews-app && nr1 nerdpack:serve Found and loaded 2 nr1.json files on PageviewsApp (00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45) Nerdpack. Nerdpack: ‚úî PageviewsApp (00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45) nr1.json Launchers: ‚úî pageviews-app-launcher launchers/pageviews-app-launcher/nr1.json Nerdlets: ‚úî pageviews-app-nerdlet nerdlets/pageviews-app-nerdlet/nr1.json üõ† Built artifact files for: ‚Åé 00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45--pageviews-app-nerdlet built ‚úî ‚úî Nerdpack built successfully! ‚òÖ Starting as orchestrator... ‚úî Server ready! Test it at: https://staging-one.newrelic.com/?nerdpacks=local ‚Ü© Server will reload automatically if you modify any file! üõ† Built artifact files for: ‚Åé 00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45--pageviews-app-nerdlet built ‚úî ‚úî Nerdpack built successfully! Step 3 of 8 Review your app files and view your app locally Navigate to your pageviews-app to see how it's structured. It contains a launcher folder, where you can customize the description and icon that will be displayed on the app's launcher in New Relic One. It also contains nerdlets, which each contain three default files: index.js, nr1.json, and styles.scss. You'll edit some of these files as part of this guide. For more information, see Nerdpack file structure. Now in your browser, open https://one.newrelic.com/?nerdpacks=local, and then click Apps to see the pageview-apps Nerdpack that you served up. When you select the launcher, you see a Hello message. Step 4 of 8 Hard code your account ID For the purposes of this exercise and for your convenience, hard code your account ID. In the pageview-app-nerdlet directory, in the index.js file, add this code between the import and export lines. (Read about finding your account ID here). index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 3 const accountId = 0; // Replace with your account ID 4 5 export default class PageViewApp extends React.Component { 6 render() { 7 return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; 8 } 9 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 5 of 8 Import the TableChart component To show your data in a table chart, import the TableChart component from New Relic One. To do so, in index.js, add this code under import React. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; 9 } 10 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 6 of 8 Add a table with a single row To add a table with a single row, in the index.js file, replace this line with this export code: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"></div> 11 </div> 12 ); 13 } 14 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 7 of 8 Customize the look of your table (optional) You can use standard CSS to customize the look of your components. In the styles.scss file, add this CSS. Feel free to customize this CSS to your taste. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"></div> 11 </div> 12 ); 13 } 14 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 8 of 8 Get your data into that table Now that you've got a table, you can drop a TableChart populated with data from the NRQL query you wrote at the very beginning of this guide. Put this code into the row div. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <TableChart 12 accountId={accountId} 13 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 14 fullWidth 15 className=\"chart\" 16 /> 17 </div> 18 </div> 19 ); 20 } 21 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Go to New Relic One and click your app to see your data in the table. (You might need to serve your app to New Relic again.) Congratulations! You made your app! Continue on to make it interactive and show your data on a map. Make your app interactive with a text field Once you confirm that data is getting to New Relic from your app, you can start customizing it and making it interactive. To do this, you add a text field to filter your data. Later, you use a third-party library called Leaflet to show that data on a world map. Step 1 of 3 Import the TextField component Like you did with the TableChart component, you need to import a TextField component from New Relic One. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <TableChart 12 accountId={accountId} 13 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 14 fullWidth 15 className=\"chart\" 16 /> 17 </div> 18 </div> 19 ); 20 } 21 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 2 of 3 Add a row for your text field To add a text field filter above the table, put this code above the TableChart div. The text field will have a default value of \"US\". index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <div className=\"row\"> 12 <TextField 13 placeholder=\"US\" 14 onChange={(event) => { 15 this.setState({ countryCode: event.target.value }); 16 }} 17 /> 18 </div> 19 <TableChart 20 accountId={accountId} 21 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 22 fullWidth 23 className=\"chart\" 24 /> 25 </div> 26 </div> 27 ); 28 } 29 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 3 of 3 Build the text field object Above the render() function, add a constructor to build the text field object. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 return ( 16 <div className=\"container\"> 17 <div className=\"row\"> 18 <div className=\"row\"> 19 <TextField 20 placeholder=\"US\" 21 onChange={(event) => { 22 this.setState({ countryCode: event.target.value }); 23 }} 24 /> 25 </div> 26 <TableChart 27 accountId={accountId} 28 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 29 fullWidth 30 className=\"chart\" 31 /> 32 </div> 33 </div> 34 ); 35 } 36 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Above return, add: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 31 fullWidth 32 className=\"chart\" 33 /> 34 </div> 35 </div> 36 ); 37 } 38 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Now add countryCode to your table chart query. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Reload your app to try out the text field. Get your data on a map To create the map, you use npm to install Leaflet. Step 1 of 9 Install Leaflet In your terminal, type: bash Copy $ npm install --save leaflet react-leaflet In your nerdlets styles.scss file, import the Leaflet CSS: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy While you're in styles.scss, fix the width and height of your map: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 2 of 9 Add a webpack config file for Leaflet Add a webpack configuration file .extended-webpackrc.js to the top-level folder in your nerdpack. This supports your use of map tiling information data from Leaflet. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 3 of 9 Import modules from Leaflet In index.js, import modules from Leaflet. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 4 5 const accountId = 0; // Replace with your account ID 6 7 export default class PageViewApp extends React.Component { 8 constructor(props) { 9 super(props); 10 this.state = { 11 countryCode: null, 12 }; 13 } 14 15 render() { 16 const { countryCode } = this.state; 17 18 return ( 19 <div className=\"container\"> 20 <div className=\"row\"> 21 <div className=\"row\"> 22 <TextField 23 placeholder=\"US\" 24 onChange={(event) => { 25 this.setState({ countryCode: event.target.value }); 26 }} 27 /> 28 </div> 29 <TableChart 30 accountId={accountId} 31 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 32 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 33 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 34 fullWidth 35 className=\"chart\" 36 /> 37 </div> 38 </div> 39 ); 40 } 41 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 4 of 9 Import additional modules from New Relic One You need several more modules from New Relic One to make the Leaflet map work well. Import them with this code: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 render() { 23 const { countryCode } = this.state; 24 25 return ( 26 <div className=\"container\"> 27 <div className=\"row\"> 28 <div className=\"row\"> 29 <TextField 30 placeholder=\"US\" 31 onChange={(event) => { 32 this.setState({ countryCode: event.target.value }); 33 }} 34 /> 35 </div> 36 <TableChart 37 accountId={accountId} 38 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 39 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 40 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 41 fullWidth 42 className=\"chart\" 43 /> 44 </div> 45 </div> 46 ); 47 } 48 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy NerdGraphQuery lets you make multiple NRQL queries at once and is what will populate the map with data. Spinner adds a loading spinner. Button gives you button components. BlockText give you block text components. Step 5 of 9 Get data for the map Using latitude and longitude with country codes, you can put New Relic data on a map. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 mapData() { 23 const { countryCode } = this.state; 24 const query = `{ 25 actor { 26 account(id: 1606862) { 27 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 28 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 29 } LIMIT 1000 \") { 30 results 31 nrql 32 } 33 } 34 } 35 }`; 36 37 return query; 38 } 39 40 render() { 41 const { countryCode } = this.state; 42 43 return ( 44 <div className=\"container\"> 45 <div className=\"row\"> 46 <div className=\"row\"> 47 <TextField 48 placeholder=\"US\" 49 onChange={(event) => { 50 this.setState({ countryCode: event.target.value }); 51 }} 52 /> 53 </div> 54 <TableChart 55 accountId={accountId} 56 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 57 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 58 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 59 fullWidth 60 className=\"chart\" 61 /> 62 </div> 63 </div> 64 ); 65 } 66 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 6 of 9 Customize the map marker colors Above the mapData function, add this code to customize the map marker colors. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 53 return ( 54 <div className=\"container\"> 55 <div className=\"row\"> 56 <div className=\"row\"> 57 <TextField 58 placeholder=\"US\" 59 onChange={(event) => { 60 this.setState({ countryCode: event.target.value }); 61 }} 62 /> 63 </div> 64 <TableChart 65 accountId={accountId} 66 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 67 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 68 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 69 fullWidth 70 className=\"chart\" 71 /> 72 </div> 73 </div> 74 ); 75 } 76 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Feel free to change the HTML color code values to your taste. In this example, #11A600 is green, #FFD966 is sort of yellow, and #BF0016 is red. Step 7 of 9 Set your map's default center point Set a default center point for your map using latitude and longitude. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <TableChart 66 accountId={accountId} 67 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 68 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 69 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 70 fullWidth 71 className=\"chart\" 72 /> 73 </div> 74 </div> 75 ); 76 } 77 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 8 of 9 Add a row for your map Between the text field row and the table chart row, insert a new row for the map content using NerdGraphQuery. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <div className=\"row\"> 66 <NerdGraphQuery query={this.mapData()}> 67 {({ loading, error, data }) => { 68 if (loading) { 69 return <Spinner fillContainer />; 70 } 71 if (error) { 72 return 'Error'; 73 } 74 const { results } = data.actor.account.mapData; 75 console.debug(results); 76 return 'Hello'; 77 }} 78 </NerdGraphQuery> 79 </div> 80 <TableChart 81 accountId={accountId} 82 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 83 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 84 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 85 fullWidth 86 className=\"chart\" 87 /> 88 </div> 89 </div> 90 ); 91 } 92 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Reload your application in New Relic One to test that it works. Step 9 of 9 Replace \"Hello\" with the Leaflet code Replace return \"Hello\"; with: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <div className=\"row\"> 66 <NerdGraphQuery query={this.mapData()}> 67 {({ loading, error, data }) => { 68 if (loading) { 69 return <Spinner fillContainer />; 70 } 71 if (error) { 72 return 'Error'; 73 } 74 const { results } = data.actor.account.mapData; 75 console.debug(results); 76 77 return ( 78 <Map 79 className=\"containerMap\" 80 center={defaultMapCenter} 81 zoom={2} 82 zoomControl 83 > 84 <TileLayer 85 attribution='&amp;copy <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' 86 url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\" 87 /> 88 {results.map((pt, i) => { 89 const center = [pt.lat, pt.lng]; 90 return ( 91 <CircleMarker 92 key={`circle-${i}`} 93 center={center} 94 color={this.getMarkerColor(pt.y)} 95 radius={Math.log(pt.x) * 3} 96 onClick={() => { 97 alert(JSON.stringify(pt)); 98 }} 99 /> 100 ); 101 })} 102 </Map> 103 ); 104 }} 105 </NerdGraphQuery> 106 </div> 107 <TableChart 108 accountId={accountId} 109 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 110 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 111 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 112 fullWidth 113 className=\"chart\" 114 /> 115 </div> 116 </div> 117 ); 118 } 119 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy This code creates a world map centered on the latitude and longitude you chose using OpenStreetMap data and your marker colors. Reload your app to see the pageview data on the map!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.11934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create and serve a new <em>Nerdpack</em>",
        "tags": "<em>nerdpack</em>",
        "body": ": ‚úî pageviews-app-nerdlet nerdlets&#x2F;pageviews-app-nerdlet&#x2F;<em>nr1</em>.json üõ† Built artifact files for: ‚Åé 00e0f043-<em>1</em>fc3-42cd-a8ca-7eef5fc9cd45--pageviews-app-nerdlet built ‚úî ‚úî <em>Nerdpack</em> built successfully! ‚òÖ Starting as orchestrator... ‚úî Server ready! Test it at: https:&#x2F;&#x2F;staging-<em>one</em>.newrelic.com&#x2F;?nerdpacks=local"
      },
      "id": "5efa993c196a67066b766469"
    }
  ],
  "/build-apps/add-nerdgraphquery-guide": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add the NerdGraphQuery component to an application",
        "Add a table to your app",
        "Permissions for managing applications",
        "Set up your development environment",
        "Publish and deploy apps",
        "Create a custom map view"
      ],
      "published_at": "2020-10-24T01:53:25Z",
      "title": "Build apps",
      "updated_at": "2020-10-24T01:53:25Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 30 min Add a table to your app Add a table to your New Relic One app ¬† Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 30 min Publish and deploy apps Start sharing the apps you build 30 min Create a custom map view Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 724.5477,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add the <em>NerdGraphQuery</em> <em>component</em> to an <em>application</em>",
        "body": " the <em>NerdGraphQuery</em> <em>component</em> to an application The <em>NerdGraphQuery</em> <em>component</em> allows you to <em>query</em> <em>data</em> from your <em>account</em> and add it to a dropdown <em>menu</em> in an application 30 min Add a table to your <em>app</em> Add a table to your New Relic One <em>app</em> ¬† Permissions for managing applications Learn about permissions"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Map page views by region in a custom app",
        "Before you begin",
        "New Relic terminology",
        "Build a custom app with a table chart",
        "Query your browser data",
        "Create and serve a new Nerdpack",
        "Review your app files and view your app locally",
        "Hard code your account ID",
        "Import the TableChart component",
        "Add a table with a single row",
        "Customize the look of your table (optional)",
        "Get your data into that table",
        "Make your app interactive with a text field",
        "Import the TextField component",
        "Add a row for your text field",
        "Build the text field object",
        "Get your data on a map",
        "Install Leaflet",
        "Add a webpack config file for Leaflet",
        "Import modules from Leaflet",
        "Import additional modules from New Relic One",
        "Get data for the map",
        "Customize the map marker colors",
        "Set your map's default center point",
        "Add a row for your map",
        "Replace \"Hello\" with the Leaflet code"
      ],
      "title": "Map page views by region in a custom app",
      "type": "developer",
      "tags": [
        "custom app",
        "map",
        "page views",
        "region",
        "nerdpack"
      ],
      "external_id": "6ff5d696556512bb8d8b33fb31732f22bab455cb",
      "image": "https://developer.newrelic.com/static/d87a72e8ee14c52fdfcb91895567d268/0086b/pageview.png",
      "url": "https://developer.newrelic.com/build-apps/map-pageviews-by-region/",
      "published_at": "2020-10-24T01:51:47Z",
      "updated_at": "2020-10-24T01:51:46Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a New Relic app showing page view data on a world map.",
      "body": "Map page views by region in a custom app 30 min New Relic has powerful and flexible tools for building custom apps and populating them with data. This guide shows you how to build a custom app and populate it with page view data using New Relic's Query Language (NRQL - pronounced 'nurkle'). Then you make your data interactive. And last, if you have a little more time and want to install a third-party React library, you can display the page view data you collect on a map of the world. In this guide, you build an app to display page view data in two ways: In a table On a map Please review the Before you begin section to make sure you have everything you need and don't get stuck halfway through. Before you begin In order to get the most out of this guide, you must have: A New Relic developer account, API key, and the command-line tool. If you don't have these yet, see the steps in Setting up your development environment New Relic Browser page view data to populate the app. Without this data, you won't be able to complete this guide. To add your data to a world map in the second half of the guide: npm, which you'll use during this section of the guide to install Leaflet, a third-party JavaScript React library used to build interactive maps. If you're new to React and npm, you can go here to install Node.js and npm. New Relic terminology The following are some terms used in this guide: New Relic application: The finished product where data is rendered in New Relic One. This might look like a series of interactive charts or a map of the world. Nerdpack: New Relic's standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see Nerdpack file structure. Launcher: The button on New Relic One that launches your application. Nerdlets: New Relic React components used to build your application. The three default files are index.js, nr1.json, and styles.scss, but you can customize and add your own. Build a custom app with a table chart Step 1 of 8 Query your browser data Use Query builder to write a NRQL query to see your page view data, as follows. On New Relic One, select Query your data (in the top right corner). That puts you in NRQL mode. You'll use NRQL to test your query before dropping the data into your table. Copy and paste this query into a clear query field, and then select Run. FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000 Copy If you have PageView data, this query shows a week of average page views broken down by country and limited to a thousand items. The table will be full width and use the \"chart\" class defined in the CSS. If you don't have any results at this point, ensure your query doesn't have any errors. If your query is correct, you might not have the Browser agent installed. Step 2 of 8 Create and serve a new Nerdpack To get started, create a new Nerdpack, and serve it up to New Relic from your local development environment: Create a new Nerdpack for this app: bash Copy $ nr1 create --type nerdpack --name pageviews-app ‚úî Component created successfully! nerdpack pageviews-app is available at \"./pageviews-app\" Serve the project up to New Relic: bash Copy $ cd pageviews-app && nr1 nerdpack:serve Found and loaded 2 nr1.json files on PageviewsApp (00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45) Nerdpack. Nerdpack: ‚úî PageviewsApp (00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45) nr1.json Launchers: ‚úî pageviews-app-launcher launchers/pageviews-app-launcher/nr1.json Nerdlets: ‚úî pageviews-app-nerdlet nerdlets/pageviews-app-nerdlet/nr1.json üõ† Built artifact files for: ‚Åé 00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45--pageviews-app-nerdlet built ‚úî ‚úî Nerdpack built successfully! ‚òÖ Starting as orchestrator... ‚úî Server ready! Test it at: https://staging-one.newrelic.com/?nerdpacks=local ‚Ü© Server will reload automatically if you modify any file! üõ† Built artifact files for: ‚Åé 00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45--pageviews-app-nerdlet built ‚úî ‚úî Nerdpack built successfully! Step 3 of 8 Review your app files and view your app locally Navigate to your pageviews-app to see how it's structured. It contains a launcher folder, where you can customize the description and icon that will be displayed on the app's launcher in New Relic One. It also contains nerdlets, which each contain three default files: index.js, nr1.json, and styles.scss. You'll edit some of these files as part of this guide. For more information, see Nerdpack file structure. Now in your browser, open https://one.newrelic.com/?nerdpacks=local, and then click Apps to see the pageview-apps Nerdpack that you served up. When you select the launcher, you see a Hello message. Step 4 of 8 Hard code your account ID For the purposes of this exercise and for your convenience, hard code your account ID. In the pageview-app-nerdlet directory, in the index.js file, add this code between the import and export lines. (Read about finding your account ID here). index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 3 const accountId = 0; // Replace with your account ID 4 5 export default class PageViewApp extends React.Component { 6 render() { 7 return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; 8 } 9 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 5 of 8 Import the TableChart component To show your data in a table chart, import the TableChart component from New Relic One. To do so, in index.js, add this code under import React. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; 9 } 10 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 6 of 8 Add a table with a single row To add a table with a single row, in the index.js file, replace this line with this export code: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"></div> 11 </div> 12 ); 13 } 14 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 7 of 8 Customize the look of your table (optional) You can use standard CSS to customize the look of your components. In the styles.scss file, add this CSS. Feel free to customize this CSS to your taste. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"></div> 11 </div> 12 ); 13 } 14 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 8 of 8 Get your data into that table Now that you've got a table, you can drop a TableChart populated with data from the NRQL query you wrote at the very beginning of this guide. Put this code into the row div. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <TableChart 12 accountId={accountId} 13 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 14 fullWidth 15 className=\"chart\" 16 /> 17 </div> 18 </div> 19 ); 20 } 21 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Go to New Relic One and click your app to see your data in the table. (You might need to serve your app to New Relic again.) Congratulations! You made your app! Continue on to make it interactive and show your data on a map. Make your app interactive with a text field Once you confirm that data is getting to New Relic from your app, you can start customizing it and making it interactive. To do this, you add a text field to filter your data. Later, you use a third-party library called Leaflet to show that data on a world map. Step 1 of 3 Import the TextField component Like you did with the TableChart component, you need to import a TextField component from New Relic One. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <TableChart 12 accountId={accountId} 13 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 14 fullWidth 15 className=\"chart\" 16 /> 17 </div> 18 </div> 19 ); 20 } 21 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 2 of 3 Add a row for your text field To add a text field filter above the table, put this code above the TableChart div. The text field will have a default value of \"US\". index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <div className=\"row\"> 12 <TextField 13 placeholder=\"US\" 14 onChange={(event) => { 15 this.setState({ countryCode: event.target.value }); 16 }} 17 /> 18 </div> 19 <TableChart 20 accountId={accountId} 21 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 22 fullWidth 23 className=\"chart\" 24 /> 25 </div> 26 </div> 27 ); 28 } 29 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 3 of 3 Build the text field object Above the render() function, add a constructor to build the text field object. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 return ( 16 <div className=\"container\"> 17 <div className=\"row\"> 18 <div className=\"row\"> 19 <TextField 20 placeholder=\"US\" 21 onChange={(event) => { 22 this.setState({ countryCode: event.target.value }); 23 }} 24 /> 25 </div> 26 <TableChart 27 accountId={accountId} 28 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 29 fullWidth 30 className=\"chart\" 31 /> 32 </div> 33 </div> 34 ); 35 } 36 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Above return, add: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 31 fullWidth 32 className=\"chart\" 33 /> 34 </div> 35 </div> 36 ); 37 } 38 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Now add countryCode to your table chart query. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Reload your app to try out the text field. Get your data on a map To create the map, you use npm to install Leaflet. Step 1 of 9 Install Leaflet In your terminal, type: bash Copy $ npm install --save leaflet react-leaflet In your nerdlets styles.scss file, import the Leaflet CSS: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy While you're in styles.scss, fix the width and height of your map: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 2 of 9 Add a webpack config file for Leaflet Add a webpack configuration file .extended-webpackrc.js to the top-level folder in your nerdpack. This supports your use of map tiling information data from Leaflet. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 3 of 9 Import modules from Leaflet In index.js, import modules from Leaflet. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 4 5 const accountId = 0; // Replace with your account ID 6 7 export default class PageViewApp extends React.Component { 8 constructor(props) { 9 super(props); 10 this.state = { 11 countryCode: null, 12 }; 13 } 14 15 render() { 16 const { countryCode } = this.state; 17 18 return ( 19 <div className=\"container\"> 20 <div className=\"row\"> 21 <div className=\"row\"> 22 <TextField 23 placeholder=\"US\" 24 onChange={(event) => { 25 this.setState({ countryCode: event.target.value }); 26 }} 27 /> 28 </div> 29 <TableChart 30 accountId={accountId} 31 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 32 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 33 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 34 fullWidth 35 className=\"chart\" 36 /> 37 </div> 38 </div> 39 ); 40 } 41 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 4 of 9 Import additional modules from New Relic One You need several more modules from New Relic One to make the Leaflet map work well. Import them with this code: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 render() { 23 const { countryCode } = this.state; 24 25 return ( 26 <div className=\"container\"> 27 <div className=\"row\"> 28 <div className=\"row\"> 29 <TextField 30 placeholder=\"US\" 31 onChange={(event) => { 32 this.setState({ countryCode: event.target.value }); 33 }} 34 /> 35 </div> 36 <TableChart 37 accountId={accountId} 38 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 39 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 40 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 41 fullWidth 42 className=\"chart\" 43 /> 44 </div> 45 </div> 46 ); 47 } 48 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy NerdGraphQuery lets you make multiple NRQL queries at once and is what will populate the map with data. Spinner adds a loading spinner. Button gives you button components. BlockText give you block text components. Step 5 of 9 Get data for the map Using latitude and longitude with country codes, you can put New Relic data on a map. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 mapData() { 23 const { countryCode } = this.state; 24 const query = `{ 25 actor { 26 account(id: 1606862) { 27 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 28 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 29 } LIMIT 1000 \") { 30 results 31 nrql 32 } 33 } 34 } 35 }`; 36 37 return query; 38 } 39 40 render() { 41 const { countryCode } = this.state; 42 43 return ( 44 <div className=\"container\"> 45 <div className=\"row\"> 46 <div className=\"row\"> 47 <TextField 48 placeholder=\"US\" 49 onChange={(event) => { 50 this.setState({ countryCode: event.target.value }); 51 }} 52 /> 53 </div> 54 <TableChart 55 accountId={accountId} 56 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 57 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 58 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 59 fullWidth 60 className=\"chart\" 61 /> 62 </div> 63 </div> 64 ); 65 } 66 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 6 of 9 Customize the map marker colors Above the mapData function, add this code to customize the map marker colors. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 53 return ( 54 <div className=\"container\"> 55 <div className=\"row\"> 56 <div className=\"row\"> 57 <TextField 58 placeholder=\"US\" 59 onChange={(event) => { 60 this.setState({ countryCode: event.target.value }); 61 }} 62 /> 63 </div> 64 <TableChart 65 accountId={accountId} 66 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 67 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 68 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 69 fullWidth 70 className=\"chart\" 71 /> 72 </div> 73 </div> 74 ); 75 } 76 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Feel free to change the HTML color code values to your taste. In this example, #11A600 is green, #FFD966 is sort of yellow, and #BF0016 is red. Step 7 of 9 Set your map's default center point Set a default center point for your map using latitude and longitude. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <TableChart 66 accountId={accountId} 67 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 68 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 69 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 70 fullWidth 71 className=\"chart\" 72 /> 73 </div> 74 </div> 75 ); 76 } 77 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 8 of 9 Add a row for your map Between the text field row and the table chart row, insert a new row for the map content using NerdGraphQuery. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <div className=\"row\"> 66 <NerdGraphQuery query={this.mapData()}> 67 {({ loading, error, data }) => { 68 if (loading) { 69 return <Spinner fillContainer />; 70 } 71 if (error) { 72 return 'Error'; 73 } 74 const { results } = data.actor.account.mapData; 75 console.debug(results); 76 return 'Hello'; 77 }} 78 </NerdGraphQuery> 79 </div> 80 <TableChart 81 accountId={accountId} 82 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 83 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 84 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 85 fullWidth 86 className=\"chart\" 87 /> 88 </div> 89 </div> 90 ); 91 } 92 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Reload your application in New Relic One to test that it works. Step 9 of 9 Replace \"Hello\" with the Leaflet code Replace return \"Hello\"; with: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <div className=\"row\"> 66 <NerdGraphQuery query={this.mapData()}> 67 {({ loading, error, data }) => { 68 if (loading) { 69 return <Spinner fillContainer />; 70 } 71 if (error) { 72 return 'Error'; 73 } 74 const { results } = data.actor.account.mapData; 75 console.debug(results); 76 77 return ( 78 <Map 79 className=\"containerMap\" 80 center={defaultMapCenter} 81 zoom={2} 82 zoomControl 83 > 84 <TileLayer 85 attribution='&amp;copy <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' 86 url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\" 87 /> 88 {results.map((pt, i) => { 89 const center = [pt.lat, pt.lng]; 90 return ( 91 <CircleMarker 92 key={`circle-${i}`} 93 center={center} 94 color={this.getMarkerColor(pt.y)} 95 radius={Math.log(pt.x) * 3} 96 onClick={() => { 97 alert(JSON.stringify(pt)); 98 }} 99 /> 100 ); 101 })} 102 </Map> 103 ); 104 }} 105 </NerdGraphQuery> 106 </div> 107 <TableChart 108 accountId={accountId} 109 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 110 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 111 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 112 fullWidth 113 className=\"chart\" 114 /> 115 </div> 116 </div> 117 ); 118 } 119 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy This code creates a world map centered on the latitude and longitude you chose using OpenStreetMap data and your marker colors. Reload your app to see the pageview data on the map!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 560.22876,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map page views by region in a custom <em>app</em>",
        "sections": "<em>Query</em> your browser <em>data</em>",
        "info": "Build a New Relic <em>app</em> showing page view <em>data</em> on a world map.",
        "tags": "custom <em>app</em>",
        "body": ": event.target.value }); 62 }} 63 &#x2F;&gt; 64 &lt;&#x2F;div&gt; 65 &lt;div className=&quot;row&quot;&gt; 66 &lt;<em>NerdGraphQuery</em> <em>query</em>={this.map<em>Data</em>()}&gt; 67 {({ loading, error, <em>data</em> }) =&gt; { 68 if (loading) { 69 return &lt;Spinner fillContainer &#x2F;&gt;; 70 } 71 if (error) { 72 return &#x27;Error&#x27;; 73 } 74 const { results } = <em>data.actor.account.mapData</em>; 75"
      },
      "id": "5efa993c196a67066b766469"
    },
    {
      "sections": [
        "Explore NerdGraph using the API Explorer",
        "Before you begin",
        "Build a query to retrieve your name",
        "Click the play button to see the result",
        "Add more fields to your query",
        "Experiment with mutations",
        "Tip",
        "Try your NerdGraph query in the terminal",
        "Next steps"
      ],
      "title": "Explore NerdGraph using the API Explorer",
      "type": "developer",
      "tags": [
        "nerdgraph",
        "mutations",
        "nerdgraph query terminal"
      ],
      "external_id": "df1f04edc2336c69769d946edbaf263a5339bc92",
      "image": "https://developer.newrelic.com/static/0ce8c387a290d7fbd6be155322be9bce/bc8d6/create-account.png",
      "url": "https://developer.newrelic.com/collect-data/get-started-nerdgraph-api-explorer/",
      "published_at": "2020-10-24T01:53:26Z",
      "updated_at": "2020-10-24T01:53:26Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Explore NerdGraph, our GraphQL API, and build the queries you need.",
      "body": "Explore NerdGraph using the API Explorer 25 min NerdGraph is New Relic's GraphQL API. It allows you to get all the information you need in a single request. With NerdGraph API Explorer you don't need to know the query format: using the Query Builder you can browse our entire graph and compose queries just by selecting the items you want and filling out their required values. Before you begin Go to api.newrelic.com/graphiql and log in using your New Relic user ID and password: the NerdGraph API Explorer loads up. Make sure you have a valid New Relic API key. You can create one directly from the NerdGraph API Explorer. Step 1 of 5 Build a query to retrieve your name Time for your first NerdGraph query. Search for your name in the New Relic database: Erase everything in the query editor. Select the following fields in the query explorer in this order: actor, user, name. This GraphQL snippet appears in the editor. { actor { user { name } } } Copy Step 2 of 5 Click the play button to see the result With this query, you're telling NerdGraph to retrieve your name. You're asking for the name field, which is nested within the user field. This refers to the user who owns the API key, which in turn is nested within actor. Click the play button to see the result: It has almost the same shape as the request. All the fields in the Query Builder make up what's called the GraphQL schema, which describes all the available data types and their attributes. To learn more about each field, click the Docs button, or hover over a field in the editor. Step 3 of 5 Add more fields to your query Now you can try adding more fields to your query. The simplest way is clicking the fields in the Query Builder: The API Explorer knows where the attributes should go in the query. In the example, you add the account id and email fields. Once again, running the GraphQL query results in just the data you need, without over or under-fetching data. Notice that the id field has an argument: passing arguments is a powerful way of customizing your NerdGraph queries. Every field and object can contain arguments, so instead of running multiple queries, you just compose the one that you need. { actor { user { name email } account(id: 12345678) } } Copy Step 4 of 5 Experiment with mutations In GraphQL, mutations are a way to execute queries with side effects that can alter the data by creating, updating, or deleting objects (Commonly referred to as CRUD operations in REST APIs). Ready for your first mutation? Erase what's in the editor. Scroll down the Query Builder and expand mutation. Select the fields in the following screenshot: In this case, you're trying to add a custom tag to an entity. Notice that the editor complains if you don't select errors: mutations must have a way of telling you how the operation performed in the backend (failed requests result in null responses). Tip Unlike REST, GraphQL APIs like NerdGraph can return partial responses. For example, if you try adding tags to multiple entities, some mutations can fail and others succeed; all is logged in the GraphQL response you get. Step 5 of 5 Try your NerdGraph query in the terminal Let's say that you've built a NerdGraph query you're happy with and you want to test it elsewhere. To capture code-ready queries and mutations: Select the Tools menu. Copy the query as a curl call or as a New Relic CLI command. bash Copy $ # curl version $ curl https://api.newrelic.com/graphql \\ > -H 'Content-Type: application/json' \\ > -H 'API-Key: API_KEY_REDACTED' \\ > --data-binary '{\"query\":\"{\\n actor {\\n user {\\n name\\n email\\n }\\n account(id: 12345678)\\n }\\n}\\n\", \"variables\":\"\"}' $ $ # New Relic CLI version $ newrelic nerdgraph query '{ $ actor { $ user { $ name $ email $ } $ account(id: 12345678) $ } $ } $ ' Next steps Now you know the basics of composing and testing NerdGraph queries, but how do you turn them into client or server code? Solutions such as GraphQL Code Generator can help you turn the NerdGraph queries into code for your implementation. Try creating more complex queries by clicking fields and expanding objects in the Query Builder (be careful with mutations though, since they could write data to your account). For more information on NerdGraph and explore other projects from the developer community, check out the threads on the Explorer‚Äôs Hub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 531.1537,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Explore <em>NerdGraph</em> using the API Explorer",
        "sections": "Try your <em>NerdGraph</em> <em>query</em> in the terminal",
        "info": "Explore <em>NerdGraph</em>, our <em>GraphQL</em> API, and build the <em>queries</em> you need.",
        "tags": "<em>nerdgraph</em> <em>query</em> terminal",
        "body": " the <em>account</em> id and email fields. Once again, running the <em>Graph</em>QL <em>query</em> results in just the <em>data</em> you need, without over or under-fetching <em>data</em>. Notice that the id field has an argument: passing arguments is a powerful way of customizing your <em>NerdGraph</em> queries. Every field and object can contain"
      },
      "id": "5efa9973196a6791f4766402"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-10-24T02:00:01Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 403.51843,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>NerdStorage</em>",
        "sections": "Use <em>NerdStorage</em> in your <em>apps</em>",
        "info": "Intro to <em>NerdStorage</em> on New Relic One",
        "tags": "<em>nerdstorage</em> <em>components</em>",
        "body": " document can have a maximum length of 1024 KiB when serialized. <em>Data</em> access To access <em>Nerd</em>Storage, you can run <em>NerdGraph</em> queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorage<em>Query</em>"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "Intro to NerdStorageVault",
        "Using NerdStorageVault in your apps",
        "Tip",
        "Usage considerations",
        "Component library",
        "NerdGraph queries",
        "Write",
        "Delete",
        "Fetch a single secret",
        "Fetch a list of secrets",
        "Limits",
        "Permissions for working with NerdStorageVault"
      ],
      "title": "Intro to NerdStorageVault",
      "type": "developer",
      "tags": [
        "nerdstoragevault",
        "nerdstoragevault components",
        "new relic one apps",
        "data access",
        "encrypted storage"
      ],
      "external_id": "8355de4bf337963434c4d3b90f5d9c32f58e4bcc",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstoragevault/",
      "published_at": "2020-10-24T01:54:35Z",
      "updated_at": "2020-10-24T01:54:35Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorageVault on New Relic One",
      "body": "Intro to NerdStorageVault 15 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data such as: personal access tokens license keys API keys other third party secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorageVault can currently only be used within the context of a Nerdpack. You cannot make a direct query or mutation to NerdStorageVault. You can explore the fields and response types via the NerdGraph API explorer. The only supported scope is ACTOR, or data that relates to a particular user. Component library Currently NerdStorageVault is available in the alpha release of Nr1 Community component library and is not available in the Nr1 core components library. Open source components can be use to augment Nr1 core components for additional functionality. NerdGraph queries Below are examples of the queries used by the components to interact with NerdStorageVault. Tip NerdStorageVault can currently only be used within the context of a Nerdpack. Write mutation { nerdStorageVaultWriteSecret(scope: { actor: CURRENT_USER } , secret: { key: \"test\", value: \"secret_test\" } ) { status errors { message type } } } Copy Delete mutation { nerdStorageVaultDeleteSecret(scope: { actor: CURRENT_USER } , key: \"test_key\" ) { status errors { message type } } } Copy Fetch a single secret { actor { nerdStorageVault { secret(key: \"test_key\") { key value } } } } Copy Fetch a list of secrets { actor { nerdStorageVault { secrets { key value } } } } Copy Limits A maximum of 10 secrets can be stored per ACTOR. A secret value is limited to 5000 characters. A key value is limited to 64 characters. Permissions for working with NerdStorageVault In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 382.27484,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>NerdStorageVault</em>",
        "sections": "Using <em>NerdStorageVault</em> in your <em>apps</em>",
        "info": "Intro to <em>NerdStorageVault</em> on New Relic One",
        "tags": "<em>nerdstoragevault</em> <em>components</em>",
        "body": " currently only be used within the context of a Nerdpack. You cannot make a direct <em>query</em> or mutation to <em>Nerd</em>StorageVault. You can explore the fields and response types via the <em>NerdGraph</em> API explorer. The only supported scope is ACTOR, or <em>data</em> that relates to a particular user. <em>Component</em> library Currently"
      },
      "id": "5f865b55196a675792bd5340"
    }
  ],
  "/build-apps/howto-use-nrone-table-components": [
    {
      "sections": [
        "Map page views by region in a custom app",
        "Before you begin",
        "New Relic terminology",
        "Build a custom app with a table chart",
        "Query your browser data",
        "Create and serve a new Nerdpack",
        "Review your app files and view your app locally",
        "Hard code your account ID",
        "Import the TableChart component",
        "Add a table with a single row",
        "Customize the look of your table (optional)",
        "Get your data into that table",
        "Make your app interactive with a text field",
        "Import the TextField component",
        "Add a row for your text field",
        "Build the text field object",
        "Get your data on a map",
        "Install Leaflet",
        "Add a webpack config file for Leaflet",
        "Import modules from Leaflet",
        "Import additional modules from New Relic One",
        "Get data for the map",
        "Customize the map marker colors",
        "Set your map's default center point",
        "Add a row for your map",
        "Replace \"Hello\" with the Leaflet code"
      ],
      "title": "Map page views by region in a custom app",
      "type": "developer",
      "tags": [
        "custom app",
        "map",
        "page views",
        "region",
        "nerdpack"
      ],
      "external_id": "6ff5d696556512bb8d8b33fb31732f22bab455cb",
      "image": "https://developer.newrelic.com/static/d87a72e8ee14c52fdfcb91895567d268/0086b/pageview.png",
      "url": "https://developer.newrelic.com/build-apps/map-pageviews-by-region/",
      "published_at": "2020-10-24T01:51:47Z",
      "updated_at": "2020-10-24T01:51:46Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a New Relic app showing page view data on a world map.",
      "body": "Map page views by region in a custom app 30 min New Relic has powerful and flexible tools for building custom apps and populating them with data. This guide shows you how to build a custom app and populate it with page view data using New Relic's Query Language (NRQL - pronounced 'nurkle'). Then you make your data interactive. And last, if you have a little more time and want to install a third-party React library, you can display the page view data you collect on a map of the world. In this guide, you build an app to display page view data in two ways: In a table On a map Please review the Before you begin section to make sure you have everything you need and don't get stuck halfway through. Before you begin In order to get the most out of this guide, you must have: A New Relic developer account, API key, and the command-line tool. If you don't have these yet, see the steps in Setting up your development environment New Relic Browser page view data to populate the app. Without this data, you won't be able to complete this guide. To add your data to a world map in the second half of the guide: npm, which you'll use during this section of the guide to install Leaflet, a third-party JavaScript React library used to build interactive maps. If you're new to React and npm, you can go here to install Node.js and npm. New Relic terminology The following are some terms used in this guide: New Relic application: The finished product where data is rendered in New Relic One. This might look like a series of interactive charts or a map of the world. Nerdpack: New Relic's standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see Nerdpack file structure. Launcher: The button on New Relic One that launches your application. Nerdlets: New Relic React components used to build your application. The three default files are index.js, nr1.json, and styles.scss, but you can customize and add your own. Build a custom app with a table chart Step 1 of 8 Query your browser data Use Query builder to write a NRQL query to see your page view data, as follows. On New Relic One, select Query your data (in the top right corner). That puts you in NRQL mode. You'll use NRQL to test your query before dropping the data into your table. Copy and paste this query into a clear query field, and then select Run. FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000 Copy If you have PageView data, this query shows a week of average page views broken down by country and limited to a thousand items. The table will be full width and use the \"chart\" class defined in the CSS. If you don't have any results at this point, ensure your query doesn't have any errors. If your query is correct, you might not have the Browser agent installed. Step 2 of 8 Create and serve a new Nerdpack To get started, create a new Nerdpack, and serve it up to New Relic from your local development environment: Create a new Nerdpack for this app: bash Copy $ nr1 create --type nerdpack --name pageviews-app ‚úî Component created successfully! nerdpack pageviews-app is available at \"./pageviews-app\" Serve the project up to New Relic: bash Copy $ cd pageviews-app && nr1 nerdpack:serve Found and loaded 2 nr1.json files on PageviewsApp (00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45) Nerdpack. Nerdpack: ‚úî PageviewsApp (00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45) nr1.json Launchers: ‚úî pageviews-app-launcher launchers/pageviews-app-launcher/nr1.json Nerdlets: ‚úî pageviews-app-nerdlet nerdlets/pageviews-app-nerdlet/nr1.json üõ† Built artifact files for: ‚Åé 00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45--pageviews-app-nerdlet built ‚úî ‚úî Nerdpack built successfully! ‚òÖ Starting as orchestrator... ‚úî Server ready! Test it at: https://staging-one.newrelic.com/?nerdpacks=local ‚Ü© Server will reload automatically if you modify any file! üõ† Built artifact files for: ‚Åé 00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45--pageviews-app-nerdlet built ‚úî ‚úî Nerdpack built successfully! Step 3 of 8 Review your app files and view your app locally Navigate to your pageviews-app to see how it's structured. It contains a launcher folder, where you can customize the description and icon that will be displayed on the app's launcher in New Relic One. It also contains nerdlets, which each contain three default files: index.js, nr1.json, and styles.scss. You'll edit some of these files as part of this guide. For more information, see Nerdpack file structure. Now in your browser, open https://one.newrelic.com/?nerdpacks=local, and then click Apps to see the pageview-apps Nerdpack that you served up. When you select the launcher, you see a Hello message. Step 4 of 8 Hard code your account ID For the purposes of this exercise and for your convenience, hard code your account ID. In the pageview-app-nerdlet directory, in the index.js file, add this code between the import and export lines. (Read about finding your account ID here). index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 3 const accountId = 0; // Replace with your account ID 4 5 export default class PageViewApp extends React.Component { 6 render() { 7 return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; 8 } 9 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 5 of 8 Import the TableChart component To show your data in a table chart, import the TableChart component from New Relic One. To do so, in index.js, add this code under import React. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; 9 } 10 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 6 of 8 Add a table with a single row To add a table with a single row, in the index.js file, replace this line with this export code: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"></div> 11 </div> 12 ); 13 } 14 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 7 of 8 Customize the look of your table (optional) You can use standard CSS to customize the look of your components. In the styles.scss file, add this CSS. Feel free to customize this CSS to your taste. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"></div> 11 </div> 12 ); 13 } 14 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 8 of 8 Get your data into that table Now that you've got a table, you can drop a TableChart populated with data from the NRQL query you wrote at the very beginning of this guide. Put this code into the row div. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <TableChart 12 accountId={accountId} 13 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 14 fullWidth 15 className=\"chart\" 16 /> 17 </div> 18 </div> 19 ); 20 } 21 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Go to New Relic One and click your app to see your data in the table. (You might need to serve your app to New Relic again.) Congratulations! You made your app! Continue on to make it interactive and show your data on a map. Make your app interactive with a text field Once you confirm that data is getting to New Relic from your app, you can start customizing it and making it interactive. To do this, you add a text field to filter your data. Later, you use a third-party library called Leaflet to show that data on a world map. Step 1 of 3 Import the TextField component Like you did with the TableChart component, you need to import a TextField component from New Relic One. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <TableChart 12 accountId={accountId} 13 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 14 fullWidth 15 className=\"chart\" 16 /> 17 </div> 18 </div> 19 ); 20 } 21 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 2 of 3 Add a row for your text field To add a text field filter above the table, put this code above the TableChart div. The text field will have a default value of \"US\". index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <div className=\"row\"> 12 <TextField 13 placeholder=\"US\" 14 onChange={(event) => { 15 this.setState({ countryCode: event.target.value }); 16 }} 17 /> 18 </div> 19 <TableChart 20 accountId={accountId} 21 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 22 fullWidth 23 className=\"chart\" 24 /> 25 </div> 26 </div> 27 ); 28 } 29 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 3 of 3 Build the text field object Above the render() function, add a constructor to build the text field object. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 return ( 16 <div className=\"container\"> 17 <div className=\"row\"> 18 <div className=\"row\"> 19 <TextField 20 placeholder=\"US\" 21 onChange={(event) => { 22 this.setState({ countryCode: event.target.value }); 23 }} 24 /> 25 </div> 26 <TableChart 27 accountId={accountId} 28 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 29 fullWidth 30 className=\"chart\" 31 /> 32 </div> 33 </div> 34 ); 35 } 36 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Above return, add: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 31 fullWidth 32 className=\"chart\" 33 /> 34 </div> 35 </div> 36 ); 37 } 38 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Now add countryCode to your table chart query. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Reload your app to try out the text field. Get your data on a map To create the map, you use npm to install Leaflet. Step 1 of 9 Install Leaflet In your terminal, type: bash Copy $ npm install --save leaflet react-leaflet In your nerdlets styles.scss file, import the Leaflet CSS: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy While you're in styles.scss, fix the width and height of your map: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 2 of 9 Add a webpack config file for Leaflet Add a webpack configuration file .extended-webpackrc.js to the top-level folder in your nerdpack. This supports your use of map tiling information data from Leaflet. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 3 of 9 Import modules from Leaflet In index.js, import modules from Leaflet. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 4 5 const accountId = 0; // Replace with your account ID 6 7 export default class PageViewApp extends React.Component { 8 constructor(props) { 9 super(props); 10 this.state = { 11 countryCode: null, 12 }; 13 } 14 15 render() { 16 const { countryCode } = this.state; 17 18 return ( 19 <div className=\"container\"> 20 <div className=\"row\"> 21 <div className=\"row\"> 22 <TextField 23 placeholder=\"US\" 24 onChange={(event) => { 25 this.setState({ countryCode: event.target.value }); 26 }} 27 /> 28 </div> 29 <TableChart 30 accountId={accountId} 31 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 32 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 33 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 34 fullWidth 35 className=\"chart\" 36 /> 37 </div> 38 </div> 39 ); 40 } 41 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 4 of 9 Import additional modules from New Relic One You need several more modules from New Relic One to make the Leaflet map work well. Import them with this code: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 render() { 23 const { countryCode } = this.state; 24 25 return ( 26 <div className=\"container\"> 27 <div className=\"row\"> 28 <div className=\"row\"> 29 <TextField 30 placeholder=\"US\" 31 onChange={(event) => { 32 this.setState({ countryCode: event.target.value }); 33 }} 34 /> 35 </div> 36 <TableChart 37 accountId={accountId} 38 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 39 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 40 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 41 fullWidth 42 className=\"chart\" 43 /> 44 </div> 45 </div> 46 ); 47 } 48 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy NerdGraphQuery lets you make multiple NRQL queries at once and is what will populate the map with data. Spinner adds a loading spinner. Button gives you button components. BlockText give you block text components. Step 5 of 9 Get data for the map Using latitude and longitude with country codes, you can put New Relic data on a map. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 mapData() { 23 const { countryCode } = this.state; 24 const query = `{ 25 actor { 26 account(id: 1606862) { 27 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 28 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 29 } LIMIT 1000 \") { 30 results 31 nrql 32 } 33 } 34 } 35 }`; 36 37 return query; 38 } 39 40 render() { 41 const { countryCode } = this.state; 42 43 return ( 44 <div className=\"container\"> 45 <div className=\"row\"> 46 <div className=\"row\"> 47 <TextField 48 placeholder=\"US\" 49 onChange={(event) => { 50 this.setState({ countryCode: event.target.value }); 51 }} 52 /> 53 </div> 54 <TableChart 55 accountId={accountId} 56 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 57 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 58 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 59 fullWidth 60 className=\"chart\" 61 /> 62 </div> 63 </div> 64 ); 65 } 66 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 6 of 9 Customize the map marker colors Above the mapData function, add this code to customize the map marker colors. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 53 return ( 54 <div className=\"container\"> 55 <div className=\"row\"> 56 <div className=\"row\"> 57 <TextField 58 placeholder=\"US\" 59 onChange={(event) => { 60 this.setState({ countryCode: event.target.value }); 61 }} 62 /> 63 </div> 64 <TableChart 65 accountId={accountId} 66 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 67 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 68 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 69 fullWidth 70 className=\"chart\" 71 /> 72 </div> 73 </div> 74 ); 75 } 76 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Feel free to change the HTML color code values to your taste. In this example, #11A600 is green, #FFD966 is sort of yellow, and #BF0016 is red. Step 7 of 9 Set your map's default center point Set a default center point for your map using latitude and longitude. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <TableChart 66 accountId={accountId} 67 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 68 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 69 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 70 fullWidth 71 className=\"chart\" 72 /> 73 </div> 74 </div> 75 ); 76 } 77 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 8 of 9 Add a row for your map Between the text field row and the table chart row, insert a new row for the map content using NerdGraphQuery. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <div className=\"row\"> 66 <NerdGraphQuery query={this.mapData()}> 67 {({ loading, error, data }) => { 68 if (loading) { 69 return <Spinner fillContainer />; 70 } 71 if (error) { 72 return 'Error'; 73 } 74 const { results } = data.actor.account.mapData; 75 console.debug(results); 76 return 'Hello'; 77 }} 78 </NerdGraphQuery> 79 </div> 80 <TableChart 81 accountId={accountId} 82 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 83 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 84 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 85 fullWidth 86 className=\"chart\" 87 /> 88 </div> 89 </div> 90 ); 91 } 92 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Reload your application in New Relic One to test that it works. Step 9 of 9 Replace \"Hello\" with the Leaflet code Replace return \"Hello\"; with: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <div className=\"row\"> 66 <NerdGraphQuery query={this.mapData()}> 67 {({ loading, error, data }) => { 68 if (loading) { 69 return <Spinner fillContainer />; 70 } 71 if (error) { 72 return 'Error'; 73 } 74 const { results } = data.actor.account.mapData; 75 console.debug(results); 76 77 return ( 78 <Map 79 className=\"containerMap\" 80 center={defaultMapCenter} 81 zoom={2} 82 zoomControl 83 > 84 <TileLayer 85 attribution='&amp;copy <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' 86 url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\" 87 /> 88 {results.map((pt, i) => { 89 const center = [pt.lat, pt.lng]; 90 return ( 91 <CircleMarker 92 key={`circle-${i}`} 93 center={center} 94 color={this.getMarkerColor(pt.y)} 95 radius={Math.log(pt.x) * 3} 96 onClick={() => { 97 alert(JSON.stringify(pt)); 98 }} 99 /> 100 ); 101 })} 102 </Map> 103 ); 104 }} 105 </NerdGraphQuery> 106 </div> 107 <TableChart 108 accountId={accountId} 109 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 110 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 111 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 112 fullWidth 113 className=\"chart\" 114 /> 115 </div> 116 </div> 117 ); 118 } 119 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy This code creates a world map centered on the latitude and longitude you chose using OpenStreetMap data and your marker colors. Reload your app to see the pageview data on the map!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 529.22046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map page views by <em>region</em> <em>in</em> a custom <em>app</em>",
        "sections": "Import the <em>TableChart</em> <em>component</em>",
        "info": "Build a New <em>Relic</em> <em>app</em> showing page view data on a world map.",
        "tags": "custom <em>app</em>",
        "body": " { <em>Table</em>Chart } from &#x27;nr1&#x27;; 3 4 const accountId = 0; &#x2F;&#x2F; Replace with your account ID 5 6 export default class PageView<em>App</em> extends React.<em>Component</em> { 7 render() { 8 return ( 9 &lt;div className=&quot;container&quot;&gt; 10 &lt;div className=&quot;<em>row</em>&quot;&gt;&lt;&#x2F;div&gt; 11 &lt;&#x2F;div&gt; 12 ); 13 } 14 } pageview-<em>app</em>-nerdlet&#x2F;index.js Copy 1 .container { 2"
      },
      "id": "5efa993c196a67066b766469"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/table-header-cell/",
      "sections": [
        "TableHeaderCell",
        "Usage",
        "Props"
      ],
      "published_at": "2020-10-24T02:01:31Z",
      "title": "TableHeaderCell",
      "updated_at": "2020-08-03T04:46:36Z",
      "type": "developer",
      "external_id": "2a4be1419d1a6e501a8eed915b8acf7c9798259d",
      "document_type": "page",
      "popularity": 1,
      "info": "A TableHeaderCell component!",
      "body": "TableHeaderCell Usage Copy Props There are no props for this component.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 467.11285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>TableHeaderCell</em>",
        "sections": "<em>TableHeaderCell</em>",
        "info": "A <em>TableHeaderCell</em> <em>component</em>!",
        "body": "<em>TableHeaderCell</em> Usage Copy Props There are no props for this <em>component</em>."
      },
      "id": "5efa9906196a67523e76646e"
    },
    {
      "sections": [
        "Add a time picker",
        "Before you begin",
        "Important",
        "Prepare the time picker sample code",
        "Import the PlatformStateContext component",
        "Add the time to the queries",
        "Summary"
      ],
      "title": "Add a time picker",
      "type": "developer",
      "tags": [
        "time picker",
        "app",
        "helper method",
        "platformstatecontext"
      ],
      "external_id": "2602edf3077388ba4fded3a76208e5e0ae1be98f",
      "image": "https://developer.newrelic.com/static/7f679da4c4ffce5fa547a04b27ac700d/0086b/add-timepicker.png",
      "url": "https://developer.newrelic.com/build-apps/add-time-picker-guide/",
      "published_at": "2020-10-24T01:53:26Z",
      "updated_at": "2020-10-24T01:53:26Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a time picker to a sample application",
      "body": "Add a time picker 20 min This guide steps you through the process of adding access to our time picker in the sample transaction overview application. The sample application provides an overview of the telemetry data showing your account's transactions by application, average response time, HTTP response codes, and transaction errors. When you enable the time picker, users can specify the time range of data to view. We also have a 12 minute video that covers the steps below. Before you begin To develop projects, you need our New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete steps 1‚Äì4 of the CLI quick start. In step 1, be sure to make a copy of the number preceding your account name. This is your accound ID, and you‚Äôll need it later. Important If you've already installed the New Relic One CLI, but you can't remember your account ID, start the CLI quick start again, and then click the Get your API key down arrow. The account ID is the number preceding your account name. For additional details, see Set up your development environment. Prepare the time picker sample code To get started, complete these steps to update the application UUID (unique ID) and run the sample application locally: Step 1 of 7 If you haven't already done so, clone the example applications from our how-to GitHub repo. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git Step 2 of 7 Change to the directory nr1-howto-add-time-picker-nerdlet: bash Copy $ cd nr1-how-to/add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet Step 3 of 7 In your preferred text editor, open index.js. Step 4 of 7 Replace <ADD YOUR ACCOUNT ID> with your account id: Important Your account ID is available in the CLI quick start (see Before you begin). this.accountId = <ADD YOUR ACCOUNT ID>; Copy Step 5 of 7 Change to the add-time-picker directory: cd / nr1 - how - to / add - time - picker; Copy Step 6 of 7 Execute these commands to update the UUID and serve the sample application: nr1 nerdpack:uuid -gf nr1 nerdpack:serve Copy Step 7 of 7 Once the sample application is successfully served, go to the local version of New Relic One (https://one.newrelic.com/?nerdpacks=local) click Apps, and click Add Time Picker. After launching the Add Time Picker application, you see a dashboard that gives an overview of the transactions in your New Relic account: By default, the application shows your data within the last 60 minutes. If you toggle the time picker, it doesn't update the charts because the transaction overview application isn't connected to the New Relic One platform. It has no access to the data from the time picker. In the following sections, you'll add the time picker to the example application and add the time to the queries. Import the PlatformStateContext component The first step in adding the time picker is to import the PlatformStateContext component. Important If you need more details about the PlatformStateContext example that follows, see the APIs and components page Here's what the PlatformStateContext component does: Wraps all of the code within the return statement of the render method Makes a function call passing in the New Relic platform state Returns all of the code within our current return statement Complete these steps: Step 1 of 5 In a text editor, open /add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet/index.js. Step 2 of 5 Add the PlatformStateContext component to the end of the import statement so it looks like this: import { Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, PlatformStateContext, } from 'nr1'; Copy Step 3 of 5 Just below the current return insert this code for the PlatformStateContext component: <PlatformStateContext.Consumer> {(platformState) => { return ( // ADD THE CURRENT RETURN CODE HERE ) }} </PlatformStateContext.Consumer> Copy Step 4 of 5 Move the current application code so it is under the return of the PlatformState function call. The return statement should now look like this: return ( <PlatformStateContext.Consumer> {(PlatformState) => { return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); Copy Step 5 of 5 Add a console.log statement to make sure you are seeing appropriate data. Insert the following code inside the PlatformState return statement just before the opening tag for the <Grid> component: /* Taking a peek at the PlatformState */ console.log(PlatformState); Copy After you complete these steps, your browser console displays something like this: Add the time to the queries In your console, you should see some data from the New Relic platform state. Now you're ready to add timeRange data to update the charts in the transaction overview application. This step requires you to import the timeRangeToNrql utility method from the New Relic One community library. Important You can get more details on the New Relic One community library from our GitHub repo. This helper method takes your PlatformState.timeRange duration data, formats it from milliseconds, and returns a formatted SINCE statement to add to your NRQL. Step 1 of 4 Import the timeRangeToNrql method by inserting this line of code below the other import sections: Important You don't need to include the AccountDropdown from the community import example. import { timeRangeToNrql } from '@newrelic/nr1-community'; Copy Step 2 of 4 Pass the PlatformState to the timeRangeToNrql helper, and save its output as a since statement for later use: const since = timeRangeToNrql(PlatformState); Copy Step 3 of 4 After creating the since variable, go through the code in the PlatformStateContext return statement and concatenate the since variable in each of the existing chart component queries. Here's a TableChart example: <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} />; Copy Step 4 of 4 After you update all of the chart components, confirm that the final index.js file looks similar to this: Important This completed sample code is in your nerdlet final.js. import React from 'react'; import { PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, } from 'nr1'; import { timeRangeToNrql } from '@newrelic/nr1-community'; export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props) { super(props); this.accountId = 1; } render() { const avgResTime = `SELECT average(duration) FROM Transaction FACET appName TIMESERIES AUTO `; const trxOverview = `FROM Transaction SELECT count(*) as 'Transactions', apdex(duration) as 'apdex', percentile(duration, 99, 95) FACET appName `; const errCount = `FROM TransactionError SELECT count(*) as 'Transaction Errors' FACET error.message `; const responseCodes = `SELECT count(*) as 'Response Code' FROM Transaction FACET httpResponseCode `; return ( <PlatformStateContext.Consumer> {(PlatformState) => { /* Taking a peek at the PlatformState */ console.log(PlatformState); const since = timeRangeToNrql(PlatformState); console.log(since); return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount + since} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); } } Copy Summary When you completed all the steps in this example, you successfully implemented the time picker in your application by importing the PlatformStateContext component and accessing its timePicker data object.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 442.96594,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Import the PlatformStateContext <em>component</em>",
        "info": "Add a time picker to a sample <em>application</em>",
        "tags": "<em>app</em>",
        "body": ", <em>Table</em>Chart, PieChart, PlatformStateContext, } from &#x27;nr1&#x27;; Copy Step 3 of 5 Just below the current return insert this code for the PlatformStateContext <em>component</em>: &lt;PlatformStateContext.Consumer&gt; {(platformState) =&gt; { return ( &#x2F;&#x2F; ADD THE CURRENT RETURN CODE HERE ) }} &lt;&#x2F;PlatformStateContext.Consumer&gt; Copy Step"
      },
      "id": "5efa993d28ccbc91ff307dde"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add the NerdGraphQuery component to an application",
        "Add a table to your app",
        "Permissions for managing applications",
        "Set up your development environment",
        "Publish and deploy apps",
        "Create a custom map view"
      ],
      "published_at": "2020-10-24T01:53:25Z",
      "title": "Build apps",
      "updated_at": "2020-10-24T01:53:25Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 30 min Add a table to your app Add a table to your New Relic One app ¬† Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 30 min Publish and deploy apps Start sharing the apps you build 30 min Create a custom map view Build an app to show page view data on a map",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 408.53064,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add the NerdGraphQuery <em>component</em> to an <em>application</em>",
        "body": " the NerdGraphQuery <em>component</em> to an application The NerdGraphQuery <em>component</em> allows you to query data from your account and add it to a dropdown menu in an application 30 min Add a <em>table</em> to your <em>app</em> Add a <em>table</em> to your New Relic One <em>app</em> ¬† Permissions for managing applications Learn about permissions"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/table-row/",
      "sections": [
        "TableRow",
        "Usage",
        "Props"
      ],
      "published_at": "2020-10-24T02:00:01Z",
      "title": "TableRow",
      "updated_at": "2020-08-03T04:45:42Z",
      "type": "developer",
      "external_id": "b9ca0d4e07a506dd961eb2194c5344bfa9ab770d",
      "document_type": "page",
      "popularity": 1,
      "info": "A TableRow component!",
      "body": "TableRow Usage Copy Props There are no props for this component.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 390.5152,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>TableRow</em>",
        "sections": "<em>TableRow</em>",
        "info": "A <em>TableRow</em> <em>component</em>!",
        "body": "<em>TableRow</em> Usage Copy Props There are no props for this <em>component</em>."
      },
      "id": "5efa98d564441f93435f7e24"
    }
  ],
  "/build-apps/map-pageviews-by-region": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-10-24T02:00:01Z",
      "updated_at": "2020-10-24T02:00:01Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 176.90051,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use NerdStorage in your <em>apps</em>",
        "tags": "new relic one <em>apps</em>",
        "body": " as a nested key-value <em>map</em>. Data is inside documents, which are nested inside collections: { &quot;Your<em>Nerdpack</em>Uuid&quot;: { &quot;collection-1&quot;: { &quot;document-1-of-collection-1&quot;: &quot;{\\&quot;lastNumber\\&quot;: 42, \\&quot;another\\&quot;: [1]}&quot;, &quot;document-2-of-collection-1&quot;: &quot;\\&quot;userToken\\&quot;&quot; &#x2F;&#x2F; ... }, &quot;another-collection&quot;: { &quot;fruits&quot;: &quot;[\\&quot;pear"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "category_2": "On-host integrations list",
      "nodeid": 38406,
      "sections": [
        "On-host integrations",
        "Get started",
        "Installation",
        "On-host integrations list",
        "Understand and use data",
        "Troubleshooting",
        "StatsD monitoring integration (version 2)",
        "Features",
        "Requirements",
        "Install",
        "Install for Kubernetes",
        "Configure",
        "Metric format",
        "Metric types",
        "Add tags (attributes)",
        "Create alerts",
        "Find and use data",
        "Check the source code",
        "For more help"
      ],
      "title": "StatsD monitoring integration (version 2) ",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "On-host integrations",
      "external_id": "5d94989a9004778a43aba9fc5187b7904affc412",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/statsd-nrql-alert-condition-example-2.png",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/statsd-monitoring-integration-version-2",
      "published_at": "2020-10-22T11:31:52Z",
      "updated_at": "2020-10-22T11:31:52Z",
      "breadcrumb": "Contents / Integrations / On-host integrations / On-host integrations list",
      "document_type": "page",
      "popularity": 1,
      "body": "The second version of our StatsD integration was released on May 25 2020. It's an improvement on our first StatsD integration. Improvements include: simpler configuration, and a simpler method for adding tags (key-value pairs). Features Our StatsD integration (version 2) lets you easily get StatsD-format data into New Relic. You can also add any arbitrary tags (key-value pairs) to your data. Once your metrics are in New Relic, you can query your data and create custom charts and dashboards. Requirements This integration uses our Metric API and our Event API to ingest data. To use these APIs, you'll need an Insert API key. The integration adheres to the Metric API requirements and data limits. The default rate limit is 100,000 data points per minute (DPM). If you think you're missing metrics or sending more than 100K DPM, see Request data changes. To see if you're account is hitting the rate limit, run the following NRQL query: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature ='Metrics' FACET category, message LIMIT 100 since 1 day ago Install This section will explain how to do a standard install. If you want to run StatsD in Kubernetes, see Kubernetes install. To install the StatsD integration, run the following command and include your New Relic account ID and New Relic Insert API key. This generates a TOML configuration file used by gostatsd. docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 If your account is in the EU data center region, add this to the above command: -e NR_EU_REGION=true \\ After installing, you can: Do optional additional configuration Define your metrics Add custom tags to your data Create alerts Install for Kubernetes Here are examples of Kubernetes manifests for deployment and service objects: Kubernetes manifest examples Below are examples of Kubernetes manifests to deploy StatsD in a Kubernetes environment and create a StatsD service named newrelic-statsd. You need to insert your account ID and your license key. deployment.yml: apiVersion: apps/v1 kind: Deployment metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: selector: matchLabels: app: newrelic-statsd replicas: 2 revisionHistoryLimit: 2 template: metadata: labels: app: newrelic-statsd spec: containers: - name: newrelic-statsd image: newrelic/nri-statsd:2.0.0 env: - name: NR_ACCOUNT_ID value: \"NEW_RELIC_ACCOUNT_ID\" - name: NR_API_KEY value: \"NEW_RELIC_LICENSE_KEY\" service.yml: apiVersion: v1 kind: Service metadata: name: newrelic-statsd namespace: tooling labels: app: newrelic-statsd spec: type: ClusterIP ports: - name: newrelic-statsd port: 80 targetPort: 8125 protocol: UDP selector: app: newrelic-statsd For configuration details, see Kubernetes configuration. Configure In the install procedure, you run nri-statsd with environment variables, and this generates a TOML configuration file. Additionally, you can set these configuration options: Configuration options Description expiry-interval string If a metric is not updated for this amount of time, we stop reporting that metric. Default is 5m. If you want to send the metrics only if the value was updated between the flush intervals, configure this to 1ms. To never expire metrics, set it to 0. percent-threshold list of integers Specifies the percentiles used for metrics aggregation. Default: 90. metrics-addr string Indicates address on which to listen for metrics. Default: :8125. To ensure FedRAMP compliance when using the StatsD integration you must define the following endpoints in the custom configuration: address = 'https://gov-insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://gov-infra-api.newrelic.com/metric/v1' Here are some examples of customizing configuration by overwriting the default configuration: Example of custom configuration # Specify after how long do we expire metrics, default:5m expiry-interval = '1ms' # percent-threshold specify a list of percentiles for metrics aggregation, default:90 percent-threshold = [90, 99] backends='newrelic' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://insights-collector.newrelic.com/v1/accounts/$NR_ACCOUNT_ID/events' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' Disable timer sub-metrics: By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. If you want to disable those metrics you can do it by adding a disabled-sub-metrics configuration section and set true for the ones you want disabled. Here's an example: # disabled-sub-metrics configuration section allows disabling timer sub-metrics [disabled-sub-metrics] # Regular metrics count=false count-per-second=false mean=false median=false lower=false upper=false stddev=false sum=false sum-squares=false # Percentile metrics count-pct=false mean-pct=false sum-pct=false sum-squares-pct=false lower-pct=false upper-pct=false Docker: overwrite default configuration To overwrite the default nri-statsd configuration while running in a container, you can mount a configuration file inside the container. You can adopt the following template as needed for your situation. Example: backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address-metrics = 'https://metric-api.newrelic.com/metric/v1' api-key = 'NEW_RELIC_API_KEY' To run the container with the file mounted in the appropriate path: docker run \\ ... -v ${PWD}/nri-statsd.toml:/etc/opt/newrelic/nri-statsd.toml \\ ... newrelic/nri-statsd:2.0.0 Kubernetes: overwrite default configuration The best approach to configure nri-statsd running in Kubernetes is to use a configMap and mount the configMap into the container. (This is a similar process to mounting the configuration file in Docker.) Example: apiVersion: v1 kind: ConfigMap metadata: name: nri-statsd-config namespace: default data: nri-statsd.toml: | backends='newrelic' flush-interval='10s' [newrelic] # flush types supported: metrics, insights, infra flush-type = 'metrics' transport = 'default' address = 'https://metric-api.newrelic.com/metric/v1' api-key = '$NEW_RELIC_API_KEY' To use the configMap, declare a volume on your deployment spec template and then declare a volumeMount on your container spec. Example: apiVersion: apps/v1 kind: Deployment spec: template: spec: containers: .... volumeMounts: - mountPath: /etc/opt/newrelic/ name: nri-statsd-config volumes: - name: nri-statsd-config configMap: name: nri-statsd-config Metric format The integration receives metrics using the StatsD protocol. Optionally, the sample rate can be configured and tags can be added. Here's the metric data format we use: <metric name>:<value>|<type>|@<sample rate>|#<tags> Here are explanations of these fields: Field name Description <metric name> string Required. Name of the metric. <value> string Required. The metric type: c = counter g = gauge ms = timer @<sample rate> float Optional for simple counters or timer counters. When many metrics must be sent, you can use sampling to reduce network traffic. The downside is a reduction in the resolution of the data. An example of how this would work for sample rates below 1: If you set this to 0.1, the counter would send a measurement one out of every 10 times. #<tags> string Optional. Tags attached to your metrics are converted into attributes (key-value pairs). For more on tagging options, see Tags. Metric types Here are the types of metrics and how to format them: Counter A counter measures the number of occurrences of an event. Examples include cache hits per reporting interval and the number of threads created per reporting interval. A counter can be incremented or decremented during the same flush interval by adding a sign to the value. In the following example, the counter value will be 2: counter:4|c counter:-2|c At each flush, the current count is sent and reset to 0. If the count is not updated, at the next flush it will send the value 0. You can opt to disable this behavior by setting expiry-interval to 1ms. Here‚Äôs an example of a counter that is being sampled 1 out of 10 times: counter:4|c@0.1 Gauge A gauge represents a value that can increase or decrease with time. Examples of gauges include temperature, CPU usage, and memory. Here's an example: temperature:40|g If the gauge is not updated, at the next flush it will send the previous value. You can opt to disable this behavior by setting expiry-interval to 1ms. Timer The timer metric type measures timing data. By default, nri_statsd calculates the following for timer metrics: standard deviation, mean, median, sum, lower, and upper bounds for the flush interval. These are sent as sub-metrics in the following format: <metric_base_name>.std_dev <metric_base_name>.median <metric_base_name>.summary <metric_base_name>.sum_squares <metric_base_name>.mean <metric_base_name>.per_second The configured percentiles will generate the following metrics. The percentile threshold value will be attached as a tag. <metric_base_name>.sum_squares.percentiles <metric_base_name>.sum.percentiles <metric_base_name>.count.percentiles <metric_base_name>.upper.percentiles <metric_base_name>.mean.percentiles The percentile threshold can be tweaked with the percent-threshold config option. These can be controlled through the disabled-sub-metrics configuration section. Add tags (attributes) You can add tags to your data, which we save as attributes (key-value pairs). There are two options for adding tags: Add default tags that apply to all metrics: These apply to all metrics. They are fixed and don't change over time. Add metric-level tags: These apply to specific metrics and allow the value to be changed between two submits. Add default tags that apply to all metrics Add tags to metrics and events by defining an environment variable in the startup command. Here's an example that would create two tags: -e TAGS=\"environment:production region:us\" Here's that environment variable used in the startup command: docker run \\ -d --restart unless-stopped \\ --name newrelic-statsd \\ -h $(hostname) \\ -e NR_ACCOUNT_ID=YOUR_ACCOUNT_ID \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -e TAGS=\"environment:production region:us\" \\ -p 8125:8125/udp \\ newrelic/nri-statsd:2.0.0 Add metric-level tags When defining the metric format, you can add tags using this format: <bucket name>:<value>|<type>|#<tags> In this example, <tags> is a comma-separated list of tags. Tags format is: simple or key:value. Here's an example NRQL query that includes a custom tag: SELECT count(*) FROM Metric WHERE environment = 'production' Create alerts You can alert on StatsD data using NRQL alert conditions. Alert example This procedure walks you through sending some sample data and then creating an alert condition using that data. First, send this data to New Relic‚Äôs StatsD container: echo \"prod.test.num:32|g\" | nc -v -w 1 -u localhost 8125 Next, create a NRQL alert condition using this query: SELECT latest(prod.test.num) FROM Metric WHERE metricName = 'prod.test.num' Here's an image showing creating this NRQL alert condition. Notice that the sample data sent in is represented by the blue dot on the upper right of the chart. Now we can create the alert condition with these settings: Remember to set the Condition name. If a metric with a value above 50 is sent, then an incident is created and notified. The incident is closed automatically after 24 hours. To test that the alert is working, run this command: echo \"prod.test.num:60|g\" | nc -v -w 1 -u localhost 8125 Find and use data To query your data, you'd use any New Relic query option. For example, you might run a NRQL query like: SELECT count(*) FROM Metric WHERE metricName = 'myMetric' and environment = 'production' For more on how to query the Metric data type, see Query metric data. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.600204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " \\ -e NR_API_KEY=YOUR_INSERT_API_KEY \\ -p 8125:8125&#x2F;udp \\ newrelic&#x2F;nri-statsd:2.0.0 If your account is in the EU data center <em>region</em>, add this to the above command: -e NR_EU_<em>REGION</em>=true \\ After installing, you can: Do optional additional configuration Define your metrics Add <em>custom</em> tags to your data"
      },
      "id": "5ece854928ccbc9dbdc13573"
    },
    {
      "sections": [
        "Add the NerdGraphQuery component to an application",
        "Important",
        "Before you begin",
        "Prepare the sample code",
        "Add the NerdGraphQuery component",
        "How to use NerdGraphQuery.query",
        "Review the results of the NerdGraph query",
        "Summary"
      ],
      "title": "Add the NerdGraphQuery component to an application",
      "type": "developer",
      "tags": [
        "nerdgraphquery component",
        "transaction overview app",
        "query account data",
        "drop-down menu",
        "NerdGraphQuery.query method"
      ],
      "external_id": "6bd6c8a72eab352a3e8f4332570e286c7831ba84",
      "image": "https://developer.newrelic.com/static/5dcf6e45874c1fa40bb6f21151af0c24/b01d9/no-name.png",
      "url": "https://developer.newrelic.com/build-apps/add-nerdgraphquery-guide/",
      "published_at": "2020-10-24T01:54:36Z",
      "updated_at": "2020-10-24T01:54:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application",
      "body": "Add the NerdGraphQuery component to an application 20 minutes This guide steps you through the process of adding the `NerdGraphQuery` component to a sample transaction overview application. This allows you to query data from your New Relic account and add it to a dropdown menu. NerdGraph is our GraphQL implementation. GraphQL has some key differences when compared to REST: The client, not the server, determines what data is returned. You can easily collect data from multiple sources. For example, in a single query, you can get account information, infrastructure data, and issue a NRQL request. Important Before completing this exercise, you can experiment with GraphQL queries in our NerdGraph API explorer. We also have a 14-minute video that covers the steps below. Before you begin To develop projects, you need our New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete steps 1‚Äì4 of our CLI quick start, and be sure to make a copy of your account ID from step 1 because you‚Äôll need it later. Important If you've already installed the New Relic One CLI, but you can't remember your account ID, start the CLI quick start again, and then click the Get your API key down arrow. The account ID is the number preceding your account name. For additional details, see Set up your development environment. Prepare the sample code To get started, complete these steps to update the application UUID (unique ID) and run the sample application locally: Step 1 of 8 If you haven't already done so, clone the example applications from our how-to GitHub repo. Here's an example using HTTPS: bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git Step 2 of 8 Change to the directory use-nerdgraph-nerdlet: bash Copy $ cd nr1-how-to/use-nerdgraph/nerdlets/use-nerdgraph-nerdlet Step 3 of 8 In your preferred text editor, open index.js. Step 4 of 8 Replace <ADD YOUR ACCOUNT ID> with your account id: Important Your account ID is available in the CLI quick start (see Before you begin). this.accountId = <ADD YOUR ACCOUNT ID>; Copy Step 5 of 8 Change to the /nr1-howto/use-nerdgraph directory: bash Copy $ cd ../.. Step 6 of 8 If this is your first time executing this code run the below command to install all the required modules: bash Copy $ npm install Step 7 of 8 Execute these commands to update the UUID and serve the sample application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 8 of 8 Once the sample application is successfully served, go to the local New Relic One homepage (https://one.newrelic.com/?nerdpacks=local), click Apps, and then click Use NerdGraph. After launching the Use NerdGraph application, you see a dashboard that gives an overview of the transactions in your account: Add the NerdGraphQuery component Now you can create a dropdown menu for changing the account the application is viewing. The first step is to import the NerdGraphQuery component into the application's index.js file. Important If you need more details about our example below, see the APIs and components page on https://developer.newrelic.com Step 1 of 3 Add the NerdGraphQuery component into the first StackItem inside of the return in the index.js file: <NerdGraphQuery query={query} variables={variables}> {({ loading, error, data }) => { console.log({ loading, error, data }); if (loading) { return <Spinner />; } if (error) { return 'Error!'; } return null; }} </NerdGraphQuery>; Copy Step 2 of 3 The NerdGraphQuery component takes a query object that states the source you want to access and the data you want returned. Add the following code to your index.js file in the render method: Important In the browser console, you can see the data from your query returned in an object that follows the same structure of the object in the initial query. const query = ` query($id: Int!) { actor { account(id: $id) { name } } } `; Copy Step 3 of 3 To take the data returned by the NerdGraph query and display it in the application, replace the return null in the current NerdGraphQuery component with this return statement: return <HeadingText>{data.actor.account.name} Apps:</HeadingText>; Copy When you go back to the browser and view your application, you see a new headline showing the name of your account returned from NerdGraph: How to use NerdGraphQuery.query At this point, you have implemented the NerdGraphQuery component with the application's render method and displayed the return data within the transaction overview application. Here's what you need to do next: Query NerdGraph inside of the componentDidMount lifecycle method. Save the returned data for later use in the application. Step 1 of 2 This code takes the response from NerdGraph and makes sure the results are processed, stored into the application state, and logged to the browser console for viewing. Add this code into the index.js file just under the constructor: componentDidMount() { const accountId = this.state; const gql = `{ actor { accounts { id name } } }`; const accounts = NerdGraphQuery.query({query: gql}) //The NerdGraphQuery.query method called with the query object to get your account data is stored in the accounts variable. accounts.then(results => { console.log('Nerdgraph Response:', results); const accounts = results.data.actor.accounts.map(account => { return account; }); const account = accounts.length > 0 && accounts[0]; this.setState({ selectedAccount: account, accounts }); }).catch((error) => { console.log('Nerdgraph Error:', error); }) } Copy Step 2 of 2 After the data is stored into state, display a selection so users can change accounts and update the application. To do this, add this code to index.js for the second StackItem in the return statement: { accounts && ( <StackItem> <Select value={selectedAccount} onChange={(evt, value) => this.selectAccount(value)} > {accounts.map((a) => { return ( <SelectItem key={a.id} value={a}> {a.name} </SelectItem> ); })} </Select> </StackItem> ); } Copy Review the results of the NerdGraph query After you complete these steps, look at the application in your browser, and note the following: The dropdown menu now displays the data returned from the NerdGraphQuery.query and allows you to select an account. After you select a new account, the application shows data from the new selection. The final index.js file should have code similar to the code below. This completed sample is in your nerdlet final.js. import React from 'react'; import { PlatformStateContext, NerdGraphQuery, Spinner, HeadingText, Grid, GridItem, Stack, StackItem, Select, SelectItem, AreaChart, TableChart, PieChart } from 'nr1' import { timeRangeToNrql } from '@newrelic/nr1-community'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class UseNerdgraphNerdletNerdlet extends React.Component { constructor(props){ super(props) this.state = { accountId: <YOUR ACCOUNT ID>, accounts: null, selectedAccount: null, } } componentDidMount() { const accountId = this.state; const gql = `{ actor { accounts { id name } } }`; const accounts = NerdGraphQuery.query({ query: gql }) accounts.then(results => { console.log('Nerdgraph Response:', results); const accounts = results.data.actor.accounts.map(account => { return account; }); const account = accounts.length > 0 && accounts[0]; this.setState({ selectedAccount: account, accounts }); }).catch((error) => { console.log('Nerdgraph Error:', error); }) } selectAccount(option) { this.setState({ accountId: option.id, selectedAccount: option }); } render() { const { accountId, accounts, selectedAccount } = this.state; console.log({ accountId, accounts, selectedAccount }); const query = ` query($id: Int!) { actor { account(id: $id) { name } } } `; const variables = { id: accountId, }; const avgResTime = `SELECT average(duration) FROM Transaction FACET appName TIMESERIES AUTO `; const trxOverview = `FROM Transaction SELECT count(*) as 'Transactions', apdex(duration) as 'apdex', percentile(duration, 99, 95) FACET appName `; const errCount = `FROM TransactionError SELECT count(*) as 'Transaction Errors' FACET error.message `; const responseCodes = `SELECT count(*) as 'Response Code' FROM Transaction FACET httpResponseCode `; return ( <Stack fullWidth horizontalType={Stack.HORIZONTAL_TYPE.FILL} gapType={Stack.GAP_TYPE.EXTRA_LOOSE} spacingType={[Stack.SPACING_TYPE.MEDIUM]} directionType={Stack.DIRECTION_TYPE.VERTICAL}> <StackItem> <NerdGraphQuery query={query} variables={variables}> {({loading, error, data}) => { if (loading) { return <Spinner />; } if (error) { return 'Error!'; } return <HeadingText>{data.actor.account.name} Apps:</HeadingText>; }} </NerdGraphQuery> </StackItem> {accounts && <StackItem> <Select value={selectedAccount} onChange={(evt, value) => this.selectAccount(value)}> {accounts.map(a => { return ( <SelectItem key={a.id} value={a}> {a.name} </SelectItem> ) })} </Select> </StackItem> } <StackItem> <hr /> <PlatformStateContext.Consumer> {(PlatformState) => { /* Taking a peek at the PlatformState */ const since = timeRangeToNrql(PlatformState); return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4}> Transaction Overview </HeadingText> <TableChart fullWidth accountId={accountId} query={trxOverview+since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4}> Average Response Time </HeadingText> <AreaChart fullWidth accountId={accountId} query={avgResTime+since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4}> Response Code </HeadingText> <PieChart fullWidth accountId={accountId} query={responseCodes+since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4}> Transaction Errors </HeadingText> <PieChart fullWidth accountId={accountId} query={errCount+since} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> </StackItem> </Stack> ) } } Copy Summary Now that you've completed all the steps in this example, you've successfully queried data from your account using the NerdGraphQuery component in two methods: Using the NerdGraphQuery component inside the application's render method and then passing the returned data into the children's components. Using the NerdGraphQuery.query method to query data before the application renders.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.25447,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add the NerdGraphQuery component to an <em>application</em>",
        "sections": "Add the NerdGraphQuery component to an <em>application</em>",
        "info": "The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an <em>application</em>",
        "tags": "transaction overview <em>app</em>",
        "body": " the sample application: bash Copy $ nr1 <em>nerdpack</em>:uuid -gf $ nr1 <em>nerdpack</em>:serve Step 8 of 8 Once the sample application is successfully served, go to the local New Relic One homepage (https:&#x2F;&#x2F;one.newrelic.com&#x2F;?nerdpacks=local), click Apps, and then click Use NerdGraph. After launching the Use NerdGraph"
      },
      "id": "5efa993c64441ff4865f7e32"
    },
    {
      "image": "https://newrelic.com/content/dam/component-assets/p03-product-image/browser/products_browsers_features_browserloadtime_sept2020_thumb.png",
      "url": "https://newrelic.com/products/browser-monitoring/features",
      "sections": [
        "New Relic Browser features",
        "Full Support for Google‚Äôs Core Web Vitals",
        "User Centric Perceived Performance",
        "Single Page App Route Changes",
        "Session Traces",
        "Browser Traces",
        "Page Load Time - Segmentation Chart",
        "Page Load Time - Histogram and Percentiles",
        "Geographic Reporting",
        "Page-Level AJAX Calls",
        "Page View Throughput",
        "Connect Browser with Backend Performance",
        "JavaScript Error Summary",
        "Errors by Browser",
        "Percentage of Page Views with Errors",
        "Source Map Support",
        "Best-in-class Customer Experience Monitoring",
        "Browser Throughput",
        "Browser Load Time - Segmentation Chart",
        "Browser Version Chart",
        "Error Instance Details",
        "AJAX Dashboard",
        "Calls by Page View",
        "Request Status Codes",
        "Data Transfer Per Request",
        "Quickly View App Health",
        "Custom dashboards",
        "Integrate with your ticketing system",
        "Alerting",
        "Filterable Geography",
        "U.S. and EU Data Regions",
        "SOC2 Audited",
        "Secure Data Center",
        "Continuous Monitoring",
        "Secure by Default",
        "Compliance Friendly",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-10-24T01:42:05Z",
      "title": "New Relic Browser | New Relic",
      "updated_at": "2020-10-16T01:58:30Z",
      "type": "",
      "external_id": "b30121e0e2deb44e52a48d9a83ca4f854e2fb470",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon New Relic Browser Overview Features Resources New Relic Browser features Sign up for free Page Load Performance JavaScript Errors Browser Performance AJAX Global Features Security Page Load Performance New Relic Browser is the world‚Äôs most deployed Real User Monitoring (RUM) solution because it‚Äôs easy to use, and instantly connects end-user experience with time spent in backend services. From easy-to-understand overviews to user-centric perceived performance metrics and events, Browser helps you benchmark and improve web performance and troubleshoot across your full stack. Full Support for Google‚Äôs Core Web Vitals By adding Cumulative Layout Shift, a score measuring the impact of sudden unexpected shifts in layout due to content dynamically resizing, we now offer full support for all three of Google‚Äôs Core Web Vitals for web health. Use NRQL to create dashboards for all three measurements, definitions below: Largest Contentful Paint (LCP) - measures loading performance First Input Delay (FID) - measures interactivity Cumulative Layout Shift (CLS) - measures visual stability User Centric Perceived Performance Web performance teams can use more modern metrics than just page load time to benchmark and improve end-user experience for their dynamic pages. Browser helps developers understand how code impacts customers, answering key questions on page performance. Monitor how long users wait for content to display (paint metrics), how long until users can interact with our page (interactivity metrics), and how long until marquee content renders (largest contentful paint). (see blogpost for more) Single Page App Route Changes View Single Page Application route change performance, regardless of what JavaScript framework you use. Powerful low-level instrumentation can even capture interactions beyond the route change that can be customized via API, allowing monitoring tailored to the architecture of your application, such as for custom frameworks. Session Traces Session Traces provide one of the most valuable assets an engineer requires - context. Beyond identifying long load times, and specific errors, Browser Session Traces provide the story that occurred both before and after an error or performance issue. Pivot from AJAX requests and JavaScript errors into a Session Trace and conversely pivot from a Session Trace out to a specific JavaScript error or Network error. Browser Traces Traces are snapshots of one user‚Äôs experience, surfaced as an outlier due to a longer than average load time. It provides details around when it took place, a segmented breakdown of where load time was spent, browser type, and the user‚Äôs geographic location. This report is excellent when dissecting areas of your application which are performing poorly for specific users. Page Load Time - Segmentation Chart Page load times capture metrics from the moment a user begins a transaction in the browser until the page completes loading. The reports show average page load time broken down into color-coded segments for: Request queuing, application code, network latency, DOM processing, and Page rendering. Page Load Time - Histogram and Percentiles Histograms and percentiles of browser page load times provide a holistic view of the speed of page loads, one that is not focused on averages alone. Histograms and percentiles surface every page load that occurred during a specified time window, providing the ability to drill into outliers that might have been overlooked otherwise. Geographic Reporting Understand how your end users‚Äô experience with your site varies by geographical region. Identify if more CDN‚Äôs are required, or if high value customers in specific parts of the world are having a negative experience with your site‚Äôs performance. Page-Level AJAX Calls For a specific page, see all the AJAX calls being made as well as the response time, throughput (rpm), total number of calls, error status codes, and average data transfer made for each one. Page View Throughput Throughput is measured in requests per per minute. Throughput metrics help you understand which pages are being called most frequently. Connect Browser with Backend Performance From the Page views report, you can select single page URL and see all of the associated backend APM transactions (if you have the APM Agent installed in your application). Quickly view the total call time, average response time, and call count for any individual backend transaction. You can also dive deeper into a particular transaction and see diagnostics within our APM reports. JavaScript Errors The JavaScript error dashboards help you identify production JavaScript errors impacting your users' experiences and begin pinpointing how to resolve them. JavaScript Error Summary This summary view gives you a high level understanding of the types of JavaScript errors happening, the frequency at which they occur, and the percentage of users affected by the errors. Errors by Browser For each type of error, this chart shows you which browsers are being impacted by the error and the relative contribution it is making to your total error volume. Percentage of Page Views with Errors For each type of error, this chart shows you the percentage of page views affected by it. This allows you to quickly assess the reach and impact a particular error has on your end users. Source Map Support Troubleshoot minified production JavaScript code, with source map support giving you full visibility to where in your code the front-end error is. Intuitive drag-and-drop lets you locate issues in a click, while API integrations work seamlessly with your build pipeline. Best-in-class Customer Experience Monitoring Crash analysis in New Relic Mobile lets you analyze the most impactful crashes and fix them faster. Source map support in New Relic Browser gives you more actionable visibility into front-end JS errors by showing you exactly where in the original source the error occurred, even if your code is minified. Browser Performance New Relic's Browser dashboards provide information about your end users' experience based on browser type and version, so you can understand where to focus your time testing and optimizing for performance. Browser Throughput Provides a snapshot of the average number of pageviews received per minute broken down by browser type. Browser Load Time - Segmentation Chart For each type of browser, a segmented view of time spent on request queuing, application code, network latency, DOM processing, and Page rendering. Browser Version Chart Helps you understand which versions of each browser type your customers come from based on throughput. Error Instance Details Error Instance details grabs a snapshot of a single error and captures the stack trace details available from the browser, focusing on the actionable components, down to the line of code. These are metrics are combined with unique browser combinations down to the version level, and unique url. JavaScript diagnostics doesn't get more granular than this. AJAX If your applications use AJAX to update parts of a webpage after the initial page load, our AJAX dashboards will provide you with the level of visibility you need to understand how those requests are performing and ultimately affecting your users‚Äô experience. AJAX Dashboard The main AJAX dashboard surfaces your site‚Äôs most resource intensive AJAX requests, filterable by time consumption, response time, throughput, callback time, and data transfer. From here you can drill into a particular call for detailed analysis. Calls by Page View Shows which page views are calling a particular server side controller, with page level detail around throughput, response time, total number of calls, and data transfer. Request Status Codes The status codes reporting indicates the return behavior from an AJAX call. A large number of non-200 status codes may indicate a problem with your AJAX endpoints. Data Transfer Per Request This shows data transfer which is requested and sent. Use this to look for correlations between high callback times and data transfer rates. Global Features The following features are used throughout New Relic‚Äôs product suite to help make our products easier to use and fit seamlessly into your existing workflows. Quickly View App Health New Relic uses color coded status indicators throughout to help you quickly spot performance issues. Custom dashboards Keep an eye on your most critical performance metrics quickly by adding them to a custom dashboard. Integrate with your ticketing system File tickets related to performance problems directly into your ticketing system.¬†Learn which ticketing systems we support. Alerting Check out our new Alerts Features¬†for Browser that report on JS error %, response time, throughput and much more! Filterable Geography Understand how your end users‚Äô experience with your site varies by geographical region, down to the city level. Identify how a CDN or ASN/ Internet Service Provider is performing in different regions. Security New Relic is committed to helping customers make their applications fast and secure. We take protecting our customers' data seriously, here's an overview of how we do it. U.S. and EU Data Regions Our global data-hosting structure consists of two regions: European Union and United States. You can select your preferred data region during the account setup process, regardless of your physical location. (Note: We do not support migration or aggregation of data across regions.) SOC2 Audited New Relic has successfully completed a SOC 2 audit of processes and controls relevant to security and availability. This audit reviews our security process and controls and provides both ourselves, and more importantly our customers an independent, third-party assurance that we are taking the appropriate steps to protect our systems and our customer‚Äôs data. Secure Data Center The infrastructure that runs the New Relic service and stores our customer‚Äôs data resides in a Tier III, SSAE-16 certified data center. Customer data is backed up on a regular basis. Continuous Monitoring New Relic employs both internal and third-party services to perform continuous security scanning on both our network and applications to ensure that our applications and servers remain secure. Secure by Default We strongly believe in the concept of ‚Äúsecure by default‚Äù. Customers have to explicitly enable settings within New Relic to authorize the sending of sensitive data. We want to make sure that you are not accidentally exposing anything that you don‚Äôt want to. Compliance Friendly New Relic can be configured to operate securely in regulated environments such as PCI, HIPAA, or SOX. In addition we are Swiss and EU Privacy Shield certified. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.41788,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Percentage of <em>Page</em> <em>Views</em> with Errors",
        "body": " users can interact with our <em>page</em> (interactivity metrics), and how long until marquee content renders (largest contentful paint). (see blogpost for more) Single <em>Page</em> <em>App</em> Route Changes <em>View</em> Single <em>Page</em> Application route change performance, regardless of what JavaScript framework you use. Powerful low"
      },
      "id": "5c66a952b5b9e17d23a27084"
    },
    {
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Subscribe or unsubscribe apps",
        "Handle duplicate applications"
      ],
      "title": "Serve, publish, and deploy your New Relic One app",
      "type": "developer",
      "tags": [
        "publish apps",
        "deploy apps",
        "subscribe apps",
        "add metadata apps"
      ],
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "published_at": "2020-10-24T01:54:36Z",
      "updated_at": "2020-10-14T01:58:45Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Start sharing and using the custom New Relic One apps you build",
      "body": "Serve, publish, and deploy your New Relic One app 30 min When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. nr1 update Copy Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. nr1 catalog:submit Copy Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Subscribe or unsubscribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.52771,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and deploy your New Relic One <em>app</em>",
        "sections": "Serve, publish, and deploy your New Relic One <em>app</em>",
        "info": "Start sharing and using the <em>custom</em> New Relic One <em>apps</em> you build",
        "tags": "publish <em>apps</em>",
        "body": " that you haven&#x27;t subscribed to, some developed by New Relic engineers to provide visualizations we think you&#x27;ll want, like Cloud Optimizer, which analyzes your cloud environment, or <em>PageView</em> <em>Map</em>, which uses Browser events to chart performance across geographies. Your apps in the catalog are created"
      },
      "id": "5efa999de7b9d283e67bab8f"
    }
  ],
  "/collect-data/query-data-nrql": [
    {
      "category_2": "NRQL query tutorials",
      "nodeid": 40986,
      "sections": [
        "NRQL: New Relic Query Language",
        "Get started",
        "NRQL query tools",
        "NRQL query tutorials",
        "Create smoother charts with sliding windows",
        "When to use sliding windows",
        "Valid NRQL syntax for SLIDE BY",
        "Translation from PromQL-style queries",
        "Use SLIDE BY with MAX and AUTO",
        "For more help"
      ],
      "title": "Create smoother charts with sliding windows",
      "category_0": "Query your data",
      "type": "docs",
      "category_1": "NRQL: New Relic Query Language",
      "external_id": "931df70d3ab9a82c04cb7c8e27d3c12b018c68fe",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/SlidingWindow2.jpg",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows",
      "published_at": "2020-10-22T13:12:59Z",
      "updated_at": "2020-10-21T16:26:16Z",
      "breadcrumb": "Contents / Query your data / NRQL: New Relic Query Language / NRQL query tutorials",
      "document_type": "page",
      "popularity": 1,
      "info": "Explains how to use the SLIDE BY clause with TIMESERIES to smooth out ",
      "body": "Sliding windows are a technique for generating charts using the SLIDE BY clause in conjunction with the TIMESERIES clause. With sliding windows, data is gathered in time \"windows\" that overlap with each other. For example, in the image below, a query gathers data with 5 minute windows. The windows \"slide\" by 1 minute. Each window overlaps with the previous window by 4 minutes. 5-minute windows with 1-minute \"slide\" In contrast, with \"tumbling\" or \"cascading\" windows, the windows do not overlap. For example, in this TIMESERIES 3 minutes NRQL query, the windows are 3 minutes in length, with each beginning when the other ends. There is no overlap in the measurement interval. 3-minute windows with no overlap or \"slide\". When to use sliding windows Sliding windows are helpful when you need to smooth out \"spiky\" charts. In the example below, data varies greatly from one minute to another, so the 1-minute tumbling window chart shows many high peaks and low valleys. TIMESERIES query without SLIDE BY clause However, in this example, 5-minute wide TIMESERIES windows are flattened out with the help of 1-minute SLIDE BY intervals. The query returns similar data but create a much smoother chart. TIMESERIES query with SLIDE BY clause Valid NRQL syntax for SLIDE BY Valid NRQL syntax for the SLIDE BY clause will follow the format below. SELECT ... TIMESERIES integer1 units SLIDE BY integer2 units integer1 specifies the sliding window width and integer2 specifies the SLIDE BY interval. units is a time unit, such as second, minute, hour, or day. All standard NRQL time units are accepted. Here‚Äôs a real-life example. It shows 5-minute TIMESERIES windows with a 1-minute SLIDE BY interval. SELECT average(duration) from Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Translation from PromQL-style queries When applicable, a PromQL-style query is translated into a NRQL sliding window query. For example, if your PromQL style query uses rate(request_count[5m]) for the past 60 minutes with a 1-minute window overlap, the NRQL translation would be the query below. SELECT rate(sum(request_count), 1 SECONDS) FROM Metric SINCE 3600 SECONDS AGO UNTIL NOW FACET dimensions() LIMIT 100 TIMESERIES 300000 SLIDE BY 60000 In the translation output, the default unit of millisecond is used for TIMESERIES and SLIDE BY clauses. For TIMESERIES, 300000 ms is 300 seconds, or 5 minutes, specifying a window size of 5 minutes. For SLIDE BY, 60000 ms is 60 seconds, specifying a slide interval of 1 minute. Use SLIDE BY with MAX and AUTO You can combine SLIDE BY with MAX and AUTO arguments to further tailor query results, as shown in the examples below. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO When paired with SLIDE BY, TIMESERIES does not support AUTO or MAX. The TIMESERIES value must be an integer time unit value. In other words, SLIDE BY AUTO or SLIDE BY MAX will work, but TIMESERIES AUTO or TIMESERIES MAX followed by SLIDE BY and MAX, AUTO, or a specific integer time unit is not supported. The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which will show up as gaps and unexpected results. If you experience these issues with query results, consider checking for instances of SLIDE BY where the step interval exceeds the window size. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.2433,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Valid <em>NRQL</em> <em>syntax</em> for SLIDE BY",
        "category_0": "Query your <em>data</em>",
        "category_1": "<em>NRQL</em>: New Relic Query Language",
        "category_2": "<em>NRQL</em> query tutorials",
        "body": " chart. TIMESERIES query with SLIDE BY clause Valid <em>NRQL</em> <em>syntax</em> for SLIDE BY Valid <em>NRQL</em> <em>syntax</em> for the SLIDE BY clause will follow the format below. SELECT ... TIMESERIES integer1 units SLIDE BY integer2 units integer1 specifies the sliding window width and integer2 specifies the SLIDE BY interval. units",
        "breadcrumb": "Contents &#x2F; Query your <em>data</em> &#x2F; <em>NRQL</em>: New Relic Query Language &#x2F; <em>NRQL</em> query tutorials"
      },
      "id": "5f8c0dde28ccbcc5b7b5075d"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13661,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Data requirements and limits for custom event data",
        "General requirements",
        "Reserved words",
        "Additional Browser PageAction requirements",
        "Additional Event API requirements",
        "Event type limits",
        "For more help"
      ],
      "title": "Data requirements and limits for custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "external_id": "f5beef0d09bb5918be3f8a1a3ece98c09947cd1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "published_at": "2020-10-22T18:01:30Z",
      "updated_at": "2020-10-18T07:41:12Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic, general limits and requirements for reporting custom events and attributes. ",
      "body": "You can report custom events to New Relic in several ways, including the New Relic Event API, APM agent APIs, Browser agent APIs, and the Mobile SDK. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. General requirements How long custom data is retained depends on your Insights subscription and its associated data retention. When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. This is not a complete list. In general, it's a good practice to avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Additional Browser PageAction requirements For additional requirements for using New Relic Browser's custom PageAction event, see Insert custom data via New Relic Browser agent. Additional Event API requirements For more requirements and details for the Event API, see Event API. Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.840256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for custom event <em>data</em>",
        "sections": "Event <em>data</em> sources",
        "category_1": "Event <em>data</em> sources",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;insights-<em>data</em>-sources&#x2F;custom-<em>data</em>&#x2F;insights-custom-<em>data</em>-requirements-limits",
        "body": " may apply based on the method you use. General requirements How long custom <em>data</em> is retained depends on your Insights subscription and its associated <em>data</em> retention. When reporting custom events and attributes, follow these general requirements for supported <em>data</em> types, naming <em>syntax</em>, and size",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; Event <em>data</em> sources &#x2F; Custom events"
      },
      "id": "59f4354f4bb81c2ea8b80d0a"
    },
    {
      "category_2": "Get started",
      "nodeid": 11431,
      "sections": [
        "NRQL: New Relic Query Language",
        "Get started",
        "NRQL query tools",
        "NRQL query tutorials",
        "Introduction to NRQL, New Relic's query language",
        "What is NRQL?",
        "Where can you use NRQL?",
        "What data can you query with NRQL?",
        "Start using NRQL",
        "NRQL query examples",
        "NRQL syntax",
        "For more help"
      ],
      "title": "Introduction to NRQL, New Relic's query language",
      "category_0": "Query your data",
      "type": "docs",
      "category_1": "NRQL: New Relic Query Language",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language",
      "external_id": "d44be2c7df7addda8679b4c842015223cfcbd1a3",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-view-chart-nrql-query_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language",
      "published_at": "2020-10-22T16:39:34Z",
      "updated_at": "2020-09-24T08:40:20Z",
      "breadcrumb": "Contents / Query your data / NRQL: New Relic Query Language / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to New Relic Query Language (NRQL) and how to use it.",
      "body": "One way to query your New Relic data is with the New Relic Query Language (NRQL). This resource explains what NRQL is, when and how you can use it, and basic syntax rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see NRQL syntax, clauses, and functions. What is NRQL? NRQL is New Relic's SQL-like query language. You can use NRQL to retrieve detailed New Relic data and get insight into your applications, hosts, and business-important activity. Reasons to use NRQL include: To answer a question for the purpose of troubleshooting or business analysis To create a new chart To make API queries of New Relic data (for example, using our NerdGraph API) NRQL is used behind the scenes to generate some New Relic charts: Some New Relic charts are built using NRQL. One way to start using NRQL is to view a chart's query and then edit it to make your own custom chart. Where can you use NRQL? You can use NRQL in these places: New Relic One query builder: Advanced mode is a NRQL query interface Basic mode provides a simplified query experience that doesn't require knowledge of NRQL but that uses NRQL to generate results New Relic Insights NerdGraph: our GraphQL-format API, which includes options for making NRQL queries one.newrelic.com > Query your data: You can run a NRQL query in both New Relic One and New Relic Insights. This NRQL query shows a count of distributed tracing spans faceted by their entity names. NRQL is one of several ways to query New Relic data. For more on all query options, see Query your data. What data can you query with NRQL? NRQL allows you to query these New Relic data types: Event data from all New Relic products, including: APM events, like Transaction New Relic Browser events, like PageView New Relic Mobile events, like Mobile Infrastructure events, like ProcessSample Synthetics events, like SyntheticCheck Custom events, like those reported by the Event API Metric timeslice data (metrics reported by New Relic APM, Browser, and Mobile) The Metric data type (metrics reported by the Metric API and data sources that use that API) The Span data type (distributed tracing data) The Log data type (data from New Relic Logs) Some data, like relationships between monitored entities, is not available via NRQL but is available using our NerdGraph API. Start using NRQL One way to start using NRQL and to understand what data you have available is to go to a NRQL interface (for example, the New Relic One query builder), type FROM, and press space. The interface will suggest available types of data: To see the attributes available for a specific data type, type FROM DATA_TYPE SELECT and press space. The interface will suggest available attributes. For example: To see the complete JSON associated with a data type, including all of its attributes, use the keyset() attribute. For example: FROM Transaction SELECT keyset() NRQL is used behind the scenes to build some New Relic charts and dashboards. One way to learn NRQL is to find one of these NRQL-generated charts and start playing with the NRQL to create new, customized queries and charts: Charts built with NRQL will have View query as an option. You can then edit and customize that query to see how your changes affect the resulting visualization. To explore your data without having to use NRQL, use the basic mode of New Relic One query builder. NRQL query examples Here's an example NRQL query of Transaction data, which is reported by New Relic APM. FROM Transaction SELECT average(duration) FACET appName TIMESERIES auto This would generate a chart that looks like: Here are some more query examples: Basic NRQL query of Browser data Here's a NRQL query of PageView data, which is reported by New Relic Browser. SELECT uniqueCount(user) FROM PageView WHERE userAgentOS = 'Mac' FACET countryCode SINCE 1 day ago LIMIT 20 Attribute name with a space in it If a custom attribute name has a space in it, use backticks around the attribute name: SELECT count(*) FROM Transaction FACET `Logged-in user` Querying multiple data sources To return data from two data sources, separate their data types with a comma. For example, this query returns a count of all APM transactions and Browser events over the last three days:‚Äã SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Query returning multiple columns To return multiple columns from a dataset, separate the aggregator arguments with a comma: SELECT function(attribute), function(attribute) ... FROM ... This query returns the minimum, average, and maximum duration for New Relic Browser PageView events over the last week: SELECT min(duration), max(duration), average(duration) FROM PageView SINCE 1 week ago See more NRQL query examples. NRQL syntax The syntax of a NRQL query is similar to standard SQL queries. Here is a breakdown of the structure of a NRQL query: SELECT function(attribute) [AS 'label'][, ...] FROM data type [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Basic rules include: NRQL condition Details Required values The SELECT statement and FROM clause are required. All other clauses are optional. You can start your query with either SELECT or FROM. Query string size The query string must be less than 4 KB. Case sensitivity The data type names and attribute names are case sensitive. NRQL clauses and functions are not case sensitive. Syntax for strings NRQL uses single quotes to designate strings. For example: ... where traceId = '030a573f0df02c57' Attribute names with spaces Use backticks `` to quote a custom attribute name that has a space in it. For example: ... FACET `Logged-in user` Data type coercion Insights does not support data type \"coercion.\" For more information, see Data type conversion. Use of math functions Basic and advanced math functions are supported in the SELECT statement. JOIN functions NRQL does not have the equivalent of the SQL JOIN function, but you can simulate a JOIN with custom attributes. Read more about NRQL syntax and functions. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.83177,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>NRQL</em>, New Relic&#x27;s query language",
        "sections": "What <em>data</em> can you query with <em>NRQL</em>?",
        "info": "An introduction to New Relic Query Language (<em>NRQL</em>) and how to use it.",
        "category_0": "Query your <em>data</em>",
        "category_1": "<em>NRQL</em>: New Relic Query Language",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;query-your-<em>data</em>&#x2F;<em>nrql</em>-new-relic-query-language&#x2F;get-started&#x2F;introduction-<em>nrql</em>-new-relics-query-language",
        "body": "One way to query your New Relic <em>data</em> is with the New Relic Query Language (<em>NRQL</em>). This resource explains what <em>NRQL</em> is, when and how you can use it, and basic <em>syntax</em> rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see <em>NRQL</em> <em>syntax</em>",
        "breadcrumb": "Contents &#x2F; Query your <em>data</em> &#x2F; <em>NRQL</em>: New Relic Query Language &#x2F; Get started"
      },
      "id": "5f2abd47196a67747343fbe1"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 9231,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Create NRQL alert conditions",
        "Create a NRQL alert condition",
        "Alert threshold types",
        "NRQL alert syntax",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Evaluation offset",
        "Fill data gaps",
        "NRQL alert threshold examples",
        "Nested Aggregation NRQL Alerts",
        "Create a description",
        "For more help"
      ],
      "title": "Create NRQL alert conditions",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "external_id": "956a7a0b84d2afac5e6236df3143085ebc4f7459",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/signal-loss-ui.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "published_at": "2020-10-22T21:28:31Z",
      "updated_at": "2020-10-14T21:48:04Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "How to define thresholds that trigger alert notifications based on your NRQL queries.",
      "body": "You can create alert conditions using NRQL queries. This resource contains information about creating NRQL alert conditions. For more information on key concepts relating to NRQL alert conditions and Streaming Alerts, see Streaming Alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition: When you start to create a condition, where it prompts you to Select a product, click NRQL. Tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. Query results Queries must return a number. The condition works by evaluating that returned number against the thresholds you set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use it to ensure that violations for sporadic data, such as error counts, are closed when no signal is coming in. To learn more about signal loss and how to request access to it, see this announcement. Advanced signal settings You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. The default streaming aggregation window duration is 1 minute. The minimum aggregation window is 30 seconds and the maximum is 15 minutes. Note: Baseline thresholds don't support configurable aggregation window durations. They use the 1 minute default. You can adjust the evaluation offset to coordinate the streaming algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. If your data is sporadic or has aggregation windows that may not have data, you can fill those gaps with a custom value or the lask known value. The default value is None. To learn more about gap filling and how to request access to it, see this announcement Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to the condition to include your organization's procedures for handling the incident. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions do not affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type, except you cannot use a FACET clause. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. NRQL alert syntax Here is the basic syntax for creating all NRQL alert conditions. Depending on the threshold type, also include a FACET clause as applicable. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Optional Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Static: Optional Baseline: Not allowed Outlier: Required Including a FACET clause in your NRQL syntax depends on the threshold type: static, baseline, or outlier. Use the FACET clause to separate your results by attribute and alert on each attribute independently. Faceted queries can return a maximum of 5000 values for static conditions and a maximum of 500 values for outlier conditions. If the query returns more than this number of values, the alert condition cannot be created. If you create the condition and the query returns more than this number later, the alert will fail. Sum of query results (limited or intermittent data) Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of the one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum, and the preview chart will update accordingly. Set the loss of signal threshold Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Create a condition. Loss of signal is only available for NRQL conditions. A loss of signal is a period of time when no data is received by the New Relic One Streaming Alerts platform. This can be because no data is being sent to New Relic, or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. This often indicates that a service or entity is no longer online, or that a periodic job failed to run. You can use loss of signal detection to be notified when an signal is lost, or to ensure that violations for ephemeral services or sporadic data, such as error counts, close when there is no longer data being sent to New Relic. Loss of signal settings: Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration This is a timer that starts, and resets, when we receive a data point in the streaming alerts pipeline. If we do not receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic, or the \"where\" clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline Loss of signal expiration time is independent of the threshold duration, and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we caution you against setting this value below 3-5 minutes. Loss of signal actions Once a signal is considered lost, there are two options. You may choose one option or both. Close all current open violations: This will close all open violations that are related to this specific signal. It will not necessarily close all violations for a condition. If you are alerting on an ephemeral service, or on a sporadic signal, you will want to chose this action to ensure that violations are closed properly. The graphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to loss of signal. Based on your Incident Preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we will close all open violations first, then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: When creating a condition, under Select a product, click NRQL, then click Next, define thresholds. Create a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in the field labeled \"Signal is lost after\" in minutes or seconds. Choose which action(s) to take when the signal is lost. Check the boxes to Close all current open violations and/or Open new \"lost signal\" violation to indicate how loss of signal violations should be handled for this condition. Make sure you name your condition and then save it. You may also manage these settings using the GraphQL API (recommended), or the REST API. See this document for GraphQL API Examples. Please note, loss of signal detection does not work on NRQL queries that use Nested Aggregation (aka sub queries). Evaluation offset The streaming alerts platform works by moving time-bound windows of data, referred to as \"aggregation windows\" through a pipeline. You may configure the duration, or size, of an aggregation window. The default is 1 minute. When we receive a data point in the streaming alerts pipeline, we use the timestamp on the data point to map it to the correct aggregation window. The streaming algorithm uses the server's clock time to advance the aggregation windows forward, and triggers the data to be aggregated using the function in the NRQL query. When a data point arrives at New Relic with a timestamp that is older than the duration of the aggregation window (1 minute by default), the data point may get dropped, and not evaluated by the alert condition. Evaluation Offset defines the number of aggregation windows that we keep in the queue, before we trigger aggregation, to increase the likelihood that the incoming data point will be matched to a waiting aggregation window. If there is a lot of latency before your data arrives, you will have to increase the number of aggregation windows in the evaluation offset. The current default is 3. Aggregation window and Offset evaluation toggles As indicated on the UI, the total supported latency is the multiple of the aggregation window duration times the evaluation offset. In this example, the allowed latency is 15 minutes (5 minute aggregation window X 3). If the event type is sourced from an APM language agent and aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3, with 1 minute aggregation windows. For cloud data, such as AWS integrations, you may need an offset longer than 3 minutes. Check our AWS polling intervals documentation to determine your best setting. Fill data gaps Sometimes a signal will have one or more aggregation windows that does not contain data. This may happen for a variety or reasons, both expected and unexpected. There may be an issue with the network or the host that causes data not to be sent, or the signal may be sparse. Some signals, such as error counts, may only contain data when there are errors. The alert evaluation process needs to know how to process these gaps, and how these gaps should affect the threshold duration. We provide you with 3 gap filling options to choose from : none, last value, and static value. The default is 'none'. How to edit: In the UI, under NRQL Conditions, this control is located under condition settings > advanced signal settings > fill data gaps with . In the Nerdgraph API (preferred), you will find this node located at : actor : account : alerts : nrqlCondition : signal : fillOption | fillValue In the REST API Explorer, you will see this under the the \"signal\" section of the Alert NRQL Conditions API. Gap filling options: None : This is the default. With this option, we do not take any action on empty aggregation windows. When evaluation occurs, an empty aggregation window will reset the threshold duration timer. If the condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition will not be in violation. Custom static value : This option inserts the static value that you specify into the empty windows before evaluation. This option has an additional, required parameter of \"fillValue\" (as named in the API) that specifies what static value should be used. This defaults to \"0\". Last Known Value : This option inserts the last seen value in the gaps before evaluation occurs. We maintain the state of the last seen value for 2 hours. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction SELECT percentile(databaseDuration, 75) FROM Transaction Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction SELECT average(duration) FROM Transaction Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Nested Aggregation NRQL Alerts Nested aggregation queries are a powerful way to query your data and open up new possibilities to alert on. However, they have a few restrictions that are important to note. Nested queries with a non-faceted innermost query are not currently supported Without a FACET, the inner query will produce a single result thus giving the outer query nothing to aggregate. Registering the inner query alone would be equivalent. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu) ‚Äã‚Äã‚Äã‚Äã‚Äã Queries at all levels must have the same aggregation window Assuming the alert is registered with an aggregation window of 1 minute, this inner query would produce 2 smaller windows of width 30 seconds which could be aggregated by the outer query. However, this is not currently supported. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)‚Äã‚Äã Signal loss is not yet supported for nested queries For more information on signal loss, see NerdGraph API: Loss of signal and gap filling. Create a description You can define a description that passes useful information downstream for better violation responses or for use by downstream systems. For details, see Description. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.73497,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>NRQL</em> alert conditions",
        "sections": "<em>NRQL</em> alert <em>syntax</em>",
        "info": "How to define thresholds that trigger alert notifications based on your <em>NRQL</em> queries.",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;alerts-applied-intelligence&#x2F;new-relic-alerts&#x2F;alert-conditions&#x2F;create-<em>nrql</em>-alert-conditions",
        "body": " you set. Time period As with all alert conditions, <em>NRQL</em> conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent <em>data</em> may be incomplete, you may want to query <em>data</em> from"
      },
      "id": "5f2d992528ccbc489d88dfc1"
    },
    {
      "category_2": "NRQL query tutorials",
      "nodeid": 36916,
      "sections": [
        "NRQL: New Relic Query Language",
        "Get started",
        "NRQL query tools",
        "NRQL query tutorials",
        "Query APM metric timeslice data with NRQL",
        "Why query metric timeslice data?",
        "Where to query?",
        "How to construct a query",
        "How metric timeslice data is converted",
        "Attributes",
        "Generic queries with the newrelic.timeslice.value metric",
        "When to use newrelic.timeslice.value?",
        "Get available metrics",
        "Facet on a wildcarded metric name segment",
        "Recommended aggregator functions",
        "Query examples",
        "For more help"
      ],
      "title": "Query APM metric timeslice data with NRQL",
      "category_0": "Query your data",
      "type": "docs",
      "category_1": "NRQL: New Relic Query Language",
      "external_id": "f536406572d7d2aafd2df6acd5da36a035ef82c3",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-one-nrql-query-metric-timeslice-data.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/query-apm-metric-timeslice-data-nrql",
      "published_at": "2020-10-22T14:32:52Z",
      "updated_at": "2020-10-18T15:02:12Z",
      "breadcrumb": "Contents / Query your data / NRQL: New Relic Query Language / NRQL query tutorials",
      "document_type": "page",
      "popularity": 1,
      "info": "In New Relic, you can query metric timeslice data from APM using NRQL. ",
      "body": "APM reports metric data in the form of metric timeslice data, and you can use NRQL to query and facet this type of data. To explore timeslice data in the data explorer, see Explore your metrics. Why query metric timeslice data? We report metrics in several ways. One variety of metric data we call metric timeslice data; this is the type of data used to generate many of the charts in APM, Mobile, and Browser (for more details, see metric timeslice data). Historically, this type of data couldn't be queried via our query language, NRQL. But now we are converting popular APM metrics from metric timeslice data to more-detailed dimensional metric data, which opens them up for querying via NRQL and via our NerdGraph API. This capability allows you to create powerful, in-depth custom visualizations of these important APM metrics. And this includes being able to query your custom metrics. You cannot query timeslice metrics in conjunction with dimensional metrics or event data. Any query involving newrelic.timeslice.value or an apm.* metric can only return APM metrics. Where to query? We recommend querying APM metric timeslice data using New Relic One query builder in advanced mode. This experience offers full NRQL functionality, and also gives helpful auto-complete suggestions and feedback on query errors. You can also incorporate NRQL queries in our NerdGraph (GraphQL) API. How to construct a query In APM, some charts have the option to view the NRQL query that generated that chart. This can be a good option for understanding how to query metrics. The NRQL query examined below is slightly modified from the error rate chart on the APM summary page. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE (entity.guid = 'AN_ENTITY_GUID') AND (transactionType = 'Web') SINCE 1 day ago TIMESERIES Here is a breakdown of how the parts of this query work: Query segment What does it do? FROM Metric Metric is one of our core data types, and metric timeslice data is stored as this data type. For general tips on querying Metric data, see Metric query examples. SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) This math generates a count of errors out of a total count of transaction metrics. This query uses the converted metric names. Note that you can use other aggregator functions. WHERE (entity.guid = 'AN_ENTITY_GUID') You must specify at least one data source. You can select a single entity's GUID, as shown here, or you can select multiple sources. This query uses entity.guid, but you can also use appId or appName. AND (transactionType = 'Web') Sets the transaction type to web, meaning that background/non-web transactions won't be counted. SINCE 1 day ago Selecting a time range. TIMESERIES This optional clause displays the results in a time-based chart. For general information on NRQL syntax, including FROM, FACET, and TIMESERIES, see Intro to NRQL. For more queries, see Query examples. How metric timeslice data is converted The conversion of original APM metric timeslice metrics into dimensional metrics that are available for querying is an ongoing process and isn't complete. If you don't see a metric you're looking for in this section, see Generic queries. Here are how the original APM metric timeslice metrics are converted into dimensional metrics: Metric timeslice structure Dimensional metric structure APM metric names are represented as single strings of segments separated by forward slashes. For example, the ‚ÄúDatastore/statement/MySQL/users/select‚Äù metric represents the time spent in a select database operation on the users table. A single dimensional metric named apm.service.datastore.operation.duration represents the entire group of datastore metrics. This metric has three attributes representing the data values encoded into the metric name, datastoreType, table and operation: datastoreType = ‚ÄòMySQL‚Äô table = ‚Äòusers‚Äô operation = ‚Äòselect‚Äô Some of the APM metrics made available as dimensional metrics: Metric name Description Attributes apm.service.cpu.usertime.utilization Time spent in user-mode code percentage apm.service.datastore.operation.duration Response time for database calls broken out by table operations datastoreType, table, operation apm.service.error.count Summary error count metrics transactionType apm.service.external.host.duration Response time for external calls broken out by external host name external.host apm.service.instance.count Count of the number of agent instances apm.service.memory.physical Process memory in MB apm.service.transaction.apdex Apdex scores per transaction transactionName, transactionType apm.service.transaction.duration Response time per transaction keyTransactionName, transactionName, transactionType apm.service.transaction.error.count Error counts per transaction keyTransactionName, transactionName, transactionType apm.service.transaction.external.duration External call response time by transaction type transactionType Learn how to see all metrics available to you. To understand more about the general structure of metric timeslice data, including some common examples, see Metric timeslice data. Attributes These attributes are available in addition to the metric-specific attributes listed in the APM metrics table above. Name Description appName The name of the application. appId The ID of the application. entity.guid The GUID of the application. host The host of the monitored process. host.bootId The ID of the boot of the host, if available. host.displayName The display_name of the host, if it was set in the agent. instanceName For Java APM agents, host : port metricName The name of the dimensional metric. metricTimesliceName The timeslice name of the legacy metric. scope (Optional) The timeslice name of the legacy metric that this metric is \"scoped\" to. Metrics with a scope belong to it--their measurements apply to the context of the metric named in the scope attribute. See below for examples. Generic queries with the newrelic.timeslice.value metric For metrics that haven't been converted to dimensional metrics, or for your own custom metrics, we have a dimensional metric named newrelic.timeslice.value. We recommend using the dimensional metrics from the table above when possible. When to use newrelic.timeslice.value? Given a metric timeslice name, you can query to see if it has a converted dimensional metric equivalent with this syntax: FROM Metric SELECT uniques(metricName) WHERE metricTimesliceName = 'Datastore/statement/MySQL/test/select' If the only metric name returned is newrelic.timeslice.value, you'll need to query your data using this general approach. Get available metrics To get a list of available metrics for an application, you can use a query like: SELECT uniques(metricTimesliceName) FROM Metric WHERE appName='YOUR_APP_NAME' AND newrelic.timeslice.value IS NOT NULL Facet on a wildcarded metric name segment Some metric timeslice names include attribute values as segments of the metric name. For example, our APM agents report metrics by tracking the duration of external calls using this format: External/{externalHost}/all Here, {externalHost} represents the host name for the outbound network call. Here's an example of a generic newrelic.timeslice.value query of a custom metric that facets on a wildcarded metric segment: FROM Metric SELECT count(newrelic.timeslice.value) WHERE appName = 'MY APP' WITH METRIC_FORMAT 'Custom/Labels/{action}' TIMESERIES FACET action In this query, {action} creates a temporary attribute, action, which is then used by FACET action. You can use any name you want, because it's only an attribute that exists for the duration of the query. You should choose a name that does not conflict with an existing attribute name. Here's another example of a faceted wildcard query: This shows a NRQL query of metric timeslice data that facets the rate of Flask functions by the wildcarded process name. Recommended aggregator functions Recommended NRQL aggregator functions include: apdex average sum count rate uniques Query examples Some examples of querying metric timeslice data: Facet by multiple app names This query uses WHERE‚Ä¶ IN to specify two applications and then facet by them: FROM Metric SELECT rate(count(apm.service.transaction.duration), 1 minute) as 'Web throughput' WHERE appName IN ('MY_APPLICATION', 'MY_OTHER_APPLICATION') AND (transactionType = 'Web') FACET appName TIMESERIES Throughput-per-minute rate This query displays requests-per-minute chart using the rate function: FROM Metric SELECT rate(count(apm.service.transaction.duration), 1 minute) as 'HttpDispatcher requests_per_minute' WHERE appName = 'MY_APPLICATION' AND (transactionType = 'Web') TIMESERIES SINCE 3 days ago Facet by host-related attributes This query displays a requests-per-minute chart faceted by host name: FROM Metric SELECT count(apm.service.transaction.duration) as 'HttpDispatcher requests_per_minute' WHERE appName = 'MY_APPLICATION' AND (transactionType = 'Web') TIMESERIES SINCE 3 hours ago FACET host LIMIT 20 Instead of using host, you can facet by other host-related attributes, like host.bootId. Query of average duration of a metric This queries the average duration for a metric using average: FROM Metric SELECT average(apm.service.transaction.duration) as 'HttpDispatcher average duration' WHERE appName = 'MY_APPLICATION' AND (transactionType = 'Web') TIMESERIES SINCE 3 days ago Break down average time spent in a transaction by its component segments This query breaks down the average duration of single transaction (in this case, the show action in the UsersController of a Rails app named MY_APPLICATION) by the top 20 individual segments (database queries, external service calls, garbage collection time, etc.). It reproduces much of the \"Application breakdown\" chart as seen on the Transactions page In New Relic One for a service entity: FROM Metric SELECT average(newrelic.timeslice.value, exclusiveTime: true) as 'duration, seconds' WHERE appName = 'MY_APPLICATION' AND scope = 'Controller/users/show' LIMIT 20 FACET metricTimesliceName TIMESERIES SINCE 3 days ago For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.49182,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Query APM metric timeslice <em>data</em> with <em>NRQL</em>",
        "sections": "Query APM metric timeslice <em>data</em> with <em>NRQL</em>",
        "info": "In New Relic, you can query metric timeslice <em>data</em> from APM using <em>NRQL</em>. ",
        "category_0": "Query your <em>data</em>",
        "category_1": "<em>NRQL</em>: New Relic Query Language",
        "category_2": "<em>NRQL</em> query tutorials",
        "body": "APM reports metric <em>data</em> in the form of metric timeslice <em>data</em>, and you can use <em>NRQL</em> to query and facet this type of <em>data</em>. To explore timeslice <em>data</em> in the <em>data</em> explorer, see Explore your metrics. Why query metric timeslice <em>data</em>? We report metrics in several ways. One variety of metric <em>data</em> we call",
        "breadcrumb": "Contents &#x2F; Query your <em>data</em> &#x2F; <em>NRQL</em>: New Relic Query Language &#x2F; <em>NRQL</em> query tutorials"
      },
      "id": "5f2b1349196a67379343fbcf"
    }
  ],
  "/explore-docs/nerdpack-file-structure": [
    {
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps"
      ],
      "title": "Add tables to your New Relic One application",
      "type": "developer",
      "tags": [
        "table in app",
        "Table component",
        "TableHeaderc omponent",
        "TableHeaderCell component",
        "TableRow component",
        "TableRowCell component"
      ],
      "external_id": "7ff7a8426eb1758a08ec360835d9085fae829936",
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/",
      "published_at": "2020-10-24T01:53:24Z",
      "updated_at": "2020-10-24T01:53:23Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a table to your New Relic One app.",
      "body": "Add tables to your New Relic One application 30 min Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git` $ cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet` Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. bash Copy $ nr1 nerdpack:uuid -gf # Update the app unique ID $ npm install # Install dependencies $ nr1 nerdpack:serve # Serve the demo app locally Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the nerdlets/create-a-table-nerdlet subdirectory and open the index.js file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside of the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 468.15405,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add tables to your <em>New</em> <em>Relic</em> <em>One</em> application",
        "sections": "Add tables to your <em>New</em> <em>Relic</em> <em>One</em> application",
        "info": "Add a table to your <em>New</em> <em>Relic</em> <em>One</em> app.",
        "body": " the demo application, you need to update its unique id by invoking the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. Once you&#x27;ve assigned a <em>new</em> UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. bash Copy $ nr1 <em>nerdpack</em>:uuid -gf # Update the app unique ID"
      },
      "id": "5efa989ee7b9d2ad567bab51"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Summary",
        "Related information"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2020-10-24T01:51:45Z",
      "updated_at": "2020-08-21T01:45:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Create a \"Hello, World!\" application 15 min Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin To get started, make sure you have accounts in GitHub and New Relic. To develop projects, you need the New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete all the steps in the CLI quick start. For additional details about setting up your environment, see Set up your development environment. Tip Use the NR1 VS Code extension to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two artifacts: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: npm start Copy Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: nr1 nerdpack:publish Copy Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: nr1 create Copy Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: nr1 catalog:submit Copy Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it. Related information Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can see it directly on their homepage.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 381.1871,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Publish your application to <em>New</em> <em>Relic</em>",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "body": "!&quot; application The <em>CLI</em> allows you to run a local version of <em>New</em> <em>Relic</em> <em>One</em>. You can develop your application locally before you publish it in <em>New</em> <em>Relic</em> <em>One</em>. If you followed all the steps in the <em>CLI</em> quick start, you now have files under a <em>new</em> directory named after your <em>nerdpack</em> project. Here&#x27;s how you edit"
      },
      "id": "5efa9973196a67d16d76645c"
    },
    {
      "sections": [
        "Map page views by region in a custom app",
        "Before you begin",
        "New Relic terminology",
        "Build a custom app with a table chart",
        "Query your browser data",
        "Create and serve a new Nerdpack",
        "Review your app files and view your app locally",
        "Hard code your account ID",
        "Import the TableChart component",
        "Add a table with a single row",
        "Customize the look of your table (optional)",
        "Get your data into that table",
        "Make your app interactive with a text field",
        "Import the TextField component",
        "Add a row for your text field",
        "Build the text field object",
        "Get your data on a map",
        "Install Leaflet",
        "Add a webpack config file for Leaflet",
        "Import modules from Leaflet",
        "Import additional modules from New Relic One",
        "Get data for the map",
        "Customize the map marker colors",
        "Set your map's default center point",
        "Add a row for your map",
        "Replace \"Hello\" with the Leaflet code"
      ],
      "title": "Map page views by region in a custom app",
      "type": "developer",
      "tags": [
        "custom app",
        "map",
        "page views",
        "region",
        "nerdpack"
      ],
      "external_id": "6ff5d696556512bb8d8b33fb31732f22bab455cb",
      "image": "https://developer.newrelic.com/static/d87a72e8ee14c52fdfcb91895567d268/0086b/pageview.png",
      "url": "https://developer.newrelic.com/build-apps/map-pageviews-by-region/",
      "published_at": "2020-10-24T01:51:47Z",
      "updated_at": "2020-10-24T01:51:46Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a New Relic app showing page view data on a world map.",
      "body": "Map page views by region in a custom app 30 min New Relic has powerful and flexible tools for building custom apps and populating them with data. This guide shows you how to build a custom app and populate it with page view data using New Relic's Query Language (NRQL - pronounced 'nurkle'). Then you make your data interactive. And last, if you have a little more time and want to install a third-party React library, you can display the page view data you collect on a map of the world. In this guide, you build an app to display page view data in two ways: In a table On a map Please review the Before you begin section to make sure you have everything you need and don't get stuck halfway through. Before you begin In order to get the most out of this guide, you must have: A New Relic developer account, API key, and the command-line tool. If you don't have these yet, see the steps in Setting up your development environment New Relic Browser page view data to populate the app. Without this data, you won't be able to complete this guide. To add your data to a world map in the second half of the guide: npm, which you'll use during this section of the guide to install Leaflet, a third-party JavaScript React library used to build interactive maps. If you're new to React and npm, you can go here to install Node.js and npm. New Relic terminology The following are some terms used in this guide: New Relic application: The finished product where data is rendered in New Relic One. This might look like a series of interactive charts or a map of the world. Nerdpack: New Relic's standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see Nerdpack file structure. Launcher: The button on New Relic One that launches your application. Nerdlets: New Relic React components used to build your application. The three default files are index.js, nr1.json, and styles.scss, but you can customize and add your own. Build a custom app with a table chart Step 1 of 8 Query your browser data Use Query builder to write a NRQL query to see your page view data, as follows. On New Relic One, select Query your data (in the top right corner). That puts you in NRQL mode. You'll use NRQL to test your query before dropping the data into your table. Copy and paste this query into a clear query field, and then select Run. FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000 Copy If you have PageView data, this query shows a week of average page views broken down by country and limited to a thousand items. The table will be full width and use the \"chart\" class defined in the CSS. If you don't have any results at this point, ensure your query doesn't have any errors. If your query is correct, you might not have the Browser agent installed. Step 2 of 8 Create and serve a new Nerdpack To get started, create a new Nerdpack, and serve it up to New Relic from your local development environment: Create a new Nerdpack for this app: bash Copy $ nr1 create --type nerdpack --name pageviews-app ‚úî Component created successfully! nerdpack pageviews-app is available at \"./pageviews-app\" Serve the project up to New Relic: bash Copy $ cd pageviews-app && nr1 nerdpack:serve Found and loaded 2 nr1.json files on PageviewsApp (00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45) Nerdpack. Nerdpack: ‚úî PageviewsApp (00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45) nr1.json Launchers: ‚úî pageviews-app-launcher launchers/pageviews-app-launcher/nr1.json Nerdlets: ‚úî pageviews-app-nerdlet nerdlets/pageviews-app-nerdlet/nr1.json üõ† Built artifact files for: ‚Åé 00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45--pageviews-app-nerdlet built ‚úî ‚úî Nerdpack built successfully! ‚òÖ Starting as orchestrator... ‚úî Server ready! Test it at: https://staging-one.newrelic.com/?nerdpacks=local ‚Ü© Server will reload automatically if you modify any file! üõ† Built artifact files for: ‚Åé 00e0f043-1fc3-42cd-a8ca-7eef5fc9cd45--pageviews-app-nerdlet built ‚úî ‚úî Nerdpack built successfully! Step 3 of 8 Review your app files and view your app locally Navigate to your pageviews-app to see how it's structured. It contains a launcher folder, where you can customize the description and icon that will be displayed on the app's launcher in New Relic One. It also contains nerdlets, which each contain three default files: index.js, nr1.json, and styles.scss. You'll edit some of these files as part of this guide. For more information, see Nerdpack file structure. Now in your browser, open https://one.newrelic.com/?nerdpacks=local, and then click Apps to see the pageview-apps Nerdpack that you served up. When you select the launcher, you see a Hello message. Step 4 of 8 Hard code your account ID For the purposes of this exercise and for your convenience, hard code your account ID. In the pageview-app-nerdlet directory, in the index.js file, add this code between the import and export lines. (Read about finding your account ID here). index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 3 const accountId = 0; // Replace with your account ID 4 5 export default class PageViewApp extends React.Component { 6 render() { 7 return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; 8 } 9 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 5 of 8 Import the TableChart component To show your data in a table chart, import the TableChart component from New Relic One. To do so, in index.js, add this code under import React. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; 9 } 10 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 6 of 8 Add a table with a single row To add a table with a single row, in the index.js file, replace this line with this export code: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"></div> 11 </div> 12 ); 13 } 14 } pageview-app-nerdlet/index.js Copy 1 pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 7 of 8 Customize the look of your table (optional) You can use standard CSS to customize the look of your components. In the styles.scss file, add this CSS. Feel free to customize this CSS to your taste. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"></div> 11 </div> 12 ); 13 } 14 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 8 of 8 Get your data into that table Now that you've got a table, you can drop a TableChart populated with data from the NRQL query you wrote at the very beginning of this guide. Put this code into the row div. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <TableChart 12 accountId={accountId} 13 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 14 fullWidth 15 className=\"chart\" 16 /> 17 </div> 18 </div> 19 ); 20 } 21 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Go to New Relic One and click your app to see your data in the table. (You might need to serve your app to New Relic again.) Congratulations! You made your app! Continue on to make it interactive and show your data on a map. Make your app interactive with a text field Once you confirm that data is getting to New Relic from your app, you can start customizing it and making it interactive. To do this, you add a text field to filter your data. Later, you use a third-party library called Leaflet to show that data on a world map. Step 1 of 3 Import the TextField component Like you did with the TableChart component, you need to import a TextField component from New Relic One. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <TableChart 12 accountId={accountId} 13 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 14 fullWidth 15 className=\"chart\" 16 /> 17 </div> 18 </div> 19 ); 20 } 21 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 2 of 3 Add a row for your text field To add a text field filter above the table, put this code above the TableChart div. The text field will have a default value of \"US\". index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 render() { 8 return ( 9 <div className=\"container\"> 10 <div className=\"row\"> 11 <div className=\"row\"> 12 <TextField 13 placeholder=\"US\" 14 onChange={(event) => { 15 this.setState({ countryCode: event.target.value }); 16 }} 17 /> 18 </div> 19 <TableChart 20 accountId={accountId} 21 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 22 fullWidth 23 className=\"chart\" 24 /> 25 </div> 26 </div> 27 ); 28 } 29 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 3 of 3 Build the text field object Above the render() function, add a constructor to build the text field object. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 return ( 16 <div className=\"container\"> 17 <div className=\"row\"> 18 <div className=\"row\"> 19 <TextField 20 placeholder=\"US\" 21 onChange={(event) => { 22 this.setState({ countryCode: event.target.value }); 23 }} 24 /> 25 </div> 26 <TableChart 27 accountId={accountId} 28 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 29 fullWidth 30 className=\"chart\" 31 /> 32 </div> 33 </div> 34 ); 35 } 36 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Above return, add: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} 31 fullWidth 32 className=\"chart\" 33 /> 34 </div> 35 </div> 36 ); 37 } 38 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Now add countryCode to your table chart query. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 .container { 2 width: 100%; 3 height: 99vh; 4 display: flex; 5 flex-direction: column; 6 .row { 7 margin: 10px; 8 display: flex; 9 flex-direction: row; 10 } 11 .chart { 12 height: 250px; 13 } 14 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Reload your app to try out the text field. Get your data on a map To create the map, you use npm to install Leaflet. Step 1 of 9 Install Leaflet In your terminal, type: bash Copy $ npm install --save leaflet react-leaflet In your nerdlets styles.scss file, import the Leaflet CSS: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy While you're in styles.scss, fix the width and height of your map: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 .extended-webpackrc.js Copy Step 2 of 9 Add a webpack config file for Leaflet Add a webpack configuration file .extended-webpackrc.js to the top-level folder in your nerdpack. This supports your use of map tiling information data from Leaflet. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 4 const accountId = 0; // Replace with your account ID 5 6 export default class PageViewApp extends React.Component { 7 constructor(props) { 8 super(props); 9 this.state = { 10 countryCode: null, 11 }; 12 } 13 14 render() { 15 const { countryCode } = this.state; 16 17 return ( 18 <div className=\"container\"> 19 <div className=\"row\"> 20 <div className=\"row\"> 21 <TextField 22 placeholder=\"US\" 23 onChange={(event) => { 24 this.setState({ countryCode: event.target.value }); 25 }} 26 /> 27 </div> 28 <TableChart 29 accountId={accountId} 30 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 31 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 32 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 33 fullWidth 34 className=\"chart\" 35 /> 36 </div> 37 </div> 38 ); 39 } 40 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 3 of 9 Import modules from Leaflet In index.js, import modules from Leaflet. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { TableChart, TextField } from 'nr1'; 3 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 4 5 const accountId = 0; // Replace with your account ID 6 7 export default class PageViewApp extends React.Component { 8 constructor(props) { 9 super(props); 10 this.state = { 11 countryCode: null, 12 }; 13 } 14 15 render() { 16 const { countryCode } = this.state; 17 18 return ( 19 <div className=\"container\"> 20 <div className=\"row\"> 21 <div className=\"row\"> 22 <TextField 23 placeholder=\"US\" 24 onChange={(event) => { 25 this.setState({ countryCode: event.target.value }); 26 }} 27 /> 28 </div> 29 <TableChart 30 accountId={accountId} 31 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 32 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 33 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 34 fullWidth 35 className=\"chart\" 36 /> 37 </div> 38 </div> 39 ); 40 } 41 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 4 of 9 Import additional modules from New Relic One You need several more modules from New Relic One to make the Leaflet map work well. Import them with this code: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 render() { 23 const { countryCode } = this.state; 24 25 return ( 26 <div className=\"container\"> 27 <div className=\"row\"> 28 <div className=\"row\"> 29 <TextField 30 placeholder=\"US\" 31 onChange={(event) => { 32 this.setState({ countryCode: event.target.value }); 33 }} 34 /> 35 </div> 36 <TableChart 37 accountId={accountId} 38 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 39 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 40 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 41 fullWidth 42 className=\"chart\" 43 /> 44 </div> 45 </div> 46 ); 47 } 48 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy NerdGraphQuery lets you make multiple NRQL queries at once and is what will populate the map with data. Spinner adds a loading spinner. Button gives you button components. BlockText give you block text components. Step 5 of 9 Get data for the map Using latitude and longitude with country codes, you can put New Relic data on a map. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 mapData() { 23 const { countryCode } = this.state; 24 const query = `{ 25 actor { 26 account(id: 1606862) { 27 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 28 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 29 } LIMIT 1000 \") { 30 results 31 nrql 32 } 33 } 34 } 35 }`; 36 37 return query; 38 } 39 40 render() { 41 const { countryCode } = this.state; 42 43 return ( 44 <div className=\"container\"> 45 <div className=\"row\"> 46 <div className=\"row\"> 47 <TextField 48 placeholder=\"US\" 49 onChange={(event) => { 50 this.setState({ countryCode: event.target.value }); 51 }} 52 /> 53 </div> 54 <TableChart 55 accountId={accountId} 56 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 57 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 58 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 59 fullWidth 60 className=\"chart\" 61 /> 62 </div> 63 </div> 64 ); 65 } 66 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 6 of 9 Customize the map marker colors Above the mapData function, add this code to customize the map marker colors. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 53 return ( 54 <div className=\"container\"> 55 <div className=\"row\"> 56 <div className=\"row\"> 57 <TextField 58 placeholder=\"US\" 59 onChange={(event) => { 60 this.setState({ countryCode: event.target.value }); 61 }} 62 /> 63 </div> 64 <TableChart 65 accountId={accountId} 66 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 67 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 68 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 69 fullWidth 70 className=\"chart\" 71 /> 72 </div> 73 </div> 74 ); 75 } 76 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Feel free to change the HTML color code values to your taste. In this example, #11A600 is green, #FFD966 is sort of yellow, and #BF0016 is red. Step 7 of 9 Set your map's default center point Set a default center point for your map using latitude and longitude. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <TableChart 66 accountId={accountId} 67 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 68 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 69 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 70 fullWidth 71 className=\"chart\" 72 /> 73 </div> 74 </div> 75 ); 76 } 77 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Step 8 of 9 Add a row for your map Between the text field row and the table chart row, insert a new row for the map content using NerdGraphQuery. index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <div className=\"row\"> 66 <NerdGraphQuery query={this.mapData()}> 67 {({ loading, error, data }) => { 68 if (loading) { 69 return <Spinner fillContainer />; 70 } 71 if (error) { 72 return 'Error'; 73 } 74 const { results } = data.actor.account.mapData; 75 console.debug(results); 76 return 'Hello'; 77 }} 78 </NerdGraphQuery> 79 </div> 80 <TableChart 81 accountId={accountId} 82 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 83 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 84 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 85 fullWidth 86 className=\"chart\" 87 /> 88 </div> 89 </div> 90 ); 91 } 92 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy Reload your application in New Relic One to test that it works. Step 9 of 9 Replace \"Hello\" with the Leaflet code Replace return \"Hello\"; with: index.js styles.scss .extended-webpackrc.js 1 import React from 'react'; 2 import { 3 TableChart, 4 TextField, 5 NerdGraphQuery, 6 Spinner, 7 Button, 8 BlockText, 9 } from 'nr1'; 10 import { Map, CircleMarker, TileLayer } from 'react-leaflet'; 11 12 const accountId = 0; // Replace with your account ID 13 14 export default class PageViewApp extends React.Component { 15 constructor(props) { 16 super(props); 17 this.state = { 18 countryCode: null, 19 }; 20 } 21 22 getMarkerColor(measure, apdexTarget = 1.7) { 23 if (measure <= apdexTarget) { 24 return '#11A600'; 25 } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { 26 return '#FFD966'; 27 } else { 28 return '#BF0016'; 29 } 30 } 31 32 mapData() { 33 const { countryCode } = this.state; 34 const query = `{ 35 actor { 36 account(id: 1606862) { 37 mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${ 38 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 39 } LIMIT 1000 \") { 40 results 41 nrql 42 } 43 } 44 } 45 }`; 46 47 return query; 48 } 49 50 render() { 51 const { countryCode } = this.state; 52 const defaultMapCenter = [10.5731, -7.5898]; 53 54 return ( 55 <div className=\"container\"> 56 <div className=\"row\"> 57 <div className=\"row\"> 58 <TextField 59 placeholder=\"US\" 60 onChange={(event) => { 61 this.setState({ countryCode: event.target.value }); 62 }} 63 /> 64 </div> 65 <div className=\"row\"> 66 <NerdGraphQuery query={this.mapData()}> 67 {({ loading, error, data }) => { 68 if (loading) { 69 return <Spinner fillContainer />; 70 } 71 if (error) { 72 return 'Error'; 73 } 74 const { results } = data.actor.account.mapData; 75 console.debug(results); 76 77 return ( 78 <Map 79 className=\"containerMap\" 80 center={defaultMapCenter} 81 zoom={2} 82 zoomControl 83 > 84 <TileLayer 85 attribution='&amp;copy <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' 86 url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\" 87 /> 88 {results.map((pt, i) => { 89 const center = [pt.lat, pt.lng]; 90 return ( 91 <CircleMarker 92 key={`circle-${i}`} 93 center={center} 94 color={this.getMarkerColor(pt.y)} 95 radius={Math.log(pt.x) * 3} 96 onClick={() => { 97 alert(JSON.stringify(pt)); 98 }} 99 /> 100 ); 101 })} 102 </Map> 103 ); 104 }} 105 </NerdGraphQuery> 106 </div> 107 <TableChart 108 accountId={accountId} 109 query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ 110 countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' 111 } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} 112 fullWidth 113 className=\"chart\" 114 /> 115 </div> 116 </div> 117 ); 118 } 119 } pageview-app-nerdlet/index.js Copy 1 @import `~leaflet/dist/leaflet.css`; 2 3 .container { 4 width: 100%; 5 height: 99vh; 6 display: flex; 7 flex-direction: column; 8 .row { 9 margin: 10px; 10 display: flex; 11 flex-direction: row; 12 } 13 .chart { 14 height: 250px; 15 } 16 } 17 18 .containerMap { 19 width: 100%; 20 z-index: 0; 21 height: 70vh; 22 } pageview-app-nerdlet/styles.scss Copy 1 module.exports = { 2 module: { 3 rules: [ 4 { 5 test: /\\.(png|jpe?g|gif)$/, 6 use: [ 7 { 8 loader: 'file-loader', 9 options: {}, 10 }, 11 { 12 loader: 'url-loader', 13 options: { limit: 25000 }, 14 }, 15 ], 16 }, 17 ], 18 }, 19 }; .extended-webpackrc.js Copy This code creates a world map centered on the latitude and longitude you chose using OpenStreetMap data and your marker colors. Reload your app to see the pageview data on the map!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 371.4619,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Import additional modules from <em>New</em> <em>Relic</em> <em>One</em>",
        "info": "Build a <em>New</em> <em>Relic</em> app showing page view data on a world map.",
        "tags": "<em>nerdpack</em>",
        "body": " look like a series of interactive charts or a map of the world. <em>Nerdpack</em>: <em>New</em> <em>Relic</em>&#x27;s standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see <em>Nerdpack</em> <em>file</em> <em>structure</em>. <em>Launcher</em>: The button on <em>New</em> <em>Relic</em> <em>One</em>"
      },
      "id": "5efa993c196a67066b766469"
    },
    {
      "sections": [
        "Add a time picker",
        "Before you begin",
        "Important",
        "Prepare the time picker sample code",
        "Import the PlatformStateContext component",
        "Add the time to the queries",
        "Summary"
      ],
      "title": "Add a time picker",
      "type": "developer",
      "tags": [
        "time picker",
        "app",
        "helper method",
        "platformstatecontext"
      ],
      "external_id": "2602edf3077388ba4fded3a76208e5e0ae1be98f",
      "image": "https://developer.newrelic.com/static/7f679da4c4ffce5fa547a04b27ac700d/0086b/add-timepicker.png",
      "url": "https://developer.newrelic.com/build-apps/add-time-picker-guide/",
      "published_at": "2020-10-24T01:53:26Z",
      "updated_at": "2020-10-24T01:53:26Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a time picker to a sample application",
      "body": "Add a time picker 20 min This guide steps you through the process of adding access to our time picker in the sample transaction overview application. The sample application provides an overview of the telemetry data showing your account's transactions by application, average response time, HTTP response codes, and transaction errors. When you enable the time picker, users can specify the time range of data to view. We also have a 12 minute video that covers the steps below. Before you begin To develop projects, you need our New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete steps 1‚Äì4 of the CLI quick start. In step 1, be sure to make a copy of the number preceding your account name. This is your accound ID, and you‚Äôll need it later. Important If you've already installed the New Relic One CLI, but you can't remember your account ID, start the CLI quick start again, and then click the Get your API key down arrow. The account ID is the number preceding your account name. For additional details, see Set up your development environment. Prepare the time picker sample code To get started, complete these steps to update the application UUID (unique ID) and run the sample application locally: Step 1 of 7 If you haven't already done so, clone the example applications from our how-to GitHub repo. bash Copy $ git clone https://github.com/newrelic/nr1-how-to.git Step 2 of 7 Change to the directory nr1-howto-add-time-picker-nerdlet: bash Copy $ cd nr1-how-to/add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet Step 3 of 7 In your preferred text editor, open index.js. Step 4 of 7 Replace <ADD YOUR ACCOUNT ID> with your account id: Important Your account ID is available in the CLI quick start (see Before you begin). this.accountId = <ADD YOUR ACCOUNT ID>; Copy Step 5 of 7 Change to the add-time-picker directory: cd / nr1 - how - to / add - time - picker; Copy Step 6 of 7 Execute these commands to update the UUID and serve the sample application: nr1 nerdpack:uuid -gf nr1 nerdpack:serve Copy Step 7 of 7 Once the sample application is successfully served, go to the local version of New Relic One (https://one.newrelic.com/?nerdpacks=local) click Apps, and click Add Time Picker. After launching the Add Time Picker application, you see a dashboard that gives an overview of the transactions in your New Relic account: By default, the application shows your data within the last 60 minutes. If you toggle the time picker, it doesn't update the charts because the transaction overview application isn't connected to the New Relic One platform. It has no access to the data from the time picker. In the following sections, you'll add the time picker to the example application and add the time to the queries. Import the PlatformStateContext component The first step in adding the time picker is to import the PlatformStateContext component. Important If you need more details about the PlatformStateContext example that follows, see the APIs and components page Here's what the PlatformStateContext component does: Wraps all of the code within the return statement of the render method Makes a function call passing in the New Relic platform state Returns all of the code within our current return statement Complete these steps: Step 1 of 5 In a text editor, open /add-time-picker/nerdlets/nr1-howto-add-time-picker-nerdlet/index.js. Step 2 of 5 Add the PlatformStateContext component to the end of the import statement so it looks like this: import { Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, PlatformStateContext, } from 'nr1'; Copy Step 3 of 5 Just below the current return insert this code for the PlatformStateContext component: <PlatformStateContext.Consumer> {(platformState) => { return ( // ADD THE CURRENT RETURN CODE HERE ) }} </PlatformStateContext.Consumer> Copy Step 4 of 5 Move the current application code so it is under the return of the PlatformState function call. The return statement should now look like this: return ( <PlatformStateContext.Consumer> {(PlatformState) => { return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); Copy Step 5 of 5 Add a console.log statement to make sure you are seeing appropriate data. Insert the following code inside the PlatformState return statement just before the opening tag for the <Grid> component: /* Taking a peek at the PlatformState */ console.log(PlatformState); Copy After you complete these steps, your browser console displays something like this: Add the time to the queries In your console, you should see some data from the New Relic platform state. Now you're ready to add timeRange data to update the charts in the transaction overview application. This step requires you to import the timeRangeToNrql utility method from the New Relic One community library. Important You can get more details on the New Relic One community library from our GitHub repo. This helper method takes your PlatformState.timeRange duration data, formats it from milliseconds, and returns a formatted SINCE statement to add to your NRQL. Step 1 of 4 Import the timeRangeToNrql method by inserting this line of code below the other import sections: Important You don't need to include the AccountDropdown from the community import example. import { timeRangeToNrql } from '@newrelic/nr1-community'; Copy Step 2 of 4 Pass the PlatformState to the timeRangeToNrql helper, and save its output as a since statement for later use: const since = timeRangeToNrql(PlatformState); Copy Step 3 of 4 After creating the since variable, go through the code in the PlatformStateContext return statement and concatenate the since variable in each of the existing chart component queries. Here's a TableChart example: <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} />; Copy Step 4 of 4 After you update all of the chart components, confirm that the final index.js file looks similar to this: Important This completed sample code is in your nerdlet final.js. import React from 'react'; import { PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, PieChart, } from 'nr1'; import { timeRangeToNrql } from '@newrelic/nr1-community'; export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props) { super(props); this.accountId = 1; } render() { const avgResTime = `SELECT average(duration) FROM Transaction FACET appName TIMESERIES AUTO `; const trxOverview = `FROM Transaction SELECT count(*) as 'Transactions', apdex(duration) as 'apdex', percentile(duration, 99, 95) FACET appName `; const errCount = `FROM TransactionError SELECT count(*) as 'Transaction Errors' FACET error.message `; const responseCodes = `SELECT count(*) as 'Response Code' FROM Transaction FACET httpResponseCode `; return ( <PlatformStateContext.Consumer> {(PlatformState) => { /* Taking a peek at the PlatformState */ console.log(PlatformState); const since = timeRangeToNrql(PlatformState); console.log(since); return ( <> <Grid className=\"primary-grid\" spacingType={[Grid.SPACING_TYPE.NONE, Grid.SPACING_TYPE.NONE]} > <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Overview </HeadingText> <TableChart fullWidth accountId={this.accountId} query={trxOverview + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Average Response Time </HeadingText> <AreaChart fullWidth accountId={this.accountId} query={avgResTime + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Response Code </HeadingText> <PieChart fullWidth accountId={this.accountId} query={responseCodes + since} /> </main> </GridItem> <GridItem className=\"primary-content-container\" columnSpan={6}> <main className=\"primary-content full-height\"> <HeadingText spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} type={HeadingText.TYPE.HEADING_4} > Transaction Errors </HeadingText> <PieChart fullWidth accountId={this.accountId} query={errCount + since} /> </main> </GridItem> </Grid> </> ); }} </PlatformStateContext.Consumer> ); } } Copy Summary When you completed all the steps in this example, you successfully implemented the time picker in your application by importing the PlatformStateContext component and accessing its timePicker data object.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 362.7732,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " response codes, and transaction errors. When you enable the time picker, users can specify the time range of data to view. We also have a 12 minute video that covers the steps below. Before you begin To develop projects, you need our <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (command line interface). If you haven&#x27;t already"
      },
      "id": "5efa993d28ccbc91ff307dde"
    },
    {
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Subscribe or unsubscribe apps",
        "Handle duplicate applications"
      ],
      "title": "Serve, publish, and deploy your New Relic One app",
      "type": "developer",
      "tags": [
        "publish apps",
        "deploy apps",
        "subscribe apps",
        "add metadata apps"
      ],
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "published_at": "2020-10-24T01:54:36Z",
      "updated_at": "2020-10-14T01:58:45Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Start sharing and using the custom New Relic One apps you build",
      "body": "Serve, publish, and deploy your New Relic One app 30 min When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. nr1 update Copy Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. nr1 catalog:submit Copy Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Subscribe or unsubscribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 335.63397,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and deploy your <em>New</em> <em>Relic</em> <em>One</em> app",
        "sections": "Serve, publish, and deploy your <em>New</em> <em>Relic</em> <em>One</em> app",
        "info": "Start sharing and using the custom <em>New</em> <em>Relic</em> <em>One</em> apps you build",
        "body": " to the app Handle duplicate applications Before you begin This guide requires the following: A <em>New</em> <em>Relic</em> <em>One</em> app or <em>Nerdpack</em> <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> A <em>Nerdpack</em> manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to <em>New</em> <em>Relic</em> <em>One</em> to test"
      },
      "id": "5efa999de7b9d283e67bab8f"
    }
  ]
}