{
  "/build-apps/add-query-mutate-data-nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Permissions for managing applications",
        "Publish and deploy apps",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Build apps",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Permissions for managing applications ¬† Learn about permissions for subscribing to apps Publish and deploy apps 30 min Start sharing the apps you build Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 391.55542,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em>",
        "body": " from your account and <em>add</em> it to a dropdown menu in an application <em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em> 45 min <em>NerdStorage</em> is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. <em>Add</em> a time picker to your app"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies üç™"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2021-02-10T01:54:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash Copy --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic decode - Use the decode url command to print out information encrypted within the URL newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.37106,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching <em>data</em> from your laptop while troubleshooting an issue, or adding New Relic into your CI&#x2F;CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash Copy"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/user-storage-mutation/",
      "sections": [
        "UserStorageMutation",
        "Usage",
        "Examples",
        "Write document",
        "Delete document",
        "Delete collection",
        "Props",
        "Methods",
        "UserStorageMutation.render",
        "UserStorageMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:51:51Z",
      "title": "UserStorageMutation",
      "updated_at": "2021-01-29T01:58:05Z",
      "type": "developer",
      "external_id": "1f38ffb2681d23040587f4b46a5db3bffeff7206",
      "document_type": "page",
      "popularity": 1,
      "body": "Save, delete, or update a user scoped document in NerdStorage. Usage import { UserStorageMutation } from 'nr1' Copy Examples Write document 1 UserStorageMutation.mutate({ 2 actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, 3 collection: 'mycollection', 4 documentId: 'mydocumentID', 5 document: { 6 name: 'John', 7 surname: 'Doe', 8 }, 9 }); Copy Delete document 1 UserStorageMutation.mutate({ 2 actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, 3 collection: 'mycollection', 4 documentId: 'mydocumentID', 5 }); Copy Delete collection 1 UserStorageMutation.mutate({ 2 actionType: UserStorageMutation.ACTION_TYPE.DELETE_COLLECTION, 3 collection: 'mycollection', 4 }); Copy Props actionTyperequiredenum Type of action to perform. <One of UserStorageMutation.ACTION_TYPE.DELETE_COLLECTION , UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT , UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT , > childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : {Object // Results of the mutation. ) => undefined collectionstring Name of the collection to mutate. documentobject NerdStorage document. Documents are restricted to 64KB in size. documentIdstring ID of the document to mutate. Methods UserStorageMutation.render function () => undefined UserStorageMutation.mutate Static method to use UserStorageMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any UserStorageMutation prop is a valid option except children. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.67007,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Save, delete, or update a user scoped document in <em>NerdStorage</em>. Usage import { UserStorageMutation } from &#x27;nr1&#x27; Copy Examples Write document 1 UserStorageMutation.<em>mutate</em>({ 2 actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, 3 collection: &#x27;mycollection&#x27;, 4 documentId: &#x27;mydocumentID&#x27;, 5"
      },
      "id": "5efa993c196a67066b766466"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/account-storage-mutation/",
      "sections": [
        "AccountStorageMutation",
        "Usage",
        "Examples",
        "Write document",
        "Delete document",
        "Delete collection",
        "Props",
        "Methods",
        "AccountStorageMutation.render",
        "AccountStorageMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:55:32Z",
      "title": "AccountStorageMutation",
      "updated_at": "2021-01-29T01:54:06Z",
      "type": "developer",
      "external_id": "ebcf287cdc8712a7a0f6c95b60e49a5e5d3fac66",
      "document_type": "page",
      "popularity": 1,
      "body": "Save, delete, or update an account scoped document in NerdStorage. In order to successfully perform this operation, the user must have the right permissions. Usage import { AccountStorageMutation } from 'nr1' Copy Examples Write document 1 AccountStorageMutation.mutate({ 2 accountId: 1, 3 actionType: AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, 4 collection: 'mycollection', 5 documentId: 'mydocumentID', 6 document: { 7 name: 'John', 8 surname: 'Doe', 9 }, 10 }); Copy Delete document 1 AccountStorageMutation.mutate({ 2 accountId: 1, 3 actionType: AccountStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, 4 collection: 'mycollection', 5 documentId: 'mydocumentID', 6 }); Copy Delete collection 1 AccountStorageMutation.mutate({ 2 accountId: 1, 3 actionType: AccountStorageMutation.ACTION_TYPE.DELETE_COLLECTION, 4 collection: 'mycollection', 5 }); Copy Props accountIdnumber Account ID. actionTyperequiredenum Type of action to perform. <One of AccountStorageMutation.ACTION_TYPE.DELETE_COLLECTION , AccountStorageMutation.ACTION_TYPE.DELETE_DOCUMENT , AccountStorageMutation.ACTION_TYPE.WRITE_DOCUMENT , > childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : {Object // Results of the mutation. ) => undefined collectionstring Name of the collection to mutate. documentobject NerdStorage document. Documents are restricted to 64KB in size. documentIdstring ID of the document to mutate. Methods AccountStorageMutation.render function () => undefined AccountStorageMutation.mutate Static method to use AccountStorageMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any AccountStorageMutation prop is a valid option except children. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.66758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Save, delete, or update an account scoped document in <em>NerdStorage</em>. In order to successfully perform this operation, the user must have the right permissions. Usage import { AccountStorageMutation } from &#x27;nr1&#x27; Copy Examples Write document 1 AccountStorageMutation.<em>mutate</em>({ 2 accountId: 1, 3"
      },
      "id": "5efa997364441f8d055f7e61"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/entity-storage-mutation/",
      "sections": [
        "EntityStorageMutation",
        "Usage",
        "Examples",
        "Write document",
        "Delete document",
        "Delete collection",
        "Props",
        "Methods",
        "EntityStorageMutation.render",
        "EntityStorageMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:52:59Z",
      "title": "EntityStorageMutation",
      "updated_at": "2021-01-29T01:55:32Z",
      "type": "developer",
      "external_id": "da00b0c5ac105e1bdff9a733569cfa006d7dd65c",
      "document_type": "page",
      "popularity": 1,
      "body": "Save, delete, or update an entity scoped document in NerdStorage. In order to successfully perform this operation, the user must have the right permissions. Usage import { EntityStorageMutation } from 'nr1' Copy Examples Write document 1 EntityStorageMutation.mutate({ 2 entityGuid: 'MTIzNDU2fEZPT3xCQVJ8OTg3NjU0Mzcz', 3 actionType: EntityStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, 4 collection: 'mycollection', 5 documentId: 'mydocumentID', 6 document: { 7 name: 'John', 8 surname: 'Doe', 9 }, 10 }); Copy Delete document 1 EntityStorageMutation.mutate({ 2 entityGuid: 'MTIzNDU2fEZPT3xCQVJ8OTg3NjU0Mzcz', 3 actionType: EntityStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, 4 collection: 'mycollection', 5 documentId: 'mydocumentID', 6 }); Copy Delete collection 1 EntityStorageMutation.mutate({ 2 entityGuid: 'MTIzNDU2fEZPT3xCQVJ8OTg3NjU0Mzcz', 3 actionType: EntityStorageMutation.ACTION_TYPE.DELETE_COLLECTION, 4 collection: 'mycollection', 5 }); Copy Props actionTyperequiredenum Type of action to perform. <One of EntityStorageMutation.ACTION_TYPE.DELETE_COLLECTION , EntityStorageMutation.ACTION_TYPE.DELETE_DOCUMENT , EntityStorageMutation.ACTION_TYPE.WRITE_DOCUMENT , > childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : {Object // Results of the mutation. ) => undefined collectionstring Name of the collection to mutate. documentobject NerdStorage document. Documents are restricted to 64KB in size. documentIdstring ID of the document to mutate. entityGuidstring GUID of the entity in which the collection is stored. Methods EntityStorageMutation.render function () => undefined EntityStorageMutation.mutate Static method to use EntityStorageMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any EntityStorageMutation prop is a valid option except children. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.60563,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Save, delete, or update an entity scoped document in <em>NerdStorage</em>. In order to successfully perform this operation, the user must have the right permissions. Usage import { EntityStorageMutation } from &#x27;nr1&#x27; Copy Examples Write document 1 EntityStorageMutation.<em>mutate</em>({ 2 entityGuid"
      },
      "id": "5efa999d196a67d9ff76645e"
    }
  ],
  "/automate-workflows/5-mins-tag-resources": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Automate common tasks",
        "Set up New Relic using the Kubernetes operator",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Automate workflows",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.25696,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " Toolkit. Guides to automate workflows Quickly <em>tag</em> resources 5 min Add <em>tags</em> to apps for easy filtering Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em>"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2021-02-25T01:58:11Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag‚Å† (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.66145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " application. You should copy it or write it down. Step 6 of 10 Add a simple <em>tag</em> to your application. Now that you have the GUID, you can point the <em>New</em> <em>Relic</em> <em>CLI</em> directly at your application. Adding a <em>tag</em> is the simplest way to try out the <em>CLI</em> capabilities (don&#x27;t worry, <em>tags</em> can be deleted by using"
      },
      "id": "5efa999c196a67c4e1766461"
    },
    {
      "category_2": "Examples",
      "nodeid": 42656,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "Golden metrics for entities NerdGraph API tutorial",
        "Fetch golden metrics",
        "Fetch golden tags",
        "Customize golden metrics and golden tags",
        "Override golden metrics or golden tags for a specific entity type in your whole account",
        "Override golden metrics from a particular entity type in a workload",
        "Fetch the custom golden metrics and golden tags",
        "Reset custom metrics and golden tags",
        "Expected errors",
        "For more help"
      ],
      "title": "Golden metrics for entities NerdGraph API tutorial",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "956bc04201d39123c3cb69777298c967ab1c4cfd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/golden-metrics-entities-nerdgraph-api-tutorial",
      "published_at": "2021-02-23T07:47:19Z",
      "updated_at": "2021-02-21T15:35:42Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic's NerdGraph (our GraphQL API) to query or override golden metrics and tags.",
      "body": "Golden metrics and golden tags are bits of information about an entity that we consider to be the most important for that entity. We use this information to display a brief overview of an entity across all New Relic. You can see and contribute to the standard definitions of the golden metrics and tags in this public repository. This document explains how to query an entity's custom metrics using NerdGraph. For more on how to query entities using the NerdGraph API, see our tutorial. Fetch golden metrics When fetching golden metrics for a specific GUID or list of GUIDS, the provided queries are already filtered for you. You can run the resulting query as is in the query builder. The resulting metric can be either a timeseries or a single value. Here's an example of one golden metric query for an AWS DynamoDB table entity with the GUID ExampleGUID. SELECT average(provider.getSuccessfulRequestLatency.Average) FROM DatastoreSample WHERE entityGuid IN ('ExampleGUID') AND provider='DynamoDbTable' TIMESERIES You can use NerdGraph to query for the golden metrics of a specific entity; for example: { actor { entity(guid: \"ENTITY-GUID\") { goldenMetrics { query title } } } } Fetch golden tags Golden tags are always represented the same way, whether requested by GUID or by entityType. You will always receive the list of tag keys considered the most important about the entity. { actor { entity(guid: \"ENTITY-GUID\") { goldenTags { key } } } } Customize golden metrics and golden tags If you want to change the golden metrics and golden tags based on the specificities of your environment, you can override them in two different contexts, in your account, or in a workload. Override golden metrics or golden tags for a specific entity type in your whole account In this case, the new golden metrics or the new golden tags will be applied in all New Relic One, converting your new metrics and tags as the default for the specified entity type. To do that, you can use a NerdGraph mutation to override the golden metrics for a specific entity. mutation { entityGoldenMetricsOverride( context: {account: ACCOUNT_TO_OVERRIDE_GOLDEN METRICS}, domainType: {domain: DOMAIN, type: TYPE}, metrics: [ {eventId: EVENT_ID, select: NRDB_QUERY_SELECT, from: NRDB_QUERY_EVENT, where: NRDB_QUERY_WHERE, title: TITLE_OF_THE_METRIC, facet: FACET, name: NAME_OF_THE_METRIC}, ...]) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } Where: domainType: The entity type of the metrics to override. context: The context to fetch the golden metrics from. In this case, you should set the account that you want to override. metrics: The new NRDB query will be shown as golden metrics. eventId: The field used to filter the entity in the metric. How the entity GUID is defined in your event. select: The SELECT clause of the NRDB query. This field is required. from: The FROM clause of the NRDB query. where: Complementary where clause to identify the entity type field. facet: The field to FACET. title: The title of the golden metric. This field is optional. name: The name of the golden metric. This field is required. Override an APM application mutation { entityGoldenMetricsOverride( context: {account: ACCOUNT_ID}, domainType: {domain: \"APM\", type: \"APPLICATION\"}, metrics: [ {eventId: \"entity.guid\", from: \"Transaction\", name: \"cpuUsage\", select: \"max(cpuUsage)\", title: \"CPU Usage\"}, {eventId: \"guid\", from: \"Metric\", where: \"metricTimesliceName in ('HttpDispatcher', 'OtherTransaction/all')\", facet: \"appName\", select: \"count(newrelic.timeslice.value)\", name: \"throughput\", title: \"Throughput\"}]) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } The metrics input object defines the parts of an NRDB query, split into sections. One of these sections is the eventId, which is used to identify the field that defines the GUID inside the NRDB Event you want to use as a golden metric. For example: SELECT average(provider.getSuccessfulRequestLatency.Average) FROM DatastoreSample WHERE entityGuid IN ('EntityGuid') AND provider='DynamoDbTable' FACET entityName TIMESERIES It's defined as follows: { eventId: \"entityGuid\", from: \"DatastoreSample\", where: \"provider='DynamoDbTable'\", facet: \"entityName\", select: \"average(provider.getSuccessfulRequestLatency.Average)\", name: GetItem latency (ms), title: GetItem latency (ms) } As you can see in the resultant object, the where clause only contains the provider field. The system adds the where clause with the eventId field by default. You can do the same for the golden tags using this NerdGraph mutation: mutation { entityGoldenTagsOverride( context: {account: ACCOUNT_ID}, domainType: {domain: \"APM\", type: \"APPLICATION\"}, tags: [{key: \"applicationName\"} , {key: \"environment\"} ]) { errors { message type } tags { context { account } domainType { domain type } tags { key } } } } Override golden metrics from a particular entity type in a workload New Relic's workloads provide an aggregated view of health and performance data about a group of entities. The time series charts shown for each entity type in a workload are defined by the golden metrics in the workload account. If you want to further customize which time series to show for a specific entity type in a particular workload, override the golden metrics in the account with the following mutation: mutation { entityGoldenMetricsOverride( context: {guid: WORKLOAD_TO_OVERRIDE_GOLDEN METRICS}, domainType: {domain: DOMAIN, type: TYPE}, metrics: [ {eventId: EVENT_ID, select: NRDB_QUERY_SELECT, from: NRDB_QUERY_EVENT, where: NRDB_QUERY_WHERE, title: TITLE_OF_THE_METRIC, facet: FACET, name: NAME_OF_THE_METRIC}, ...]) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } See above for details on each field. In this case, context is the workload's GUID. Override an APM application mutation { entityGoldenMetricsOverride( context: {guid: WORKLOAD_ENTITY_GUID}, domainType: {domain: \"APM\", type: \"APPLICATION\"}, metrics: [ {eventId: \"entity.guid\", from: \"Transaction\", name: \"cpuUsage\", select: \"max(cpuUsage)\", title: \"CPU Usage\"}, {eventId: \"guid\", from: \"Metric\", where: \"metricTimesliceName in ('HttpDispatcher', 'OtherTransaction/all')\", facet: \"appName\", select: \"count(newrelic.timeslice.value)\", name: \"throughput\", title: \"Throughput\"}]) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } Fetch the custom golden metrics and golden tags The queries defined in the previous sections always return the default golden metrics and golden tags. If you want to fetch your custom golden metrics or golden tags, you need to send the context defined in the query, for example: { actor { entity(guid: INFRA-AWSDYNAMODBTABLE-GUID) { goldenMetricsByContext( context: {account: ACCOUNT_ID, guid: WORKLOAD_ENTITY_GUID}) { metrics { title query name } } } } } For golden tags: { actor { entity(guid: INFRA-AWSDYNAMODBTABLE-GUID) { goldenTags(context: {account: ACCOUNT_ID, guid: WORKLOAD_ENTITY_GUID}) { tags { key } } } } } You can send both contexts simultaneously for querying, if your metrics or tags have the context inside the workload. The API returns the most specific golden metric or golden tags based on the context that you defined in the requests. The priority is workload and account. Reset custom metrics and golden tags If your custom golden metrics are not relevant to you any more, you can restore the defaults defined by New Relic. In the context parameter, set the desired account or workload guid (in the guid parameter). To restore your golden metrics in an account, run this query: mutation { entityGoldenMetricsReset( context: {guid: ACCOUNT_TO_OVERRIDE_GOLDEN_METRICS}, domainType: {domain: DOMAIN, type: TYPE}) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } Where: domainType: The entity type of the metrics to override. context: The context to fetch the golden metrics from. In this case, you should set the account you want to reset. To restore your golden metrics in a workload, run this query: mutation { entityGoldenMetricsReset( context: {guid: GUID_TO_OVERRIDE_GOLDEN_METRICS}, domainType: {domain: DOMAIN, type: TYPE}) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } You can do the same for your custom golden tags: mutation { entityGoldenTagsReset( context: {guid: WORKLOAD_ENTITY_GUID}, domainType: {domain: \"APM\", type: \"APPLICATION\"}) { errors { message type } tags { key context { account guid } domainType { domain type } tags { key } } } } Expected errors All these mutations can answer with the result of the operation or a list of errors. These are all the expected errors that you can receive: INVALID_CONTEXT: The context is not valid. There can only be one context, an account or a workload's GUID. If you use both, or use any other concept, or a GUID that doesn't belong to a workload, you will get this error. INVALID_DOMAIN_TYPE: The domain type is not valid. LIMIT_EXCEEDED: The maximum amount of metrics is 9. If you exceed this limit you will get this error. NOT_AUTHORIZED: The user doesn't have the permissions to carry out this action. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.3534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Fetch golden <em>tags</em>",
        "info": "Use <em>New</em> <em>Relic&#x27;s</em> NerdGraph (our GraphQL API) to query or override golden metrics and <em>tags</em>.",
        "body": "Golden metrics and golden <em>tags</em> are bits of information about an entity that we consider to be the most important for that entity. We use this information to display a brief overview of an entity across all <em>New</em> <em>Relic</em>. You can see and contribute to the standard definitions of the golden metrics"
      },
      "id": "60327dcfe7b9d2f2838b3bb0"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/32r7lf1gmda1w/promo-image.1608575562.png",
      "url": "https://learn.newrelic.com/go-deeper-advanced-alerting-nrql-alerts",
      "sections": [
        "Delve deeper into Alerts and move beyond the basics to implement an effective alerting strategy in this FREE 2 hour workshop. With scenario based labs, you‚Äôll create specific policies and conditions for typical use cases, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance s",
        "About this workshop"
      ],
      "published_at": "2021-02-25T01:39:49Z",
      "title": "Go Deeper: Advanced Alerting & NRQL Alerts",
      "updated_at": "2021-02-25T01:39:49Z",
      "type": "",
      "external_id": "a44bc2bed49a8b258b97a438df3e7a0bbcf7095a",
      "popularity": 1,
      "body": "Sign In Go Deeper: Advanced Alerting & NRQL Alerts Delve deeper into Alerts and move beyond the basics to implement an effective alerting strategy in this FREE 2 hour workshop. With scenario based labs, you‚Äôll create specific policies and conditions for typical use cases, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios. Register | FREE Already registered? Sign In About this workshop You‚Äôve mastered Alerting Fundamentals and want to know more about alerting? Join this highly practical and engaging session where we delve deeper into how to move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you, and get routed effectively to relevant teams or tools.¬†¬† With scenario based labs, you‚Äôll create specific policies and conditions for typical use cases across the full stack, use tags to dynamically target entities, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.¬† The format of this session will include best practices, challenge based labs and activities, and takeaways you can immediately apply to your accounts, or your requirements.¬† Agenda and Labs Effective Alerting strategies¬† SLO‚Äôs, SLA‚Äôs and Thresholds Use Cases and labs:¬† Alerting on SLA‚Äôs Alerting on variable performance -Dynamic Baseline Alerting Using tags to dynamically target Entities NRQL Alerts; Outlier detection, and other use cases Lab: Alert on Multiple issues (Static),¬† Lab: Alert on Synthetic performance (Dynamic),¬† Lab: Alert on Outlier behaviour (Outlier - Facets) Notifying the right team: Channels, Test Channels and Webhooks¬† Lab: Webhook Challenge Alerts and Dashboarding¬† Lab: Charting alerts Managing Alerts and Conditions REST API and Muting Rules Go Deeper: Advanced Alerting & NRQL Alerts Event Date Spaces left Go Deeper: Advanced Alerting & NRQL Alerts Feb. 25, 2021, 10 a.m. - Feb. 25, 2021, noon GMT 105 Go Deeper: Advanced Alerting & NRQL Alerts Feb. 25, 2021, 10 a.m. - Feb. 25, 2021, noon PST 95 Go Deeper: Advanced Alerting & NRQL Alerts March 23, 2021, 10 a.m. - March 23, 2021, noon GMT 145 Go Deeper: Advanced Alerting & NRQL Alerts March 30, 2021, 10 a.m. - March 30, 2021, noon PDT 148 About this workshop You‚Äôve mastered Alerting Fundamentals and want to know more about alerting? Join this highly practical and engaging session where we delve deeper into how to move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you, and get routed effectively to relevant teams or tools.¬†¬† With scenario based labs, you‚Äôll create specific policies and conditions for typical use cases across the full stack, use tags to dynamically target entities, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.¬† The format of this session will include best practices, challenge based labs and activities, and takeaways you can immediately apply to your accounts, or your requirements.¬† Agenda and Labs Effective Alerting strategies¬† SLO‚Äôs, SLA‚Äôs and Thresholds Use Cases and labs:¬† Alerting on SLA‚Äôs Alerting on variable performance -Dynamic Baseline Alerting Using tags to dynamically target Entities NRQL Alerts; Outlier detection, and other use cases Lab: Alert on Multiple issues (Static),¬† Lab: Alert on Synthetic performance (Dynamic),¬† Lab: Alert on Outlier behaviour (Outlier - Facets) Notifying the right team: Channels, Test Channels and Webhooks¬† Lab: Webhook Challenge Alerts and Dashboarding¬† Lab: Charting alerts Managing Alerts and Conditions REST API and Muting Rules Live events Go Deeper: Advanced Alerting & NRQL Alerts Event Date Spaces left Go Deeper: Advanced Alerting & NRQL Alerts Feb. 25, 2021, 10 a.m. - Feb. 25, 2021, noon GMT 105 Go Deeper: Advanced Alerting & NRQL Alerts Feb. 25, 2021, 10 a.m. - Feb. 25, 2021, noon PST 95 Go Deeper: Advanced Alerting & NRQL Alerts March 23, 2021, 10 a.m. - March 23, 2021, noon GMT 145 Go Deeper: Advanced Alerting & NRQL Alerts March 30, 2021, 10 a.m. - March 30, 2021, noon PDT 148 ¬© 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.998825,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", use <em>tags</em> to dynamically target entities, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.¬† The format of this session will include best practices, challenge based labs and activities, and takeaways you can immediately apply to your accounts, or your requirements"
      },
      "id": "600789b728ccbc0c0a3f6fa8"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:38:35Z",
      "title": "New Relic Developers",
      "updated_at": "2021-02-06T01:37:36Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes ¬† Use custom attributes for deeper analysis Show 28 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.22891,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "Getting started with <em>New</em> <em>Relic</em> and Terraform",
        "body": " source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    }
  ],
  "/automate-workflows/diagnose-problems/error-alerts": [
    {
      "sections": [
        "Practice diagnosing common issues using New Relic",
        "Welcome to Acme Telco Lite!",
        "Set up your environment",
        "Deploy Telco Lite",
        "Tip",
        "View your services",
        "Tear down Telco Lite",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Practice diagnosing common issues using New Relic",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "0d4529b0c9a58c8b8d3098b4916d99c61f649cba",
      "image": "https://developer.newrelic.com/static/f94b1522d40914cb51e86ff2166f5c8e/0e533/acme.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Automatically spin up a microservice infrastructure, and use New Relic to diagnose its issues.",
      "body": "Every time you deploy an application, you hope that it's efficient and error-free. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or rely on a broken dependency. These issues, and others, can result in bad user experiences. In this guide, you: Use the open-source New Relic demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This demo scenario is part of our Demo Catalog and will simulate real-world issues in a controlled, demo environment Use New Relic to understand those issues from the perspective of a Telco Lite developer Use the deployer to tear down the resources you create Welcome to Acme Telco Lite! Acme Telco Lite is a mock telecom business that maintains an eCommerce website for its customers. The site's architecture has eight, interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. Set up your environment Before you begin, follow the Prerequisites guide from the deployer's GitHub repository for a detailed walkthrough of how to set up your environment. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. The guide steps you through: Installing Docker & pulling the demo-deployer image locally Creating a user config file containing credentials for New Relic and your cloud provider Downloading a .pem key file (if your cloud provider is AWS) Once you're all set up, deploy Acme Telco Lite. Deploy Telco Lite It's time to deploy and instrument the Telco Lite services using demo-deployer. Copy the url for the demo that corresponds to the cloud provider you chose when you set up your environment: AWS Telco Lite Demo Azure Telco Lite Demo GCP Telco Lite Demo Follow the Deployment guide in the Demo Catalog repository for a thorough explanation of how to use the deployer in a local Docker environment. When you run the deployment script, make sure to pass the url you copied for <demo-url>. Tip Since Telco Lite contains several services, the deployment can take over half an hour. When the deloyer is finished, you should see some output stating that the deployment was successful: bash Copy [INFO] Executing Deployment [‚úî] Parsing and validating Deployment configuration success [‚úî] Provisioner success [‚úî] Installing On-Host instrumentation success [‚úî] Installing Services and instrumentations success [INFO] Deployment successful! Deployed Resources: simuhost (aws/ec2): ip: 34.201.60.23 services: [\"simulator\"] uihost (aws/ec2): ip: 18.233.97.28 services: [\"webportal\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 backendhost (aws/ec2): ip: 35.170.192.236 services: [\"promo\", \"login\", \"inventory\", \"plan\", \"fulfillment\", \"warehouse\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 reportinghost (aws/ec2): ip: 54.152.82.127 services: [\"billing\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 Installed Services: simulator: url: http://34.201.60.23:5000 webportal: url: http://18.233.97.28:5001 instrumentation: nr_node_agent: newrelic v6.11.0 nr_logging_in_context: newrelic promo: url: http://35.170.192.236:8001 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic login: url: http://35.170.192.236:8002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic inventory: url: http://35.170.192.236:8003 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic plan: url: http://35.170.192.236:8004 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fulfillment: url: http://35.170.192.236:8005 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic billing: url: http://54.152.82.127:9001 instrumentation: nr_java_agent: newrelic v5.14.0 nr_logging_in_context: newrelic nr_logging: newrelic warehouse: url: http://35.170.192.236:9002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fluentd: url: http://18.233.97.28:9999 url: http://35.170.192.236:9999 url: http://54.152.82.127:9999 Completed at 2020-08-11 11:27:00 -0700 [INFO] This deployment summary can also be found in: [INFO] /tmp/telcolite/deploy_summary.txt After configuring your environment, you only needed two commands (and a bit of patience) to spin up all the Telco Lite services! View your services With your services running in the cloud, log in to New Relic and select APM from the top navigation to see how your services are holding up: Yikes! The alerts, high response times, and red-colored indicators suggest things aren't well. Use New Relic to diagnose these issues, which are simultaneously affecting your services: Issue 1: The Warehouse Portal has abnormally high response times Issue 2: Multiple services are raising error alerts Tip Don't worry if you don't see all the same alerts. The simulator triggers issues at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. Tear down Telco Lite When you're finished diagnosing all the issues effecting Telco Lite, follow the Teardown guide in the deployer's repository to tear down the services you created in your cloud provider. If you're still exploring, don't tear down your services, or you'll have to deploy them again later. Conclusion Congratulations, you're done! Throughout this tutorial, you: Used the demo-deployer to deploy Telco Lite to the cloud Used New Relic to investigate simulated issues in Telco Lite services Tore down all the infrastructural resources you created throughout this tutorial Hopefully, you learned a lot about using New Relic to investigate issues in your services. To get your hands on more features of New Relic, pick another demo from the catalog and spin it up with the deployer!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 62.391693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": ". In this guide, you: Use the open-source New Relic <em>demo</em>-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This <em>demo</em> scenario is part of our <em>Demo</em> Catalog and will simulate real-world issues in a controlled, <em>demo</em> environment Use New Relic to understand those issues from"
      },
      "id": "5f97897864441f14936ed88e"
    },
    {
      "sections": [
        "Diagnose high response times in Telco Lite",
        "Prerequisites",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Diagnose high response times in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "257b617b5a1c415b4563b211805653c5f59647b1",
      "image": "https://developer.newrelic.com/static/7b43ba54fb07afd22eb0b6b72e8aacc0/0086b/high-response-times.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/high-response-times/",
      "published_at": "2021-02-25T01:58:11Z",
      "updated_at": "2020-12-04T01:54:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose high response times in your services.",
      "body": "Use New Relic to understand why Telco-Warehouse Portal has slower-than-normal response times. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the high response times in your services. Step 1 of 6 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that the response time for Telco-Warehouse Portal is 43 seconds, much higher than the response times in other services: On the APM page, select the Telco-Warehouse Portal service name to see a summary of that service. The top graph in the summary view shows Web transactions time: You see several peaks, reaching almost 50,000 milliseconds‚Äîor 50 seconds! From this graph, you can actually gain a little more insight by toggling the colored components beneath the graph. For example, select Node.js: The graph changes to show only what the Node.js component contributes to the overall response time‚Äîless than 100 ms, in this example. Now, select Web external and deselect Node.js: External web traffic is the primary contributor to the high response times. That's a good start, but it doesn't tell the whole story. Next, dive deeper to find out which external service is causing the issue. Step 2 of 6 So, you know that Web external is the culprit of the high response times, but it's hard to tell why. External web traffic is all the requests made from your service to other services. This means you should look into what external requests that the warehouse portal makes to try to understand exactly what external service is the bottleneck. From the left-hand navigation, select Monitor > Distributed tracing: This view shows you requests to the warehouse portal. Select a request from the table at the bottom of the view to see a trace through that request: This trace shows that one external request contributes almost all of the total trace duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select Explore this transaction: Step 3 of 6 You're now looking at the __main__:inventory_item transaction overview. Because you know that some part of this transaction is slow, you can use this overview to narrow your focus even further. Similar to how you modified the warehouse portal APM graph, you can look specifically at the components of this transaction to understand where the root cause of the slowness is. Another way to view this information is to scroll down to the Breakdown table in that same view: Function/__main__:inventory_item, a Python function, contributes over 99% of the overall response time. At this point, you know that Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow. You also know that the issue in the fulfillment service is local because over 99% of the request is spent in Python code, not external services. Navigate to the fulfillment service's summary page to look at the service as a whole, instead of this single transaction: Step 4 of 6 Scroll down on this view to familiarize yourself with the graphs it shows, such as Throughput and Error rate. At the bottom of the page, you can see a table with the fulfillment hosts. You can't currently drill into a specific host in the new UI (we're working on it), but you can in the old UI. Toggle Show new view to off and select the host link: Step 5 of 6 Now, you're looking at graphs in the infrastructure view for that service's host. Notice that CPU % has a lot of high spikes. Click and drag on the graph from the start of a spike to the end of it to narrow the timeslice to the period when CPU utilization goes up: If you compare this graph to the fulfillment service's transaction graph you looked at earlier, you'll see that soon after __main__:inventory_item begins executing, the CPU utilization of the host sharply rises to 100%! Step 6 of 6 Now, you understand the problem causing slow response times in the warehouse portal, but you don't know the extent of the issue. Using service maps, you can see all your services that depend on the fullfillment service. Navigate to the service map under APM > Telco-Fulfillment Service: This map shows you the fulfillment service's incoming and outgoing dependencies. Not only is Telco-Warehouse Portal dependent on the fullfillment service, but so is Telco-Web Portal! Select the web portal node to see that the fulfillment service also affects the web portal's response times: Conclusion At the end of your investigation, you discovered: Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow The fulfillment service's Python function contributes over 99% of the response time Soon after the Python function starts executing, the host's CPU utilization spikes up to 100% The fulfillment service also affects Telco-Web Portal response times Now, as the developer behind the fulfillment service, you have enough information to debug the issue causing the CPU spikes. Congratulations! You can learn more about using New Relic by diagnosing other issues. If this is your last issue, you can tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 54.912186,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": " duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select <em>Explore</em>"
      },
      "id": "5f9789dde7b9d23fd65c94fa"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/kr/request-demo",
      "sections": [
        "ÎùºÏù¥Î∏å Îç∞Î™® ÏöîÏ≤≠ÌïòÍ∏∞",
        "Í∏∞ÏóÖÏ†ïÎ≥¥",
        "Í≥†Í∞ùÎ¨∏Ïùò",
        "Ìï¥Ïô∏ ÏÇ¨Ïù¥Ìä∏"
      ],
      "published_at": "2021-02-22T14:26:20Z",
      "title": "Request Demo",
      "updated_at": "2021-01-07T14:41:26Z",
      "type": "",
      "external_id": "eba55c740b0a5077de3c90126c802b60d5ce7926",
      "popularity": 1,
      "body": "logo-newrelic Search Ï†úÌíà ÏöîÍ∏à ÏÜîÎ£®ÏÖò ÏßÄÏõê ÏÑºÌÑ∞ Ï†ïÎ≥¥ iOS ÎòêÎäî AndroidÏö© Îâ¥Î†êÎ¶≠ ¬†¬† iOSÏö© Îâ¥Î†êÎ¶≠ Insights Ïï± Search icon Ïã†Ï≤≠ÌïòÍ∏∞ Î°úÍ∑∏Ïù∏ÌïòÍ∏∞ Ï†úÌíà Îâ¥Î†êÎ¶≠ One ÌîåÎû´Ìèº Í∞úÏöî Telemetry Data Platform Full-Stack Observability Applied Intelligence ÏÜîÎ£®ÏÖò Ï£ºÏ†úÎ≥Ñ Îç∞Î∏åÏòµÏä§ ÌÅ¥ÎùºÏö∞Îìú ÎèÑÏûÖ ÌÅ¥ÎùºÏö∞Îìú ÎÑ§Ïù¥Ìã∞Î∏å ÎîîÏßÄÌÑ∏ Í≥†Í∞ù Í≤ΩÌóò Tool ÌÜµÌï© ÏóÖÏ¢ÖÎ≥Ñ Ïù¥Ïª§Î®∏Ïä§ Î∞è Î¶¨ÌÖåÏùº ÎØ∏ÎîîÏñ¥ Í≥µÍ≥µ Î∂ÄÎ¨∏ Í∏∞Ïà†Î≥Ñ Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes ÏßÄÏõê ÏÑºÌÑ∞ ÌôïÏù∏ÌïòÍ∏∞ Docs Îâ¥Î†êÎ¶≠Ïóê Í∏∞Î∞òÌïú Íµ¨Ï∂ï Ïò§Ìîà ÏÜåÏä§ ÌîÑÎ°úÏ†ùÌä∏ ÏÇ¥Ìé¥Î≥¥Í∏∞ ÍµêÏú° ÎèÑÏõÄ ÏöîÏ≤≠ÌïòÍ∏∞ Ïª§ÎÆ§ÎãàÌã∞ Ìè¨Îüº Í∏ÄÎ°úÎ≤å Í∏∞Ïà† ÏßÄÏõê Ï†ÑÎ¨∏Í∞Ä ÏÑúÎπÑÏä§ Ï†ïÎ≥¥ Í≥†Í∞ù Ìè¨Ï∂òÏùò 'Í∏ÄÎ°úÎ≤å 500ÎåÄ Í∏∞ÏóÖ‚ÄôÏóêÏÑú Ï§ëÏÜåÍ∏∞ÏóÖÍπåÏßÄ, Ï†Ñ ÏÑ∏Í≥Ñ 17,000Ïó¨ Í∏∞ÏóÖÎì§Ïù¥ Îâ¥Î†êÎ¶≠ÏùÑ ÏÇ¨Ïö©ÌïòÍ≥† ÏûàÏäµÎãàÎã§. Î∏îÎ°úÍ∑∏ Îâ¥Î†êÎ¶≠Í≥º ÎîîÏßÄÌÑ∏ Ïù∏ÌÖîÎ¶¨Ï†ÑÏä§Ïùò ÏÑ∏Í≥ÑÍ∞Ä Ï†úÍ≥µÌïòÎäî ÏµúÏã† Îâ¥Ïä§, ÌåÅ Î∞è ÌÜµÏ∞∞ÏùÑ ÌôïÏù∏Ìï† Ïàò ÏûàÏäµÎãàÎã§. ¬†¬† Close icon Îâ¥Î†êÎ¶≠ Ï†ïÎ≥¥ ÌöåÏÇ¨ ÏÜåÍ∞ú Í≤ΩÏòÅÏßÑ Î™®ÏûÑ Î∞è Ïù¥Î≤§Ìä∏ Ï∞∏Í≥† ÏûêÎ£å ¬† Ìà¨ÏûêÏûê Ï†ïÎ≥¥ Îâ¥Ïä§Î£∏ ÌååÌä∏ÎÑà ÌîÑÎ°úÍ∑∏Îû® Ïó∞ÎùΩ Ï†ïÎ≥¥ logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon ÎùºÏù¥Î∏å Îç∞Î™® ÏöîÏ≤≠ÌïòÍ∏∞ ÏïÑÎûò¬†ÏñëÏãùÏùÑ¬†ÏÇ¨Ïö©Ìï¥¬†ÏßÄÍ∏à¬†ÎßûÏ∂§Ìòï¬†ÎùºÏù¥Î∏å¬†Îç∞Î™®Î•º¬†ÏöîÏ≤≠ÌïòÏã≠ÏãúÏò§. Í∏∞ÏóÖÏ†ïÎ≥¥ Ï±ÑÏö© Î∞è Î¨∏Ìôî ÌååÌä∏ÎÑà ÌîÑÎ°úÍ∑∏Îû® Ìà¨ÏûêÏûê Ï†ïÎ≥¥ NewRelic.org Í≥µÍ∏âÏóÖÏ≤¥ Ìè¨ÌÑ∏ Í≥†Í∞ùÎ¨∏Ïùò Ïó∞ÎùΩ Ï†ïÎ≥¥ Îç∞Î™® Ïã†Ï≤≠ÌïòÍ∏∞ Ïù¥Î≤§Ìä∏ Ìï¥Ïô∏ ÏÇ¨Ïù¥Ìä∏ Deutsch English Fran√ßais Êó•Êú¨Ë™û ÏÑúÎπÑÏä§ Ïù¥Ïö©ÏïΩÍ¥Ä DMCA Ï†ïÏ±Ö Í∞úÏù∏Ï†ïÎ≥¥ Ï≤òÎ¶¨Î∞©Ïπ® Ïø†ÌÇ§ Ï†ïÏ±Ö 2015ÎÖÑ ÏòÅÍµ≠ ÎÖ∏Ïòà Î∞©ÏßÄÎ≤ï ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 14.969709,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Request <em>Demo</em>"
      },
      "id": "5fdc3078196a679498213956"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/request-demo",
      "sections": [
        "Request a live demo.",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-02-25T01:50:08Z",
      "title": "Request a New Relic Demo | New Relic",
      "updated_at": "2021-01-04T13:42:55Z",
      "type": "",
      "external_id": "3106a7a9ae5e77d7d4c56815b91f8933a4faeb1f",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Request a live demo. Use the form below to request your personalized live demo. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 11.987905,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Request a New Relic <em>Demo</em> | New Relic",
        "sections": "Request a live <em>demo</em>.",
        "body": " Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects"
      },
      "id": "5786ed3ce621f423f2e9cf78"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/resources/webinars/apac-live-demo-optimizing-CX?video=past-webinar",
      "sections": [
        "Learn why over 16,000 companies use the New Relic One Observability Platform daily to:",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-02-22T16:22:23Z",
      "title": "On-Demand Demo: Optimising the Customer Experience with New Relic One",
      "updated_at": "2021-01-01T04:37:32Z",
      "type": "storefront",
      "external_id": "57f7b338dbf4898ff26209e8eddb8704a22589e1",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Video On-Demand Demo: Optimising the Customer Experience with New Relic One 61:56 ¬† Interested in learning more about New Relic One before you decide to sign up? Watch this demo of New Relic One led by a member of our Solutions Engineering team to see a detailed tour of the observability platform. Learn why over 16,000 companies use the New Relic One Observability Platform daily to: Measure real-user experience - See and understand the intricacies of who‚Äôs using your site, and identify ways to improve their experience. Catch problems before customers - Simulate real user flows across every digital touchpoint‚Äîstarting in development, through QA, and all the way into production. Cultivate deeper customer relationships - Gain real-time insight into what your users are experiencing and how they‚Äôre engaging with your content. Request a Demo COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 10.213428,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "On-Demand <em>Demo</em>: Optimising the Customer Experience with New Relic One",
        "body": " Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects"
      },
      "id": "5ed2fe0728ccbc929bc135d3"
    }
  ],
  "/automate-workflows/automated-tagging": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Automate common tasks",
        "Set up New Relic using the Kubernetes operator",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Automate workflows",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.46875,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Automate</em> workflows",
        "sections": "<em>Automatically</em> <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em>",
        "body": " Toolkit. Guides to <em>automate</em> workflows Quickly <em>tag</em> resources 5 min Add tags to apps for easy filtering Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em> 30 min See how easy it is to leverage automation in <em>your</em> DevOps environment! <em>Automate</em> common tasks 20 min Use the New Relic CLI"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "nodeid": 42681,
      "sections": [
        "Recent Announcements",
        "New Relic Explorer: Say goodbye to blindspots"
      ],
      "title": "New Relic Explorer: Say goodbye to blindspots",
      "type": "docs",
      "external_id": "21e248f7fffe0717e40484e37f7a0bcf3ed3e66e",
      "image": "",
      "url": "https://docs.newrelic.com/whats-new/new-relic-explorer-say-goodbye-blindspots",
      "published_at": "2021-02-25T08:39:12Z",
      "updated_at": "2021-02-24T22:31:16Z",
      "breadcrumb": "Contents / What's New",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "New Relic Explorer lets you discover emerging issues in real time, without relying on static, pre-configured thresholds or dashboards, because crucial changes in your estate are highlighted across all your accounts. View everything in one place, including open source and third-party data, with zero configuration. At a glance, gain instant understanding of health and changes across your entire environment so you can zoom in to analyze, understand, and resolve issues faster. New Relic Explorer includes several new approaches to visualizing, exploring, and understanding your entire estate: New Relic Lookout provides a real-time view across all your accounts, highlighting changes in all your telemetry, regardless of instrumentation source‚Äîeven third-party and open source data‚Äîin an easy-to-understand, accessible user experience that requires no configuration. An intuitive circle visualization, with color indicating severity of recent changes and size conveying the scale, draws your attention where it‚Äôs needed most. Beyond showing key metrics of throughput, response time, and errors, you can view changes in any signal in your telemetry data that you find important, across all your accounts. You can analyze changes with performance, abnormal history, correlations, traces, and error profiles to quickly uncover blind spots and unknown relationships so you understand what‚Äôs changed and why. That way, you can resolve issues before they impact your customers. Get started with Lookout and learn more about Lookout. New Relic Navigator also offers an estate-wide view of your system. It filters the view by entities rather than changes, and it displays the health of your estate in a highly dense honeycomb view with traffic-light colors based on alerts so you can quickly explore your entire environment, understand health status, and resolve issues quickly. New Relic Navigator lets you explore all your entities belonging to all your accounts, focusing on specific entity types or specific groups of entities organized by tags to quickly zero in on issues. When you have thousands, or tens of thousands of hosts, containers, and services, this capability makes it easy for you to explore everything in one place. Related Entities shows you all the entities related to a specific application, host, container, or integration. It lets you quickly understand which upstream or downstream services are related to an issue, gives you a broader view of the overall health of your system, and helps you troubleshoot issues faster. New Relic automatically detects most relationships, but you can also create your own relationships to make sure that you have the most complete map of your environment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.76972,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " configuration. At a glance, gain instant understanding of health and changes across <em>your</em> <em>entire</em> environment so you can zoom in to analyze, understand, and resolve issues faster. New Relic Explorer includes several new approaches to visualizing, exploring, and understanding <em>your</em> <em>entire</em> estate: New"
      },
      "id": "6036d3b564441fa8ca4e889f"
    },
    {
      "category_2": "Get started",
      "nodeid": 34151,
      "sections": [
        "Use New Relic One",
        "Get started",
        "Core concepts",
        "UI and data",
        "Workloads",
        "Build on New Relic One",
        "Introduction to New Relic One",
        "A more consistent and unified platform",
        "Quickly understand context",
        "Know your relationships and dependencies",
        "Query your data more easily",
        "Enhanced dashboards",
        "What‚Äôs next?",
        "For more help"
      ],
      "title": "Introduction to New Relic One",
      "category_0": "New Relic One",
      "type": "docs",
      "category_1": "Use New Relic One",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one",
      "external_id": "2762b085f68c949ebe8f291e611e1ca5cfb09523",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one",
      "published_at": "2021-02-23T00:55:08Z",
      "updated_at": "2021-02-23T00:55:08Z",
      "breadcrumb": "Contents / New Relic One / Use New Relic One / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about the benefits of the New Relic One UI and how to get around on the platform. ",
      "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence functionality. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. To use New Relic One and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. A more consistent and unified platform Before our release of New Relic One, our platform was separated into various products, like APM, Browser, and Mobile. With our move to New Relic One, you can view and interact with all the data from across your entire system more easily. For more information, see our New Relic One transition guide. Quickly understand context New Relic One gives you and your teams a connected view that cuts through complexity and allows you to: Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities in your system. The New Relic Navigator gives you a high density overview of all your entities so you can detect any issues at a glance. And the New Relic Lookout shows entities recently experiencing behavior deviations. Organize your environments and manage data more effectively with tags. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. View everything you‚Äôre monitoring in one place, like entities or dashboards across your organization. Cross-account access brings all types of data together while still making everything easy to find. Group any entities together into functional team-focused or project-focused groupings with workloads. Tailor custom dashboards for your unique needs. Create visuals that showcase your business needs at a glance, and make the most of your expertise. Get more context while you query with the query builder which surfaces data definitions as you craft and edit queries. Know your relationships and dependencies We provide multiple ways to understand dependencies, so you can easily see how everything fits together and troubleshoot problems. If you want to... Use this Have an overall view of your system, and drill down to get performance details. The New Relic Explorer gives you context to the performance data from all your monitored applications, services, hosts, or containers. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Organize everything you monitor and provide context for your entities. Add tags to all your entities. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the entity explorer by tags or text View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity you‚Äôre viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Know which teams are responsible for specific entities across your organization. Create tags for teams and all the services they monitor. Query your data more easily At the top of all UI pages, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the NRQL mode query builder. Run PromQL-style queries in the query builder. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. What‚Äôs next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the entity explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.57883,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Know <em>your</em> relationships and dependencies",
        "info": "Learn about the benefits <em>of</em> the New Relic One UI and how to get around on the platform. ",
        "body": " was separated into various products, like APM, Browser, and Mobile. With our move to New Relic One, you can view and interact with all the data from across <em>your</em> <em>entire</em> system more easily. For more information, see our New Relic One transition guide. Quickly understand context New Relic One gives you and <em>your</em>"
      },
      "id": "5cdc21160711e80c16e4de59"
    },
    {
      "category_2": "Workloads",
      "nodeid": 39081,
      "sections": [
        "Use New Relic One",
        "Get started",
        "Core concepts",
        "UI and data",
        "Workloads",
        "Build on New Relic One",
        "Use workloads",
        "Create a workload",
        "Use the API",
        "For more help"
      ],
      "title": "Use workloads",
      "category_0": "New Relic One",
      "type": "docs",
      "category_1": "Use New Relic One",
      "external_id": "ceb8cc0a7f379f735e0a0fee73f4456837868f91",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/Disrupted_workload_with_breakdown.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads",
      "published_at": "2021-02-23T08:10:40Z",
      "updated_at": "2021-02-23T08:10:39Z",
      "breadcrumb": "Contents / New Relic One / Use New Relic One / Workloads",
      "document_type": "page",
      "popularity": 1,
      "info": "In New Relic, use workloads to group together entities that make up a specific business service, making it easier to isolate and troubleshoot issues.",
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. A Workload looks like this: Important components in the New Relic One workload UI. The screenshot numbers are important parts of the workload UI we'd like to describe to you: The Overview tab shows the most relevant entity performance and alert data that you need to operate the workload. View of workload components. This is useful for understanding the workload‚Äôs architecture, especially if the workload‚Äôs entities change over time because they are dynamically defined. Important charts. These are charts with key metrics for each entity type, such as number of requests, response time and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level. Workload status. You can configure the status to inform about how your workload is performing, based on the individual alerting status of the entities in your workload. Open violations. You can filter the workload to only the alerting entities to make it easier to troubleshoot the most important issues. Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. The Entities tab shows the entities that make up the workload. If you‚Äôve used queries to dynamically select entities, the workload entities will change over time. Edit workload. Edit the workload to define the entities that are part of the workload and to link dashboards to the workload. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's GUID and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Apps > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload‚Äôs dashboard: From a workload‚Äôs Overview page, select a dashboard. Add search terms to filter the dashboard to a view that‚Äôs relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.36354,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize <em>your</em> use of workloads, it helps to have a good entity-<em>tagging</em> strategy. We recommend reading the <em>tagging</em>"
      },
      "id": "5f246157196a67553f94f5cd"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/800w/public/2021-02/platform_fso_experience_july2020.png?itok=cNJ03YCK",
      "url": "https://newrelic.com/platform/full-stack-observability",
      "sections": [
        "Full-Stack Observability",
        "Full-Stack Observability includes:",
        "One place to explore your entire system",
        "APM",
        "Infrastructure Monitoring",
        "Serverless Monitoring",
        "Digital Experience Monitoring",
        "Logs in Context",
        "Experience Full-Stack Observability",
        "Free access to New Relic. Forever."
      ],
      "published_at": "2021-02-25T01:41:29Z",
      "title": "Full Stack Observability | New Relic",
      "updated_at": "2021-02-25T01:41:29Z",
      "type": "",
      "external_id": "d62202a5e448becf8db9ed0c894dfd409d3a555a",
      "popularity": 1,
      "body": "Skip to main content New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Full-Stack Observability Visualize, analyze, and troubleshoot your entire software stack in one curated, unified platform. And by automatically connecting infrastructure health with application performance and end-user behavior, you can cut through the noise to find the signal. Fast. That means less time troubleshooting, and more time building great software. Sign up for free Full-Stack Observability includes: New One place to explore your entire system Move faster than ever with New Relic Explorer. Catch sudden changes before they‚Äôre problems with New Relic Lookout. And see your estate‚Äôs health in a glance with New Relic Navigator. All new, and only with Full-Stack Observability. Explore what's new APM Find root causes and fix issues fast. In-depth transaction details show exact method calls with line numbers, including external dependencies for apps of any size and complexity. Get a complete picture by combining key metrics from mobile and browser apps with supporting services, data stores, and hosts. Capabilities include: Application Monitoring Distributed Tracing (New Relic Edge) Infrastructure Monitoring Gain visibility into all of your infrastructure‚Äîincluding servers and VMs on-premises, cloud resources and cloud-native infrastructure. Then connect the health and performance of all of your hosts, services, containers, and resources with the richest application context, logs, and configuration changes, so you can understand, identify, and troubleshoot problems faster. Learn more about Infrastructure Monitoring Serverless Monitoring Deliver serverless apps with confidence by rapidly identifying when something goes wrong and quickly pinpointing the problem‚Äîwithout wading through millions of invocation logs. Auto-instrument monitoring and observability to your serverless functions without requiring code changes. And auto-instrument tracing for your legacy application components alongside the performance of modern serverless components‚Äîfrom backend infrastructure to client-side apps. Learn more about Serverless Monitoring Digital Experience Monitoring Combine RUM, synthetic, and native app monitoring to proactively ensure uptime and performance across services, URLs, APIs, and third party resources on web and mobile. Benchmark and improve end-user experience for every deployment and code change. End-to-end visibility of latency and errors makes it easy to troubleshoot customer-impacting issues faster, and user-centric perceived performance metrics help you optimize page loads. Capabilities include: Browser Monitoring Mobile Monitoring Synthetics Monitoring Logs in Context On top of complete Log Management provided in Telemetry Data Platform, Full-Stack Monitoring provides Logs in Context. Logs are automatically correlated with curated content for errors, traces, and spans ensuring the deepest and fastest root-cause analysis. Learn more about Log Management Learn more about configuring Logs in Context Experience Full-Stack Observability Full-Stack Observability lets you easily visualize and troubleshoot your entire software stack in one connected experience.¬† Learn more about Full-Stack Observability. Free access to New Relic. Forever. Monitoring your stack should never include host-based guessing games or hidden costs‚Äîjust simple pricing with no surprises. Sign up now Customers trust New Relic. Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International Êó•Êú¨Ë™û Fran√ßais Deutsch ÌïúÍµ≠Ïñ¥ Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.163246,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Full <em>Stack</em> Observability | New Relic",
        "sections": "One place to explore <em>your</em> <em>entire</em> system",
        "body": " Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Full-<em>Stack</em> Observability Visualize, analyze, and troubleshoot <em>your</em> <em>entire</em> software <em>stack</em>"
      },
      "id": "5f22638664441f8d032a48d9"
    }
  ],
  "/build-apps/add-time-picker-guide": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Permissions for managing applications",
        "Publish and deploy apps",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Build apps",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Permissions for managing applications ¬† Learn about permissions for subscribing to apps Publish and deploy apps 30 min Start sharing the apps you build Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.24847,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add a <em>time</em> <em>picker</em> to your <em>app</em>",
        "body": " from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a <em>time</em> <em>picker</em> to your <em>app</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "category_2": "iOS app release notes",
      "nodeid": 8411,
      "sections": [
        "Mobile apps release notes",
        "Android app release notes",
        "iOS app release notes",
        "Insights for Android release notes",
        "Insights for iOS release notes",
        "Insights for tvOS release notes",
        "New Relic for iOS 3.20.3",
        "New Relic for iOS 3.62.0",
        "Notes",
        "New features",
        "New Relic for iOS 3.61.0",
        "Bug fixes",
        "New Relic for iOS 3.59.0",
        "New Relic for iOS 3.58.0",
        "New Relic for iOS 3.57.0",
        "New Relic for iOS 3.56.0",
        "Improvements",
        "New Relic for iOS 3.55.0",
        "New Relic for iOS 3.54.0",
        "New Relic for iOS 3.53.1",
        "New Relic for iOS 3.53.0",
        "Pages"
      ],
      "title": "New Relic for iOS 3.20.3",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "Mobile apps release notes",
      "external_id": "a266a331e9c78e3af9160c97be2d58be684a96cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/mobile-apps-release-notes/new-relic-ios-3203?page=0%2C1",
      "published_at": "2021-02-23T12:43:12Z",
      "updated_at": "2021-02-23T12:43:12Z",
      "breadcrumb": "Contents / Release notes / Mobile apps release notes / iOS app release notes",
      "document_type": "release_notes",
      "popularity": -2,
      "body": "[RSS] Items per page 5 10 New Relic for iOS 3.62.0 Wednesday, August 19, 2020 - 07:00 Download Notes Added support to filter any dashboard! New features Dashboards now support filtering to specified attributes and values New Relic for iOS 3.61.0 Tuesday, July 21, 2020 - 13:30 Download Notes Easier login flow to provide support for our newest customers Bug fixes Fixes a rare crash when a user tries to view some violations on a 32 bit device New Relic for iOS 3.59.0 Wednesday, June 24, 2020 - 10:00 Download Notes Introducing NRQL editing from within the iPad app New features Adds in NRQL query history to the iPad. Adds in the ability to write NRQL queries. Adds in sharing functionality for NRQL queries to both iPad and iPhone Adds in sharing functionality for Dashboards Bug fixes Fixes a crash when trying to share on the iPad Fixes a crash when trying to open a malformed universal link to errors New Relic for iOS 3.58.0 Tuesday, June 16, 2020 - 09:00 Download New features Improved Home screen look and feel Added dashboards to the Home screen Added the ability to filter to specific entity types on the Home screen (iPhone) Updated header colors in light mode New Relic for iOS 3.57.0 Tuesday, June 2, 2020 - 09:15 Download Notes Introducing NRQL editing from within the iPhone app! New features Adds in NRQL query history to the iPhone (iPad will come later). Adds in the ability to write NRQL queries. Links Alert incidents that target a NRQL query to show the in-app NRQL editor. Includes more detail screens on the iPad for APM, Browser, Mobile, and key transactions. New Relic for iOS 3.56.0 Thursday, May 14, 2020 - 09:00 Download Notes Introducing Dashboards on iPad. Now view all your dashboards right from the New Relic mobile app. New features iPad now has support for Dashboards iPad now has an improved Home page with favorites and support for searching across services, apps, hosts and monitors Home on iPhone now shows monitors Improvements Improved cards, and searching on iPad Improved network performance for large lists Improved network calls for filtering by tags (what used to be labels & rollups) in APM and Synthetics New Relic for iOS 3.55.0 Thursday, April 23, 2020 - 06:00 Download Improvements Improved time picker with custom start and end time selection Added time picker to Dashboards Bug fixes Fixed a crash that sometimes occurred in the new Dashboards Fixed a crash that sometimes occurred on the iPad Fixed a crash that occurred sometimes on error charts with no data New Relic for iOS 3.54.0 Thursday, April 9, 2020 - 09:00 Download New features View New Relic dashboards Added detailed pages that include new chart tooltip and legend behavior Landscape support for widgets New Relic for iOS 3.53.1 Friday, February 21, 2020 - 08:49 Download Notes 3.53.1 is a hot fix for 3.53.0 which has an improved Mobile APM Http Errors view, to allow you to facet & filter down to the errors you care about. Bug fixes Fixes crash that sometimes occurred when viewing line charts with multiple elements. New Relic for iOS 3.53.0 Wednesday, November 20, 2019 - 15:30 Download Notes We now have an improved Mobile APM Http Errors view, to allow you to facet & filter down to the errors you care about. New features New Mobile APM HTTP Errors view Improvements Added support for Radar in context 'event' anomalies Bug fixes Fixed a crash that sometimes occurred when viewing charts Fixed a crash that sometimes appeared when trying to login Fixed a crash that occurred rarely in the monitors page Pages ¬´ first ‚Äπ previous 1 2 3 4 5 6 7 8 9 next ‚Ä∫ last ¬ª",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.70264,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Mobile <em>apps</em> release notes",
        "category_1": "Mobile <em>apps</em> release notes",
        "category_2": "iOS <em>app</em> release notes",
        "body": " (what used to be labels &amp; rollups) in APM and Synthetics New Relic for iOS 3.55.0 Thursday, April 23, 2020 - 06:00 Download Improvements Improved <em>time</em> <em>picker</em> with custom start and end <em>time</em> selection Added <em>time</em> <em>picker</em> to Dashboards Bug fixes Fixed a crash that sometimes occurred in the new Dashboards",
        "breadcrumb": "Contents &#x2F; Release notes &#x2F; Mobile apps release notes &#x2F; iOS <em>app</em> release notes"
      },
      "id": "5b6b67d5827a6614c852ffd6"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs",
        "This site uses cookies üç™"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.76599,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic One <em>apps</em>",
        "body": ": <em>PlatformStateContext</em>: provides read access to the platform URL state variables. Example: <em>time</em>Range in the <em>time</em> <em>picker</em>. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state."
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/platform-state-context/",
      "sections": [
        "PlatformStateContext",
        "Usage",
        "Examples",
        "Basic",
        "Props",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:52:59Z",
      "title": "PlatformStateContext",
      "updated_at": "2021-01-29T01:56:48Z",
      "type": "developer",
      "external_id": "aa6b86b3dc0dcd7cd758b20655318b108875cce7",
      "document_type": "page",
      "popularity": 1,
      "body": "React context to access the platform URL state. Usage import { PlatformStateContext } from 'nr1' Copy Examples Basic <PlatformStateContext.Consumer> {(platformState) => <pre>{JSON.stringify(platformState, null, 4)}</pre>} </PlatformStateContext.Consumer>; 1 <PlatformStateContext.Consumer> 2 {(platformState) => <pre>{JSON.stringify(platformState, null, 4)}</pre>} 3 </PlatformStateContext.Consumer>; Copy Props There are no props for this component.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.4527,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PlatformStateContext</em>",
        "sections": "<em>PlatformStateContext</em>",
        "body": "React context to access the platform URL state. Usage import { <em>PlatformStateContext</em> } from &#x27;nr1&#x27; Copy Examples Basic &lt;PlatformStateContext.Consumer&gt; {(platformState) =&gt; &lt;pre&gt;{JSON.stringify(platformState, null, 4)}&lt;&#x2F;pre&gt;} &lt;&#x2F;PlatformStateContext.Consumer&gt;; 1 &lt;PlatformStateContext.Consumer&gt; 2 {(platformState) =&gt; &lt;pre&gt;{JSON.stringify(platformState, null, 4)}&lt;&#x2F;pre&gt;} 3 &lt;&#x2F;PlatformStateContext.Consumer&gt;; Copy Props There are no props for this component."
      },
      "id": "5efa997128ccbccc6f307dc0"
    },
    {
      "category_2": "Explore data",
      "nodeid": 38956,
      "sections": [
        "Explore and query data",
        "Explore data",
        "Query builder",
        "Use charts",
        "Dashboards",
        "New Relic Query Language",
        "Introduction to the data explorer",
        "Why it matters",
        "Query your data",
        "Use the data explorer",
        "Visualize and refine your exploration",
        "Use cases",
        "For more help"
      ],
      "title": "Introduction to the data explorer",
      "category_0": "Query your data",
      "type": "docs",
      "category_1": "Explore and query data",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer",
      "external_id": "424e4f82ebb79fada5581dcbb2b49998783f4967",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/data_explorer_new.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer",
      "published_at": "2021-02-23T08:05:12Z",
      "updated_at": "2021-02-23T08:05:11Z",
      "breadcrumb": "Contents / Query your data / Explore and query data / Explore data",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to New Relic One's data explorer, which lets you run custom queries of your data, build charts and other visualizations, and share with others.",
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. To use the data explorer and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces apps to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count(*), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Need to do more advanced searches or customize your charts? From data explorer you can access query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I‚Äôve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there‚Äôs something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.511284,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " the <em>time</em> range using the <em>time</em> <em>picker</em>. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account"
      },
      "id": "5feed4a3e7b9d2acc7df9231"
    }
  ],
  "/terms": [
    {
      "category_2": "Developer Edition",
      "nodeid": 39641,
      "sections": [
        "Product or service licenses",
        "New Relic One",
        "APM",
        "Browser",
        "Developer Edition",
        "Infrastructure",
        "Insights",
        "Logs",
        "Mobile",
        "Synthetics",
        "Mobile apps",
        "Plugins",
        "Miscellaneous",
        "Developer Program Resources",
        "For more help"
      ],
      "title": "Developer Program Resources",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "Product or service licenses",
      "external_id": "98308cfffa652e4c25967e1be5b848b9c28ca410",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-developer-edition/developer-program-resources",
      "published_at": "2021-02-23T05:36:28Z",
      "updated_at": "2020-08-08T19:17:02Z",
      "breadcrumb": "Contents / Licenses / Product or service licenses / Developer Edition",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic Developer edition policy",
      "body": "As a customer, you are eligible to participate in New Relic‚Äôs Developer Program. Additional information and resources are available at New Relic‚Äôs Developer Program site. By downloading, accessing, or using the developer resources (including the CLI), you agree that usage of the developer resources is pursuant to the New Relic Developers Terms and Conditions and that you have the authority to bind your organization. Such terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not use these developer resources. If your use of the New Relic developer resources are covered under a separate agreement, the above does not apply to you. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 323.35815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is pursuant to the New Relic Developers <em>Terms</em> and <em>Conditions</em> and that you have the authority to bind your organization. Such <em>terms</em> do not have to be signed in order to be binding. If you do not agree to these <em>terms</em> and <em>conditions</em>, your sole remedy is to not use these developer resources. If your"
      },
      "id": "5f338507e7b9d2f670c9de83"
    },
    {
      "category_2": "New Relic One",
      "nodeid": 39366,
      "sections": [
        "Product or service licenses",
        "New Relic One",
        "APM",
        "Browser",
        "Developer Edition",
        "Infrastructure",
        "Insights",
        "Logs",
        "Mobile",
        "Synthetics",
        "Mobile apps",
        "Plugins",
        "Miscellaneous",
        "Preview access for New Relic One",
        "For more help"
      ],
      "title": "Preview access for New Relic One",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "Product or service licenses",
      "external_id": "eae3865081d3bd8ad2dd8b6eaf0fe0147355360c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-one/preview-access-new-relic-one",
      "published_at": "2021-02-23T04:44:58Z",
      "updated_at": "2020-07-31T04:41:27Z",
      "breadcrumb": "Contents / Licenses / Product or service licenses / New Relic One",
      "document_type": "page",
      "popularity": 1,
      "body": "As a customer with a paid subscription to New Relic products, you are eligible to participate in preview access of the New Relic One platform (e.g. Telemetry Data Platform, Full Stack Observability, and Applied Intelligence products) for the period beginning July 31, 2020 and ending December 31, 2020 (‚ÄúPreview Access‚Äù). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE TERMS AND CONDITIONS IN LIEU OF ANY OTHER TERMS. These terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not participate in Preview Access. New Relic reserves the right to terminate or restrict Preview Access, in whole or in part, at any time. Notwithstanding the foregoing and any other materials provided by New Relic, select customers are ineligible for the Preview Access. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 322.45932,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", 2020 (‚ÄúPreview Access‚Äù). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE <em>TERMS</em> AND <em>CONDITIONS</em> IN LIEU OF ANY OTHER <em>TERMS</em>. These <em>terms</em> do not have to be signed in order to be binding"
      },
      "id": "5f23a0f7e7b9d29da9c82305"
    },
    {
      "image": "",
      "url": "https://opensource.newrelic.com/cla/",
      "sections": [
        "NEW RELIC, INC.",
        "INDIVIDUAL CONTRIBUTOR LICENSE AGREEMENT",
        "Definitions.",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:54:45Z",
      "title": "New Relic Open Source Contributor License Agreement",
      "updated_at": "2020-12-08T13:43:57Z",
      "type": "opensource",
      "external_id": "478151b2a97835e82c3cd1eaa49610793dc56783",
      "document_type": "page",
      "popularity": 1,
      "info": "",
      "body": "External Projects Highlighted Projects New Relic Projects Standards Menu External Projects Highlighted Projects New Relic Projects Standards NEW RELIC, INC. INDIVIDUAL CONTRIBUTOR LICENSE AGREEMENT Thank you for your interest in contributing to the open source projects of New Relic, Inc. (‚ÄúNew Relic‚Äù). In order to clarify the intellectual property license granted with Contributions from any person or entity, New Relic must have a Contributor License Agreement (\"Agreement\") on file that has been signed by each Contributor, indicating agreement to the license terms below. This Agreement is for your protection as a Contributor as well as the protection of New Relic; it does not change your rights to use your own Contributions for any other purpose. You accept and agree to the following terms and conditions for Your present and future Contributions submitted to New Relic. Except for the licenses granted herein to New Relic and recipients of software distributed by New Relic, You reserve all right, title, and interest in and to Your Contributions. Definitions. \"You\" (or \"Your\") shall mean the copyright owner or legal entity authorized by the copyright owner that is entering into this Agreement with New Relic. For legal entities, the entity making a Contribution and all other entities that control, are controlled by, or are under common control with that entity are considered to be a single Contributor. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"Contribution\" shall mean any original work of authorship, including any modifications or additions to an existing work, that is intentionally submitted by You to New Relic for inclusion in, or documentation of, any of the products managed or maintained by New Relic (the \"Work\"). For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to New Relic or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, New Relic for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by You as \"Not a Contribution.\" Grant of Copyright License. Subject to the terms and conditions of this Agreement, You hereby grant to New Relic and to recipients of software distributed by New Relic a perpetual, worldwide, non-exclusive, no-charge, royalty-free, transferable, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense, and distribute Your Contributions and such derivative works. Grant of Patent License. Subject to the terms and conditions of this Agreement, You hereby grant to New Relic and to recipients of software distributed by New Relic a perpetual, worldwide, non-exclusive, no-charge, royalty-free, transferable, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by You that are necessarily infringed by Your Contributions alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that Your Contribution, or the Work to which You have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the date such litigation is filed. You represent that You are legally entitled to grant the above licenses. If Your employer(s) has rights to intellectual property that You create that includes Your Contributions, You represent that You have received permission to make Contributions on behalf of that employer, that Your employer has waived such rights for Your Contributions to New Relic, or that Your employer has executed a separate Agreement with New Relic. You represent that each of Your Contributions is Your original creation (see section 7 for submissions on behalf of others). You represent that Your Contribution submissions include complete details of any third-party license or other restriction (including, but not limited to, related patents and trademarks) of which You are personally aware and which are associated with any part of Your Contributions. You are not expected to provide support for Your Contributions, except to the extent You desire to provide support. You may provide support for free, for a fee, or not at all. Unless required by applicable law or agreed to in writing, You provide Your Contributions on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON- INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. Should You wish to submit work that is not Your original creation, You may submit it to New Relic separately from any Contribution, identifying the complete details of its source and of any license or other restriction (including, but not limited to, related patents, trademarks, and license agreements) of which You are personally aware, and conspicuously marking the work as \"Submitted on behalf of a third-party: [named here] \". You agree to notify New Relic of any facts or circumstances of which You become aware that would make these representations inaccurate in any respect. This site uses cookies üç™ We use cookies and other similar technologies (\"Cookies\") on our websites and services to enhance your experience and to provide you with relevant content. By using our websites and services you are agreeing to the use of cookies. You can read more here. If you consent to our cookies, please click Yes. Yes No",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 311.0519,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is for your protection as a Contributor as well as the protection of New Relic; it does not change your rights to use your own Contributions for any other purpose. You accept and agree to the following <em>terms</em> and <em>conditions</em> for Your present and future Contributions submitted to New Relic. Except"
      },
      "id": "5f31822264441fcbe056a984"
    },
    {
      "category_2": "Product definitions",
      "nodeid": 39646,
      "sections": [
        "License information",
        "General usage licenses",
        "Special services licenses",
        "Usage plans",
        "Distributed licenses",
        "Referenced policies",
        "Product definitions",
        "FAQ",
        "New Relic One pricing: Definitions",
        "For more help"
      ],
      "title": "New Relic One pricing: Definitions",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "License information",
      "external_id": "097fc095ef18942f3af1845237742340e36416b8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/license-information/product-definitions/new-relic-one-pricing-definitions",
      "published_at": "2021-02-23T05:37:05Z",
      "updated_at": "2020-09-10T14:58:10Z",
      "breadcrumb": "Contents / Licenses / License information / Product definitions",
      "document_type": "page",
      "popularity": 1,
      "info": "This document provides definitions of terminology you may see in New Relic contracts.",
      "body": "This document provides definitions of terminology you may see in the Terms or this site for New Relic One pricing and billing: Account Account refers to the online account or subaccounts that New Relic provides for customers to manage their use of the Products. Commitment Term Commitment Term means the non-cancelable, committed Subscription Term for the Products. Customer Data Customer Data means the data, information, or content that Customer and its users send to an Account from the Software, the Customer Properties, or Third-Party Services. Customer Properties Customer Properties means Customer‚Äôs websites, infrastructure, networks, mobile applications, or other systems, as well as Customer accounts on Third-Party Services. Documentation Documentation means the New Relic technical guides and documentation made available from the dedicated ‚ÄòDocumentation‚Äô page of the New Relic website. GB Ingested A GB Ingested is a measurement of the volume of metrics, events, logs, traces, or other telemetry data sent to or generated by the Products for the benefit of the Customer, including from the Software, the Customer Properties, or Third-Party Services. In this context, a GB is defined as 1 billion bytes. Login Credentials Login Credentials means the username, email address, password, or other personal information that is provided by a Customer user in order to manage an Account. Monthly Provisioned User A Monthly Provisioned User is any user who can log into Customer‚Äôs Account(s) and access the New Relic One Product functionality as specified in an Order and the Documentation. Order Order means the purchasing order for access to the Service or related services that: (1) is either executed by the Parties or entered into by you via self-service, and references this Agreement, or (2) is entered into by you and a Channel Partner. Paid Terms of Service Paid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/paid. Product(s) Product(s) mean the purchase of the New Relic subscription products described in the applicable Order and any updates, corrections, bug fixes, modifications, improvements, related services, new features, and functionality (made generally available to New Relic‚Äôs customer base) thereto. Software Software means the distributed software, APIs, scripts, or other code proprietary to New Relic provided with the Products. Terms Terms means the underlying Customer-New Relic agreement and the Order. Third-Party Services Third-Party Services means any third party platform, add-on, service, or product not provided by New Relic and that a user integrates or enables for use with the Products, including third-party applications and plug-ins. Unpaid Terms of Service Unpaid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/unpaid. Usage Plan Usage Plan refers to the Service or Product pricing, invoicing related information, and product-specific terms (e.g. concurrent user account sessions) contained within the Documentation. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 269.8091,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "This document provides definitions of <em>terminology</em> you may see in New Relic contracts.",
        "body": "This document provides definitions of terminology you may see in the <em>Terms</em> or this site for New Relic One pricing and billing: Account Account refers to the online account or subaccounts that New Relic provides for customers to manage their use of the Products. Commitment <em>Term</em> Commitment <em>Term</em> means"
      },
      "id": "5f23b039196a67030b94f5c4"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/termsandconditions/terms",
      "sections": [
        "Terms of Service",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-02-25T01:41:29Z",
      "title": "Terms of Service Agreement | New Relic",
      "updated_at": "2021-01-04T01:39:52Z",
      "type": "",
      "external_id": "f1539ad0dbd46a29c243907400c646ed11c33bd1",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon New Relic Inc. Terms of Service Paid Accounts Customers that access New Relic‚Äôs platform through a paid subscription are governed by the Terms of Service set forth immediately above. Unpaid Accounts Customers that access New Relic‚Äôs platform on an unpaid (e.g. trials, proof of concepts, New Relic Developer Edition or ‚Äòlite‚Äô) basis are governed by the Terms of Service set forth immediately above. Community Forums Community Forum participants ask and answer questions about New Relic‚Äôs platform.¬† Use of the Community Form is governed by the terms and conditions set forth immediately above. New Relic Data Processing Addendum Customers who currently send, or intend to send, personal data to the New Relic Services for processing should download and complete the Data Processing Addendum set forth immediately¬†above. Data Processing Addendum¬†FAQ ¬†This guide is designed to assist customers in their completion of the New Relic Data Processing Addendum. New Relic CCPA Service Provider Addendum New Relic¬†CCPA Service Provider Addendum FAQ COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.1904,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Terms</em> of Service Agreement | New Relic",
        "sections": "<em>Terms</em> of Service",
        "body": " by the <em>terms</em> and <em>conditions</em> set forth immediately above. New Relic Data Processing Addendum Customers who currently send, or intend to send, personal data to the New Relic Services for processing should download and complete the Data Processing Addendum set forth immediately¬†above. Data Processing Addendum"
      },
      "id": "5ac68e78c75d077fcb6edc38"
    }
  ],
  "/explore-docs/newrelic-cli": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Automate common tasks",
        "Set up New Relic using the Kubernetes operator",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Automate workflows",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 840.91486,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": ", and a command-line interface. These tools enable you to integrate <em>New</em> <em>Relic</em> into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and <em>CLI</em> guides below, find more automation solutions in our Developer"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 553.7031,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the <em>New</em> <em>Relic</em> <em>CLI</em> is a good candidate for automation. In this 5-minute guide, you use the <em>New</em> <em>Relic</em> <em>CLI</em> to add multiple tags to one"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/2g790g7la1iot/promo-image.1573253956.png",
      "url": "https://learn.newrelic.com/live-learncast-new-relic-one-programmability",
      "sections": [
        "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications.",
        "About this Learncast",
        "Prerequisites",
        "Virtual Training Session List"
      ],
      "published_at": "2021-02-25T01:39:49Z",
      "title": "Live Learncast: New Relic One Programmability",
      "updated_at": "2021-01-02T01:38:56Z",
      "type": "",
      "external_id": "053510b559767dbde34e3f1ee9a73bbf813a5a83",
      "popularity": 1,
      "body": "Sign In Live Learncast: New Relic One Programmability Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. Not currently available Available until July 10, 2020, 3:30 p.m. PDT. Already registered? Sign In About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. ¬† During this session we will review the following topics: ¬† 1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites ¬† This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications. ¬† Must have: ¬† Permissions to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. ¬† During this session we will review the following topics: ¬† 1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites ¬† This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications. ¬† Must have: ¬† Permissions to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) ¬© 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 471.06982,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Live Learncast: <em>New</em> <em>Relic</em> One Programmability",
        "sections": "Join us for this exclusive 90-minute introduction to the fundamentals of <em>New</em> <em>Relic</em> One Programmability. This training will introduce you to the key concepts and walk you through developing <em>New</em> <em>Relic</em> Applications.",
        "body": " available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. ¬† During this session we will review the following topics: ¬† 1. Installation of <em>New</em> <em>Relic</em> <em>CLI</em> and Environment setup 2. Familiarization with <em>New</em> <em>Relic</em> One"
      },
      "id": "5dc618cbe7b9d2a0a8e4649c"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:38:35Z",
      "title": "New Relic Developers",
      "updated_at": "2021-02-06T01:37:36Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes ¬† Use custom attributes for deeper analysis Show 28 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 450.97797,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "Getting started with <em>New</em> <em>Relic</em> and Terraform",
        "body": " source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "category_2": "Installation",
      "nodeid": 36151,
      "sections": [
        "On-host integrations",
        "Get started",
        "Installation",
        "On-host integrations list",
        "Understand and use data",
        "Troubleshooting",
        "Secrets management",
        "Define secrets",
        "Using environment variables",
        "Secrets variables",
        "AWS KMS secrets",
        "Vault secrets",
        "tls_config properties",
        "CyberArk command line interface",
        "CyberArk REST API",
        "New Relic CLI Obfuscation",
        "For more help"
      ],
      "title": "Secrets management",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "On-host integrations",
      "external_id": "3ed4bf692161b620f4768d98b920dfdf102ce524",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/installation/secrets-management",
      "published_at": "2021-02-23T00:01:24Z",
      "updated_at": "2020-12-18T04:28:00Z",
      "breadcrumb": "Contents / Integrations / On-host integrations / Installation",
      "document_type": "page",
      "popularity": 1,
      "info": "Use secrets variables in your New Relic infrastructure integration configuration to inject sensitive data that you don‚Äôt want in your configuration files.",
      "body": "With secrets management, you can configure the agent and on-host integrations to use sensitive data (such as passwords) without having to write them as plain text into the configuration files. Currently, Hashicorp Vault, AWS KMS, CyberArk and New Relic CLI obfuscation are supported. Define secrets To use secrets in a configuration YAML file: Define a variables section, where each entry is a name for a secret object. In each entry, include the source of the secret and the proper configuration to retrieve those secrets. In the general configuration section, set ${variable.property} placeholders that will be automatically replaced by the properties of the secret object. The secret object can be defined as a simple string or json object. If the secrets retrieval fails, the integration won't be executed, as the infrastructure agent does not have all the data it requires to execute. For example, the following configuration will retrieve an object named creds from Vault (you can define the object's name for the secret.) Let's assume that the stored object is a valid JSON with a property named user and another property named password. We want to use them to set the basic HTTP credentials of the status_url property from an Nginx on-host integration: integration_name: com.newrelic.nginx variables: creds: vault: http: url: http://my.vault.host/v1/newengine/data/secret headers: X-Vault-Token: my-vault-token instances: - name: nginx-server-metrics command: metrics arguments: status_url: http://${creds.user}:${creds.password}@example.com/status status_module: discover remote_monitoring: true labels: env: production role: load_balancer Both simple strings and valid JSON objects can be retrieved from variables. When using JSON objects make sure both keys and values are enclosed with double-quotes. Using environment variables Environment variables can be used into the variables section with the {{MY_ENV_VAR}} notation. When doing so, environment variables are expanded and their value is replaced at runtime. Use this method to avoid having sensitive values such as tokens or obfuscation keys included in the configuration file. When using environment variables in on-host integration configuration files the passthrough_environment setting must be defined. Secrets variables Define secrets in each configuration under a variables section. Each entry is a user-defined secret name that will store the properties of the retrieved secrets. Each variable can contain the following properties: YAML key Description ttl Type: String Amount of time before a secret is refreshed. This can be a number followed by a time unit (s, m or h). Examples: 30s, 10m, 1h Default: 1h aws-kms AWS KMS secret retrieval configuration vault Vault secret retrieval configuration cyberark-cli CyberArk command line interface configuration cyberark-api CyberArk REST API configuration obfuscated New Relic CLI obfuscation AWS KMS secrets To retrieve your secrets from Amazon KMS, you can set the following properties in your aws-kms section. Not all fields are required. For example, you will need either data, file, or http to provide the encoded KMS string. YAML key Description data Type: String Base64 encoded KMS string to decrypt file Type: String Path to file containing Base64 encoded KMS string to decrypt http Type: YAML properties HTTP configuration to use to request Base64 encoded KMS string to decrypt. For more information, see Vault http. credential_file Type: String Path to AWS credentials file config_file Type: String Path to AWS config file region Type: String AWS KMS region type Type: String (plain, equal, or json) Secret value format: plain: a raw string to be stored directly into the destination variable. equal: a key=property one-line string to be stored as object properties into the destination variable. json: a JSON object to be stored as properties into the destination variable. Secrets of type plain or json use dot notation; for example, ${mysecret.nestedkey}. The following example will allow retrieving a plain password string from AWS KMS. It must be decrypted from the provided data encoded string. variables: myPassword: aws-kms: data: T0hBSStGTEVY region: ap-southeast-2 credential_file: \"./my-aws-credentials-file\" config_file: \"./my-aws-config-file\" type: plain Vault secrets Vault must enable an http field containing the HTTP configuration used to connect to Vault. The http entry can contain the following entries: YAML key Description url Type: String URL to request data from tls_config Type: YAML properties Use the TLS configuration properties headers Type: YAML map Request headers tls_config properties Secrets must use dot notation, for example, ${mysecret.nestedkey}. YAML key Description enable Type: Boolean Enable TLS Default: false insecure_skip_verify Type: Boolean Skip verifying server‚Äôs certificate chain and host Default: false min_version Type: UInt16 The minimum SSL/TLS version that is acceptable Default: 0 (which uses TLS version 1.0) max_version Type: UInt16 The maximum SSL/TLS version that is acceptable Default: 0 (which uses TLS version 1.3) ca Type: String TLS certificate \"\" The following example will retrieve a secret using a Vault token from a secured server, and skip the server certificates verification: variables: mydata: vault: http: url: https://my.vault.host/v1/newengine/data/secret headers: X-Vault-Token: my-vault-token tls_config: insecure_skip_verify: true CyberArk command line interface To retrieve secrets from the CyberArk command line interface (CLI) use the following configuration, all keys are required YAML Key Description cli Type: string Full path to the CyberArk CLI executable Default: \"\" app-id Type: string Application id of the secret holder Default: \"\" safe Type: string Safe containing the secret Default: \"\" folder Type: string Folder containing the secret Default: \"\" object Type: string The object the secret is associated with Default: \"\" The following example will retrieve a CyberArk secret using the command line interface: variables: credentials: cyberark-cli: cli: /full/path/to/clipasswordsdk app-id: my-appid safe: my-safe folder: my-folder object: my-object CyberArk REST API To retrieve secrets using the CyberArk REST API there must be a http key containing the HTTP configuration. The http key contains these sub-keys, only url is required: YAML key Description url Type: String URL to request data from, this key is required Default: none tls_config Type: YAML properties Use the TLS configuration properties headers Type: YAML map Request headers The following example will retrieve a secret using the CyberArk REST API, skipping server certificate verification: variables: credentials: cyberark-api: http: url: https://hostname/AIMWebService/api/Accounts?AppID=myAppID&Query=Safe=mySafe;Object=myObject tls_config: insecure_skip_verify: true New Relic CLI Obfuscation We recommend using any of the supported secrets providers instead of the simple obfuscation when possible. See our guidelines below to define environment variables to avoid having the obfuscation key in configuration files. Infrastructure Agent 1.14.0 or above is required You can use the New Relic CLI obfuscate command to obscure sensitive information in the infrastructure agent or any on-host integration configuration file. Steps: Install the New Relic CLI on any host (it can be your development host). Run the CLI obfuscate command in order to generate the obfuscated value: newrelic agent config obfuscate --value '<plain_text_config_value>' --key '<obfuscation_key>' Copy the result of the cli command into the text argument in the obfuscated section as shown in the examples below. YAML key Description key Type: String The string used when obfuscating the clear-text value using New Relic CLI Default: none secret Type: String The output of the newrelic-cli command Default: none Integrations configuration example The following example will allow retrieving the Nginx user and password that has been obfuscated using the New Relic CLI: integration_name: com.newrelic.nginx variables: creds: obfuscated: key: 'random_key_used_in_cli' secret: 'obscured_output_from_cli' instances: - name: nginx-server-metrics command: metrics arguments: status_url: http://${creds.user}:${creds.password}@example.com/status status_module: discover remote_monitoring: true It's recommended to use environment variables for the obfuscation arguments as shown in the example below: integration_name: com.newrelic.nginx variables: creds: obfuscated: key: {{OBFUSCATION_KEY}} secret: {{OBFUSCATION_TEXT}} instances: - name: nginx-server-metrics command: metrics arguments: status_url: http://${creds.user}:${creds.password}@example.com/status status_module: discover remote_monitoring: true Agent configuration example This example allows retrieving a string that contains the proxy details (user, password and host): variables: obfuscated_proxy: obfuscated: key: 'random_key_used_in_cli' secret: 'obscured_output_from_cli' proxy: ${obfuscated_proxy} For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 433.5307,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> Obfuscation",
        "info": "Use secrets variables in your <em>New</em> <em>Relic</em> infrastructure integration configuration to inject sensitive data that you don‚Äôt want in your configuration files.",
        "body": "With secrets management, you can configure the agent and on-host integrations to use sensitive data (such as passwords) without having to write them as plain text into the configuration files. Currently, Hashicorp Vault, AWS KMS, CyberArk and <em>New</em> <em>Relic</em> <em>CLI</em> obfuscation are supported. Define secrets"
      },
      "id": "5dc2d677e7b9d2d311e4648c"
    }
  ],
  "/automate-workflows/diagnose-problems/high-response-times": [
    {
      "sections": [
        "Practice diagnosing common issues using New Relic",
        "Welcome to Acme Telco Lite!",
        "Set up your environment",
        "Deploy Telco Lite",
        "Tip",
        "View your services",
        "Tear down Telco Lite",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Practice diagnosing common issues using New Relic",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "0d4529b0c9a58c8b8d3098b4916d99c61f649cba",
      "image": "https://developer.newrelic.com/static/f94b1522d40914cb51e86ff2166f5c8e/0e533/acme.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Automatically spin up a microservice infrastructure, and use New Relic to diagnose its issues.",
      "body": "Every time you deploy an application, you hope that it's efficient and error-free. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or rely on a broken dependency. These issues, and others, can result in bad user experiences. In this guide, you: Use the open-source New Relic demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This demo scenario is part of our Demo Catalog and will simulate real-world issues in a controlled, demo environment Use New Relic to understand those issues from the perspective of a Telco Lite developer Use the deployer to tear down the resources you create Welcome to Acme Telco Lite! Acme Telco Lite is a mock telecom business that maintains an eCommerce website for its customers. The site's architecture has eight, interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. Set up your environment Before you begin, follow the Prerequisites guide from the deployer's GitHub repository for a detailed walkthrough of how to set up your environment. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. The guide steps you through: Installing Docker & pulling the demo-deployer image locally Creating a user config file containing credentials for New Relic and your cloud provider Downloading a .pem key file (if your cloud provider is AWS) Once you're all set up, deploy Acme Telco Lite. Deploy Telco Lite It's time to deploy and instrument the Telco Lite services using demo-deployer. Copy the url for the demo that corresponds to the cloud provider you chose when you set up your environment: AWS Telco Lite Demo Azure Telco Lite Demo GCP Telco Lite Demo Follow the Deployment guide in the Demo Catalog repository for a thorough explanation of how to use the deployer in a local Docker environment. When you run the deployment script, make sure to pass the url you copied for <demo-url>. Tip Since Telco Lite contains several services, the deployment can take over half an hour. When the deloyer is finished, you should see some output stating that the deployment was successful: bash Copy [INFO] Executing Deployment [‚úî] Parsing and validating Deployment configuration success [‚úî] Provisioner success [‚úî] Installing On-Host instrumentation success [‚úî] Installing Services and instrumentations success [INFO] Deployment successful! Deployed Resources: simuhost (aws/ec2): ip: 34.201.60.23 services: [\"simulator\"] uihost (aws/ec2): ip: 18.233.97.28 services: [\"webportal\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 backendhost (aws/ec2): ip: 35.170.192.236 services: [\"promo\", \"login\", \"inventory\", \"plan\", \"fulfillment\", \"warehouse\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 reportinghost (aws/ec2): ip: 54.152.82.127 services: [\"billing\", \"fluentd\"] instrumentation: nr_infra: newrelic v1.12.1 Installed Services: simulator: url: http://34.201.60.23:5000 webportal: url: http://18.233.97.28:5001 instrumentation: nr_node_agent: newrelic v6.11.0 nr_logging_in_context: newrelic promo: url: http://35.170.192.236:8001 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic login: url: http://35.170.192.236:8002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic inventory: url: http://35.170.192.236:8003 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic plan: url: http://35.170.192.236:8004 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fulfillment: url: http://35.170.192.236:8005 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic billing: url: http://54.152.82.127:9001 instrumentation: nr_java_agent: newrelic v5.14.0 nr_logging_in_context: newrelic nr_logging: newrelic warehouse: url: http://35.170.192.236:9002 instrumentation: nr_python_agent: newrelic v5.14.1.144 nr_logging_in_context: newrelic fluentd: url: http://18.233.97.28:9999 url: http://35.170.192.236:9999 url: http://54.152.82.127:9999 Completed at 2020-08-11 11:27:00 -0700 [INFO] This deployment summary can also be found in: [INFO] /tmp/telcolite/deploy_summary.txt After configuring your environment, you only needed two commands (and a bit of patience) to spin up all the Telco Lite services! View your services With your services running in the cloud, log in to New Relic and select APM from the top navigation to see how your services are holding up: Yikes! The alerts, high response times, and red-colored indicators suggest things aren't well. Use New Relic to diagnose these issues, which are simultaneously affecting your services: Issue 1: The Warehouse Portal has abnormally high response times Issue 2: Multiple services are raising error alerts Tip Don't worry if you don't see all the same alerts. The simulator triggers issues at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. Tear down Telco Lite When you're finished diagnosing all the issues effecting Telco Lite, follow the Teardown guide in the deployer's repository to tear down the services you created in your cloud provider. If you're still exploring, don't tear down your services, or you'll have to deploy them again later. Conclusion Congratulations, you're done! Throughout this tutorial, you: Used the demo-deployer to deploy Telco Lite to the cloud Used New Relic to investigate simulated issues in Telco Lite services Tore down all the infrastructural resources you created throughout this tutorial Hopefully, you learned a lot about using New Relic to investigate issues in your services. To get your hands on more features of New Relic, pick another demo from the catalog and spin it up with the deployer!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 62.391693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": ". In this guide, you: Use the open-source New Relic <em>demo</em>-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company. This <em>demo</em> scenario is part of our <em>Demo</em> Catalog and will simulate real-world issues in a controlled, <em>demo</em> environment Use New Relic to understand those issues from"
      },
      "id": "5f97897864441f14936ed88e"
    },
    {
      "sections": [
        "Diagnose error alerts in Telco Lite",
        "Prerequisites",
        "Tip",
        "Extra Credit",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Diagnose error alerts in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "2857da924e8d8a8e78dca86040692d061bf14753",
      "image": "https://developer.newrelic.com/static/a03659a8d751f40e75f74a23b135c921/0086b/error-alerts.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/error-alerts/",
      "published_at": "2021-02-25T01:58:11Z",
      "updated_at": "2021-01-16T01:47:39Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose error alerts in your services.",
      "body": "Use New Relic to understand why some services are raising alerts. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the error alerts in your services. Step 1 of 8 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that Telco-Login Service and Telco-Web Portal have opened critical violations for high error percentages: Tip If you don't see all the same alerts, don't worry. The simulated issues happen at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. The deployment has created an alert condition for cases where a service's error percentage rises above 10% for 5 minutes or longer. A critical violation means that the service's conditions violate that threshold. Begin your investigation by selecting the Telco-Web Portal service name. Step 2 of 8 You're now on the web portal's APM summary page. The top graph, Web transactions time, shows you the service's response times. By default, it also displays periods of critical violation. On the right-hand side of the view, Application activity shows when violations opened and closed: From the left-hand navigation, select Events > Errors to learn more about the errors: At the bottom of the view, the Errors table shows you what errors occurred in the service along with number of times each error occurred. In this scenario, the only error in the service has the following message: bash Copy An error occurred during a downstream request to http://35.182.223.70:7001/api/inventory detail:response code 500 This is a helpful message that explains that the web portal made a request to another service, raised an error, and responded with a response code of 500, indicating an Internal server error. Since this message tells you that the error occurred while the web portal was making an outbound request, use distributed tracing to better understand the issue. Select Monitor > Distributed tracing from the left-hand navigation. Step 3 of 8 Distributed tracing provides end-to-end information about a request. In this case, you're looking for a request to the web portal that raised an error, so that you can better understand what happened during that request. Filter the table, by selecting the Errors column header twice, to order by descending counts: Select the first row in the table: This trace gives a lot of information about what happened with the request once the web portal received it. One of the things that the trace reveals is that the web portal made a GET request to Telco-Login Service and received an error. The trace indicates an error by coloring the text red. Select the row (called a span) to see more information about the request to the login service: Expand Error details to see the error message: bash Copy java.lang.Exception: The application is not yet ready to accept traffic Interesting! This message says that, at the time that the web portal made the GET request to the login service, the login service was not ready to accept traffic. Inspect the login service to dive further into the root cause of these cascading errors. Return to the APM page, and select Telco-Login Service. Step 4 of 8 Notice that the APM summary for Telco-Login Service has similar red flags to the ones in the web portal: Web transactions time has a red error indicator, and Application activity shows critical violations. More than that, the times that the errors occurred in both services match up (around 10:53 AM, in this example). Step 5 of 8 Web transactions time, in APM, shows that requests to the login service spend all their time in Java code. So, in the left-hand navigation, open Monitor > JVMs: Java Virtual Machines, or JVMs, run Java processes, such as those used by the login service. This view shows resource graphs for each JVM your service uses. Change the timeslice to look at data for the last 3 hours, so you can get a better idea of how the service has been behaving: Notice, in Heap memory usage, that the line for Used Heap rises consistently over 30 minute intervals. About two-thirds of the way through each interval, the line for Committed Heap (the amount of JVM heap memory dedicated for use by Java processes) quickly rises to accommodate the increasing memory demands. This graph indicates that the Java process is leaking memory. Step 6 of 8 Your Java process is leaking memory, but you need to understand the extent of the leak's impact. Navigate to the login service's host infrastructure view to dive a little deeper. First, go to the Telco-Login Service summary page and turn off Show new view: Then, scroll to the bottom of the page, and select the host's name: Right now, you can only select the host's name from the old version of the UI (we're working on it). So, make sure you toggle off Show new view. In this infrastructure view, Memory Used % for Telco-Authentication-host consistently climbs from around 60% to around 90% over 30-minute intervals, matching the intervals in the JVM's heap memory usage graph: Therefore, the memory leak effects the login service's entire host. Click and drag on Memory Used % to narrow the timeslice to one of the peaks: Now, compare this graph with the login service's Errors graph to see how they relate. Step 7 of 8 Open New Relic in a new tab. From APM, select Telco-Login Service. Then, navigate to Events > Errors. By comparing these graphs, you see that the memory percentage reached its peak at 10:25 AM (in this example) and then dropped off. You also see that errors started occurring in the login service just after that, at 10:26 AM. The message for those errors is the same one you saw earlier: bash Copy java.lang.Exception: The application is not yet ready to accept traffic This suggests that the memory leaks cause the application to fail for a time. To understand the error a bit more, select the error class from the table at the bottom of the view: The stack trace shows that the service raised an UnhandledException from a function called EnsureAppIsStarted: With the information you've collected so far, you can conclude that Telco-Login Service's Java code has a memory leak. Also, the login service restarts the application when it runs out of memory, and it raises an UnhandledException when it receives requests while the app is restarting. You also know the login service is effecting the web portal, because that is what introduced you to this problem, but does the issue effect any other services? Step 8 of 8 Visualize service dependencies using service maps. First, navigate back to APM, and from Telco-Login Service, select Monitor > Service map: Both Telco-Web Portal and Telco-Warehouse Portal depend on Telco-Login Service. So, when the login service goes down, you start seeing errors in both portals. Extra Credit Use the same steps you used to investigate issues in the web portal to confirm there are issues in the warehouse portal. Conclusion At the end of your investigation, you discovered: Telco-Login Service and Telco-Web Portal raise alerts during critical violations The login service's Java processes leak memory When the login service's host, Telco-Authentication-host, runs out of memory, it restarts the login application While the login application is restarting, it raises an UnhandledException when it receives requests When the web portal and the warehouse portal make requests to the login service while it's restarting, they receive errors and raise errors of their own Now, as a Telco Lite developer, you have enough information to debug the issue causing the memory leak. Congratulations! Learn more about using New Relic by diagnosing other issues. If this is your last issue, tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 62.39017,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>"
      },
      "id": "5f97897964441f26ff6ed879"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/kr/request-demo",
      "sections": [
        "ÎùºÏù¥Î∏å Îç∞Î™® ÏöîÏ≤≠ÌïòÍ∏∞",
        "Í∏∞ÏóÖÏ†ïÎ≥¥",
        "Í≥†Í∞ùÎ¨∏Ïùò",
        "Ìï¥Ïô∏ ÏÇ¨Ïù¥Ìä∏"
      ],
      "published_at": "2021-02-22T14:26:20Z",
      "title": "Request Demo",
      "updated_at": "2021-01-07T14:41:26Z",
      "type": "",
      "external_id": "eba55c740b0a5077de3c90126c802b60d5ce7926",
      "popularity": 1,
      "body": "logo-newrelic Search Ï†úÌíà ÏöîÍ∏à ÏÜîÎ£®ÏÖò ÏßÄÏõê ÏÑºÌÑ∞ Ï†ïÎ≥¥ iOS ÎòêÎäî AndroidÏö© Îâ¥Î†êÎ¶≠ ¬†¬† iOSÏö© Îâ¥Î†êÎ¶≠ Insights Ïï± Search icon Ïã†Ï≤≠ÌïòÍ∏∞ Î°úÍ∑∏Ïù∏ÌïòÍ∏∞ Ï†úÌíà Îâ¥Î†êÎ¶≠ One ÌîåÎû´Ìèº Í∞úÏöî Telemetry Data Platform Full-Stack Observability Applied Intelligence ÏÜîÎ£®ÏÖò Ï£ºÏ†úÎ≥Ñ Îç∞Î∏åÏòµÏä§ ÌÅ¥ÎùºÏö∞Îìú ÎèÑÏûÖ ÌÅ¥ÎùºÏö∞Îìú ÎÑ§Ïù¥Ìã∞Î∏å ÎîîÏßÄÌÑ∏ Í≥†Í∞ù Í≤ΩÌóò Tool ÌÜµÌï© ÏóÖÏ¢ÖÎ≥Ñ Ïù¥Ïª§Î®∏Ïä§ Î∞è Î¶¨ÌÖåÏùº ÎØ∏ÎîîÏñ¥ Í≥µÍ≥µ Î∂ÄÎ¨∏ Í∏∞Ïà†Î≥Ñ Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes ÏßÄÏõê ÏÑºÌÑ∞ ÌôïÏù∏ÌïòÍ∏∞ Docs Îâ¥Î†êÎ¶≠Ïóê Í∏∞Î∞òÌïú Íµ¨Ï∂ï Ïò§Ìîà ÏÜåÏä§ ÌîÑÎ°úÏ†ùÌä∏ ÏÇ¥Ìé¥Î≥¥Í∏∞ ÍµêÏú° ÎèÑÏõÄ ÏöîÏ≤≠ÌïòÍ∏∞ Ïª§ÎÆ§ÎãàÌã∞ Ìè¨Îüº Í∏ÄÎ°úÎ≤å Í∏∞Ïà† ÏßÄÏõê Ï†ÑÎ¨∏Í∞Ä ÏÑúÎπÑÏä§ Ï†ïÎ≥¥ Í≥†Í∞ù Ìè¨Ï∂òÏùò 'Í∏ÄÎ°úÎ≤å 500ÎåÄ Í∏∞ÏóÖ‚ÄôÏóêÏÑú Ï§ëÏÜåÍ∏∞ÏóÖÍπåÏßÄ, Ï†Ñ ÏÑ∏Í≥Ñ 17,000Ïó¨ Í∏∞ÏóÖÎì§Ïù¥ Îâ¥Î†êÎ¶≠ÏùÑ ÏÇ¨Ïö©ÌïòÍ≥† ÏûàÏäµÎãàÎã§. Î∏îÎ°úÍ∑∏ Îâ¥Î†êÎ¶≠Í≥º ÎîîÏßÄÌÑ∏ Ïù∏ÌÖîÎ¶¨Ï†ÑÏä§Ïùò ÏÑ∏Í≥ÑÍ∞Ä Ï†úÍ≥µÌïòÎäî ÏµúÏã† Îâ¥Ïä§, ÌåÅ Î∞è ÌÜµÏ∞∞ÏùÑ ÌôïÏù∏Ìï† Ïàò ÏûàÏäµÎãàÎã§. ¬†¬† Close icon Îâ¥Î†êÎ¶≠ Ï†ïÎ≥¥ ÌöåÏÇ¨ ÏÜåÍ∞ú Í≤ΩÏòÅÏßÑ Î™®ÏûÑ Î∞è Ïù¥Î≤§Ìä∏ Ï∞∏Í≥† ÏûêÎ£å ¬† Ìà¨ÏûêÏûê Ï†ïÎ≥¥ Îâ¥Ïä§Î£∏ ÌååÌä∏ÎÑà ÌîÑÎ°úÍ∑∏Îû® Ïó∞ÎùΩ Ï†ïÎ≥¥ logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon ÎùºÏù¥Î∏å Îç∞Î™® ÏöîÏ≤≠ÌïòÍ∏∞ ÏïÑÎûò¬†ÏñëÏãùÏùÑ¬†ÏÇ¨Ïö©Ìï¥¬†ÏßÄÍ∏à¬†ÎßûÏ∂§Ìòï¬†ÎùºÏù¥Î∏å¬†Îç∞Î™®Î•º¬†ÏöîÏ≤≠ÌïòÏã≠ÏãúÏò§. Í∏∞ÏóÖÏ†ïÎ≥¥ Ï±ÑÏö© Î∞è Î¨∏Ìôî ÌååÌä∏ÎÑà ÌîÑÎ°úÍ∑∏Îû® Ìà¨ÏûêÏûê Ï†ïÎ≥¥ NewRelic.org Í≥µÍ∏âÏóÖÏ≤¥ Ìè¨ÌÑ∏ Í≥†Í∞ùÎ¨∏Ïùò Ïó∞ÎùΩ Ï†ïÎ≥¥ Îç∞Î™® Ïã†Ï≤≠ÌïòÍ∏∞ Ïù¥Î≤§Ìä∏ Ìï¥Ïô∏ ÏÇ¨Ïù¥Ìä∏ Deutsch English Fran√ßais Êó•Êú¨Ë™û ÏÑúÎπÑÏä§ Ïù¥Ïö©ÏïΩÍ¥Ä DMCA Ï†ïÏ±Ö Í∞úÏù∏Ï†ïÎ≥¥ Ï≤òÎ¶¨Î∞©Ïπ® Ïø†ÌÇ§ Ï†ïÏ±Ö 2015ÎÖÑ ÏòÅÍµ≠ ÎÖ∏Ïòà Î∞©ÏßÄÎ≤ï ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 14.969709,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Request <em>Demo</em>"
      },
      "id": "5fdc3078196a679498213956"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/request-demo",
      "sections": [
        "Request a live demo.",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-02-25T01:50:08Z",
      "title": "Request a New Relic Demo | New Relic",
      "updated_at": "2021-01-04T13:42:55Z",
      "type": "",
      "external_id": "3106a7a9ae5e77d7d4c56815b91f8933a4faeb1f",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Request a live demo. Use the form below to request your personalized live demo. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 11.987905,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Request a New Relic <em>Demo</em> | New Relic",
        "sections": "Request a live <em>demo</em>.",
        "body": " Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects"
      },
      "id": "5786ed3ce621f423f2e9cf78"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/resources/webinars/apac-live-demo-optimizing-CX?video=past-webinar",
      "sections": [
        "Learn why over 16,000 companies use the New Relic One Observability Platform daily to:",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-02-22T16:22:23Z",
      "title": "On-Demand Demo: Optimising the Customer Experience with New Relic One",
      "updated_at": "2021-01-01T04:37:32Z",
      "type": "storefront",
      "external_id": "57f7b338dbf4898ff26209e8eddb8704a22589e1",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Video On-Demand Demo: Optimising the Customer Experience with New Relic One 61:56 ¬† Interested in learning more about New Relic One before you decide to sign up? Watch this demo of New Relic One led by a member of our Solutions Engineering team to see a detailed tour of the observability platform. Learn why over 16,000 companies use the New Relic One Observability Platform daily to: Measure real-user experience - See and understand the intricacies of who‚Äôs using your site, and identify ways to improve their experience. Catch problems before customers - Simulate real user flows across every digital touchpoint‚Äîstarting in development, through QA, and all the way into production. Cultivate deeper customer relationships - Gain real-time insight into what your users are experiencing and how they‚Äôre engaging with your content. Request a Demo COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 10.213428,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "On-Demand <em>Demo</em>: Optimising the Customer Experience with New Relic One",
        "body": " Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects"
      },
      "id": "5ed2fe0728ccbc929bc135d3"
    }
  ],
  "/build-apps/publish-deploy": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Permissions for managing applications",
        "Publish and deploy apps",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Build apps",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Permissions for managing applications ¬† Learn about permissions for subscribing to apps Publish and deploy apps 30 min Start sharing the apps you build Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 224.61452,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "<em>Publish</em> and <em>deploy</em> <em>apps</em>",
        "body": " 20 min <em>Add</em> a time picker to a sample application Create a &quot;Hello, World!&quot; application 15 min Build a &quot;Hello, World!&quot; <em>app</em> and <em>publish</em> it to New Relic One <em>Add</em> a table to your <em>app</em> 30 min <em>Add</em> a table to your New Relic One <em>app</em> Create a custom map view 30 min Build an <em>app</em> to show page view data on a map"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Permissions for managing applications",
        "New Relic One pricing plan",
        "Original product-based pricing",
        "This site uses cookies üç™"
      ],
      "title": "Permissions for managing applications",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2021-02-25T01:58:11Z",
      "updated_at": "2020-12-04T01:59:58Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for subscribing to apps",
      "body": "When you create an app, you'll likely want to share it. From New Relic One's Apps page, you can subscribe to apps you create, publish, and deploy, and to other publicly available apps. You must have the Nerdpack manager role to subcribe accounts to apps. Read on to learn about permissions and versions. Permissions for managing applications The Nerdpack manager role is a New Relic add-on role. When you create a Nerdpack, you have the Nerdpack manager role for handling that Nerdpack. New Relic account administrators have the Nerdpack manager role automatically, and can subscribe their accounts to available Nerdpacks. User permissions vary depending on which pricing plan you are on. New Relic One pricing plan For accounts with New Relic One pricing, there are permissions differences for basic users and full users: Full users have the Nerdpack manager role and have full capabilities for creating and managing New Relic One applications, as well as accessing all types of applications in the New Relic One catalog. A basic user can develop and view their own local New Relic One apps, but they cannot: Subscribe other users to apps they‚Äôve created. Access or manage apps in the New Relic One catalog. Access apps in the entity explorer sidebar. Original product-based pricing For accounts on our original product-based pricing, here are access details: Subscribe to publicly available applications To subscribe to publicly available applications, you must have the Nerdpack manager role. Nerdpack manager permissions are automatically assigned to New Relic account owners and admins and can be assigned to individual users. If you aren‚Äôt an owner or admin, you can request Nerdpack manager permission, or ask your New Relic admin or owner to subscribe the apps to your account for you. You can add any of the publicly available applications to master accounts or separate sub-accounts on which you have the Nerdpack manager role, or to separate sub-accounts under a master account you own or administer. If you add the application to a master account, the access flows to all of its sub-accounts as well. Subscribe to applications that you create You also must have the Nerdpack manager role to subscribe the applications you create to accounts. Applications that you publish and deploy can only be subscribed to the master account that was used to publish them, or to its sub-accounts. This means you might want a New Relic admin to deploy your applications for you if they need to be available across the organization.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 52.752884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Permissions for managing <em>applications</em>",
        "sections": "Permissions for managing <em>applications</em>",
        "info": "Learn about permissions for <em>subscribing</em> to <em>apps</em>",
        "tags": "managing <em>apps</em>",
        "body": "When you create an <em>app</em>, you&#x27;ll likely want to share it. From New Relic One&#x27;s <em>Apps</em> page, you can <em>subscribe</em> to <em>apps</em> you create, <em>publish</em>, and <em>deploy</em>, and to other publicly available <em>apps</em>. You must have the Nerdpack manager role to subcribe accounts to <em>apps</em>. Read on to learn about permissions"
      },
      "id": "5f45bf2864441ffb4dfdcdbb"
    },
    {
      "image": "https://newrelic.com/themes/custom/curio/assets/images/metadata/NROG_Image.png",
      "url": "https://newrelic.com/press-releases/20110118",
      "sections": [
        "Engine Yard Extends Partnership with New Relic to Provide Proven Rails Application Management to Its Customers at No Charge",
        "About Engine Yard",
        "About New Relic",
        "Media Contact",
        "Investor Contact"
      ],
      "published_at": "2021-02-22T14:49:16Z",
      "title": "Engine Yard Extends Partnership with New Relic to Provide Proven Rails Application Management to Its Customers at No Charge | New Relic",
      "updated_at": "2021-02-22T14:49:16Z",
      "type": "",
      "external_id": "50f1afc9a9aa17044545d812736fd10c37638c99",
      "popularity": 1,
      "body": "Skip to main content New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Newsroom Press Release Engine Yard Extends Partnership with New Relic to Provide Proven Rails Application Management to Its Customers at No Charge Engine Yard customers can now use New Relic RPM Bronze at no cost to monitor and troubleshoot their production Ruby on Rails web applications in the cloud Share on Facebook Share on Twitter Share on LinkedIn San Francisco - January 18, 2011 New Relic, Inc., the leading software-as-a-service provider of¬†application performance management¬†(APM) solutions, and¬†Engine Yard, the leading cloud computing Platform-as-a-Service for¬†Ruby on Rails, today announced that New Relic RPM is available free to Engine Yard customers. Now, organizations deploying business-critical Ruby on Rails web applications on Engine Yard AppCloud and xCloud can use RPM Bronze at no charge to monitor app performance 24x7, proactively troubleshoot potential issues, and help meet high standards for online service delivery. Engine Yard Platform-as-a-Service enables web-based companies and enterprises to scale by running mission-critical applications without the cost of investing in computing infrastructure. The Engine Yard platform-as-a-service offerings provide a curated and optimized Ruby on Rails stack, a set of best-of-breed deployment and management tools, and access to Engine Yard support and professional services. New Relic RPM is the leading on-demand application performance management service for Ruby on Rails. It allows teams to monitor applications in production, proactively identify performance issues, and drill down for root-cause diagnosis. The combination of RPM‚Äôs proven application management capabilities and the Engine Yard platform creates an unparalleled solution for deploying and maintaining superior-performing web applications in the cloud. ‚ÄúOur customers are shoppers who want instant access to discount and coupon information on their iPhones, so we need to deliver quick service and 100% uptime,‚Äù said Matt Greer, CEO of Armadealo. ‚ÄúWe rely on Engine Yard because they are experts in deploying Ruby on Rails applications, and we have confidence that we can scale quickly to respond to large traffic spikes, up to 300%, on weekends and holidays. We chose New Relic because we can optimize our application response times during development and then monitor performance after we deploy to make sure we‚Äôre providing the best user experience. Using the combination of Engine Yard AppCloud and New Relic RPM frees me to focus on growing my business and serving customers.‚Äù ‚ÄúOver 1,800 Engine Yard customers have chosen to build their mission-critical applications in Ruby on Rails and deploy to the cloud,‚Äù said Tom Mornini, CTO and co-founder of Engine Yard. ‚ÄúAs fast-growing web companies and enterprises continue to build innovative products and services, they want to provide maximum uptime and the best user experience for their customers. New Relic and Engine Yard are delivering an enterprise-class platform and service that allows companies to easily deploy their apps and get a critical view into production application performance.‚Äù ‚ÄúNew Relic and Engine Yard share a very strong commitment to the Ruby on Rails community and have been working closely together for some time now to help organizations successfully deploy and maintain their business-critical web apps,‚Äù said Lew Cirne, New Relic‚Äôs founder and CEO. ‚ÄúWith RPM Bronze available free of charge, Engine Yard customers can gain tremendous advantage by monitoring production application performance and proactively identifying potential issues.‚Äù Engine Yard AppCloud and xCloud customers can easily start using RPM Bronze by contacting their Engine Yard sales representative for details. Additionally, RPM Silver and Gold subscriptions are available to Engine Yard customers at special discounted pricing. For more information about using New Relic RPM on Engine Yard, please visit¬†http://pages.engineyard.com/NewRelicOffer.html. About Engine Yard Engine Yard is the leading provider of automation technologies and services for Ruby on Rails, including AppCloud and xCloud, Engine Yard‚Äôs Platform-as-a-Service (PaaS) products for web developers and web teams. Engine Yard products provide easy-to-use, automated Rails application deployment and management with a design philosophy that allows for the migration of existing applications. Engine Yard helps development teams realize productivity gains and cost savings by eliminating the operational overhead caused by application deployment issues and managing complex infrastructures. A significant contributor to the advancement of Open Source projects, Engine Yard employs top industry experts and sponsors or directly contributes to many projects such as Ruby on Rails, JRuby, Rubinius, and fog. Headquartered in San Francisco, Calif., Engine Yard is backed by Benchmark Capital, New Enterprise Associates, and Amazon.com. Back to press releases About New Relic The world‚Äôs best engineering teams rely on New Relic to visualize, analyze and troubleshoot their software. New Relic One is the most powerful cloud-based observability platform built to help companies create more perfect software. Learn why customers trust New Relic for improved uptime and performance, greater scale and efficiency, and accelerated time to market at newrelic.com. New Relic is a registered trademark of New Relic, Inc. All product and company names herein may be trademarks of their registered owners. New Relic on Facebook New Relic on Twitter New Relic on LinkedIn New Relic on YouTube Media Contact Andrew Schmitt 415-869-7109 PR@newrelic.com Investor Contact Peter Goldmacher 503-336-9280 IR@newrelic.com Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International Êó•Êú¨Ë™û Fran√ßais Deutsch ÌïúÍµ≠Ïñ¥ Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 30.447567,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Engine Yard Extends Partnership with New Relic to Provide Proven Rails <em>Application</em> Management to Its Customers at No Charge | New Relic",
        "sections": "Engine Yard Extends Partnership with New Relic to Provide Proven Rails <em>Application</em> Management to Its Customers at No Charge",
        "body": "%, on weekends and holidays. We chose New Relic because we can optimize our application response times during development and then monitor performance after we <em>deploy</em> to make sure we‚Äôre providing the best user experience. Using the combination of Engine Yard <em>App</em>Cloud and New Relic RPM frees me to focus"
      },
      "id": "575f8b78c75d0758a5c39401"
    },
    {
      "image": "https://newrelic.com/themes/custom/curio/assets/images/metadata/NROG_Image.png",
      "url": "https://newrelic.com/press-releases/20110120",
      "sections": [
        "cloudControl Selects New Relic RPM as Web Application Management Tool of Choice for Its Customers",
        "About cloudControl",
        "About New Relic",
        "Media Contact",
        "Investor Contact"
      ],
      "published_at": "2021-02-22T14:48:15Z",
      "title": "cloudControl Selects New Relic RPM as Web Application Management Tool of Choice for Its Customers | New Relic",
      "updated_at": "2021-02-22T14:48:14Z",
      "type": "",
      "external_id": "750c65ca71332d98695a72c5f557fdfe70dab7e0",
      "popularity": 1,
      "body": "Skip to main content New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Newsroom Press Release cloudControl Selects New Relic RPM as Web Application Management Tool of Choice for Its Customers All cloudControl customers can now use New Relic RPM Bronze free of charge to monitor and troubleshoot their production PHP web applications in the cloud Share on Facebook Share on Twitter Share on LinkedIn San Francisco - January 20, 2011 New Relic, Inc., the leading software-as-a-service provider of¬†application performance management¬†(APM) solutions, and¬†cloudControl, a leading cloud hosting platform for PHP web applications, today announced that cloudControl is providing the proven application monitoring and troubleshooting capabilities of New Relic RPM Bronze to all cloudControl customers at no cost. Additionally, cloudControl customers are eligible for discounts on upgrades to RPM Silver and Gold premium subscriptions at preferential prices in¬†cloudControl‚Äôs Add-on Marketplace. ‚ÄúAs organizations continue to rely on cloudControl as a trusted platform for deploying business-critical web applications, it‚Äôs important that we provide them with the very best resources to help them be successful,‚Äù said Philipp Strube, co-founder of cloudControl. ‚ÄúPartnering with New Relic to enable application monitoring and troubleshooting will make it easier for our customers to deploy, maintain, and ensure superior-performing web applications.‚Äù cloudControl‚Äôs PHP Platform as a Service solution helps developers to focus on the important part of their work ‚Äî developing exciting web applications. Developers can easily deploy PHP apps on cloudControl‚Äôs platform without having to administer the underlying hardware. By partnering with New Relic, cloudControl will enable its customers to not only develop and host web applications in a high performance and scalable managed environment, but also to monitor and improve application performance. ‚ÄúNew Relic and cloudControl share a common philosophy that the very best solutions for deploying and maintaining web applications in the cloud should be fast, easy and reliable,‚Äù said Bill Lapcevic, New Relic‚Äôs vice president of business development. ‚ÄúBy offering effective SaaS-based production application monitoring as part of their proven deployment platform, cloudControl is providing tremendous benefits for organizations that want manageability for the cloud while eliminating administration overhead.‚Äù The New Relic RPM Bronze Add-on is available to cloudControl customers at no cost in the Add-on marketplace, which offers additional resources for customers wishing to scale and optimize applications deployed on cloudControl. Developers can get started right away by selecting the New Relic add-on and deploying it on one of cloudControl‚Äôs free developer accounts. About cloudControl Based in Potsdam,¬†cloudControl¬†is a leading provider of cloud hosting services for deploying PHP web apps. Their highly optimized and reliable stack harnesses the scalability of Amazon EC2. CloudControl‚Äôs solution is fully managed, completely eliminating administration hassles. And because it‚Äôs pay as you go, customers can scale up and down at any time and only pay for the services they use. Additionally, cloudControl offers their Add-on Marketplace, where customers can obtain complementary solutions for scaling and optimizing their apps. Among others, these include MySQL, Memcached, MongoDB and New Relic RPM. Back to press releases About New Relic The world‚Äôs best engineering teams rely on New Relic to visualize, analyze and troubleshoot their software. New Relic One is the most powerful cloud-based observability platform built to help companies create more perfect software. Learn why customers trust New Relic for improved uptime and performance, greater scale and efficiency, and accelerated time to market at newrelic.com. New Relic is a registered trademark of New Relic, Inc. All product and company names herein may be trademarks of their registered owners. New Relic on Facebook New Relic on Twitter New Relic on LinkedIn New Relic on YouTube Media Contact Andrew Schmitt 415-869-7109 PR@newrelic.com Investor Contact Peter Goldmacher 503-336-9280 IR@newrelic.com Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International Êó•Êú¨Ë™û Fran√ßais Deutsch ÌïúÍµ≠Ïñ¥ Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 30.446339,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "cloudControl Selects New Relic RPM as Web <em>Application</em> Management Tool of Choice for Its Customers | New Relic",
        "sections": "cloudControl Selects New Relic RPM as Web <em>Application</em> Management Tool of Choice for Its Customers",
        "body": " customers to <em>deploy</em>, maintain, and ensure superior-performing web applications.‚Äù cloudControl‚Äôs PHP Platform as a Service solution helps developers to focus on the important part of their work ‚Äî developing exciting web applications. Developers can easily <em>deploy</em> PHP <em>apps</em> on cloudControl‚Äôs platform"
      },
      "id": "575f8b7e0755233594057b7d"
    },
    {
      "category_2": "Hosting services",
      "nodeid": 13151,
      "sections": [
        "Node.js agent",
        "Getting started",
        "Installation and configuration",
        "Extend your instrumentation",
        "Attributes",
        "API guides",
        "Hosting services",
        "Troubleshooting",
        "Install New Relic Node.js agent in GAE flexible environment",
        "Use native deploy",
        "Build a custom runtime",
        "Optional: Disable health checks",
        "Get New Relic agent troubleshooting logs from GAE",
        "For more help"
      ],
      "title": "Install New Relic Node.js agent in GAE flexible environment",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Node.js agent",
      "external_id": "92a838b215a23bd47fcc8b45abdf347c56f720db",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/hosting-services/install-new-relic-nodejs-agent-gae-flexible-environment",
      "published_at": "2021-02-22T16:00:09Z",
      "updated_at": "2020-08-18T06:29:37Z",
      "breadcrumb": "Contents / APM agents / Node.js agent / Hosting services",
      "document_type": "page",
      "popularity": 1,
      "info": "How to install your APM's Node.js app in the Google App Engine (GAE) flexible environment. ",
      "body": "With New Relic's Node.js agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. This document explains how to add New Relic to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Use native deploy To use Google App Engine's \"native mode\" installation with your Node.js app: Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. Optional: Set environment variables to configure the Node.js agent's GAE app.yaml file. Use the Google Cloud SDK's gcloud command line tool to deploy GAE apps. To deploy your Node.js app to your initialized GAE flexible environment, run the following command: gcloud --project new-relic-apm-nodejs app deploy Google App Engine automatically includes your Node.js app's newrelic.js configuration file in the deployed package. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by building a custom runtime for Docker. You can deploy the app without any special configuration. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Google App Engine's documentation for Node.js Google App Engine's tutorial to deploy a Node.js app 1. Set up the GAE project and install dependencies Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Optional: Set environment variables. 3. Configure and deploy The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. To create the Dockerfile, build the container, and deploy your app, follow the GAE procedures for Node.js. Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Optional: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in New Relic APM. If you notice performance issues, disable GAE health checks. In your app.yaml, add: health_check: enable_health_check: False Get New Relic agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect New Relic Node.js agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.js configuration file to: log_file_name: STDOUT To view the logs, use the Cloud Platform Console's Log Viewer. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 28.201029,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use native <em>deploy</em>",
        "info": "How to install your APM&#x27;s Node.js <em>app</em> in the Google <em>App</em> Engine (GAE) flexible environment. ",
        "body": ". This document explains how to <em>add</em> New Relic to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime Use native <em>deploy</em> To use Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with your"
      },
      "id": "5972fea707552313d3f9ba8d"
    }
  ],
  "/automate-workflows/diagnose-problems": [
    {
      "sections": [
        "Diagnose error alerts in Telco Lite",
        "Prerequisites",
        "Tip",
        "Extra Credit",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Diagnose error alerts in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "2857da924e8d8a8e78dca86040692d061bf14753",
      "image": "https://developer.newrelic.com/static/a03659a8d751f40e75f74a23b135c921/0086b/error-alerts.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/error-alerts/",
      "published_at": "2021-02-25T01:58:11Z",
      "updated_at": "2021-01-16T01:47:39Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose error alerts in your services.",
      "body": "Use New Relic to understand why some services are raising alerts. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the error alerts in your services. Step 1 of 8 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that Telco-Login Service and Telco-Web Portal have opened critical violations for high error percentages: Tip If you don't see all the same alerts, don't worry. The simulated issues happen at regular intervals, so you should start seeing these problems in New Relic within 30 minutes to an hour. The deployment has created an alert condition for cases where a service's error percentage rises above 10% for 5 minutes or longer. A critical violation means that the service's conditions violate that threshold. Begin your investigation by selecting the Telco-Web Portal service name. Step 2 of 8 You're now on the web portal's APM summary page. The top graph, Web transactions time, shows you the service's response times. By default, it also displays periods of critical violation. On the right-hand side of the view, Application activity shows when violations opened and closed: From the left-hand navigation, select Events > Errors to learn more about the errors: At the bottom of the view, the Errors table shows you what errors occurred in the service along with number of times each error occurred. In this scenario, the only error in the service has the following message: bash Copy An error occurred during a downstream request to http://35.182.223.70:7001/api/inventory detail:response code 500 This is a helpful message that explains that the web portal made a request to another service, raised an error, and responded with a response code of 500, indicating an Internal server error. Since this message tells you that the error occurred while the web portal was making an outbound request, use distributed tracing to better understand the issue. Select Monitor > Distributed tracing from the left-hand navigation. Step 3 of 8 Distributed tracing provides end-to-end information about a request. In this case, you're looking for a request to the web portal that raised an error, so that you can better understand what happened during that request. Filter the table, by selecting the Errors column header twice, to order by descending counts: Select the first row in the table: This trace gives a lot of information about what happened with the request once the web portal received it. One of the things that the trace reveals is that the web portal made a GET request to Telco-Login Service and received an error. The trace indicates an error by coloring the text red. Select the row (called a span) to see more information about the request to the login service: Expand Error details to see the error message: bash Copy java.lang.Exception: The application is not yet ready to accept traffic Interesting! This message says that, at the time that the web portal made the GET request to the login service, the login service was not ready to accept traffic. Inspect the login service to dive further into the root cause of these cascading errors. Return to the APM page, and select Telco-Login Service. Step 4 of 8 Notice that the APM summary for Telco-Login Service has similar red flags to the ones in the web portal: Web transactions time has a red error indicator, and Application activity shows critical violations. More than that, the times that the errors occurred in both services match up (around 10:53 AM, in this example). Step 5 of 8 Web transactions time, in APM, shows that requests to the login service spend all their time in Java code. So, in the left-hand navigation, open Monitor > JVMs: Java Virtual Machines, or JVMs, run Java processes, such as those used by the login service. This view shows resource graphs for each JVM your service uses. Change the timeslice to look at data for the last 3 hours, so you can get a better idea of how the service has been behaving: Notice, in Heap memory usage, that the line for Used Heap rises consistently over 30 minute intervals. About two-thirds of the way through each interval, the line for Committed Heap (the amount of JVM heap memory dedicated for use by Java processes) quickly rises to accommodate the increasing memory demands. This graph indicates that the Java process is leaking memory. Step 6 of 8 Your Java process is leaking memory, but you need to understand the extent of the leak's impact. Navigate to the login service's host infrastructure view to dive a little deeper. First, go to the Telco-Login Service summary page and turn off Show new view: Then, scroll to the bottom of the page, and select the host's name: Right now, you can only select the host's name from the old version of the UI (we're working on it). So, make sure you toggle off Show new view. In this infrastructure view, Memory Used % for Telco-Authentication-host consistently climbs from around 60% to around 90% over 30-minute intervals, matching the intervals in the JVM's heap memory usage graph: Therefore, the memory leak effects the login service's entire host. Click and drag on Memory Used % to narrow the timeslice to one of the peaks: Now, compare this graph with the login service's Errors graph to see how they relate. Step 7 of 8 Open New Relic in a new tab. From APM, select Telco-Login Service. Then, navigate to Events > Errors. By comparing these graphs, you see that the memory percentage reached its peak at 10:25 AM (in this example) and then dropped off. You also see that errors started occurring in the login service just after that, at 10:26 AM. The message for those errors is the same one you saw earlier: bash Copy java.lang.Exception: The application is not yet ready to accept traffic This suggests that the memory leaks cause the application to fail for a time. To understand the error a bit more, select the error class from the table at the bottom of the view: The stack trace shows that the service raised an UnhandledException from a function called EnsureAppIsStarted: With the information you've collected so far, you can conclude that Telco-Login Service's Java code has a memory leak. Also, the login service restarts the application when it runs out of memory, and it raises an UnhandledException when it receives requests while the app is restarting. You also know the login service is effecting the web portal, because that is what introduced you to this problem, but does the issue effect any other services? Step 8 of 8 Visualize service dependencies using service maps. First, navigate back to APM, and from Telco-Login Service, select Monitor > Service map: Both Telco-Web Portal and Telco-Warehouse Portal depend on Telco-Login Service. So, when the login service goes down, you start seeing errors in both portals. Extra Credit Use the same steps you used to investigate issues in the web portal to confirm there are issues in the warehouse portal. Conclusion At the end of your investigation, you discovered: Telco-Login Service and Telco-Web Portal raise alerts during critical violations The login service's Java processes leak memory When the login service's host, Telco-Authentication-host, runs out of memory, it restarts the login application While the login application is restarting, it raises an UnhandledException when it receives requests When the web portal and the warehouse portal make requests to the login service while it's restarting, they receive errors and raise errors of their own Now, as a Telco Lite developer, you have enough information to debug the issue causing the memory leak. Congratulations! Learn more about using New Relic by diagnosing other issues. If this is your last issue, tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 62.39017,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>"
      },
      "id": "5f97897964441f26ff6ed879"
    },
    {
      "sections": [
        "Diagnose high response times in Telco Lite",
        "Prerequisites",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Diagnose high response times in Telco Lite",
      "type": "developer",
      "tags": [
        "demo",
        "explore"
      ],
      "external_id": "257b617b5a1c415b4563b211805653c5f59647b1",
      "image": "https://developer.newrelic.com/static/7b43ba54fb07afd22eb0b6b72e8aacc0/0086b/high-response-times.png",
      "url": "https://developer.newrelic.com/automate-workflows/diagnose-problems/high-response-times/",
      "published_at": "2021-02-25T01:58:11Z",
      "updated_at": "2020-12-04T01:54:04Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use New Relic to diagnose high response times in your services.",
      "body": "Use New Relic to understand why Telco-Warehouse Portal has slower-than-normal response times. Prerequisites Before you begin: Learn about the infrastructure of Telco Lite Set up your local environment Deploy and instrument the Telco Lite services When you're ready, start your journey by observing the high response times in your services. Step 1 of 6 Log in to New Relic One and select APM from the top navigation menu. Here, you see an overview of all eight Telco Lite services, including the service names, response times, and throughputs. Notice that the response time for Telco-Warehouse Portal is 43 seconds, much higher than the response times in other services: On the APM page, select the Telco-Warehouse Portal service name to see a summary of that service. The top graph in the summary view shows Web transactions time: You see several peaks, reaching almost 50,000 milliseconds‚Äîor 50 seconds! From this graph, you can actually gain a little more insight by toggling the colored components beneath the graph. For example, select Node.js: The graph changes to show only what the Node.js component contributes to the overall response time‚Äîless than 100 ms, in this example. Now, select Web external and deselect Node.js: External web traffic is the primary contributor to the high response times. That's a good start, but it doesn't tell the whole story. Next, dive deeper to find out which external service is causing the issue. Step 2 of 6 So, you know that Web external is the culprit of the high response times, but it's hard to tell why. External web traffic is all the requests made from your service to other services. This means you should look into what external requests that the warehouse portal makes to try to understand exactly what external service is the bottleneck. From the left-hand navigation, select Monitor > Distributed tracing: This view shows you requests to the warehouse portal. Select a request from the table at the bottom of the view to see a trace through that request: This trace shows that one external request contributes almost all of the total trace duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select Explore this transaction: Step 3 of 6 You're now looking at the __main__:inventory_item transaction overview. Because you know that some part of this transaction is slow, you can use this overview to narrow your focus even further. Similar to how you modified the warehouse portal APM graph, you can look specifically at the components of this transaction to understand where the root cause of the slowness is. Another way to view this information is to scroll down to the Breakdown table in that same view: Function/__main__:inventory_item, a Python function, contributes over 99% of the overall response time. At this point, you know that Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow. You also know that the issue in the fulfillment service is local because over 99% of the request is spent in Python code, not external services. Navigate to the fulfillment service's summary page to look at the service as a whole, instead of this single transaction: Step 4 of 6 Scroll down on this view to familiarize yourself with the graphs it shows, such as Throughput and Error rate. At the bottom of the page, you can see a table with the fulfillment hosts. You can't currently drill into a specific host in the new UI (we're working on it), but you can in the old UI. Toggle Show new view to off and select the host link: Step 5 of 6 Now, you're looking at graphs in the infrastructure view for that service's host. Notice that CPU % has a lot of high spikes. Click and drag on the graph from the start of a spike to the end of it to narrow the timeslice to the period when CPU utilization goes up: If you compare this graph to the fulfillment service's transaction graph you looked at earlier, you'll see that soon after __main__:inventory_item begins executing, the CPU utilization of the host sharply rises to 100%! Step 6 of 6 Now, you understand the problem causing slow response times in the warehouse portal, but you don't know the extent of the issue. Using service maps, you can see all your services that depend on the fullfillment service. Navigate to the service map under APM > Telco-Fulfillment Service: This map shows you the fulfillment service's incoming and outgoing dependencies. Not only is Telco-Warehouse Portal dependent on the fullfillment service, but so is Telco-Web Portal! Select the web portal node to see that the fulfillment service also affects the web portal's response times: Conclusion At the end of your investigation, you discovered: Telco-Warehouse Portal is slow because it makes an external request to Telco-Fulfillment Service, which is slow The fulfillment service's Python function contributes over 99% of the response time Soon after the Python function starts executing, the host's CPU utilization spikes up to 100% The fulfillment service also affects Telco-Web Portal response times Now, as the developer behind the fulfillment service, you have enough information to debug the issue causing the CPU spikes. Congratulations! You can learn more about using New Relic by diagnosing other issues. If this is your last issue, you can tear down all the Telco Lite services.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 54.912186,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>explore</em>",
        "body": " duration. Specifically, an external request to the Telco-Fulfillment Service contributes over 99% of the overall response time. This is good news! You own the fulfillment service, which means you can drill down for even more information. Select the offending row (called a span), and then select <em>Explore</em>"
      },
      "id": "5f9789dde7b9d23fd65c94fa"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/kr/request-demo",
      "sections": [
        "ÎùºÏù¥Î∏å Îç∞Î™® ÏöîÏ≤≠ÌïòÍ∏∞",
        "Í∏∞ÏóÖÏ†ïÎ≥¥",
        "Í≥†Í∞ùÎ¨∏Ïùò",
        "Ìï¥Ïô∏ ÏÇ¨Ïù¥Ìä∏"
      ],
      "published_at": "2021-02-22T14:26:20Z",
      "title": "Request Demo",
      "updated_at": "2021-01-07T14:41:26Z",
      "type": "",
      "external_id": "eba55c740b0a5077de3c90126c802b60d5ce7926",
      "popularity": 1,
      "body": "logo-newrelic Search Ï†úÌíà ÏöîÍ∏à ÏÜîÎ£®ÏÖò ÏßÄÏõê ÏÑºÌÑ∞ Ï†ïÎ≥¥ iOS ÎòêÎäî AndroidÏö© Îâ¥Î†êÎ¶≠ ¬†¬† iOSÏö© Îâ¥Î†êÎ¶≠ Insights Ïï± Search icon Ïã†Ï≤≠ÌïòÍ∏∞ Î°úÍ∑∏Ïù∏ÌïòÍ∏∞ Ï†úÌíà Îâ¥Î†êÎ¶≠ One ÌîåÎû´Ìèº Í∞úÏöî Telemetry Data Platform Full-Stack Observability Applied Intelligence ÏÜîÎ£®ÏÖò Ï£ºÏ†úÎ≥Ñ Îç∞Î∏åÏòµÏä§ ÌÅ¥ÎùºÏö∞Îìú ÎèÑÏûÖ ÌÅ¥ÎùºÏö∞Îìú ÎÑ§Ïù¥Ìã∞Î∏å ÎîîÏßÄÌÑ∏ Í≥†Í∞ù Í≤ΩÌóò Tool ÌÜµÌï© ÏóÖÏ¢ÖÎ≥Ñ Ïù¥Ïª§Î®∏Ïä§ Î∞è Î¶¨ÌÖåÏùº ÎØ∏ÎîîÏñ¥ Í≥µÍ≥µ Î∂ÄÎ¨∏ Í∏∞Ïà†Î≥Ñ Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes ÏßÄÏõê ÏÑºÌÑ∞ ÌôïÏù∏ÌïòÍ∏∞ Docs Îâ¥Î†êÎ¶≠Ïóê Í∏∞Î∞òÌïú Íµ¨Ï∂ï Ïò§Ìîà ÏÜåÏä§ ÌîÑÎ°úÏ†ùÌä∏ ÏÇ¥Ìé¥Î≥¥Í∏∞ ÍµêÏú° ÎèÑÏõÄ ÏöîÏ≤≠ÌïòÍ∏∞ Ïª§ÎÆ§ÎãàÌã∞ Ìè¨Îüº Í∏ÄÎ°úÎ≤å Í∏∞Ïà† ÏßÄÏõê Ï†ÑÎ¨∏Í∞Ä ÏÑúÎπÑÏä§ Ï†ïÎ≥¥ Í≥†Í∞ù Ìè¨Ï∂òÏùò 'Í∏ÄÎ°úÎ≤å 500ÎåÄ Í∏∞ÏóÖ‚ÄôÏóêÏÑú Ï§ëÏÜåÍ∏∞ÏóÖÍπåÏßÄ, Ï†Ñ ÏÑ∏Í≥Ñ 17,000Ïó¨ Í∏∞ÏóÖÎì§Ïù¥ Îâ¥Î†êÎ¶≠ÏùÑ ÏÇ¨Ïö©ÌïòÍ≥† ÏûàÏäµÎãàÎã§. Î∏îÎ°úÍ∑∏ Îâ¥Î†êÎ¶≠Í≥º ÎîîÏßÄÌÑ∏ Ïù∏ÌÖîÎ¶¨Ï†ÑÏä§Ïùò ÏÑ∏Í≥ÑÍ∞Ä Ï†úÍ≥µÌïòÎäî ÏµúÏã† Îâ¥Ïä§, ÌåÅ Î∞è ÌÜµÏ∞∞ÏùÑ ÌôïÏù∏Ìï† Ïàò ÏûàÏäµÎãàÎã§. ¬†¬† Close icon Îâ¥Î†êÎ¶≠ Ï†ïÎ≥¥ ÌöåÏÇ¨ ÏÜåÍ∞ú Í≤ΩÏòÅÏßÑ Î™®ÏûÑ Î∞è Ïù¥Î≤§Ìä∏ Ï∞∏Í≥† ÏûêÎ£å ¬† Ìà¨ÏûêÏûê Ï†ïÎ≥¥ Îâ¥Ïä§Î£∏ ÌååÌä∏ÎÑà ÌîÑÎ°úÍ∑∏Îû® Ïó∞ÎùΩ Ï†ïÎ≥¥ logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon ÎùºÏù¥Î∏å Îç∞Î™® ÏöîÏ≤≠ÌïòÍ∏∞ ÏïÑÎûò¬†ÏñëÏãùÏùÑ¬†ÏÇ¨Ïö©Ìï¥¬†ÏßÄÍ∏à¬†ÎßûÏ∂§Ìòï¬†ÎùºÏù¥Î∏å¬†Îç∞Î™®Î•º¬†ÏöîÏ≤≠ÌïòÏã≠ÏãúÏò§. Í∏∞ÏóÖÏ†ïÎ≥¥ Ï±ÑÏö© Î∞è Î¨∏Ìôî ÌååÌä∏ÎÑà ÌîÑÎ°úÍ∑∏Îû® Ìà¨ÏûêÏûê Ï†ïÎ≥¥ NewRelic.org Í≥µÍ∏âÏóÖÏ≤¥ Ìè¨ÌÑ∏ Í≥†Í∞ùÎ¨∏Ïùò Ïó∞ÎùΩ Ï†ïÎ≥¥ Îç∞Î™® Ïã†Ï≤≠ÌïòÍ∏∞ Ïù¥Î≤§Ìä∏ Ìï¥Ïô∏ ÏÇ¨Ïù¥Ìä∏ Deutsch English Fran√ßais Êó•Êú¨Ë™û ÏÑúÎπÑÏä§ Ïù¥Ïö©ÏïΩÍ¥Ä DMCA Ï†ïÏ±Ö Í∞úÏù∏Ï†ïÎ≥¥ Ï≤òÎ¶¨Î∞©Ïπ® Ïø†ÌÇ§ Ï†ïÏ±Ö 2015ÎÖÑ ÏòÅÍµ≠ ÎÖ∏Ïòà Î∞©ÏßÄÎ≤ï ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 14.969709,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Request <em>Demo</em>"
      },
      "id": "5fdc3078196a679498213956"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/request-demo",
      "sections": [
        "Request a live demo.",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-02-25T01:50:08Z",
      "title": "Request a New Relic Demo | New Relic",
      "updated_at": "2021-01-04T13:42:55Z",
      "type": "",
      "external_id": "3106a7a9ae5e77d7d4c56815b91f8933a4faeb1f",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Request a live demo. Use the form below to request your personalized live demo. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 11.987905,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Request a New Relic <em>Demo</em> | New Relic",
        "sections": "Request a live <em>demo</em>.",
        "body": " Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects"
      },
      "id": "5786ed3ce621f423f2e9cf78"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/resources/webinars/apac-live-demo-optimizing-CX?video=past-webinar",
      "sections": [
        "Learn why over 16,000 companies use the New Relic One Observability Platform daily to:",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-02-22T16:22:23Z",
      "title": "On-Demand Demo: Optimising the Customer Experience with New Relic One",
      "updated_at": "2021-01-01T04:37:32Z",
      "type": "storefront",
      "external_id": "57f7b338dbf4898ff26209e8eddb8704a22589e1",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Video On-Demand Demo: Optimising the Customer Experience with New Relic One 61:56 ¬† Interested in learning more about New Relic One before you decide to sign up? Watch this demo of New Relic One led by a member of our Solutions Engineering team to see a detailed tour of the observability platform. Learn why over 16,000 companies use the New Relic One Observability Platform daily to: Measure real-user experience - See and understand the intricacies of who‚Äôs using your site, and identify ways to improve their experience. Catch problems before customers - Simulate real user flows across every digital touchpoint‚Äîstarting in development, through QA, and all the way into production. Cultivate deeper customer relationships - Gain real-time insight into what your users are experiencing and how they‚Äôre engaging with your content. Request a Demo COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 10.213428,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "On-Demand <em>Demo</em>: Optimising the Customer Experience with New Relic One",
        "body": " Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic <em>Explore</em> open source projects"
      },
      "id": "5ed2fe0728ccbc929bc135d3"
    }
  ],
  "/collect-data/collect-data-from-any-source": [
    {
      "category_2": "Ingest APIs",
      "nodeid": 35471,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Convert data to metrics",
        "Ingest APIs",
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs",
        "For more help"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "ae5c9ba870768ae1c06f28b22b30d4343fdb6f7c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-manage-data/ingest-apis/telemetry-sdks-report-custom-telemetry-data",
      "published_at": "2021-02-22T23:39:13Z",
      "updated_at": "2021-01-17T13:08:56Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Ingest APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Report custom telemetry data with New Relic's open-source Telemetry SDKs.",
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. To use our Telemetry SDKs and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Requirements and compatibility To build with the Telemetry SDKs, you will need an Insights insert key. New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 176.025,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "sections": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "info": "Report custom <em>telemetry</em> data with New Relic&#x27;s open-source <em>Telemetry</em> <em>SDKs</em>.",
        "category_0": "<em>Telemetry</em> Data Platform",
        "category_2": "Ingest <em>APIs</em>",
        "body": "Our <em>Telemetry</em> SDKs are an open source set of <em>API</em> client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the <em>Metric</em> <em>API</em>, <em>Trace</em> <em>API</em>, Log <em>API</em>, and <em>Event</em> <em>API</em>. We offer open-source integrations for <em>telemetry</em> tools like Prometheus, Istio",
        "breadcrumb": "Contents &#x2F; <em>Telemetry</em> Data Platform &#x2F; Ingest and manage data &#x2F; Ingest APIs"
      },
      "id": "5fef080a196a676559213932"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13806,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Insights API",
        "Report custom event data",
        "Value from custom events and attributes",
        "Avoid rate limits",
        "Send custom events and attributes",
        "Extend data retention",
        "For more help"
      ],
      "title": "Report custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "external_id": "b8f2a56874703ddc38bfade9c15171f34560e9bd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-custom-event-data",
      "published_at": "2021-02-23T03:20:46Z",
      "updated_at": "2021-02-08T05:20:31Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the options for sending custom event data to New Relic. ",
      "body": "As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. New Relic products report a variety of default event data to your account. This document explains how to report your own custom events and attributes. Value from custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. By reporting custom events, you can create more useful and customized queries and charts of your data. This is a key part of optimizing how New Relic works for you. Avoid rate limits Reporting a large number of custom events and/or attributes can cause degraded query performance. It may also result in approaching or passing data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser monitoring agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure monitoring agent Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile monitoring agent Use the mobile agent API to send custom events and attributes. Synthetic monitoring Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn how to extend how long events are retained in your account, see our documentation about event data retention. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.53482,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report custom <em>event</em> data",
        "sections": "<em>Event</em> data sources",
        "info": "An overview of the options for sending custom <em>event</em> data to New Relic. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "Custom <em>events</em>",
        "body": " data, see: <em>Metric</em> <em>API</em> Logs <em>Trace</em> <em>API</em> Extend data retention To learn how to extend how long events are retained in your account, see our documentation about <em>event</em> data retention. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; Custom events"
      },
      "id": "6020ca1f196a67b3a6da2da7"
    },
    {
      "category_2": "General usage licenses",
      "nodeid": 30376,
      "sections": [
        "License information",
        "General usage licenses",
        "Special services licenses",
        "Usage plans",
        "Distributed licenses",
        "Referenced policies",
        "Product definitions",
        "FAQ",
        "New Relic data usage limits and policies",
        "Overview of limits",
        "View limits and manage data",
        "Account-level limits",
        "Data ingest APIs",
        "Other agent and integration limits",
        "Manage data",
        "For more help"
      ],
      "title": "New Relic data usage limits and policies",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "License information",
      "external_id": "d15664737d54ade26760112ccd22bcabbd38086f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/license-information/general-usage-licenses/new-relic-data-usage-limits-policies",
      "published_at": "2021-02-22T20:40:10Z",
      "updated_at": "2021-02-16T02:47:52Z",
      "breadcrumb": "Contents / Licenses / License information / General usage licenses",
      "document_type": "page",
      "popularity": 1,
      "info": "A list of general account-level New Relic data ingest and storage limits, with links to other data limits docs. ",
      "body": "This document lists some important account-level limits and links to other limit-related docs. Overview of limits We strive to keep our resources operating efficiently so that our services are available to all our users. To prevent data usage spikes in one New Relic account from impacting other customers' accounts, we have various data volume and rate limits in place. We reserve the right to enforce these limits to protect our system and to avoid issues for you and other customers. If your New Relic account, whether by configuration or by error, exceeds one of these limits, it or its sub-accounts might experience one or both of the following: Sampling of data Temporary pause or cessation of data collection To learn more about how hitting a limit can affect your data, see View limits. If you have further questions about these limits, your contract, or a limit you've reached, contact your New Relic account representative. We can work with you to adjust any rate limits to meet your needs. View limits and manage data Want to understand your account‚Äôs limit violations using the UI? See View limits. Want to manage your data for organization or billing purposes? See Manage data. Account-level limits The following table includes general max limits that apply across all New Relic accounts. Specific New Relic tools, like agents and integrations, have their own limits and configurations, and might be lower than these theoretical maximum limits. Limited condition Limit Rate of NRDB record* ingest 55 million per account per minute Max NRDB records* ingested per API call 1MB (10^6 bytes) Max attribute value size 1KB (10^3 bytes) Max payload size 1MB (10^6 bytes) Max total attributes per data type (including default attributes) 254 (less for some tools; for example, 64 for agents) Number of unique custom data types 250 per account per day (applies to custom events because that's source of new data types) APM limits Agent instances: 50K per account Agent instances per app: 10K APM apps/services: 10K per second Browser: number of page views 1M per minute per app Rate of metric timeslice data (used by APM, browser, mobile) Ingest: 2 million per minute Rate of names: 4 million per minute per account Number per monitored app: 300K Mobile monitoring: number of crashes reported 10K per hour Infrastructure agents, integrations Number of infrastructure agents and/or integrations: 5K per account Gross number of new monitored containers: 5K per hour per account Query limits NRDB records* inspected: 100 billion per account per hour Rate of queries: 20 per account per second See other query limits * NRDB records refers to database records for our core data types, which includes events, metrics (dimensional), logs, and distributed tracing (span) data, all stored in the New Relic database (NRDB). This does not include metric timeslice data. Data ingest APIs Our ingest APIs have additional limits that may override the more general account-level limits. Note that these limits also apply to our tools that use these APIs (like our Telemetry SDKs or our open source telemetry integrations). Metric API (dimensional metrics) Event API Log API Trace API Other agent and integration limits To find limits for our other agents and integrations, which will override more general account-level limits, see the docs for those tools: you can search our solutions here. Some default reporting limits are located in these tools' configuration docs. Manage data Want to manage your New Relic data ingest and storage to improve data organization or reduce billing? See Manage data. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.28782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Data ingest <em>APIs</em>",
        "body": " also apply to our tools that use these APIs (like our <em>Telemetry</em> SDKs or our open source <em>telemetry</em> integrations). <em>Metric</em> <em>API</em> (dimensional metrics) <em>Event</em> <em>API</em> Log <em>API</em> <em>Trace</em> <em>API</em> Other <em>agent</em> and integration limits To find limits for our other agents and integrations, which will override more general"
      },
      "id": "5d5982fce7b9d2b1e2b126fa"
    },
    {
      "category_2": "OpenTelemetry",
      "nodeid": 41826,
      "sections": [
        "Open source telemetry integrations",
        "Get started",
        "OpenTelemetry",
        "Dropwizard",
        "Istio",
        "Kamon",
        "Micrometer",
        "OpenCensus",
        "Prometheus",
        "OpenTelemetry: Advanced configuration",
        "Change endpoints",
        "EU region",
        "Infinite Tracing",
        "For more help"
      ],
      "title": "OpenTelemetry: Advanced configuration",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Open source telemetry integrations",
      "external_id": "131cfb404af65784f59d6764fe88a9619af68360",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-advanced-configuration",
      "published_at": "2021-02-23T06:50:53Z",
      "updated_at": "2021-01-31T13:35:43Z",
      "breadcrumb": "Contents / Integrations / Open source telemetry integrations / OpenTelemetry",
      "document_type": "page",
      "popularity": 1,
      "body": "In some cases, you may need to change the default settings related to OpenTelemetry. Here are some advanced configurations that are available. Change endpoints You can change the New Relic endpoints where you send your data. By default, New Relic OpenTelemetry exporters send data to these US data centers: Spans: https://trace-api.newrelic.com/trace/v1 Metrics: https://metric-api.newrelic.com/metric/v1 You may need to override these default endpoints to send data to the EU region or to use Infinite Tracing. EU region To send telemetry data to New Relic‚Äôs endpoints in the EU region, use the following: These URLs don't apply to Infinite Tracing Spans: https://trace-api.eu.newrelic.com/trace/v1 Metrics: https://metric-api.eu.newrelic.com/trace/v1 Infinite Tracing If you are setting up Infinite Tracing, you need to override the default span endpoint and send telemetry data to the New Relic trace observer: Follow the steps in Set up the trace observer to get the value for YOUR_TRACE_OBSERVER_URL. Use the value of YOUR_TRACE_OBSERVER_URL to configure your integration. Since you want New Relic to analyze all your traces, make sure to verify that your OpenTelemetry integrations use the AlwaysOn sampler. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.10884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Open source <em>telemetry</em> integrations",
        "category_1": "Open source <em>telemetry</em> integrations",
        "body": " centers: Spans: https:&#x2F;&#x2F;<em>trace</em>-<em>api</em>.newrelic.com&#x2F;<em>trace</em>&#x2F;v1 Metrics: https:&#x2F;&#x2F;<em>metric</em>-<em>api</em>.newrelic.com&#x2F;<em>metric</em>&#x2F;v1 You may need to override these default endpoints to send data to the EU region or to use Infinite Tracing. EU region To send <em>telemetry</em> data to New Relic‚Äôs endpoints in the EU region, use",
        "breadcrumb": "Contents &#x2F; Integrations &#x2F; Open source <em>telemetry</em> integrations &#x2F; Open<em>Telemetry</em>"
      },
      "id": "6016b22f196a679f2313474c"
    },
    {
      "category_2": "Get started",
      "nodeid": 36051,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Convert data to metrics",
        "Ingest APIs",
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Agent APIs",
        "Telemetry SDKs",
        "APIs for sending metrics, traces, logs, and events",
        "New Relic One applications",
        "For more help"
      ],
      "title": "Get data into New Relic",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "7a413b4d7e5bd81088a08507ae4bad64c7e24b2d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-data-new-relic/getting-started/introduction-new-relic-data-ingest-apis-sdks",
      "published_at": "2021-02-22T23:57:13Z",
      "updated_at": "2020-08-10T23:16:39Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to how to get data into New Relic. ",
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our Telemetry Data Platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. To browse all New Relic-built tools and solutions, see New Relic integrations. Agent APIs Some of our monitoring solutions come with APIs and/or SDKs that allow you to customize the data reported and how it reports. For more information, see the relevant product: APM agent APIs Browser API Mobile API Infrastructure monitoring: the Flex integration tool Telemetry SDKs If our more curated solutions don't work for you, our open source Telemetry SDKs let you build your own solution. These SDKs are language wrappers for our data-ingest APIs (below) that let you send telemetry data to New Relic without requiring install of an agent. APIs for sending metrics, traces, logs, and events If our more curated solutions don't work for you, we also have data-ingest APIs: Trace API Event API Metric API Log API To learn about the differences between these data types, see Data types. New Relic One applications You can build entirely custom applications that reside in New Relic One and make use of any data you want. You can use existing open source New Relic One apps, or share your own with the open source community. For details, see New Relic One applications. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.00446,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>APIs</em> for sending <em>metrics</em>, <em>traces</em>, logs, and <em>events</em>",
        "category_0": "<em>Telemetry</em> Data Platform",
        "body": " also have data-ingest APIs: <em>Trace</em> <em>API</em> <em>Event</em> <em>API</em> <em>Metric</em> <em>API</em> Log <em>API</em> To learn about the differences between these data types, see Data types. New Relic One applications You can build entirely custom applications that reside in New Relic One and make use of any data you want. You can use existing open",
        "breadcrumb": "Contents &#x2F; <em>Telemetry</em> Data Platform &#x2F; Ingest and manage data &#x2F; Get started"
      },
      "id": "5f24aa60196a67ede394f5f3"
    }
  ],
  "/build-apps/howto-use-nrone-table-components": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/sparkline-table-row-cell/",
      "sections": [
        "SparklineTableRowCell",
        "Usage",
        "Examples",
        "Example 1",
        "Example 2",
        "Props",
        "shape",
        "Methods",
        "SparklineTableRowCell.render",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:58:11Z",
      "title": "SparklineTableRowCell",
      "updated_at": "2021-02-25T01:58:11Z",
      "type": "developer",
      "external_id": "8a9151a59bd3d13851ec9b97e44f7ff073946e60",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a table row cell showing a sparkline. Sparklines can either come from a NRQL query (thus providing accountId and query), or from a predefined data passed in the chart format. In either case, all props are 1:1 compatible with the <NrqlQuery> format type CHART. A common case to render one row per NRQL facet, is to perform the query outside of the table, then pass the result as items (returned data from a <NrqlQuery> is an array, that can be directly used as the input items of a table). Once rendering the sparkline, you need to re-wrap the data in an array, in order to build, from a series, a new entire set of data. Usage import { SparklineTableRowCell } from 'nr1' Copy Examples Example 1 1 function render() { 2 const items = [ 3 { 4 accountId: 1, 5 query: 6 \"SELECT count(*) FROM Transaction WHERE entityGuid = '‚Ä¶' TIMESERIES\", 7 }, 8 ]; 9 10 return ( 11 <Table> 12 <TableHeader> 13 <TableHeaderCell>Sparkline</TableHeaderCell> 14 </TableHeader> 15 16 {({ item }) => ( 17 <TableRow> 18 <SparklineTableRowCell 19 accountId={item.accountId} 20 query={item.query} 21 /> 22 </TableRow> 23 )} 24 </Table> 25 ); 26 } Copy Example 2 1 <NrqlQuery 2 accountId={1} 3 query=\"SELECT count(*) FROM Transaction FACET entityGuid TIMESERIES UNTIL 5 MINUTES AGO\" 4 > 5 {({ loading, error, data }) => { 6 if (loading || error) { 7 return null; 8 } 9 10 return ( 11 <Table items={data}> 12 <TableHeader> 13 <TableHeaderCell>Entity GUID</TableHeaderCell> 14 <TableHeaderCell>Transactions</TableHeaderCell> 15 </TableHeader> 16 17 {({ item }) => ( 18 <TableRow> 19 <TableRowCell>{item.metadata.name}</TableRowCell> 20 <SparklineTableRowCell data={[item]} /> 21 </TableRow> 22 )} 23 </Table> 24 ); 25 }} 26 </NrqlQuery>; Copy Props accountIdnumber Sets the account ID to perform the query. classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. dataobject[] Data is an array of objects where each object represents a series to be drawn. Each series comprises visualization metadata and an array of data points. Example 1 1 const data = [ 2 { 3 metadata: { 4 id: 'series-1', 5 name: 'Serie 1', 6 color: '#a35ebf', 7 viz: 'main', 8 units_data: { 9 x: 'TIMESTAMP', 10 y: 'BYTES', 11 }, 12 }, 13 data: [ 14 { 15 x: 1614196913178, 16 y: 21400, 17 }, 18 { 19 x: 1614200513178, 20 y: 12200, 21 }, 22 { 23 x: 1614204113178, 24 y: 9300, 25 }, 26 { 27 x: 1614207713178, 28 y: 14500, 29 }, 30 { 31 x: 1614211313178, 32 y: 27500, 33 }, 34 { 35 x: 1614214913178, 36 y: 24700, 37 }, 38 ], 39 }, 40 { 41 metadata: { 42 id: 'series-2', 43 name: 'Serie 2', 44 color: '#85c956', 45 viz: 'main', 46 units_data: { 47 x: 'TIMESTAMP', 48 y: 'BYTES', 49 }, 50 }, 51 data: [ 52 { 53 x: 1614196913178, 54 y: 8800, 55 }, 56 { 57 x: 1614200513178, 58 y: 1400, 59 }, 60 { 61 x: 1614204113178, 62 y: 4600, 63 }, 64 { 65 x: 1614207713178, 66 y: 5200, 67 }, 68 { 69 x: 1614211313178, 70 y: 14100, 71 }, 72 { 73 x: 1614214913178, 74 y: 19300, 75 }, 76 ], 77 }, 78 { 79 metadata: { 80 id: 'events', 81 name: 'Events', 82 color: 'red', 83 viz: 'event', 84 }, 85 data: [ 86 { 87 x0: 1614200513178, 88 x1: 1614204113178, 89 }, 90 { 91 x0: 1614211313178, 92 x1: 1614211313178, 93 }, 94 ], 95 }, 96 ]; Copy onClickfunction Callback fired any time the user clicks on the table cell. function ( event : Event ) => undefined querystring NRQL query used for fetching data. The query is performed against the provided accountId. styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id. Used to target the component in unit and e2e testing. toshape|string Location object or url string to link to. shape pathnamerequiredstring searchstring hashstring Methods SparklineTableRowCell.render function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1864.1375,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " &lt;<em>TableHeaderCell</em>&gt;Sparkline&lt;&#x2F;<em>TableHeaderCell</em>&gt; 14 &lt;&#x2F;<em>TableHeader</em>&gt; 15 16 {({ item }) =&gt; ( 17 &lt;<em>TableRow</em>&gt; 18 &lt;Sparkline<em>TableRowCell</em> 19 accountId={item.accountId} 20 query={item.query} 21 &#x2F;&gt; 22 &lt;&#x2F;<em>TableRow</em>&gt; 23 )} 24 &lt;&#x2F;<em>Table</em>&gt; 25 ); 26 } Copy Example 2 1 &lt;NrqlQuery 2 accountId={1} 3 query=&quot;SELECT count"
      },
      "id": "5efa9906196a67b8837663fa"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/user-table-row-cell/",
      "sections": [
        "UserTableRowCell",
        "Usage",
        "Examples",
        "Example 1",
        "Props",
        "shape",
        "Methods",
        "UserTableRowCell.render",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:52:59Z",
      "title": "UserTableRowCell",
      "updated_at": "2021-01-29T01:59:32Z",
      "type": "developer",
      "external_id": "765e8c8ba01ca8ae96c8e45e2223941812e17294",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a row table cell showing a particular user. This cell takes the user object as its children, which is in turn compatible with the NerdGraph user object (needing, at the very least, the name and gravatar fields). Usage import { UserTableRowCell } from 'nr1' Copy Examples Example 1 function render() { const items = [ { name: 'John Doe', gravatar: 'https://secure.gravatar.com/avatar/79988df068cb4d952284a3395412dc4f', }, ]; return ( <Table items={items}> <TableHeader> <TableHeaderCell>User</TableHeaderCell> </TableHeader> {({ item }) => ( <TableRow> <UserTableRowCell value={item} /> </TableRow> )} </Table> ); } 1 function render() { 2 const items = [ 3 { 4 name: 'John Doe', 5 gravatar: 6 'https://secure.gravatar.com/avatar/79988df068cb4d952284a3395412dc4f', 7 }, 8 ]; 9 10 return ( 11 <Table items={items}> 12 <TableHeader> 13 <TableHeaderCell>User</TableHeaderCell> 14 </TableHeader> 15 16 {({ item }) => ( 17 <TableRow> 18 <UserTableRowCell value={item} /> 19 </TableRow> 20 )} 21 </Table> 22 ); 23 } Copy Props classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. onClickfunction Callback fired any time the user clicks on the table cell. function ( event : Event ) => undefined styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id. Used to target the component in unit and e2e testing. toshape|string Location object or url string to link to. shape pathnamerequiredstring searchstring hashstring valuerequiredshape User object, that requires (at least), the name and gravatar fields. This object matches with the user structure obtained from NerdGraph. shape namerequiredstring gravatarrequiredstring Methods UserTableRowCell.render function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 979.109,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " render() { const items = [ { name: &#x27;John Doe&#x27;, gravatar: &#x27;https:&#x2F;&#x2F;secure.gravatar.com&#x2F;avatar&#x2F;79988df068cb4d952284a3395412dc4f&#x27;, }, ]; return ( &lt;<em>Table</em> items={items}&gt; &lt;<em>TableHeader</em>&gt; &lt;<em>TableHeaderCell</em>&gt;User&lt;&#x2F;<em>TableHeaderCell</em>&gt; &lt;&#x2F;<em>TableHeader</em>&gt; {({ item }) =&gt; ( &lt;<em>TableRow</em>&gt; &lt;User<em>TableRowCell</em> value={item"
      },
      "id": "5efa98d464441f3b815f7e72"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/entity-title-table-row-cell/",
      "sections": [
        "EntityTitleTableRowCell",
        "Usage",
        "Examples",
        "Example 1",
        "Props",
        "shape",
        "Methods",
        "EntityTitleTableRowCell.render",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:51:50Z",
      "title": "EntityTitleTableRowCell",
      "updated_at": "2021-01-29T01:56:48Z",
      "type": "developer",
      "external_id": "624657ff4b10659dfcb70e034f47ec8d28609706",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a row table cell showing the title of a particular entity. This cell takes the entity object as its children, which is in turn compatible with the NerdGraph entity object (needing, at the very least, the name and reporting fields). If alertable, you should also query for alertSeverity. Usage import { EntityTitleTableRowCell } from 'nr1' Copy Examples Example 1 function render() { const items = [ { name: 'Login service', alertSeverity: 'CRITICAL', reporting: true, }, ]; return ( <Table items={items}> <TableHeader> <TableHeaderCell>User</TableHeaderCell> </TableHeader> {({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> </TableRow> )} </Table> ); } 1 function render() { 2 const items = [ 3 { 4 name: 'Login service', 5 alertSeverity: 'CRITICAL', 6 reporting: true, 7 }, 8 ]; 9 10 return ( 11 <Table items={items}> 12 <TableHeader> 13 <TableHeaderCell>User</TableHeaderCell> 14 </TableHeader> 15 16 {({ item }) => ( 17 <TableRow> 18 <EntityTitleTableRowCell value={item} /> 19 </TableRow> 20 )} 21 </Table> 22 ); 23 } Copy Props classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. onClickfunction Callback fired any time the user clicks on the cell. function ( event : Event ) => undefined styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id. Used to target the component in unit and e2e testing. toshape|string Location object or url string to link to. shape pathnamerequiredstring searchstring hashstring valuerequiredshape Entity object, that requires (at least), the name and reporting fields. This object matches with the user structure obtained from NerdGraph. shape namerequiredstring alertSeveritystring reportingrequiredboolean Methods EntityTitleTableRowCell.render function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 978.7871,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "&lt;&#x2F;<em>TableHeaderCell</em>&gt; 14 &lt;&#x2F;<em>TableHeader</em>&gt; 15 16 {({ item }) =&gt; ( 17 &lt;<em>TableRow</em>&gt; 18 &lt;EntityTitle<em>TableRowCell</em> value={item} &#x2F;&gt; 19 &lt;&#x2F;<em>TableRow</em>&gt; 20 )} 21 &lt;&#x2F;<em>Table</em>&gt; 22 ); 23 } Copy Props classNamestring Appends class names to the <em>component</em>. Should be used only for positioning and spacing purposes. onClickfunction Callback"
      },
      "id": "5efa98d4196a67923f766450"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/table/",
      "sections": [
        "Table",
        "Usage",
        "Examples",
        "Basic",
        "Sorting",
        "Query with Table",
        "Props",
        "Methods",
        "Table.render",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:50:10Z",
      "title": "Table",
      "updated_at": "2021-01-29T01:59:31Z",
      "type": "developer",
      "external_id": "878b3ab08dbd0a7df42558a970648013adde957f",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a table with a fixed header and rows. The table implements the following features: Flexible layout: table headers accept a variety of sizes to enable fluid and fixed layouts. You can find more information on how to customize your columns checking TableHeaderCell. Sorting: items passed can be internally sorted by the table according to the current sorting state of the table. You can find more information about sorting by checking TableHeaderCell. Row selection: rows can be selected through checkboxes on the right hand side. You can find more information in the selected prop. Row actions: contextual actions can be triggered per row, enabling users to achieve functionality over them. You can find more information on how to add them in TableRow. Custom pre-defined cells: some very common patterns for cells (entity title, metrics, etc.) are already provided by the platform, so that you only need to return it as part of your row. Virtualization: cells are only rendered if they are shown on screen. This enables the table to work with a large dataset with almost no performance penalty. Usage import { Table } from 'nr1' Copy Examples Basic class Example extends React.Component { _getActions() { return [ { label: 'Action 1', disabled: true, onClick: (evt, { item, index }) => { alert(`Action 1:\\nItem: ${index}\\n${JSON.stringify(item, null, 2)}`); }, }, { label: 'Action 2', onClick: (evt, { item, index }) => { alert(`Action 2:\\nItem: ${index}\\n${JSON.stringify(item, null, 2)}`); }, }, ]; } _getItems() { return [ { name: 'Melton Garcia', gender: 'Male', company: 'Comtest', phone: '+1 (867) 477-3284', selected: true, }, { name: 'Finley Mendez', gender: 'Male', company: 'Anarco', phone: '+1 (817) 438-3205', selected: false, }, { name: 'Coleen Salinas', gender: 'Female', company: 'Macronaut', phone: '+1 (962) 419-3856', selected: true, }, ]; } render() { return ( <Table items={this._getItems()} selected={({ item }) => item.selected} onSelect={(evt, { item }) => (item.selected = evt.target.checked)} > <TableHeader> <TableHeaderCell value={({ item }) => item.name} width=\"50%\"> Name </TableHeaderCell> <TableHeaderCell value={({ item }) => item.gender}> Gender </TableHeaderCell> <TableHeaderCell value={({ item }) => item.company}> Company </TableHeaderCell> <TableHeaderCell value={({ item }) => item.phone} width=\"fit-content\" alignmentType={TableRowCell.ALIGNMENT_TYPE.RIGHT} > Phone </TableHeaderCell> </TableHeader> {({ item }) => ( <TableRow actions={this._getActions()}> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.gender}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.phone}</TableRowCell> </TableRow> )} </Table> ); } } 1 class Example extends React.Component { 2 _getActions() { 3 return [ 4 { 5 label: 'Action 1', 6 disabled: true, 7 onClick: (evt, { item, index }) => { 8 alert(`Action 1:\\nItem: ${index}\\n${JSON.stringify(item, null, 2)}`); 9 }, 10 }, 11 { 12 label: 'Action 2', 13 onClick: (evt, { item, index }) => { 14 alert(`Action 2:\\nItem: ${index}\\n${JSON.stringify(item, null, 2)}`); 15 }, 16 }, 17 ]; 18 } 19 20 _getItems() { 21 return [ 22 { 23 name: 'Melton Garcia', 24 gender: 'Male', 25 company: 'Comtest', 26 phone: '+1 (867) 477-3284', 27 selected: true, 28 }, 29 { 30 name: 'Finley Mendez', 31 gender: 'Male', 32 company: 'Anarco', 33 phone: '+1 (817) 438-3205', 34 selected: false, 35 }, 36 { 37 name: 'Coleen Salinas', 38 gender: 'Female', 39 company: 'Macronaut', 40 phone: '+1 (962) 419-3856', 41 selected: true, 42 }, 43 ]; 44 } 45 46 render() { 47 return ( 48 <Table 49 items={this._getItems()} 50 selected={({ item }) => item.selected} 51 onSelect={(evt, { item }) => (item.selected = evt.target.checked)} 52 > 53 <TableHeader> 54 <TableHeaderCell value={({ item }) => item.name} width=\"50%\"> 55 Name 56 </TableHeaderCell> 57 <TableHeaderCell value={({ item }) => item.gender}> 58 Gender 59 </TableHeaderCell> 60 <TableHeaderCell value={({ item }) => item.company}> 61 Company 62 </TableHeaderCell> 63 <TableHeaderCell 64 value={({ item }) => item.phone} 65 width=\"fit-content\" 66 alignmentType={TableRowCell.ALIGNMENT_TYPE.RIGHT} 67 > 68 Phone 69 </TableHeaderCell> 70 </TableHeader> 71 72 {({ item }) => ( 73 <TableRow actions={this._getActions()}> 74 <TableRowCell>{item.name}</TableRowCell> 75 <TableRowCell>{item.gender}</TableRowCell> 76 <TableRowCell>{item.company}</TableRowCell> 77 <TableRowCell>{item.phone}</TableRowCell> 78 </TableRow> 79 )} 80 </Table> 81 ); 82 } 83 } Copy Sorting class Example extends React.Component { constructor() { super(...arguments); this.state = { column_0: TableHeaderCell.SORTING_TYPE.ASCENDING, }; } _getItems() { return [ { name: 'Melton Garcia', gender: 'Male', company: 'Comtest', phone: '+1 (867) 477-3284', selected: true, }, { name: 'Finley Mendez', gender: 'Male', company: 'Anarco', phone: '+1 (817) 438-3205', selected: false, }, { name: 'Coleen Salinas', gender: 'Female', company: 'Macronaut', phone: '+1 (962) 419-3856', selected: true, }, ]; } _onClickTableHeaderCell(key, event, sortingData) { this.setState({ [key]: sortingData.nextSortingType }); } render() { return ( <Table items={this._getItems()} selected={({ item }) => item.selected} onSelect={(evt, { item }) => (item.selected = evt.target.checked)} > <TableHeader> <TableHeaderCell value={({ item }) => item.name} sortable sortingType={this.state.column_0} sortingOrder={1} onClick={this._onClickTableHeaderCell.bind(this, 'column_0')} > Name </TableHeaderCell> <TableHeaderCell value={({ item }) => item.gender} sortable sortingType={this.state.column_1} sortingOrder={0} onClick={this._onClickTableHeaderCell.bind(this, 'column_1')} > Gender </TableHeaderCell> <TableHeaderCell value={({ item }) => item.company} sortable sortingType={this.state.column_2} sortingOrder={2} onClick={this._onClickTableHeaderCell.bind(this, 'column_2')} > Company </TableHeaderCell> <TableHeaderCell value={({ item }) => item.phone}> Phone </TableHeaderCell> </TableHeader> {({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.gender}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.phone}</TableRowCell> </TableRow> )} </Table> ); } } 1 class Example extends React.Component { 2 constructor() { 3 super(...arguments); 4 5 this.state = { 6 column_0: TableHeaderCell.SORTING_TYPE.ASCENDING, 7 }; 8 } 9 10 _getItems() { 11 return [ 12 { 13 name: 'Melton Garcia', 14 gender: 'Male', 15 company: 'Comtest', 16 phone: '+1 (867) 477-3284', 17 selected: true, 18 }, 19 { 20 name: 'Finley Mendez', 21 gender: 'Male', 22 company: 'Anarco', 23 phone: '+1 (817) 438-3205', 24 selected: false, 25 }, 26 { 27 name: 'Coleen Salinas', 28 gender: 'Female', 29 company: 'Macronaut', 30 phone: '+1 (962) 419-3856', 31 selected: true, 32 }, 33 ]; 34 } 35 36 _onClickTableHeaderCell(key, event, sortingData) { 37 this.setState({ [key]: sortingData.nextSortingType }); 38 } 39 40 render() { 41 return ( 42 <Table 43 items={this._getItems()} 44 selected={({ item }) => item.selected} 45 onSelect={(evt, { item }) => (item.selected = evt.target.checked)} 46 > 47 <TableHeader> 48 <TableHeaderCell 49 value={({ item }) => item.name} 50 sortable 51 sortingType={this.state.column_0} 52 sortingOrder={1} 53 onClick={this._onClickTableHeaderCell.bind(this, 'column_0')} 54 > 55 Name 56 </TableHeaderCell> 57 <TableHeaderCell 58 value={({ item }) => item.gender} 59 sortable 60 sortingType={this.state.column_1} 61 sortingOrder={0} 62 onClick={this._onClickTableHeaderCell.bind(this, 'column_1')} 63 > 64 Gender 65 </TableHeaderCell> 66 <TableHeaderCell 67 value={({ item }) => item.company} 68 sortable 69 sortingType={this.state.column_2} 70 sortingOrder={2} 71 onClick={this._onClickTableHeaderCell.bind(this, 'column_2')} 72 > 73 Company 74 </TableHeaderCell> 75 <TableHeaderCell value={({ item }) => item.phone}> 76 Phone 77 </TableHeaderCell> 78 </TableHeader> 79 80 {({ item }) => ( 81 <TableRow> 82 <TableRowCell>{item.name}</TableRowCell> 83 <TableRowCell>{item.gender}</TableRowCell> 84 <TableRowCell>{item.company}</TableRowCell> 85 <TableRowCell>{item.phone}</TableRowCell> 86 </TableRow> 87 )} 88 </Table> 89 ); 90 } 91 } Copy Query with Table 1 <EntitiesByDomainTypeQuery entityDomain=\"APM\" entityType=\"APPLICATION\"> 2 {({ error, data, fetchMore }) => { 3 if (!data.entities.length && error) { 4 return 'Error!'; 5 } 6 return ( 7 <Table items={data.entities} rowCount={data.count} onLoadMore={fetchMore}> 8 <TableHeader> 9 <TableHeaderCell value={({ item }) => item.name}> 10 name 11 </TableHeaderCell> 12 <TableHeaderCell value={({ item }) => item.id}> 13 entityGuid 14 </TableHeaderCell> 15 <TableHeaderCell value={({ item }) => item.accountId}> 16 accountId 17 </TableHeaderCell> 18 </TableHeader> 19 {({ item }) => ( 20 <TableRow> 21 <EntityTitleTableRowCell value={item} /> 22 <TableRowCell>{item.guid}</TableRowCell> 23 <TableRowCell>{item.accountId}</TableRowCell> 24 </TableRow> 25 )} 26 </Table> 27 ); 28 }} 29 </EntitiesByDomainTypeQuery>; Copy Props children(node|function)[] Contents of the table. Table can only contain as children <TableHeader> and a function returning <TableRow>s. function () => undefined classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. compactboolean DEFAULT false Establishes whether the table should render in compact mode (compact mode has narrower rows). In general, use the standard mode, since compact is reserved for data representation, e.g. in a dashboard. itemsany[] DEFAULT [] The items to be used when rendering. They are required when rendering items with a render callback. Each item can have any structure and type possible, and will the corresponding one will be provided when rendering each element list. mainColumnnumber DEFAULT 0 Column containing the main data identifying the row. Often the first column (index 0) is the relevant one, but actions (like favorites) could be placed before it. onLoadMorefunction Callback fired when more items must be loaded. This happens when you're lazy loading the items and the items that are about to render cannot be found in the items array. This callback should be used to fetch/load the missing items from the backend or other sources. The returned Promise should be resolved once item data has finished loading. It will be used to determine when to refresh the list with the newly-loaded data. This callback may be called multiple times in reaction to a single scroll event. function ( cursor : {Object // Items to load. ) => undefined onSelectfunction Function called when the user clicks over a row checkbox. It is called with the event of the checkbox, as well as with an object containing the item representing the row, its index in the items array passed to the table, and the items themselves. When the user selects or unselects the header checkbox (select / unselect all), the callback will be called once for every item, representing individual clicks over each row. The header checkbox state is automatically controlled by the table. function () => undefined rowCountnumber Number of rows. By default it's equal to length of array passed in the items prop. You should specify the rowCount when you know the total number of items but you want to lazy load them while scrolling. selectedfunction Function that returns whether a row is selected. It needs to return a boolean representing the state of the row. It is called with an object containing the item representing the row, its index in the items array passed to the table, and the items themselves. function ( args : {Object ) => undefined spacingTypeenum[] Spacing property. Spacing is defined as a tuple of zero to four values, which follow the same conventions as CSS properties like margin or padding. To omit a value, use SPACING_TYPE.OMIT. <Array of <One of Table.SPACING_TYPE.EXTRA_LARGE , Table.SPACING_TYPE.LARGE , Table.SPACING_TYPE.MEDIUM , Table.SPACING_TYPE.NONE , Table.SPACING_TYPE.OMIT , Table.SPACING_TYPE.SMALL , > > styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id. Used to target the component in unit and e2e testing. Methods Table.render function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 966.97437,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Table</em>",
        "sections": "<em>Table</em>",
        "body": "={<em>TableRowCell</em>.ALIGNMENT_TYPE.RIGHT} &gt; Phone &lt;&#x2F;<em>TableHeaderCell</em>&gt; &lt;&#x2F;<em>TableHeader</em>&gt; {({ item }) =&gt; ( &lt;<em>TableRow</em> actions={this._getActions()}&gt; &lt;<em>TableRowCell</em>&gt;{item.name}&lt;&#x2F;<em>TableRowCell</em>&gt; &lt;<em>TableRowCell</em>&gt;{item.gender}&lt;&#x2F;<em>TableRowCell</em>&gt; &lt;<em>TableRowCell</em>&gt;{item.company}&lt;&#x2F;<em>TableRowCell</em>&gt; &lt;<em>TableRowCell</em>&gt;{item.phone}&lt;&#x2F;<em>TableRowCell</em>&gt; &lt;&#x2F;<em>TableRow</em>&gt; )} &lt;&#x2F;<em>Table</em>"
      },
      "id": "5efa98d428ccbcebbd307dfb"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/metric-table-row-cell/",
      "sections": [
        "MetricTableRowCell",
        "Usage",
        "Examples",
        "Example 1",
        "Props",
        "shape",
        "Methods",
        "MetricTableRowCell.render",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:54:21Z",
      "title": "MetricTableRowCell",
      "updated_at": "2021-01-29T01:58:05Z",
      "type": "developer",
      "external_id": "b3f3bb23254c69af9c2c0f5350018bae35f5506c",
      "document_type": "page",
      "popularity": 1,
      "body": "Renders a row table cell showing a particular metric. The metric is formatted according to the unit passed. Units are 1:1 compatible with the ones supported by <NrqlQuery> format type CHART. Unit and prefix formatting is automatically picked for you so that it is consistent with the rest of the platform. Metrics are automatically aligned to the left, and ellipsified from the right, which is the standard way for presenting them. Usage import { MetricTableRowCell } from 'nr1' Copy Examples Example 1 function render() { const items = [ { value: 123456789, }, ]; return ( <Table items={items}> <TableHeader> <TableHeaderCell>User</TableHeaderCell> </TableHeader> {({ item }) => ( <TableRow> <MetricTableRowCell type={MetricTableRowCell.TYPE.BITS} value={item.value} /> </TableRow> )} </Table> ); } 1 function render() { 2 const items = [ 3 { 4 value: 123456789, 5 }, 6 ]; 7 8 return ( 9 <Table items={items}> 10 <TableHeader> 11 <TableHeaderCell>User</TableHeaderCell> 12 </TableHeader> 13 14 {({ item }) => ( 15 <TableRow> 16 <MetricTableRowCell 17 type={MetricTableRowCell.TYPE.BITS} 18 value={item.value} 19 /> 20 </TableRow> 21 )} 22 </Table> 23 ); 24 } Copy Props classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. onClickfunction Callback fired any time the user clicks on the table cell. function ( event : Event ) => undefined styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id. Used to target the component in unit and e2e testing. toshape|string Location object or url string to link to. shape pathnamerequiredstring searchstring hashstring typeenum DEFAULT MetricTableRowCell . TYPE . UNKNOWN Unit of the provided metric. Will be used for auto-formatting the numerical value. <One of MetricTableRowCell.TYPE.APDEX , MetricTableRowCell.TYPE.BITS , MetricTableRowCell.TYPE.BITS_PER_MS , MetricTableRowCell.TYPE.BITS_PER_SECOND , MetricTableRowCell.TYPE.BYTES , MetricTableRowCell.TYPE.BYTES_PER_MS , MetricTableRowCell.TYPE.BYTES_PER_SECOND , MetricTableRowCell.TYPE.COUNT , MetricTableRowCell.TYPE.HERTZ , MetricTableRowCell.TYPE.MS , MetricTableRowCell.TYPE.PAGES_PER_SECOND , MetricTableRowCell.TYPE.PERCENTAGE , MetricTableRowCell.TYPE.REQUESTS_PER_SECOND , MetricTableRowCell.TYPE.SECONDS , MetricTableRowCell.TYPE.TIMESTAMP , MetricTableRowCell.TYPE.UNKNOWN , > valuerequirednumber Metric value, always in the shape of a number. Methods MetricTableRowCell.render function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 947.0139,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "}&gt; &lt;<em>TableHeader</em>&gt; &lt;<em>TableHeaderCell</em>&gt;User&lt;&#x2F;<em>TableHeaderCell</em>&gt; &lt;&#x2F;<em>TableHeader</em>&gt; {({ item }) =&gt; ( &lt;<em>TableRow</em>&gt; &lt;Metric<em>TableRowCell</em> type={Metric<em>TableRowCell</em>.TYPE.BITS} value={item.value} &#x2F;&gt; &lt;&#x2F;<em>TableRow</em>&gt; )} &lt;&#x2F;<em>Table</em>&gt; ); } 1 function render() { 2 const items = [ 3 { 4 value: 123456789, 5 }, 6 ]; 7 8 return ( 9 &lt;<em>Table</em>"
      },
      "id": "5efa98d5e7b9d2c0397bab3c"
    }
  ],
  "/build-apps/build-hello-world-app": [
    {
      "sections": [
        "Charts",
        "Query New Relic data",
        "Craft custom data",
        "Metadata",
        "Data",
        "Tip",
        "Special States",
        "Configure your chart",
        "Chart Groups",
        "Next Step",
        "This site uses cookies üç™"
      ],
      "title": "Charts",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure"
      ],
      "external_id": "67f2919065eb0e710d863bdbd106db85463cc788",
      "image": "",
      "url": "https://developer.newrelic.com/components/charts/",
      "published_at": "2021-02-25T01:59:20Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "How to use charts in your NR1 app.",
      "body": "In your application, you can display data in charts, like those used elsewhere in New Relic's user interface. The New Relic One SDK provides React components for different chart types. Once you decide the kind of data you want to present, either from New Relic or some other source, you supply that data to your chart, using props. Query New Relic data In some cases, you want to fetch data from New Relic's database. For example, you may want to display a line chart which plots the number of transactions your application receives over time. With your chart component, set the accountId and query props to query your New Relic data using NRQL: <LineChart accountId={1234} query=\"SELECT count(*) FROM Transaction\" />; Copy Alternatively, you can fetch data with a NrqlQuery and set the data prop: <NrqlQuery accountId={1234} query=\"SELECT count(*) FROM Transaction\"> {({ data }) => <LineChart data={data} />} </NrqlQuery>; Copy If you're looking to visualize New Relic data, such as your web application's response times or your server's throughput, querying data in your charts is the way to go. But what if you want to create charts that aren't focused on New Relic data? The data prop is flexible enough that you can supply any arbitrary data, as long as it matches the standardized format. Craft custom data Whether you use custom data sets or the results of a NrqlQuery, a chart's data prop must be an array of objects where each object has both of the following fields: metadata: Defines how the chart presents its data data: An array of data points that appear on the chart For example, create a chart consisting of a line between two points by supplying two x-y coordinates in its data field: const data = [ { metadata: { id: 'series-1', name: 'My series', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0, }, { x: 20, y: 10, }, ], }, ]; <LineChart data={data} />; Copy This LineChart plots a line between coordinates (0, 0) and (20, 10). Use x-y coordinates for all two-dimensional chart formats. For other formats, which you'll learn more about later, use other types of data points. Because data accepts an array, you can supply two series to the same chart: const data = [ { metadata: { id: 'series-1', name: 'My series', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0, }, { x: 20, y: 10, }, ], }, { metadata: { id: 'series-2', name: 'My second series', viz: 'main', color: 'red', }, data: [ { x: 0, y: 50, }, { x: 20, y: 100, }, ], }, ]; <LineChart data={data} />; Copy In this example, you create a single chart with two series. The first series contains the line from the last example. The second series contains a line between points (0, 50) and (20, 100). When using two series in a single chart, like this, you may want to define how the chart represents each series. Use metadata to define those elements. Metadata A series's metadata defines certain features of the series, itself, such as how it should be displayed in your chart. metadata consists of the following attributes: Attribute Description id The series's identifier. Two series having the same id are considered the same series, regardless of where they are located. In general, use a unique id for each series. However, if you use the same series for multiple charts, keeping the id consistent can help with some cross-chart functionality, like simultaneously highlighting multiple charts. name The series's name. name is used in legends, tooltips, and other areas to indicate which series you‚Äôre looking at. color The series's color. Most visualizations use this value to differentiate series. Some visualizations, like BillboardChart or JsonChart, ignore it. Use any valid CSS color representation, such as #RRGGBB, hsl(HHH, SS%, LL%), or rgba(RR, GG, BB, .AA). Avoid tweaking the alpha value, when possible, because charts use alpha to highlight or dim certain series. viz The series's visual style. While you most often use main, this field accepts several options: main: Show the series based on chart's type. For instance, a LineChart shows the series as a line, and an AreaChart shows the series as an area. line: Show the series as a line, regardless of the chart's type. This setting applies only to AreaChart and ScatterChart. Other chart types will not show the series. area: Show the series as an area, regardless of the chart's type. This setting applies only to LineChart and ScatterChart. Other chart types will not show the series. event: Show the series as an event, regardless of the chart's type. Charts represent an event as a vertical area behind the main visualization. Events are often used to show alerts. This setting applies only to AreaChart, LineChart, and ScatterChart. Other chart types will not show the series. target-line: Show the series as a vertical line. This setting applies only to AreaChart, LineChart, and ScatterChart. Other chart types will not show the series. units_data You can assign a unit type to each axis on a chart. The chart will present data according to the unit type you set with units_data. To set unit_data, pass a JSON object with maps the axis to one of the following unit types: UNKNOWN: The chart displays the series with no special units. COUNT: Each value in the chart represents a count. The chart formats values with their International System prefix. For example, \"k\" represents thousands, \"M\" represents millions, and \"G\" represents billions. PERCENTAGE: Each value in the chart represents a percentage. Typically, you provide values ranging from 0 to 1. The chart formats a value of 1 as \"100%\", a value of 2 as \"200%\", and a value of 0.01 as \"1%\". MS: Each value in the chart represents some number of milliseconds. The chart represents values higher than 1 as a human-readable time duration. For example, 60000 is represented as \"1 minute\". The chart represents values lower than 1 using SI prefixes. For example, 0.001 is represented as 1 Œºs. TIMESTAMP: Each value in the chart represents a timestamp, the number milliseconds since midnight UTC on January 1, 1970, the UNIX Epoch. The chart formats each value as a date. BITS: Each value in the chart represents some number of bits. The chart formats these values using \"b\". When upscaling, the chart will display decimal prefixes instead of binary ones. For example, the chart displays 1000 as \"1 kb\". BITS_PER_SECOND: Each value in the chart represents some number of bits per second. The chart formats these values using \"b/s\". When upscaling, the chart will display decimal prefixes instead of binary ones. For example, the chart displays 1000 as \"1 kb/s\". BYTES: Each value in the chart represents some number of bytes. The chart formats these values using \"B\". For example, the chart displays 1000 as \"1 kB\". BYTES_PER_SECOND: Each value in the chart represents some number of bytes per second. The chart formats these values using \"B/s\". For example, the chart displays 1000 as \"1 kB/s\". So, to represent the y-axis for your series in bits, set the y-value in units_data: { \"units_data\": { \"y\": \"BITS\" } } Data While a data series can contain any arbitrary values, a chart only uses values which adhere to its type. So, create your data points according to the chart type: Series Type Example Description Unidimensional [{ \"y\": 10 }, { \"y\": 20 }] The chart plots data points using y values. Use this format with BarChart, BillboardChart, PieChart, StackedBarChart. Two-dimensional [ { \"x\": 10, \"y\": 20 }, { \"x\": 20, \"y\": 30 } ] The chart plots data points using x and y values. Use this format with AreaChart, LineChart, ScatterChart, SparklineChart, Funnel [{ \"label1\": 10, \"label2\": 20 }] The chart plots data according to labels. Use this format with FunnelChart. Table [{ \"jobType\": \"SIMPLE\", \"count\": 18 }] The chart plots data according to table columns. You must specify table columns in the metadata. Use this format with TableChart. Event [ { \"x0\": 0, \"x1\": 5 }, { \"x0\": 10, \"x1\": 15 } ] The chart plots the event's width based on x0 and x1 values. Histogram [ { \"x0\": 10, \"x1\": 20, \"y\": 100 }, { \"x0\": 30, \"x1\": 40, \"y\": 150 } ] The chart plots the series's width based on x0 and x1 and height based on y. Use this format with HistogramChart and HeatmapChart. Tip JsonChart is a special case because it processes any valid data. For example, you can set an arbitrary JSON object for the chart's data: const data = { data: [ { id: 1, name: 'Foo', price: 123, tags: ['Bar', 'Eek'], stock: { warehouse: 300, retail: 20, } } ], } <JsonChart data={data} /> Copy Special States In previous sections, you learned that a chart's data is an array of series. But you can use special values to present special chart states: null or undefined: Indicates the chart is ‚Äúloading‚Äù its data. In this state, the chart shows a placeholder data set. []: Indicates there is no data to show. The chart states, \"No chart data available\". Configure your chart As you've seen, you use query or data to supply data to your chart, but you can configure other aspects of your chart, too, such as visual settings and click and hover event listeners. Read the documentation for the chart you're using for more specific information. Chart Groups Under some circumstances, you might want to synchronize events, such as dragging or scrubbing, across multiple charts. To do this, use a ChartGroup. All charts in a ChartGroup synchronize their events: <ChartGroup> <Stack> <StackItem> <LineChart accountId={1} query=\"SELECT count(*) FROM Transaction SINCE 1 hour ago\" /> </StackItem> <StackItem> <AreaChart accountId={1} query=\"SELECT count(*) FROM Synthetics SINCE 1 day ago\" /> </StackItem> </Stack> </ChartGroup>; Copy Ideally, group charts that are conceptually related, and separate charts that are conceptually unrelated. Next Step Read the documentation specific to the chart you'd like to use to learn specifics about that chart's behavior and configuration.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.51674,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "How to use charts in your <em>NR1</em> app.",
        "tags": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "body": "In your application, you can display data in charts, like those used elsewhere in New Relic&#x27;s user interface. The New Relic <em>One</em> SDK provides React components for different chart types. Once you decide the kind of data you want to present, either from New Relic or some other source, you supply"
      },
      "id": "5fdab9f1e7b9d2e1e8df9221"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs",
        "This site uses cookies üç™"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.03488,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to New Relic <em>One</em> SDK",
        "sections": "Intro to New Relic <em>One</em> SDK",
        "info": "Intro to New Relic <em>One</em> SDK",
        "tags": "New Relic <em>One</em> apps",
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "category_2": "Measure DevOps success",
      "nodeid": 34966,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs",
        "For more help"
      ],
      "title": "Automate instrumentation",
      "category_0": "Solutions and best practices",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "91b25e8572d235c7f95963650848fc6ab6cf4b39",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation",
      "published_at": "2021-02-22T23:15:36Z",
      "updated_at": "2020-12-01T22:24:21Z",
      "breadcrumb": "Contents / Solutions and best practices / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "Capture tangible, measurable metrics from before and after deployments to optimize your DevOps team. ",
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors‚Äîand more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.12654,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ", the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic <em>applications</em>. 3. Leverage the power of APIs Now"
      },
      "id": "5f5e0c14196a67e25fce6a8a"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:54:22Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.94463,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>One</em> <em>CLI</em> common commands",
        "sections": "New Relic <em>One</em> <em>CLI</em> common commands",
        "info": "An overview of common commands you can use with the New Relic <em>One</em> <em>CLI</em>.",
        "body": " The name of a particular channel. Examples $ <em>nr1</em> update $ <em>nr1</em> update somechannel <em>nr1</em> create Create a new component Creates a new component from our template (either a <em>Nerdpack</em>, Nerdlet, launcher, or <em>catalog</em>). The <em>CLI</em> will walk you through this process. To learn more about Nerdpacks and their <em>file</em> <em>structure</em>"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure",
        "This site uses cookies üç™"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ launchers ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json ‚îú‚îÄ‚îÄ nerdlets ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss ‚îú‚îÄ‚îÄ node_modules ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler ‚îú‚îÄ‚îÄ nr1.json ‚îú‚îÄ‚îÄ package-lock.json ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.36464,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "sections": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "info": "An overview of the <em>Nerdpack</em> <em>File</em> <em>Structure</em>",
        "tags": "<em>file</em> <em>structure</em>",
        "body": " building guides and the New Relic <em>One</em> <em>CLI</em> command reference. <em>Nerdpack</em> <em>file</em> <em>structure</em> When you generate a <em>Nerdpack</em> template using the <em>nr1</em> create command, it has the following <em>file</em> <em>structure</em>: my-nerdlet ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ launchers ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ <em>nr1</em>.json"
      },
      "id": "5efa989e196a671300766404"
    }
  ],
  "/explore-docs/nr1-cli": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage",
        "This site uses cookies üç™"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2021-02-25T01:51:50Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 85.32666,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use NerdStorage in your <em>apps</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users&#x27; configuration settings"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "Intro to NerdStorageVault",
        "Using NerdStorageVault in your apps",
        "Tip",
        "Usage considerations",
        "Component library",
        "NerdGraph queries",
        "Write",
        "Delete",
        "Fetch a single secret",
        "Fetch a list of secrets",
        "Limits",
        "Permissions for working with NerdStorageVault",
        "This site uses cookies üç™"
      ],
      "title": "Intro to NerdStorageVault",
      "type": "developer",
      "tags": [
        "nerdstoragevault",
        "nerdstoragevault components",
        "new relic one apps",
        "data access",
        "encrypted storage"
      ],
      "external_id": "8355de4bf337963434c4d3b90f5d9c32f58e4bcc",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstoragevault/",
      "published_at": "2021-02-25T01:53:00Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorageVault on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data such as: personal access tokens license keys API keys other third party secrets Tip NerdStorageVault is encrypted with AES-256 encryption Usage considerations This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorageVault can currently only be used within the context of a Nerdpack. You cannot make a direct query or mutation to NerdStorageVault. You can explore the fields and response types via the NerdGraph API explorer. The only supported scope is ACTOR, or data that relates to a particular user. Component library Currently NerdStorageVault is available in the alpha release of Nr1 Community component library and is not available in the Nr1 core components library. Open source components can be use to augment Nr1 core components for additional functionality. NerdGraph queries Below are examples of the queries used by the components to interact with NerdStorageVault. Tip NerdStorageVault can currently only be used within the context of a Nerdpack. Write mutation { nerdStorageVaultWriteSecret( scope: { actor: CURRENT_USER } secret: { key: \"test\", value: \"secret_test\" } ) { status errors { message type } } } Copy Delete mutation { nerdStorageVaultDeleteSecret( scope: { actor: CURRENT_USER } key: \"test_key\" ) { status errors { message type } } } Copy Fetch a single secret query { actor { nerdStorageVault { secret(key: \"test_key\") { key value } } } } Copy Fetch a list of secrets query { actor { nerdStorageVault { secrets { key value } } } } Copy Limits A maximum of 10 secrets can be stored per ACTOR. A secret value is limited to 5000 characters. A key value is limited to 64 characters. Permissions for working with NerdStorageVault In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 66.40584,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Using NerdStorageVault in your <em>apps</em>",
        "info": "Intro to NerdStorageVault on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you‚Äôll learn how to use NerdStorageVault to store data in an encrypted storage solution. Using NerdStorageVault in your apps NerdStorageVault is used to store and retrieve sensitive secrets data"
      },
      "id": "5f865b55196a675792bd5340"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs",
        "This site uses cookies üç™"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 66.40584,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "sections": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "info": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>",
        "body": "To help you build <em>New</em> <em>Relic</em> <em>One</em> applications, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch <em>New</em> <em>Relic</em> or third-party data"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Permissions for managing applications",
        "Publish and deploy apps",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Build apps",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Permissions for managing applications ¬† Learn about permissions for subscribing to apps Publish and deploy apps 30 min Start sharing the apps you build Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 58.970863,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Build <em>apps</em>",
        "body": " from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next. Add a time picker to your <em>app</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com",
        "This site uses cookies üç™"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2021-02-25T01:58:10Z",
      "updated_at": "2020-12-04T02:00:00Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 51.92291,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Prepare to build or modify <em>apps</em>",
        "info": "Prepare to build <em>apps</em> and contribute to this site",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> CLI",
        "body": "If you&#x27;ve decided to build a custom <em>app</em> or modify <em>one</em> of our open source apps, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> <em>command</em> line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your <em>app</em>, you might have some additional setup"
      },
      "id": "5efa9973e7b9d242237bab39"
    }
  ],
  "/explore-docs/nr1-subscription": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-02-25T01:55:33Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.39,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": "To build a¬†<em>New</em> <em>Relic</em> <em>One</em> app, you must install the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (<em>command</em> line interface). This page explains how to use¬†<em>CLI</em> <em>commands</em>¬†to: Generate"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies üç™"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2021-02-10T01:54:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash Copy --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic decode - Use the decode url command to print out information encrypted within the URL newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.3994,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs in GitHub. Options bash Copy"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "category_2": "Usage plans",
      "nodeid": 39506,
      "sections": [
        "License information",
        "General usage licenses",
        "Special services licenses",
        "Usage plans",
        "Distributed licenses",
        "Referenced policies",
        "Product definitions",
        "FAQ",
        "New Relic One Usage plan descriptions",
        "For more help"
      ],
      "title": "New Relic One Usage plan descriptions",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "License information",
      "external_id": "5b6d89972b6dda98648dfa0de43835d0cdf8d8ba",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/license-information/usage-plans/new-relic-one-usage-plan-descriptions",
      "published_at": "2021-02-23T06:44:49Z",
      "updated_at": "2021-02-23T06:44:49Z",
      "breadcrumb": "Contents / Licenses / License information / Usage plans",
      "document_type": "page",
      "popularity": 1,
      "info": "Explanation of New Relic One pricing usage plans: pay-as-you-go and annual pool of funds. ",
      "body": "The Usage Plan applies to (i) your Pay As You Go subscription, or (ii) your Commitment Term for the Annual Pool of Funds subscription. New Relic may modify the Usage Plan from time to time. Any changes to the Usage Plan will become effective immediately for changes that provide a benefit or right to the Customer, all other changes will become effective if Customer assents or upon any new or renewal Commitment Term. Usage Plan - Effective as February 19, 2021: The Order and Usage Plan may contain defined terms that are denoted by capitalization. In the event that a capitalized term is not defined in either the Order or the Usage Plan, such terms shall have the meaning set forth in the New Relic One pricing definitions page. Pay As You Go By electing and subscribing to the Pay As You Go subscription model (‚ÄúPay As You Go‚Äù or ‚ÄúPAYG‚Äù), Customer commits to paying for the New Relic Products on a month-to-month consumption basis. Monthly Product Usage will be invoiced regardless if a PO is required or not. Any Customer dispute to Monthly Product Usage from the prior month must be in good-faith and received by New Relic in writing within three (3) business days of the start of the next month or such dispute notice will be considered invalid. The dispute notice will set forth in reasonable detail the information concerning the disputed charges. The parties will use good-faith efforts to promptly resolve any disputed charges. Customer‚Äôs usage of the Products in excess of the Free Tier each month shall be billed in arrears on the first business day of the following month based on the Customer‚Äôs Per Unit usage of each Product each month multiplied by the corresponding rates set forth in an Order and summed (‚ÄúMonthly Product Usage‚Äù). Annual Pool of Funds By electing and subscribing to the Annual Pool of Funds subscription model (‚ÄúAnnual Pool of Funds‚Äù or ‚ÄúAPoF‚Äù) for the Commitment Term, Customer commits in an Order to: (i) paying the Commitment Fee amounts described in the Subscription table and any additional commitment fees set forth; and (ii) the Monthly Discounted Fee Rates applying to Customer‚Äôs Monthly Product Usage. New Relic will invoice the Commitment Fee as per the ‚ÄòBilling Terms‚Äô described in an Order. On a monthly cadence during the Commitment Term, Customer‚Äôs Per Unit usage of the Products will be multiplied by the corresponding Monthly Discounted Rate and summed (‚ÄúMonthly Product Usage‚Äù). Monthly Product Usage will be deducted from the Commitment Fee amounts that are paid in advance. If Monthly Product Usage exceeds any such remaining unconsumed amounts, Customer will be invoiced for the difference (‚ÄúAdditional Usage‚Äù), including for any Monthly Product Usage during the last month of the Commitment Term. Payment of such invoices will be governed as set forth in the Terms. Any Customer dispute to Monthly Product Usage from the prior month must be in good-faith and received by New Relic in writing within three (3) business days of the start of the next month (including for any Monthly Product Usage for the last month of the Commitment Term) or such dispute notice will be considered invalid. The dispute notice will set forth in reasonable detail the information concerning the disputed charges. The parties will use good-faith efforts to promptly resolve any disputed charges. Any unconsumed balances from the Customer payment of each annual Commitment Fee and any additional payments, if applicable, as set out in an Order will expire and lapse at the end of each year of the Commitment Term. Applicable Invoicing and Order Terms All amounts stated in an Order are non-cancelable payment obligations of the Customer for the Commitment Term regardless of usage. Any fees paid are non-refundable and do not represent a deposit for, or a credit towards, the purchase of other products not specified in an Order or for any purchase after the Commitment Term. Customer acknowledges that a final payment for the full outstanding amount of any remaining unpaid Commitment Fee and/or Monthly Product Usage Fee may be invoiced upon each anniversary date of the term start date. Tax will be added where applicable. New Relic may review Customer's use of the Products at any time. If New Relic identifies any Customer usage of the Product(s) that is not in accordance with the Terms or Documentation, New Relic may suspend such unauthorized usage. All existing purchases and related pricing in effect prior to the execution of an Order shall remain in force. Unless otherwise stated in an Order, an Order does not modify or amend any existing purchases. Additional future products or quantities are not subject to promotional pricing unless otherwise stated in an Order. In the event that a Customer indicates in an Order that it requires a purchase order (‚ÄúPO‚Äù) for its subscription, Customer agrees to provide the required PO prior to the provisioning of the Products. If a Customer does not indicate a PO is required, Customer agrees that New Relic may issue invoice(s) and is entitled to such payment without a PO reference. All Additional Usage fees will be invoiced regardless of a PO requirement. The Product(s) are deemed accepted upon its provisioning. User Accounts Use of the Products require Customer users to create Login Credentials. Customer user Login Credential information must be accurate, current, and complete. New Relic‚Äôs use and collection of Login Credentials (in accordance with its General Data Privacy Notice) is for account and product management and support of its customers. Customer and Customer users must abide by the New Relic Acceptable Use Policy (AUP) and Login Credentials may not be shared. Each Customer user must have their own user account. Entry into an Order indicates your agreement that the amount of provisioned users (at the rate specified in the Order) applies in lieu of and supersedes any other amount of users of the Products that may be specified in the agreement between Customer and New Relic. New Relic One Pro and Enterprise Service Level Availability Commitment With a subscription to New Relic Full Stack Observability Pro or Enterprise Products, you agree that during the Commitment Term the applicable service level availability commitment set forth on the ‚ÄòService level availability commitment‚Äô page in the Documentation shall apply to the Products. For clarity, if your agreement with New Relic contains a different service level availability commitment or remedies, the above does not apply to your subscription to the New Relic Full Stack Observability Pro or Enterprise Products. If you subscribe to any other New Relic Products with New Relic One pricing, any service level availability commitment or related remedies contained within your agreement with New Relic are vacated and nullified, and New Relic will use commercially reasonable efforts to make New Relic Full Stack Observability Standard and Telemetry Data Platform available in line with industry standards. New Relic One Pro and Enterprise Support Plans With a subscription to New Relic One Users (Full Stack Observability), New Relic provides an updated support plan commitment. By subscribing to New Relic One Users (Full Stack Observability), you agree that during the Commitment Term the applicable Support Plan set forth on the ‚ÄòSupport plan‚Äô page in the Documentation shall apply in lieu of, and supersedes and replaces, any other support related commitments that may be contained within your agreement with New Relic. For New Relic K.K. customers (Japan), the above does not currently apply to the support offerings provided by New Relic to you. Free tier, ‚Äòlite‚Äô, no-charge, preview access, New Relic One - Data, New Relic One - Standard User subscriptions If you are using New Relic‚Äôs Products in the free tier only, or on a no-charge, or a ‚Äòlite‚Äô or ‚Äòpreview access‚Äô basis you agree that the Unpaid Terms of Service will apply to such Product usage and replace and supersede any other terms. In addition, if your subscription contains the New Relic One - Standard User (Full Stack Observability Standard) Product, you agree that the Paid Terms of Service will apply to your subscription to the Products set forth in an Order and replace and supersede any other terms. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.73729,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> Usage plan descriptions",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> Usage plan descriptions",
        "info": "Explanation of <em>New</em> <em>Relic</em> <em>One</em> pricing usage plans: pay-as-you-go and annual pool of funds. ",
        "body": " is not defined in either the Order or the Usage Plan, such terms shall have the meaning set forth in the <em>New</em> <em>Relic</em> <em>One</em> pricing definitions page. Pay As You Go By electing and subscribing to the Pay As You Go <em>subscription</em> model (‚ÄúPay As You Go‚Äù or ‚ÄúPAYG‚Äù), Customer commits to paying for the <em>New</em> <em>Relic</em> Products"
      },
      "id": "5f2ef32364441f21db56a994"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.708115,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>command</em> followed by the same arguments you used to create them. [ { &quot;Key&quot;: &quot;tag1&quot;, &quot;Values&quot;: [&quot;true&quot;] }, { &quot;Key&quot;: &quot;tag2&quot;, &quot;Values&quot;: [&quot;test&quot;] }, { &quot;Key&quot;: &quot;tag3&quot;, &quot;Values&quot;: [&quot;testing&quot;] } &#x2F;&#x2F; ... ] Copy Next steps Have a look at all the <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>. For example, you could create a <em>New</em> <em>Relic</em>"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:54:22Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.08962,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": "Here&#x27;s a list of common <em>commands</em> to get you started with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1 update Updates to the latest version"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    }
  ],
  "/explore-docs/nr1-nerdpack": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:54:22Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 503.10297,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": " our other <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> docs for <em>commands</em> specific to <em>Nerdpack</em> set-up, <em>Nerdpack</em> subscriptions, <em>CLI</em> configuration, plugins, or catalogs. <em>Command</em> details nr1 help See <em>commands</em> and get details Shows all nr1 <em>commands</em> by default. To get details about a specific <em>command</em>, run nr1 help <em>COMMAND</em>_NAME. Usage"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-02-25T01:55:33Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.0592,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " and publish your application, see¬†our guide on Deploying your <em>New</em> <em>Relic</em> <em>One</em> app. Get started nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1 update Updates to the latest version of the <em>CLI</em>. nr1 create Creates a <em>new</em> component from a template (<em>Nerdpack</em>, Nerdlet, launcher, or catalog). nr1"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies üç™"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2021-02-10T01:54:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash Copy --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic decode - Use the decode url command to print out information encrypted within the URL newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.3994,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs in GitHub. Options bash Copy"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure",
        "This site uses cookies üç™"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ launchers ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json ‚îú‚îÄ‚îÄ nerdlets ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss ‚îú‚îÄ‚îÄ node_modules ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler ‚îú‚îÄ‚îÄ nr1.json ‚îú‚îÄ‚îÄ package-lock.json ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.08556,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> file structure",
        "sections": "<em>Nerdpack</em> file structure",
        "info": "An overview of the <em>Nerdpack</em> File Structure",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " application with a monitored entity For basic component definitions, see our component reference. Generate <em>Nerdpack</em> components There are two ways to generate a <em>Nerdpack</em> template: Generate a <em>Nerdpack</em>: Use the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>command</em> nr1 create and select <em>Nerdpack</em> to create a <em>Nerdpack</em> template that includes"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/2g790g7la1iot/promo-image.1573253956.png",
      "url": "https://learn.newrelic.com/live-learncast-new-relic-one-programmability",
      "sections": [
        "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications.",
        "About this Learncast",
        "Prerequisites",
        "Virtual Training Session List"
      ],
      "published_at": "2021-02-25T01:39:49Z",
      "title": "Live Learncast: New Relic One Programmability",
      "updated_at": "2021-01-02T01:38:56Z",
      "type": "",
      "external_id": "053510b559767dbde34e3f1ee9a73bbf813a5a83",
      "popularity": 1,
      "body": "Sign In Live Learncast: New Relic One Programmability Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. Not currently available Available until July 10, 2020, 3:30 p.m. PDT. Already registered? Sign In About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. ¬† During this session we will review the following topics: ¬† 1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites ¬† This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications. ¬† Must have: ¬† Permissions to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. ¬† During this session we will review the following topics: ¬† 1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites ¬† This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications. ¬† Must have: ¬† Permissions to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) ¬© 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.5423,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Live Learncast: <em>New</em> <em>Relic</em> <em>One</em> Programmability",
        "sections": "Join us for this exclusive 90-minute introduction to the fundamentals of <em>New</em> <em>Relic</em> <em>One</em> Programmability. This training will introduce you to the key concepts and walk you through developing <em>New</em> <em>Relic</em> Applications.",
        "body": " A text editor or IDE of your choice (we will be using VS Code) <em>Nerdpack</em> manager roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the <em>New</em> <em>Relic</em> <em>command</em>-line interface (<em>CLI</em>) on local workstation Setting <em>New</em> <em>Relic</em> API developer access credentials"
      },
      "id": "5dc618cbe7b9d2a0a8e4649c"
    }
  ],
  "/explore-docs/nerdstoragevault": [
    {
      "nodeid": 41516,
      "sections": [
        "Recent Announcements",
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "type": "docs",
      "external_id": "abfc5ea05724ba8d4c31198fa9d7b162d0d969da",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/store-data-encrypted-storage-solution-nerdstoragevault",
      "published_at": "2021-02-23T08:25:05Z",
      "updated_at": "2020-12-09T00:13:59Z",
      "breadcrumb": "Contents / What's New",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 364.73813,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution with <em>NerdStorageVault</em>",
        "sections": "Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution with <em>NerdStorageVault</em>",
        "body": "NerdGraph allows you to <em>access</em> your <em>New</em> <em>Relic</em> <em>data</em>, but when you want to fetch third-party <em>data</em>, <em>NerdStorageVault</em> allows you to safely store a secret to authenticate with a third-party service. <em>NerdStorageVault</em> provides you with a secure and <em>encrypted</em> <em>storage</em> location where you can safely store",
        "breadcrumb": "Contents &#x2F; What&#x27;s <em>New</em>"
      },
      "id": "5fc9989a28ccbc05264a267e"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage",
        "This site uses cookies üç™"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2021-02-25T01:51:50Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Data</em> <em>access</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you‚Äôll learn how to use Nerd<em>Storage</em> SDK <em>components</em>. Use Nerd<em>Storage</em> in your <em>apps</em> Nerd<em>Storage</em> is used to store and retrieve simple sets of <em>data</em>, including users&#x27; configuration settings"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "category_2": "New Relic One user management",
      "nodeid": 39356,
      "sections": [
        "Accounts and billing",
        "Account setup",
        "Account structure",
        "New Relic One pricing and billing",
        "New Relic One user management",
        "General account settings",
        "Automated user management",
        "Partner install",
        "New Relic One user model: Understand the user structure",
        "User type: basic and full",
        "Default user groups: Admin and User",
        "Roles and capabilities",
        "Standard roles",
        "Roles and user groups",
        "Roles and user type",
        "Custom roles and capabilities",
        "Manage users",
        "2020 user model changes",
        "For more help"
      ],
      "title": "New Relic One user model: Understand the user structure ",
      "category_0": "New Relic accounts",
      "type": "docs",
      "category_1": "Accounts and billing",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/accounts/accounts-billing/new-relic-one-user-management/new-relic-one-user-model-understand-user-structure",
      "external_id": "de57f0c45791928ff4ea0a8a8842db5fc93ecbe3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-user-management/new-relic-one-user-model-understand-user-structure",
      "published_at": "2021-02-23T04:44:31Z",
      "updated_at": "2021-02-23T04:44:31Z",
      "breadcrumb": "Contents / New Relic accounts / Accounts and billing / New Relic One user management",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic One user model: an explanation of the structure and options available when creating these users. ",
      "body": "New Relic One user model In mid-2020, New Relic released a newer user model, referred to as the New Relic One user model. Here are the users on this user model: Users on New Relic organizations created on or after July 30 2020. Users on older accounts who were added via automated user management. If you were a New Relic customer before July 30 2020, your users are likely on our original user model. For more on this, see Pricing and user model changes. This doc will explain the structure of the New Relic One user model, including: User type (basic user vs full user) User groups User roles and how they relate to user type and groups For how to add and manage users, see User management. User type: basic and full The user type determines what features a user has access to, and is a key factor in billing. There are two user types: Basic user. Details: These users are free and have access to basic features like setting up reporting of data, running queries of data, making custom charts and dashboards, and setting up alerts. They do not have access to Full-Stack Observability features (for more details, see Capabilities). With the Standard pricing tier, these users can only be assigned to the default User group. No matter what custom group a basic user is assigned to, they always have the capabilities of a basic user: no more and no less. Basic users can upgrade on their own to become full users (with exception of users on original user model). Basic users are prompted to upgrade themselves when they attempt to access a feature available only to full users. Full user. Details: These users are billable and have access to our Full-Stack Observability features, which includes our curated UI experiences, like APM, infrastructure monitoring, browser monitoring, mobile monitoring, and synthetic monitors. For details, see Capabilities. These users can be added to the default Admin group. The Standard pricing tier includes one free full user and up to five total. To change a user's type, use the User management UI. Switching from original pricing to New Relic One pricing? Learn about updating your users. Or learn more about user-related billing calculation. To understand more about basic users and full users: Compare full vs basic capabilities Below is a detailed table showing differences between basic user and full user capabilities. In short, basic users have access to our Telemetry Data Platform and Applied Intelligence (read-only) features, while full users have access to that plus Full-Stack Observability features. Features Full user Basic user Full-Stack Observability (New Relic-built UI experiences) Application performance monitoring (APM) UI fa-check Infrastructure monitoring UI fa-check Digital Experience Monitoring (Browser, Mobile, Synthetics) UI fa-check Serverless monitoring UI fa-check Logs in context with other UI experiences fa-check Synthetics checks fa-check New Relic Edge with Infinite Tracing (tail-based sampling) fa-check (Pro and Enterprise) Subscribe to New Relic One catalog apps fa-check Assorted curated UI experiences (distributed tracing, Kubernetes cluster explorer, workloads, etc.) fa-check Applied Intelligence (AI) Proactive Detection fa-check fa-check (read-only) Incident Intelligence fa-check fa-check (read-only) Telemetry Data Platform Data ingest from any source (Metrics, Events, Logs, Traces) fa-check fa-check Alerts and notifications fa-check fa-check Interactive query interface fa-check fa-check Custom charts and dashboards (not New Relic-built) fa-check fa-check Encryption at rest fa-check fa-check Standard data retention fa-check fa-check NerdGraph (GraphQL) API fa-check fa-check Security and compliance fa-check fa-check Integrations fa-check fa-check Data management fa-check fa-check Logs UI fa-check fa-check Build custom New Relic One apps fa-check fa-check Learn more about how user type (basic vs full) relates to roles and capabilities. Learn more about user-related billing calculations. Tips on choosing user type Reasons to make someone a full user: They play a key role in the development, testing, deployment, and maintenance phases of the application development lifecycle. They break/fix code regularly; they are responsible for triaging workflows, troubleshooting, or managing users and roles for their team. They have DevOps practices (i.e. version control systems and implement CI/CD). They need to use New Relic's curated dashboards and experiences (not just the ability to create their own custom queries and charts); in other words, they need full access to our platform. They need to be able to manage users and/or billing. Reasons to make someone a basic user: They play a key role in the planning phase of the application development lifecycle. They use and configure New Relic agents, APIs, and integrations to send us data, and access, configure, and use alerts on such data (not necessarily responsible for triaging workflows, troubleshooting, or managing users and roles for their team). They want to see high-level analytics and business metrics for future planning (such as C-Suite executives). They do not need to use our curated experiences and dashboards, but would benefit from the ability to create their own custom queries and charts of data; in other words, they don't need full access to the platform. They don't manage users. Are you switching from our original pricing plan to New Relic One pricing? Learn about how to convert your users. Learn more about user-related billing calculations. Understand user-related billing For user-related billing calculation details, see Calculations. For how to query and alert on usage data, see Query usage data. Default user groups: Admin and User This applies to users on our New Relic One user model. For users on our original user model, see Original user docs. A user group allows managing multiple users at the same time. Your New Relic users are assigned to a group and that group is granted access to specific roles and specific accounts. We have two default user groups available for full users: User: Adding someone to this group allows them to use and configure monitoring/analysis features but not perform account-related tasks like managing billing or users. Admin: Adding someone to this group gives them the abilities of the User group and also gives them access to account/organization-related abilities like managing billing-related settings and managing users. To edit a user's group, use the User management UI. See the roles and capabilities these default groups have. Pro and Enterprise tier accounts can create their own custom roles and custom groups. Roles and capabilities This applies to users on our New Relic One user model. For users on our original user model, see Original user docs. Roles are a set of capabilities. A capability is defined as the ability to do a specific New Relic task, like 'Delete alert conditions' (see more examples). We provide some default standard roles (below). Pro and Enterprise tier accounts can also create custom roles. Standard roles Our standard roles are default sets of capabilities that satisfy some commonly needed use cases. These standard roles are assigned to our default Admin and User groups, but you can also assign these roles to a custom group. Most standard roles have capabilities that are unique and that can't be replicated with a custom role. For example, to assign billing management capabilities to a user, you'd need to assign them the Billing user role; you wouldn't be able to assign billing management capability with a custom role. The only standard roles that can be replicated with custom roles are Read only, Standard user, and All product admin (this role is the equivalent of choosing all available capabilities). Standard roles include: Standard roles Scope Description Read only Account Provides read-only access to the New Relic platform (except for synthetic monitor secure credentials). Standard user Account Provides standard access to the platform, including the ability to configure most monitoring tools, but does not include the ability to configure more sensitive settings, including account-level configuration and synthetic monitor secure credentials. All product admin Account Provides admin-level access to the platform. This includes all New Relic capabilities with the exception of managing users (Organization manager and Authentication domain manager) and managing billing-related settings (Billing user). A basic user is defined as having the All product admin role but without access to Full-Stack Observability features. Billing user Account Provides ability to manage subscriptions and billing, and read-only access to the rest of the platform. Organization manager Organization Provides the ability to view configuration for user groups, roles, and access grants for users on the New Relic One user model. For how to grant this role, see Add user management capability. Organization read only Organization Provides the ability to view the configuration of authentication domains and view users in those domains. For how to grant this role, see Add user management capability. Authentication domain manager Organization Provides ability to configure authentication domains for users on the New Relic One user model, and manage those users. For how to grant this role, see Add user management capability. Authentication domain read only Organization Provides the ability to view the configuration of authentication domains and view users in those domains. For how to grant this role, see Add user management capability. Manage v1 users Account For New Relic organizations that existed before July 30 2020 and have users on our original user model, this role lets you manage those \"v1\" users. Roles and user groups There are two default user groups available: User and Admin. These groups have our standard roles applied in these ways: User: this group has only the All product admin standard role, which grants general platform access and some basic admin capabilities. Admin: this group has all the standard roles, giving it complete admin capabilities. Custom groups can be assigned standard roles or custom roles. Roles and user type User type refers to whether a user is a basic user or a full user. A basic user can be defined as having the All product admin standard role but without access to Full-Stack Observability features (learn more). A basic user always has basic user capabilities, no more and no less, regardless of what group they're assigned to. One nonintuitive impact of this is that a group's basic users could have more capabilities than its full users have. For example, if you created a custom group with very minimal capabilities, the full users in that group would have those minimal capabilities, but any basic users in that group would have more capabilities than the full users because the capabilities of a basic user trump group capabilities. A full user's capabilities will depend on its assigned group; it has theoretical access to all roles and capabilities. For more on this, see User type. Custom roles and capabilities For tips on setting up custom roles, see Add custom groups and roles. Manage users To learn how to add users, and create custom groups and roles, see Manage users. 2020 user model changes If you'd like to understand how our user model changed in 2020 and how this affects some functionality, see Impacts of user model changes. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.12332,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> user model: Understand the user structure ",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> pricing and billing",
        "info": "For <em>New</em> <em>Relic</em> <em>One</em> user model: an explanation of the structure and options available when creating these users. ",
        "category_0": "<em>New</em> <em>Relic</em> accounts",
        "category_2": "<em>New</em> <em>Relic</em> <em>One</em> user management",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;accounts&#x2F;accounts-billing&#x2F;<em>new</em>-<em>relic</em>-<em>one</em>-user-management&#x2F;<em>new</em>-<em>relic</em>-<em>one</em>-user-model-understand-user-structure",
        "body": " retention fa-check fa-check NerdGraph (GraphQL) API fa-check fa-check Security and compliance fa-check fa-check Integrations fa-check fa-check <em>Data</em> management fa-check fa-check Logs UI fa-check fa-check Build custom <em>New</em> <em>Relic</em> <em>One</em> <em>apps</em> fa-check fa-check Learn more about how user type (basic vs full",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> accounts &#x2F; Accounts and billing &#x2F; <em>New</em> <em>Relic</em> <em>One</em> user management"
      },
      "id": "5fcfb44ce7b9d24a9ddf926b"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-02-25T01:55:33Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 67.48423,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> CLI reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> CLI reference",
        "info": "An overview of the CLI to help you build, deploy, and manage <em>New</em> <em>Relic</em> <em>apps</em>.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>app</em>",
        "body": "To build a¬†<em>New</em> <em>Relic</em> <em>One</em> <em>app</em>, you must install the <em>New</em> <em>Relic</em> <em>One</em> CLI. The CLI helps you build, publish, and manage your <em>New</em> <em>Relic</em> <em>app</em>. We provide a variety of tools for building <em>apps</em>, including the <em>New</em> <em>Relic</em> <em>One</em> CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com",
        "This site uses cookies üç™"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2021-02-25T01:58:10Z",
      "updated_at": "2020-12-04T02:00:00Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 63.34044,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Prepare to build or modify <em>apps</em>",
        "info": "Prepare to build <em>apps</em> and contribute to this site",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> CLI",
        "body": ", publish it to <em>New</em> <em>Relic</em> <em>One</em>, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create <em>one</em> of our popular open source <em>apps</em>. You learn to add a custom query to an <em>app</em> and view it in a table, then add that <em>data</em> to a map. Contribute"
      },
      "id": "5efa9973e7b9d242237bab39"
    }
  ],
  "/explore-docs/nr1-common": [
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies üç™"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2021-02-10T01:54:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash Copy --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic decode - Use the decode url command to print out information encrypted within the URL newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.97925,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs in GitHub. Options bash Copy"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Automate common tasks",
        "Set up New Relic using the Kubernetes operator",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Automate workflows",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.92462,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": ", and a <em>command</em>-line interface. These tools enable you to integrate <em>New</em> <em>Relic</em> into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and <em>CLI</em> guides below, find more automation solutions in our Developer"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Containerized private minions release notes",
      "nodeid": 42381,
      "sections": [
        "Synthetics private minion release notes",
        "Containerized private minions release notes",
        "Containerized Private Minion (CPM) 3.0.35",
        "Reintroduction of the following:",
        "Improvements",
        "Features"
      ],
      "title": "Containerized Private Minion (CPM) 3.0.35",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "Synthetics private minion release notes",
      "external_id": "497982bdda5d8a9819e644dba7f79137d162a0fe",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/synthetics-release-notes/containerized-private-minions-release-notes/containerized-private-minion-cpm-3035",
      "published_at": "2021-02-23T06:59:53Z",
      "updated_at": "2021-02-23T06:59:53Z",
      "breadcrumb": "Contents / Release notes / Synthetics private minion release notes / Containerized private minions release notes",
      "document_type": "release_notes",
      "popularity": -2,
      "body": "[RSS] Released on:¬† Wednesday, February 10, 2021 - 04:00 Reintroduction of the following: Improvements Prevent blacklisted resources from causing timeouts on Synthetics Checks Prevents long running background requests from failing a monitor if the pageLoadEvent is detected. Common examples include Google Analytics and bam.nr-data.net. Features Added functionality where $browser.waitForAndFindElement() now returns a WebElementPromise, so users can issue commands to the webElement that is returned from the promise. To update to this version, see Install and update CPM versions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.2911,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "[RSS] Released on:¬† Wednesday, February 10, 2021 - 04:00 Reintroduction of the following: Improvements Prevent blacklisted resources from causing timeouts on Synthetics Checks Prevents long running background requests from failing a monitor if the pageLoadEvent is detected. <em>Common</em> examples include"
      },
      "id": "6034a7e9196a6784b06e6749"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-02-25T01:55:33Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.99142,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": "To build a¬†<em>New</em> <em>Relic</em> <em>One</em> app, you must install the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (<em>command</em> line interface). This page explains how to use¬†<em>CLI</em> <em>commands</em>¬†to: Generate"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2021-02-25T01:58:11Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag‚Å† (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.87049,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": "Access the <em>New</em> <em>Relic</em> platform from the comfort of your terminal. You can use the <em>New</em> <em>Relic</em> <em>CLI</em> to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the <em>CLI</em> to automate <em>common</em> tasks in your DevOps workflow. This guide walks you through"
      },
      "id": "5efa999c196a67c4e1766461"
    }
  ],
  "/explore-docs/nr1-plugins": [
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies üç™"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2021-02-10T01:54:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash Copy --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic decode - Use the decode url command to print out information encrypted within the URL newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.97925,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs in GitHub. Options bash Copy"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-02-25T01:55:33Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.14577,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": "To build a¬†<em>New</em> <em>Relic</em> <em>One</em> app, you must install the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (<em>command</em> line interface). This page explains how to use¬†<em>CLI</em> <em>commands</em>¬†to: Generate"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.63985,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>command</em> followed by the same arguments you used to create them. [ { &quot;Key&quot;: &quot;tag1&quot;, &quot;Values&quot;: [&quot;true&quot;] }, { &quot;Key&quot;: &quot;tag2&quot;, &quot;Values&quot;: [&quot;test&quot;] }, { &quot;Key&quot;: &quot;tag3&quot;, &quot;Values&quot;: [&quot;testing&quot;] } &#x2F;&#x2F; ... ] Copy Next steps Have a look at all the <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>. For example, you could create a <em>New</em> <em>Relic</em>"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:54:22Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.46177,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": "Here&#x27;s a list of common <em>commands</em> to get you started with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1 update Updates to the latest version"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Automate common tasks",
        "Set up New Relic using the Kubernetes operator",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Automate workflows",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.993996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": ", and a <em>command</em>-line interface. These tools enable you to integrate <em>New</em> <em>Relic</em> into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and <em>CLI</em> guides below, find more automation solutions in our Developer"
      },
      "id": "5efa999c196a67dfb4766445"
    }
  ],
  "/explore-docs/nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Permissions for managing applications",
        "Publish and deploy apps",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Build apps",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Permissions for managing applications ¬† Learn about permissions for subscribing to apps Publish and deploy apps 30 min Start sharing the apps you build Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 405.24646,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "body": " from your account and add it to a dropdown menu in an application Add, query, and mutate <em>data</em> using <em>NerdStorage</em> 45 min <em>NerdStorage</em> is a document database accessible within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next. Add a time picker to your <em>app</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies üç™"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2021-02-10T01:54:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash Copy --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic decode - Use the decode url command to print out information encrypted within the URL newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.30994,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> CLI Reference",
        "sections": "<em>New</em> <em>Relic</em> CLI Reference",
        "info": "The command line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> cli",
        "body": ", write, and delete <em>NerdStorage</em> documents and collections. newrelic nrql - Commands for interacting with the <em>New</em> <em>Relic</em> Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the <em>New</em> <em>Relic</em> CLI newrelic workload - Interact with <em>New</em> <em>Relic</em> <em>One</em> workloads"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Add, query, and mutate data using NerdStorage",
      "type": "developer",
      "tags": [
        "add data",
        "query data",
        "mutate data",
        "nerdstorage"
      ],
      "external_id": "97cc9637edea35ecd68683f1010f67a5f8c79038",
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/",
      "published_at": "2021-02-25T01:58:11Z",
      "updated_at": "2020-12-04T01:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "info": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next.",
      "body": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: bash Copy $ cd /nr1-how-to/use-nerdstorage Update the UUID and serve the application: bash Copy $ nr1 nerdpack:uuid -gf $ nr1 nerdpack:serve Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application‚Äôs ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application‚Äôs index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application‚Äôs ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you‚Äôve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.17268,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "sections": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "info": "<em>NerdStorage</em> is a document <em>database</em> <em>accessible</em> within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next.",
        "tags": "<em>nerdstorage</em>",
        "body": " on <em>New</em> <em>Relic</em> <em>One</em>. Load the URL. Click <em>Apps</em> and under Your <em>apps</em> you&#x27;ll see the Use <em>Nerdstorage</em> <em>app</em> listed. Click to launch the <em>app</em>. Add <em>data</em> to <em>NerdStorage</em> Once the <em>app</em> is up and running on <em>New</em> <em>Relic</em> <em>One</em>, you can prepare the <em>app</em> and start adding <em>data</em>. On the How To Use <em>NerdStorage</em> <em>app</em> screen, there&#x27;s"
      },
      "id": "5efa98d4e7b9d26d6b7bab74"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs",
        "This site uses cookies üç™"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.31552,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "sections": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "info": "Intro to <em>New</em> <em>Relic</em> <em>One</em> SDK",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>",
        "body": "To help you build <em>New</em> <em>Relic</em> <em>One</em> applications, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. Here we give you an introduction to the types of API calls and <em>components</em> in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch <em>New</em> <em>Relic</em> or third-party <em>data</em>"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/user-storage-mutation/",
      "sections": [
        "UserStorageMutation",
        "Usage",
        "Examples",
        "Write document",
        "Delete document",
        "Delete collection",
        "Props",
        "Methods",
        "UserStorageMutation.render",
        "UserStorageMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:51:51Z",
      "title": "UserStorageMutation",
      "updated_at": "2021-01-29T01:58:05Z",
      "type": "developer",
      "external_id": "1f38ffb2681d23040587f4b46a5db3bffeff7206",
      "document_type": "page",
      "popularity": 1,
      "body": "Save, delete, or update a user scoped document in NerdStorage. Usage import { UserStorageMutation } from 'nr1' Copy Examples Write document 1 UserStorageMutation.mutate({ 2 actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, 3 collection: 'mycollection', 4 documentId: 'mydocumentID', 5 document: { 6 name: 'John', 7 surname: 'Doe', 8 }, 9 }); Copy Delete document 1 UserStorageMutation.mutate({ 2 actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, 3 collection: 'mycollection', 4 documentId: 'mydocumentID', 5 }); Copy Delete collection 1 UserStorageMutation.mutate({ 2 actionType: UserStorageMutation.ACTION_TYPE.DELETE_COLLECTION, 3 collection: 'mycollection', 4 }); Copy Props actionTyperequiredenum Type of action to perform. <One of UserStorageMutation.ACTION_TYPE.DELETE_COLLECTION , UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT , UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT , > childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : {Object // Results of the mutation. ) => undefined collectionstring Name of the collection to mutate. documentobject NerdStorage document. Documents are restricted to 64KB in size. documentIdstring ID of the document to mutate. Methods UserStorageMutation.render function () => undefined UserStorageMutation.mutate Static method to use UserStorageMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any UserStorageMutation prop is a valid option except children. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.6803,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Save, delete, or update a user scoped document in <em>NerdStorage</em>. Usage import { UserStorageMutation } from &#x27;nr1&#x27; Copy Examples Write document 1 UserStorageMutation.mutate({ 2 actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, 3 collection: &#x27;mycollection&#x27;, 4 documentId: &#x27;mydocumentID&#x27;, 5"
      },
      "id": "5efa993c196a67066b766466"
    }
  ],
  "/explore-docs/nr1-config": [
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies üç™"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2021-02-10T01:54:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash Copy --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic decode - Use the decode url command to print out information encrypted within the URL newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 217.55164,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs in GitHub. Options bash Copy"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-02-25T01:55:33Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.10419,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": "To build a¬†<em>New</em> <em>Relic</em> <em>One</em> app, you must install the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (<em>command</em> line interface). This page explains how to use¬†<em>CLI</em> <em>commands</em>¬†to: Generate"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "category_2": "Develop your own integrations",
      "nodeid": 37611,
      "sections": [
        "Instrument everything",
        "Get started",
        "Instrument your code and infrastructure",
        "Instrument core services and applications",
        "Develop your own integrations",
        "New Relic Flex: Build your own integration",
        "What is Flex?",
        "Requirements",
        "How does Flex work?",
        "Learn more",
        "For more help"
      ],
      "title": "New Relic Flex: Build your own integration",
      "category_0": "Full-Stack Observability",
      "type": "docs",
      "category_1": "Instrument everything",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/integrations/host-integrations/host-integrations-list/flex-integration-tool-build-your-own-integration",
      "external_id": "556f280fe732cb42074d5f2c6198afcfb83d50af",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/flex-integration-tool-build-your-own-integration",
      "published_at": "2021-02-22T13:54:01Z",
      "updated_at": "2021-02-22T13:54:01Z",
      "breadcrumb": "Contents / Full-Stack Observability / Instrument everything / Develop your own integrations",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic's Flex integration tool to create a lightweight custom integration that reports event and metric data to New Relic. ",
      "body": "New Relic provides integrations for many popular services and frameworks. If you have New Relic and want to report data from a service we don't have an integration for, there are several ways New Relic lets you create your own integration: With New Relic infrastructure monitoring, you can use our lightweight Flex tool (recommended, documented below) or, to build a complete on-host integration, see our Integrations SDK. Telemetry (metrics, traces) monitoring solutions: Use our Telemetry SDKs. Build a custom New Relic One application that uses your own JavaScript UI functionality. What is Flex? New Relic Flex is an application-agnostic, all-in-one tool that allows you to collect metric data from a wide variety of services. It comes bundled with our infrastructure agent. You can instrument any app that exposes metrics over a standard protocol (HTTP, file, shell) in a standard format (for example, JSON or plain text): you create a YAML config file, start the Infrastructure agent, and your data is reported to New Relic. Flex can send event and metric data to New Relic from a wide range of sources. Using a simple YAML config file, you can run HTTP/HTTPS requests, run shell commands, and parse file content. You can also use standard regex expressions to customize and control the data gathered from those inputs. See an example config. After collecting and cleaning up the data, you can then query Flex data in New Relic, create custom charts for it, and use that data in your dashboards. Requirements Flex comes bundled with our infrastructure agent. To use Flex, you need: Infrastructure agent version 1.10.7 or higher (update | check version) running on Linux, Windows, or Kubernetes. How does Flex work? Flex uses our infrastructure agent to execute commands that generate the data you want to report. Here's a brief overview of how Flex works to report data: You define the data you want to report in a YAML configuration file, located in the infrastructure agent package. See an example configuration: Example config The following is an example of a Flex configuration for monitoring the uptime of a Linux server. This configuration is placed in a file named flex-uptime.yml. This would be placed in the infrastructure agent's integration configuration section, located at /etc/newrelic-infra/integrations.d/flex-uptime.yml. integrations: - name: nri-flex config: name: linuxUptimeIntegration apis: - name: Uptime commands: - run: 'cat /proc/uptime' split: horizontal split_by: \\s+ set_header: [uptimeSeconds,idletimeSeconds] Some notes on what this configuration does: run defines the command to execute. The name indicated by name: Uptime is appended with Sample to generate an event called UptimeSample. The name should not start with the ESX or PCF prefix. The split_by: \\s+ splits the fields based on the space character. The command generates attributes attached to the UptimeSample event. The attributes are named uptimeSeconds and idletimeSeconds. The infrastructure agent runs Flex at a frequency based on its own configuration (default: every 30 seconds) and sends the data to New Relic. You can then query your data, create custom charts with it, and add it to dashboards. Learn more The Flex integration comes bundled with the infrastructure agent. Learn more about requirements. To learn more, see our complete documentation on GitHub: README Tutorial For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.95512,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Flex: Build your own integration",
        "sections": "<em>New</em> <em>Relic</em> Flex: Build your own integration",
        "info": "Use <em>New</em> <em>Relic&#x27;s</em> Flex integration tool to create a lightweight custom integration that reports event and metric data to <em>New</em> <em>Relic</em>. ",
        "body": " (for example, JSON or plain text): you create a YAML <em>config</em> file, start the Infrastructure agent, and your data is reported to <em>New</em> <em>Relic</em>. Flex can send event and metric data to <em>New</em> <em>Relic</em> from a wide range of sources. Using a simple YAML <em>config</em> file, you can run HTTP&#x2F;HTTPS requests, run shell <em>commands</em>"
      },
      "id": "5e61196664441f13bde0091d"
    },
    {
      "category_2": "On-host integrations list",
      "nodeid": 12971,
      "sections": [
        "On-host integrations",
        "Get started",
        "Installation",
        "On-host integrations list",
        "Understand and use data",
        "Troubleshooting",
        "NGINX monitoring integration",
        "Compatibility and requirements",
        "Install and activate the integration",
        "Configure the integration",
        "Activate remote monitoring",
        "Environment variable passthroughs",
        "Find and use data",
        "Metrics",
        "NGINX Open Source",
        "NGINX Plus",
        "Inventory data",
        "System metadata",
        "Check the source code",
        "For more help"
      ],
      "title": "NGINX monitoring integration",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "On-host integrations",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/integrations/host-integrations/host-integrations-list/nginx-monitoring-integration",
      "external_id": "628fa793991f5e9b1642ce012cbc19183f7656cb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/nginx-monitoring-integration",
      "published_at": "2021-02-25T02:00:22Z",
      "updated_at": "2021-02-24T01:41:05Z",
      "breadcrumb": "Contents / Integrations / On-host integrations / On-host integrations list",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic's NGINX monitoring integration: how to install it, configure it, and details about the data it reports. ",
      "body": "Our NGINX integration collects and sends inventory and metrics from your NGINX server to our platform, where you can see data on connections and client requests so that you can find the source of any problems. Read on to install the integration, and to see what data we collect. Compatibility and requirements Our integration is compatible with both NGINX Open Source and NGINX Plus. Before installing the integration, make sure that you meet the following requirements: NGINX extension enabled, as described in the Configure the integration section. If NGINX is not running on Kubernetes or Amazon ECS, you must install the infrastructure agent on a Linux OS host that's running NGINX. Otherwise: If running on Kubernetes, see these requirements. If running on ECS, see these requirements. Install and activate the integration To install the NGINX integration, follow the instructions for your environment: ECS See Monitor service running on ECS. Kubernetes See Monitor service running on Kubernetes. Linux Follow the general instructions for installing an integration, using the filename nri-nginx. Then continue on to the steps below. Change the directory to the integrations configuration folder: cd /etc/newrelic-infra/integrations.d Copy the sample configuration file: sudo cp nginx-config.yml.sample nginx-config.yml Edit the configuration file nginx-config.yml. Restart the infrastructure agent. Windows Download the nri-mysql .MSI installer image from: http://download.newrelic.com/infrastructure_agent/windows/integrations/nri-nginx/nri-nginx-amd64.msi To install from the Windows command prompt, run: msiexec.exe /qn /i PATH\\TO\\nri-nginx-amd64.msi or double-click the file in Explorer. In the Integrations directory, C:\\Program Files\\New Relic\\newrelic-infra\\integrations.d\\, create a copy of the sample configuration file by running: copy nginx-config.yml.sample nginx-config.yml Edit the nginx-config.yml file as described in the configuration settings. Restart the infrastructure agent. Additional notes: Advanced: Integrations are also available in tarball format to allow for install outside of a package manager. On-host integrations do not automatically update. For best results, regularly update the integration package and the infrastructure agent. Configure the integration An integration's YAML-format configuration is where you can place required login credentials and configure how data is collected. Which options you change depend on your setup and preference. To capture data from the NGINX integration, you must first enable and configure the applicable extension module: For NGINX Open Source: HTTP stub status module For NGINX Plus: HTTP status module and HTTP API module There are several ways to configure the integration, depending on how it was installed: If enabled via Kubernetes: see Monitor services running on Kubernetes. If enabled via Amazon ECS: see Monitor services running on ECS. If installed on-host: edit the config in the integration's YAML config file, nginx-config.yml. Config options include: metrics: This command captures the metrics of a particular NGINX server. Arguments: status_url: The URL set up to provide the metrics using the status module. If the default value of 127.0.0.1 is incorrect, substitute the address/FQDN/URL for your system. Example: status_url: http://127.0.0.1/status inventory: This command captures the configuration parameters set in the NGINX config file as inventory data. Arguments: config_path: The path to the NGINX configuration file. status_url: The URL is used to attach inventory data to the same NGINX instance for which we collect metrics. To disable inventory data collection, remove the inventory command. When running in a container, to retrieve inventory data you need to map the local config_path into the container, otherwise the integration terminates. See instructions for Docker on how to map volumes to share files between the host and the container. For Kubernetes, ECS, and potentially other environments where you can have more than one instance running, inventory is complex to configure. We strongly suggest disabling inventory in this case. labels: The env label controls the environment attribute. The default value is production. Activate remote monitoring You can use the remote_monitoring configuration parameter to enable remote monitoring and multi-tenancy for this integration. You must also have infrastructure agent version 1.2.25 or higher to use remote_monitoring. Activating remote_monitoring may change some attributes and/or affect your configured alerts. For more information, see remote monitoring in on-host integrations. Environment variable passthroughs Environment variables can be used to control config settings, such as your license key, and are then passed through to the Infrastructure agent. For instructions on how to use this feature, see Configure the Infrastructure agent. With secrets management, you can configure on-host integrations with New Relic Infrastructure's agent to use sensitive data (such as passwords) without having to write them as plain text into the integration's configuration file. For more information, see Secrets management. STATUS_URL The URL set up to provide the metrics using the status module. Type String Default http://127.0.0.1/status Example: STATUS_URL='http://your.ip.address:8080/status' CONFIG_PATH The path to the NGINX configuration file. Type String Default /etc/nginx/nginx.conf Example: CONFIG_PATH='/etc/nginx/custom/mynginx.conf' For more about the general structure of on-host integration configuration, see Configuration. Find and use data Data from this service is reported to an integration dashboard. Metrics are attached to the NginxSample event type. You can query this data for troubleshooting purposes or to create custom charts and dashboards. For more on how to find and use your data, see Understand integration data. Metrics The NGINX integration collects the following metric data attributes. To find these attributes, query the NginxSample event type. NGINX Open Source Metric Description net.connectionsActive Number of connections that are currently active net.connectionsAcceptedPerSecond Number of accepted client connections per second net.connectionsDroppedPerSecond Number of connections per second that were accepted but could not he handled and hence dropped net.connectionsReading Current number of connections where NGINX is reading the request header net.connectionsWaiting Current number of idle client connections waiting for a request net.connectionsWriting Current number of connections where NGINX is writing the response back to the client net.requestsPerSecond Total number of client requests per second NGINX Plus Our integration retrieves all available metric data from the following HTTP API endpoints: /nginx, /processes, /connections, /http/requests, and /ssl. Metric Description net.connectionsAcceptedPerSecond Accepted client connections as requests per second net.connectionsDroppedPerSecond Dropped client connections as requests per second net.connectionsActive Current number of active client connections net.connectionsIdle Current number of idle client connections net.requests Current number of requests net.requestsPerSecond Current number of requests per second processes.respawned Current number of abnormally terminated and respawned child processes ssl.handshakes Current number for successful SSL handshakes ssl.failedHandshakes Current number of failed SSL handshakes ssl.sessionReuses Current number of session reuses during SSL handshake Inventory data The integration captures configuration options defined in the NGINX master config file (usually nginx.conf). The master NGINX config file can contain \"include OTHER_FILE_NAME\" commands for splitting the configuration into multiple files. The Infrastructure agent ignores (does not parse) configuration set via include commands. System metadata The integration collects these additional attributes about the NGINX service: Name Description software.edition The NGINX edition: either \"open source\" or \"plus\". software.version The version of NGINX. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.23105,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Configure</em> the integration",
        "info": "<em>New</em> <em>Relic&#x27;s</em> NGINX monitoring integration: how to install it, <em>configure</em> it, and details about the data it reports. ",
        "body": "&#x2F;infrastructure_agent&#x2F;windows&#x2F;integrations&#x2F;nri-nginx&#x2F;nri-nginx-amd64.msi To install from the Windows <em>command</em> prompt, run: msiexec.exe &#x2F;qn &#x2F;i PATH\\TO\\nri-nginx-amd64.msi or double-click the file in Explorer. In the Integrations directory, C:\\Program Files\\<em>New</em> <em>Relic</em>\\newrelic-infra\\integrations.d\\, create"
      },
      "id": "5a6251db0711e861fc8ea9a0"
    },
    {
      "category_2": "Diagnostics CLI release notes",
      "nodeid": 42056,
      "sections": [
        "Diagnostics release notes",
        "Diagnostics CLI release notes",
        "Diagnostics CLI 1.12.32",
        "New",
        "Bug fixes",
        "Changes"
      ],
      "title": "Diagnostics CLI 1.12.32",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "Diagnostics release notes",
      "external_id": "61414ac438b464f687dbe7b5d3344b0982798a76",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/diagnostics-release-notes/diagnostics-cli-release-notes/diagnostics-cli-11232",
      "published_at": "2021-02-23T06:24:03Z",
      "updated_at": "2021-02-15T16:11:14Z",
      "breadcrumb": "Contents / Release notes / Diagnostics release notes / Diagnostics CLI release notes",
      "document_type": "release_notes",
      "popularity": -2,
      "body": "[RSS] Released on:¬† Monday, January 11, 2021 - 09:30 Download New Diagnostics CLI will validate the Java agent configuration that has been done through Java System Properties. Infra/Env/NrjmxBeans - Validates that the mbeans that the user wants to query with the New Relic JMX integration are available for the integration to pull from. This task is available for Linux and Windows. Infra/Env/ValidateZookeeperPath - Validates that the setting for zookeeper_path (found in kafka-config.yml) is a valid path for the New Relic Kafka integration. Bug fixes Java/Env/Process - This task validates that the New Relic Java agent jar has been correctly added to the -javavagent argument. However, previously, it would only validate those jars that were explicitly named newrelic.jar. We have changed that behavior to look for a jar that could include that version in the filename. Infra/Config/ValidateJMX - The nrdiag-output.json will include information about the Java version and non-sensitive command line arguments for JMX. This data is mainly relevant for Support troubleshooting. Additionally, this health check now can run on Windows. Java/JVM/Permissions - It will not validate permissions for a log path that has been commented out from the Java agent config file. Infra/Config/IntegrationsMatch - This validation will no longer require the presence of on-host integration (OHI) definitions files when the user has an infrastructure agent 1.8.0 or newer and the OHI config file is using the newer configuration format. Changes The product will now be known as Diagnostics CLI Diagnostics CLI is proud to announce that is codebase is now part of New Relic's Open Source Community: https://github.com/newrelic/newrelic-diagnostics-cli",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.11832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Diagnostics <em>CLI</em> 1.12.32",
        "sections": "Diagnostics <em>CLI</em> release notes",
        "category_2": "Diagnostics <em>CLI</em> release notes",
        "body": "[RSS] Released on:¬† Monday, January 11, 2021 - 09:30 Download <em>New</em> Diagnostics <em>CLI</em> will validate the Java agent configuration that has been done through Java System Properties. Infra&#x2F;Env&#x2F;NrjmxBeans - Validates that the mbeans that the user wants to query with the <em>New</em> <em>Relic</em> JMX integration",
        "breadcrumb": "Contents &#x2F; Release notes &#x2F; Diagnostics release notes &#x2F; Diagnostics <em>CLI</em> release notes"
      },
      "id": "602a9d2264441f9cf3ce5cd0"
    }
  ],
  "/try-our-apis": [
    {
      "category_2": "Understand data",
      "nodeid": 35616,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Convert data to metrics",
        "Ingest APIs",
        "Introduction to querying New Relic data",
        "Query data in the UI",
        "Use NRQL or PromQL-style queries in the UI",
        "Query using simple UI interfaces",
        "Query data via API",
        "For more help"
      ],
      "title": "Introduction to querying New Relic data",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "95e6c1d3b3cd8e894daa665393fe13abd1d3f49a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-manage-data/understand-data/introduction-querying-new-relic-data",
      "published_at": "2021-02-23T02:38:19Z",
      "updated_at": "2021-02-23T02:38:19Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Understand data",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to querying your New Relic data in our UI or via our APIs.",
      "body": "You can query New Relic data in several ways, including in the UI or via API. To understand your New Relic-stored data better, see Data types. Query data in the UI Reasons to query your data from the New Relic UI: To answer a specific question To create a custom chart or dashboard To access and navigate your data in a quick, visual way There are two ways to query data in the New Relic UI: using query languages (New Relic query language or our PromQL-style query language), or using simpler query interfaces that don't require knowledge of how to write a query. Access your data easily on one.newrelic.com: Click the Browse data dropdown menu and select the data type (metrics, events, logs, and traces) you want to explore. Use NRQL or PromQL-style queries in the UI There are two ways to write your own queries to retrieve data and build charts: Query builder - NRQL mode: query using New Relic query language (NRQL), the same language we use to build most of our UI experiences. Query builder - PromQL-style mode: write basic queries using a PromQL-style query. Query using simple UI interfaces New Relic One offers several experiences that don't require knowledge of NRQL: Data explorer: an intuitive data navigator to create visualizations for events and metrics. Query builder (basic mode): a simple, query-less, chart-building experience. Distributed tracing query: a specialized UI for querying traces. Logs query: a specialized UI for querying New Relic Logs data. Query data via API There are several APIs for retrieving and querying New Relic data. You can run NRQL (our query language) queries with NerdGraph (our GraphQL API). For more on New Relic APIs, see Intro to New Relic APIs. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 720.8612,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to querying <em>New</em> <em>Relic</em> data",
        "sections": "Introduction to querying <em>New</em> <em>Relic</em> data",
        "info": "An introduction to querying your <em>New</em> <em>Relic</em> data in our UI or via our <em>APIs</em>.",
        "category_0": "<em>Telemetry</em> Data <em>Platform</em>",
        "body": " There are several <em>APIs</em> for retrieving and querying <em>New</em> <em>Relic</em> data. You can run NRQL (our query language) queries with <em>NerdGraph</em> (our <em>GraphQL</em> <em>API</em>). For more on <em>New</em> <em>Relic</em> <em>APIs</em>, see Intro to <em>New</em> <em>Relic</em> <em>APIs</em>. For more help If you need more help, check out these support and learning resources: Browse",
        "breadcrumb": "Contents &#x2F; <em>Telemetry</em> Data <em>Platform</em> &#x2F; Ingest and manage data &#x2F; Understand data"
      },
      "id": "60049c70196a67a3c60e4b5f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Permissions for managing applications",
        "Publish and deploy apps",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Build apps",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Permissions for managing applications ¬† Learn about permissions for subscribing to apps Publish and deploy apps 30 min Start sharing the apps you build Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 698.68427,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add the <em>NerdGraphQuery</em> component to an application",
        "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and <em>GraphQL</em>, you can create custom views tailored to your business. These guides are designed to help you start"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "category_2": "Examples",
      "nodeid": 19141,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "NerdGraph entities API tutorial",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Search by attribute",
        "Search by entity GUID",
        "Example queries",
        "For more help"
      ],
      "title": "NerdGraph entities API tutorial",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "6dad137791a70630e57cb10aa5f574776c26613f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial",
      "published_at": "2021-02-22T19:23:56Z",
      "updated_at": "2021-02-22T19:23:56Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic's NerdGraph (our GraphQL API) to query your monitored entities (applications, hosts, etc.)",
      "body": "To query data with New Relic's NerdGraph, we use the concept of an entity. An entity provides unified access to all the things you monitor with New Relic, including but not limited to: Applications monitored by APM. Cloud integrations, services, and hosts monitored by infrastructure monitoring. To view entity details in the our UI, use the New Relic Explorer in New Relic One. To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Each entity has similar traits: A unique entity GUID identifies it. It exists over a span of time, even if it's a short period. It provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements All you need is a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. OR Use the freeform query argument to provide your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. In addition to these examples, we highly recommend exploring the API using the NerdGraph GraphiQL explorer and searching its inline documentation. Search by attribute Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND type IN ('APPLICATION')\"} Search by entity GUID Use a specific entity's GUID to query deeper into its related data. For example: query($guids: EntityGuid! ) { actor { entities(guids: $guids) { entityType name } } } Add the following variables to the Query variables section: {\"guids\": \"entity-guid-here\"} Example queries Queries are requests that are intended to only fetch data (no side effects). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using the queryBuilder If you aren't sure how to start crafting an entity search query, you can rely on NerdGraph to help you build one, and then retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and searching its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and searching its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's Alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit and you want to view the rest of the results, you can request nextCursor in your initial request and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 661.2853,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> entities <em>API</em> tutorial",
        "sections": "<em>NerdGraph</em> entities <em>API</em> tutorial",
        "info": "Use <em>New</em> <em>Relic&#x27;s</em> <em>NerdGraph</em> (our <em>GraphQL</em> <em>API</em>) to query your monitored entities (applications, hosts, etc.)",
        "category_0": "<em>APIs</em>",
        "category_1": "<em>NerdGraph</em>",
        "body": "To query data with <em>New</em> <em>Relic</em>&#x27;s <em>NerdGraph</em>, we use the concept of an entity. An entity provides unified access to all the things you monitor with <em>New</em> <em>Relic</em>, including but not limited to: Applications monitored by APM. Cloud integrations, services, and hosts monitored by infrastructure monitoring",
        "breadcrumb": "Contents &#x2F; <em>APIs</em> &#x2F; <em>NerdGraph</em> &#x2F; Examples"
      },
      "id": "5d8fd87f196a67bba0756f3f"
    },
    {
      "category_2": "Core concepts",
      "nodeid": 34131,
      "sections": [
        "Use New Relic One",
        "Get started",
        "Core concepts",
        "UI and data",
        "Workloads",
        "Build on New Relic One",
        "What is an entity in New Relic?",
        "What is an entity?",
        "Find and explore entities",
        "Entity relationships",
        "Group and organize entities",
        "For more help"
      ],
      "title": "What is an entity in New Relic?",
      "category_0": "New Relic One",
      "type": "docs",
      "category_1": "Use New Relic One",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic",
      "external_id": "e37477cb70139a420735f58b6655484bf927ca96",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic",
      "published_at": "2021-02-23T00:53:36Z",
      "updated_at": "2021-02-23T00:53:35Z",
      "breadcrumb": "Contents / New Relic One / Use New Relic One / Core concepts",
      "document_type": "page",
      "popularity": 1,
      "info": "The definition of 'entity' in New Relic, and how to use and organize entities. ",
      "body": "New Relic monitoring is built around the concept of the entity. This document explains: What entities are How to find entity data How entities are related to one another How to organize them into groups for easier analysis What is an entity? From a New Relic product perspective, entity is a broad concept. An entity is anything we can identify that has data you can monitor. \"Entity\" can refer to fundamental data-reporting components like applications, hosts, and database services, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. This conceptual definition of \"entity\" is important because New Relic's goal is to give you practical information about the status of your business-important entities (and not just give you an unhelpfully large stream of assorted metrics and data). Our focus on entities, and the relationships between them, helps us optimize monitoring and troubleshooting of complex, modern systems. Find and explore entities An entity is anything that reports data to New Relic, so you'll find your entities wherever you see your data reporting in New Relic. You can create new entity types to monitor any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's unique global identifier (GUID): from any list of monitored entities in the New Relic Explorer, hover over a specific entity and click the information icon to see the GUID and other metadata. An entity's GUID is reported as the attribute entityGuid. You can query for an entity using this attribute in the query builder. Use the Related Entities view in the New Relic Explorer, service maps, distributed tracing, and our relationships API in GraphQL to see connections between entities. Explore entity data using our NerdGraph GraphiQL explorer (api.newrelic.com/graphiql). Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a single entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related Entities in the entity's mini overview. Related Entities is a visualization of the various entities connected directly to the current entity in focus. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. You can learn more about how entities are related using our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related Entities. Currently, you can only manually create calls/called-by relationships between service entities. To manage manual relationships, you need to have modify and delete capabilities on entity relationships. These are granted to user roles by default. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: How to tag entities Create workloads (groups of related entities) For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 628.4263,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "Use <em>New</em> <em>Relic</em> One",
        "info": "The definition of &#x27;entity&#x27; in <em>New</em> <em>Relic</em>, and how to use and organize entities. ",
        "category_0": "<em>New</em> <em>Relic</em> One",
        "category_1": "Use <em>New</em> <em>Relic</em> One",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;<em>new</em>-<em>relic</em>-one&#x2F;use-<em>new</em>-<em>relic</em>-one&#x2F;core-concepts&#x2F;what-entity-<em>new</em>-<em>relic</em>",
        "body": " <em>Relic</em> Explorer, service maps, distributed tracing, and our relationships <em>API</em> in <em>GraphQL</em> to see connections between entities. Explore entity data using our <em>NerdGraph</em> Graphi<em>QL</em> explorer (<em>api</em>.newrelic.com&#x2F;graphiql). Entity relationships Connections between entities are automatically created by <em>New</em> <em>Relic</em>",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> One &#x2F; Use <em>New</em> <em>Relic</em> One &#x2F; Core concepts"
      },
      "id": "5cdc20638e9c0f35676a8106"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 9231,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Rules, limits, and glossary",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Troubleshooting",
        "Create NRQL alert conditions",
        "Create a NRQL alert condition",
        "NRQL alert syntax",
        "NRQL alert threshold examples",
        "Nested aggregation NRQL alerts",
        "NRQL condition creation tips",
        "Alert threshold types",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Advanced signal settings",
        "Aggregation window",
        "Evaluation offset",
        "Fill data gaps",
        "For more help"
      ],
      "title": "Create NRQL alert conditions",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "external_id": "956a7a0b84d2afac5e6236df3143085ebc4f7459",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/nr1_nrql_alert_conditions.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "published_at": "2021-02-23T12:38:14Z",
      "updated_at": "2021-02-23T12:38:13Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "How to define thresholds that trigger alert notifications based on your NRQL queries.",
      "body": "You can use NRQL queries to create alert conditions. Once you've defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Click NRQL, and then Next, define thresholds. For more information on key concepts relating to NRQL alert conditions and streaming alerts, see Streaming alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition for a policy: On one.newrelic.com, in the header click Alerts & AI, then in the left sidebar click Policies. Select an existing policy or click New alert policy to create a new policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define thresholds. NRQL alert syntax Here's the basic syntax for creating all NRQL alert conditions. The FACET clause is required for Outlier threshold types, optional for Static, and not allowed for Baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Required for outlier conditions, but not baseline or static Include an optional FACET clause in your NRQL syntax depending on the threshold type: static, baseline, or outlier. Use the FACET clause to separate your results by attribute and alert on each attribute independently. No LIMIT clause is allowed, but all queries will receive the maximum number of facets possible. Faceted queries can return a maximum of 5000 values for static conditions and a maximum of 500 values for outlier conditions. If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction SELECT percentile(databaseDuration, 75) FROM Transaction Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction SELECT average(duration) FROM Transaction Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Nested aggregation NRQL alerts Nested aggregation queries are a powerful way to query your data. However, they have a few restrictions that are important to note. Nested queries with a non-faceted innermost query are not currently supported Without a FACET, the inner query produces a single result, giving the outer query nothing to aggregate. If you're using a nested query, make sure your inner query is faceted. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu) ‚Äã‚Äã‚Äã‚Äã‚Äã Queries at all levels must have the same aggregation window size With an alert aggregation window of 1 minute, the inner query would produce two smaller windows of 30 seconds. In theory, these two windows could be aggregated by the outer query. However, this is not currently supported. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)‚Äã‚Äã Signal loss is not yet supported for nested queries For more information on signal loss, see NerdGraph API: Loss of signal and gap filling. NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. For details, see Description Query results Queries must return a number. The condition evaluates the returned number against the thresholds you've set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that violations for sporadic data, such as error counts, are closed when no signal is coming in. To learn more about signal loss and how to request access to it, see this announcement. Advanced signal settings These settings give you options for better handling continuous, streaming data signals that may sometimes be missing. These settings include the aggregation window, the evaluation offset, and an option for filling data gaps. For more on using these, see Advanced signal settings. Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions don't affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type, except you can't use a FACET clause. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. Sum of query results (limited or intermittent data) Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. You can use loss of signal, aggregation duration, and gap filling settings to minimize these false notifications. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum and the preview chart will update accordingly. Set the loss of signal threshold Loss of signal occurs when no data matches the NRQL condition over a specific period of time. You can set your loss of signal threshold duration and and also what happens when the threshold is crossed. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Loss of signal is only available for NRQL conditions. You may also manage these settings using the GraphQL API (recommended), or the REST API. Go here for specific GraphQL API examples. Loss of signal settings: Loss of signal settings include a time duration and two possible actions. Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration Expiration duration is a timer that starts and resets when we receive a data point in the streaming alerts pipeline. If we don't receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. The loss of signal expiration time is independent of the threshold duration and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we recommend using at least 3-5 minutes. Loss of signal actions Once a signal is considered lost, you can close open violations, open new violations, or both. Close all current open violations: This closes all open violations that are related to a specific signal. It won't necessarily close all violations for a condition. If you're alerting on an ephemeral service, or on a sporadic signal, you'll want to choose this action to ensure that violations are closed properly. The GraphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to a loss of signal. Based on your incident preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we'll close all open violations first, and then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: For a policy, when you create a condition, under Select a product, click NRQL, then click Next, define thresholds. Write a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in minutes or seconds in the Signal is lost after field. Choose what you want to happen when the signal is lost. You can check one or both of Close all current open violations and Open new \"lost signal\" violation . These control how loss of signal violations will be handled for the condition. Make sure you name your condition before you save it. Loss of signal detection doesn't work on NRQL queries that use nested aggregation or sub-queries. Advanced signal settings When creating a NRQL alert condition, the advanced signal settings gives you better control over streaming alert data and helps you avoid false alarms. When creating a NRQL condition, there are several advanced signal settings: Aggregation window Evaluation offset Fill data gaps To read an explanation of what these settings are and how they relate to each other, see Streaming alerts concepts. Below are instructions and tips on how to configure them. Aggregation window You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. You can set it to anything between one second and 15 minutes. The default is one minute. Baseline alert condition thresholds don't support editing the aggregation window. They use the 1 minute default. Evaluation offset You can adjust the evaluation offset to coordinate our streaming alerting algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. The total supported latency is the product of the aggregation window duration multiplied by the evaluation offset. In the example screenshot above, the supported latency is 3 minutes (a 1-minute aggregation window multiplied by three windows). If the data type comes from an APM language agent and is aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3 with 1 minute aggregation windows. When creating NRQL conditions for data collected from Infrastructure Cloud Integrations such as AWS Cloudwatch or Azure, we recommend that you start with an evaluation offset of 15 minutes, then adjust up or down depending on how long it takes to collect your data. Fill data gaps Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with one of these settings: None: (Default) Choose this if you don't want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won't be in violation. Custom static value: Choose this if you'd like to insert a custom static value into the empty aggregation windows before they're evaluated. This option has an additional, required parameter of fillValue (as named in the API) that specifies what static value should be used. This defaults to 0. Last known value: This option inserts the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. Options for editing data gap settings: In the NRQL conditions UI, go to Condition settings > Advanced signal settings > fill data gaps with and choose an option. If using our Nerdgraph API (preferred), this node is located at: actor : account : alerts : nrqlCondition : signal : fillOption | fillValue NerdGraph is the preferred API but if you are using our REST API, you can find this setting in the REST API explorer under the \"signal\" section of the Alert NRQL conditions API. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 599.3296,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> Alerts",
        "category_1": "<em>New</em> <em>Relic</em> Alerts",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;alerts-applied-intelligence&#x2F;<em>new</em>-<em>relic</em>-alerts&#x2F;alert-conditions&#x2F;create-nrql-alert-conditions",
        "body": ", see <em>NerdGraph</em> <em>API</em>: Loss of signal and gap filling. NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can",
        "breadcrumb": "Contents &#x2F; Alerts and Applied Intelligence &#x2F; <em>New</em> <em>Relic</em> Alerts &#x2F; Alert conditions"
      },
      "id": "5f2d992528ccbc489d88dfc1"
    }
  ],
  "/automate-workflows/get-started-new-relic-cli": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Automate common tasks",
        "Set up New Relic using the Kubernetes operator",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Automate workflows",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 336.37177,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using the Kubernetes operator",
        "body": " Toolkit. Guides to automate workflows Quickly <em>tag</em> resources 5 min Add <em>tags</em> to apps for easy filtering Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em>"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Examples",
      "nodeid": 42656,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "Golden metrics for entities NerdGraph API tutorial",
        "Fetch golden metrics",
        "Fetch golden tags",
        "Customize golden metrics and golden tags",
        "Override golden metrics or golden tags for a specific entity type in your whole account",
        "Override golden metrics from a particular entity type in a workload",
        "Fetch the custom golden metrics and golden tags",
        "Reset custom metrics and golden tags",
        "Expected errors",
        "For more help"
      ],
      "title": "Golden metrics for entities NerdGraph API tutorial",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "956bc04201d39123c3cb69777298c967ab1c4cfd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/golden-metrics-entities-nerdgraph-api-tutorial",
      "published_at": "2021-02-23T07:47:19Z",
      "updated_at": "2021-02-21T15:35:42Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic's NerdGraph (our GraphQL API) to query or override golden metrics and tags.",
      "body": "Golden metrics and golden tags are bits of information about an entity that we consider to be the most important for that entity. We use this information to display a brief overview of an entity across all New Relic. You can see and contribute to the standard definitions of the golden metrics and tags in this public repository. This document explains how to query an entity's custom metrics using NerdGraph. For more on how to query entities using the NerdGraph API, see our tutorial. Fetch golden metrics When fetching golden metrics for a specific GUID or list of GUIDS, the provided queries are already filtered for you. You can run the resulting query as is in the query builder. The resulting metric can be either a timeseries or a single value. Here's an example of one golden metric query for an AWS DynamoDB table entity with the GUID ExampleGUID. SELECT average(provider.getSuccessfulRequestLatency.Average) FROM DatastoreSample WHERE entityGuid IN ('ExampleGUID') AND provider='DynamoDbTable' TIMESERIES You can use NerdGraph to query for the golden metrics of a specific entity; for example: { actor { entity(guid: \"ENTITY-GUID\") { goldenMetrics { query title } } } } Fetch golden tags Golden tags are always represented the same way, whether requested by GUID or by entityType. You will always receive the list of tag keys considered the most important about the entity. { actor { entity(guid: \"ENTITY-GUID\") { goldenTags { key } } } } Customize golden metrics and golden tags If you want to change the golden metrics and golden tags based on the specificities of your environment, you can override them in two different contexts, in your account, or in a workload. Override golden metrics or golden tags for a specific entity type in your whole account In this case, the new golden metrics or the new golden tags will be applied in all New Relic One, converting your new metrics and tags as the default for the specified entity type. To do that, you can use a NerdGraph mutation to override the golden metrics for a specific entity. mutation { entityGoldenMetricsOverride( context: {account: ACCOUNT_TO_OVERRIDE_GOLDEN METRICS}, domainType: {domain: DOMAIN, type: TYPE}, metrics: [ {eventId: EVENT_ID, select: NRDB_QUERY_SELECT, from: NRDB_QUERY_EVENT, where: NRDB_QUERY_WHERE, title: TITLE_OF_THE_METRIC, facet: FACET, name: NAME_OF_THE_METRIC}, ...]) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } Where: domainType: The entity type of the metrics to override. context: The context to fetch the golden metrics from. In this case, you should set the account that you want to override. metrics: The new NRDB query will be shown as golden metrics. eventId: The field used to filter the entity in the metric. How the entity GUID is defined in your event. select: The SELECT clause of the NRDB query. This field is required. from: The FROM clause of the NRDB query. where: Complementary where clause to identify the entity type field. facet: The field to FACET. title: The title of the golden metric. This field is optional. name: The name of the golden metric. This field is required. Override an APM application mutation { entityGoldenMetricsOverride( context: {account: ACCOUNT_ID}, domainType: {domain: \"APM\", type: \"APPLICATION\"}, metrics: [ {eventId: \"entity.guid\", from: \"Transaction\", name: \"cpuUsage\", select: \"max(cpuUsage)\", title: \"CPU Usage\"}, {eventId: \"guid\", from: \"Metric\", where: \"metricTimesliceName in ('HttpDispatcher', 'OtherTransaction/all')\", facet: \"appName\", select: \"count(newrelic.timeslice.value)\", name: \"throughput\", title: \"Throughput\"}]) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } The metrics input object defines the parts of an NRDB query, split into sections. One of these sections is the eventId, which is used to identify the field that defines the GUID inside the NRDB Event you want to use as a golden metric. For example: SELECT average(provider.getSuccessfulRequestLatency.Average) FROM DatastoreSample WHERE entityGuid IN ('EntityGuid') AND provider='DynamoDbTable' FACET entityName TIMESERIES It's defined as follows: { eventId: \"entityGuid\", from: \"DatastoreSample\", where: \"provider='DynamoDbTable'\", facet: \"entityName\", select: \"average(provider.getSuccessfulRequestLatency.Average)\", name: GetItem latency (ms), title: GetItem latency (ms) } As you can see in the resultant object, the where clause only contains the provider field. The system adds the where clause with the eventId field by default. You can do the same for the golden tags using this NerdGraph mutation: mutation { entityGoldenTagsOverride( context: {account: ACCOUNT_ID}, domainType: {domain: \"APM\", type: \"APPLICATION\"}, tags: [{key: \"applicationName\"} , {key: \"environment\"} ]) { errors { message type } tags { context { account } domainType { domain type } tags { key } } } } Override golden metrics from a particular entity type in a workload New Relic's workloads provide an aggregated view of health and performance data about a group of entities. The time series charts shown for each entity type in a workload are defined by the golden metrics in the workload account. If you want to further customize which time series to show for a specific entity type in a particular workload, override the golden metrics in the account with the following mutation: mutation { entityGoldenMetricsOverride( context: {guid: WORKLOAD_TO_OVERRIDE_GOLDEN METRICS}, domainType: {domain: DOMAIN, type: TYPE}, metrics: [ {eventId: EVENT_ID, select: NRDB_QUERY_SELECT, from: NRDB_QUERY_EVENT, where: NRDB_QUERY_WHERE, title: TITLE_OF_THE_METRIC, facet: FACET, name: NAME_OF_THE_METRIC}, ...]) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } See above for details on each field. In this case, context is the workload's GUID. Override an APM application mutation { entityGoldenMetricsOverride( context: {guid: WORKLOAD_ENTITY_GUID}, domainType: {domain: \"APM\", type: \"APPLICATION\"}, metrics: [ {eventId: \"entity.guid\", from: \"Transaction\", name: \"cpuUsage\", select: \"max(cpuUsage)\", title: \"CPU Usage\"}, {eventId: \"guid\", from: \"Metric\", where: \"metricTimesliceName in ('HttpDispatcher', 'OtherTransaction/all')\", facet: \"appName\", select: \"count(newrelic.timeslice.value)\", name: \"throughput\", title: \"Throughput\"}]) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } Fetch the custom golden metrics and golden tags The queries defined in the previous sections always return the default golden metrics and golden tags. If you want to fetch your custom golden metrics or golden tags, you need to send the context defined in the query, for example: { actor { entity(guid: INFRA-AWSDYNAMODBTABLE-GUID) { goldenMetricsByContext( context: {account: ACCOUNT_ID, guid: WORKLOAD_ENTITY_GUID}) { metrics { title query name } } } } } For golden tags: { actor { entity(guid: INFRA-AWSDYNAMODBTABLE-GUID) { goldenTags(context: {account: ACCOUNT_ID, guid: WORKLOAD_ENTITY_GUID}) { tags { key } } } } } You can send both contexts simultaneously for querying, if your metrics or tags have the context inside the workload. The API returns the most specific golden metric or golden tags based on the context that you defined in the requests. The priority is workload and account. Reset custom metrics and golden tags If your custom golden metrics are not relevant to you any more, you can restore the defaults defined by New Relic. In the context parameter, set the desired account or workload guid (in the guid parameter). To restore your golden metrics in an account, run this query: mutation { entityGoldenMetricsReset( context: {guid: ACCOUNT_TO_OVERRIDE_GOLDEN_METRICS}, domainType: {domain: DOMAIN, type: TYPE}) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } Where: domainType: The entity type of the metrics to override. context: The context to fetch the golden metrics from. In this case, you should set the account you want to reset. To restore your golden metrics in a workload, run this query: mutation { entityGoldenMetricsReset( context: {guid: GUID_TO_OVERRIDE_GOLDEN_METRICS}, domainType: {domain: DOMAIN, type: TYPE}) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } You can do the same for your custom golden tags: mutation { entityGoldenTagsReset( context: {guid: WORKLOAD_ENTITY_GUID}, domainType: {domain: \"APM\", type: \"APPLICATION\"}) { errors { message type } tags { key context { account guid } domainType { domain type } tags { key } } } } Expected errors All these mutations can answer with the result of the operation or a list of errors. These are all the expected errors that you can receive: INVALID_CONTEXT: The context is not valid. There can only be one context, an account or a workload's GUID. If you use both, or use any other concept, or a GUID that doesn't belong to a workload, you will get this error. INVALID_DOMAIN_TYPE: The domain type is not valid. LIMIT_EXCEEDED: The maximum amount of metrics is 9. If you exceed this limit you will get this error. NOT_AUTHORIZED: The user doesn't have the permissions to carry out this action. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.25092,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Golden metrics for <em>entities</em> NerdGraph <em>API</em> tutorial",
        "sections": "Golden metrics for <em>entities</em> NerdGraph <em>API</em> tutorial",
        "info": "Use <em>New</em> <em>Relic&#x27;s</em> NerdGraph (our GraphQL <em>API</em>) to query or override golden metrics and <em>tags</em>.",
        "category_0": "<em>APIs</em>",
        "body": "Golden metrics and golden <em>tags</em> are bits of information about an <em>entity</em> that we consider to be the most important for that <em>entity</em>. We use this information to display a brief overview of an <em>entity</em> across all <em>New</em> <em>Relic</em>. You can see and contribute to the standard definitions of the golden metrics"
      },
      "id": "60327dcfe7b9d2f2838b3bb0"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.23944,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Quickly <em>tag</em> a set of resources",
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Add <em>tags</em> to applications you instrument for easier filtering and organization.",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " of your entities. Before you begin For this guide you need a <em>New</em> <em>Relic</em> user <em>key</em>: You can view and create them in the <em>API</em> keys UI. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:38:35Z",
      "title": "New Relic Developers",
      "updated_at": "2021-02-06T01:37:36Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes ¬† Use custom attributes for deeper analysis Show 28 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.92416,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "Getting started with <em>New</em> <em>Relic</em> and Terraform",
        "body": " source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "category_2": "Examples",
      "nodeid": 19141,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "NerdGraph entities API tutorial",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Search by attribute",
        "Search by entity GUID",
        "Example queries",
        "For more help"
      ],
      "title": "NerdGraph entities API tutorial",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "6dad137791a70630e57cb10aa5f574776c26613f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial",
      "published_at": "2021-02-22T19:23:56Z",
      "updated_at": "2021-02-22T19:23:56Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic's NerdGraph (our GraphQL API) to query your monitored entities (applications, hosts, etc.)",
      "body": "To query data with New Relic's NerdGraph, we use the concept of an entity. An entity provides unified access to all the things you monitor with New Relic, including but not limited to: Applications monitored by APM. Cloud integrations, services, and hosts monitored by infrastructure monitoring. To view entity details in the our UI, use the New Relic Explorer in New Relic One. To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Each entity has similar traits: A unique entity GUID identifies it. It exists over a span of time, even if it's a short period. It provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements All you need is a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. OR Use the freeform query argument to provide your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. In addition to these examples, we highly recommend exploring the API using the NerdGraph GraphiQL explorer and searching its inline documentation. Search by attribute Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND type IN ('APPLICATION')\"} Search by entity GUID Use a specific entity's GUID to query deeper into its related data. For example: query($guids: EntityGuid! ) { actor { entities(guids: $guids) { entityType name } } } Add the following variables to the Query variables section: {\"guids\": \"entity-guid-here\"} Example queries Queries are requests that are intended to only fetch data (no side effects). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using the queryBuilder If you aren't sure how to start crafting an entity search query, you can rely on NerdGraph to help you build one, and then retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and searching its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and searching its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's Alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit and you want to view the rest of the results, you can request nextCursor in your initial request and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.06595,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NerdGraph <em>entities</em> <em>API</em> tutorial",
        "sections": "NerdGraph <em>entities</em> <em>API</em> tutorial",
        "info": "Use <em>New</em> <em>Relic&#x27;s</em> NerdGraph (our GraphQL <em>API</em>) to query your monitored <em>entities</em> (applications, hosts, etc.)",
        "category_0": "<em>APIs</em>",
        "body": ". To view <em>entity</em> details in the our UI, use the <em>New</em> <em>Relic</em> Explorer in <em>New</em> <em>Relic</em> One. To work with an <em>entity</em>&#x27;s golden metrics and <em>tags</em>, see the golden metrics <em>API</em> tutorial. <em>Entity</em> definition Each <em>entity</em> has similar traits: A unique <em>entity</em> GUID identifies it. It exists over a span of time, even if it&#x27;s"
      },
      "id": "5d8fd87f196a67bba0756f3f"
    }
  ],
  "/build-apps/map-pageviews-by-region": [
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com",
        "This site uses cookies üç™"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2021-02-25T01:58:10Z",
      "updated_at": "2020-12-04T02:00:00Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.38059,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Prepare to build or modify <em>apps</em>",
        "info": "Prepare to build <em>apps</em> and contribute to this site",
        "body": ", publish it to New Relic One, and share it with others by subscribing accounts to it. <em>Map</em> pageviews by <em>region</em> takes you through the steps to create one of our popular open source apps. You learn to add a <em>custom</em> query to an <em>app</em> and <em>view</em> it in a table, then add that data to a <em>map</em>. Contribute"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "category_2": "Additional standard features",
      "nodeid": 1921,
      "sections": [
        "Browser monitoring",
        "Getting started",
        "Guides",
        "Installation",
        "Configuration",
        "Browser agent and SPA API",
        "Page load timing resources",
        "Browser Pro features",
        "Additional standard features",
        "Performance quality",
        "Troubleshooting",
        "Browser Geography: Webpage performance by location",
        "Contents",
        "View performance data by region",
        "Use page functions",
        "View drill-down details",
        "For more help"
      ],
      "title": "Browser Geography: Webpage performance by location",
      "category_0": "Browser monitoring",
      "type": "docs",
      "category_1": "Browser monitoring",
      "external_id": "ccbfe8376f2aee5d35b31dbcee84ff1cbff5b094",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/geo_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/additional-standard-features/browser-geography-webpage-performance-location",
      "published_at": "2021-02-22T20:45:56Z",
      "updated_at": "2020-08-15T09:25:45Z",
      "breadcrumb": "Contents / Browser monitoring / Browser monitoring / Additional standard features",
      "document_type": "page",
      "popularity": 1,
      "info": "Browser's Geography feature shows color-coded Apdex scores and page load performance for your end users' experience around the world.",
      "body": "Browser monitoring's Geography page provides a world view with color-coded Apdex scores and other performance information about your end users' experience. You can select specific geographic regions, such as countries or states, and then you can drill down to detailed information about page load performance and historical performance. Contents View performance data by region Firewalls may have an impact on the geographical data collected about your end users. To view or sort the performance information by location: one.newrelic.com > Browser > (select an app) > Geo: This page provides a world view and drill-down details of color-coded performance information for geographic locations. Go to one.newrelic.com > Browser > (select an app) > Geo > Global (for a world view). OR Go to one.newrelic.com > Browser > (select an app) > Geo > (select a location) (for a specific location you identified in the Browser application settings). To drill down to a specific area, select a location from the list, or select any area on the geographical map. To view additional details about the selected location, select the Page load performance or Historical performance links. To return to the main Geography page, select X (Close). one.newrelic.com > Browser > (select an app) > Geo > (select a location): If you selected specific locations from Settings > Application settings, the Geography page includes tabs to view their performance data directly. Use page functions Use any of our standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Geography page: If you want to... Do this... Change how the performance data appears Select your choice from the Sort by menu. Adjust the amount of information that appears Select or clear the Hide <% throughput checkbox (<1% for global view, <2% for selected locations). View a map of a specific location Do any of these as applicable: Select the location's name from the Geo > Global list. Select its physical location on the map. If you have pre-selected the location from Application settings, select its tab. View summary performance information about a specific location Mouse over any colored area. View drill-down details After you select a specific location, the Page load performance page shows: Average page load time in seconds Number of page views and active sessions as pages per minute (ppm) Recent browser traces if applicable one.newrelic.com > Browser > (select an app) > Geo > (select a location): After you select a specific location, you can view specific details about Page load performance and Historical performance. In addition, the Historical performance page shows comparison data for the selected time period, yesterday, and last week for the selected location. This includes: Response time Apdex Throughput in pages per minute (ppm) For more help Additional documentation resources include the Page views page (details about end users' overall experience with your site). If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.69674,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>View</em> performance data by <em>region</em>",
        "info": "Browser&#x27;s Geography feature shows color-coded Apdex scores and <em>page</em> load performance for your end users&#x27; experience around the world.",
        "body": " performance and historical performance. Contents <em>View</em> performance data by <em>region</em> Firewalls may have an impact on the geographical data collected about your end users. To <em>view</em> or sort the performance information by location: one.newrelic.com &gt; Browser &gt; (select an <em>app</em>) &gt; Geo: This <em>page</em> provides a world"
      },
      "id": "561c8bbc827a6617ad000172"
    },
    {
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Subscribe or unsubscribe apps",
        "Handle duplicate applications",
        "This site uses cookies üç™"
      ],
      "title": "Serve, publish, and deploy your New Relic One app",
      "type": "developer",
      "tags": [
        "publish apps",
        "deploy apps",
        "subscribe apps",
        "add metadata apps"
      ],
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2020-12-04T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Start sharing and using the custom New Relic One apps you build",
      "body": "When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. bash Copy $ nr1 update Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. bash Copy $ nr1 catalog:submit Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Subscribe or unsubscribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.941574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and deploy your New Relic One <em>app</em>",
        "sections": "Serve, publish, and deploy your New Relic One <em>app</em>",
        "info": "Start sharing and using the <em>custom</em> New Relic One <em>apps</em> you build",
        "tags": "publish <em>apps</em>",
        "body": " Relic engineers to provide visualizations we think you&#x27;ll want, like Cloud Optimizer, which analyzes your cloud environment, or <em>PageView</em> <em>Map</em>, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via"
      },
      "id": "5efa999de7b9d283e67bab8f"
    },
    {
      "image": "https://newrelic.com/content/dam/component-assets/p03-product-image/browser/products_browsers_features_browserloadtime_sept2020_thumb.png",
      "url": "https://newrelic.com/products/browser-monitoring/features",
      "sections": [
        "New Relic Browser features",
        "Full Support for Google‚Äôs Core Web Vitals",
        "User Centric Perceived Performance",
        "Single Page App Route Changes",
        "Session Traces",
        "Browser Traces",
        "Page Load Time - Segmentation Chart",
        "Page Load Time - Histogram and Percentiles",
        "Geographic Reporting",
        "Page-Level AJAX Calls",
        "Page View Throughput",
        "Connect Browser with Backend Performance",
        "JavaScript Error Summary",
        "Errors by Browser",
        "Percentage of Page Views with Errors",
        "Source Map Support",
        "Best-in-class Customer Experience Monitoring",
        "Browser Throughput",
        "Browser Load Time - Segmentation Chart",
        "Browser Version Chart",
        "Error Instance Details",
        "AJAX Dashboard",
        "Calls by Page View",
        "Request Status Codes",
        "Data Transfer Per Request",
        "Quickly View App Health",
        "Custom dashboards",
        "Integrate with your ticketing system",
        "Alerting",
        "Filterable Geography",
        "U.S. and EU Data Regions",
        "SOC2 Audited",
        "Secure Data Center",
        "Continuous Monitoring",
        "Secure by Default",
        "Compliance Friendly",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-02-24T01:54:49Z",
      "title": "New Relic Browser | New Relic",
      "updated_at": "2021-01-03T01:40:25Z",
      "type": "",
      "external_id": "b30121e0e2deb44e52a48d9a83ca4f854e2fb470",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android ¬†¬† New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact ¬† Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon New Relic Browser Overview Features Resources New Relic Browser features Sign up for free Page Load Performance JavaScript Errors Browser Performance AJAX Global Features Security Page Load Performance New Relic Browser is the world‚Äôs most deployed Real User Monitoring (RUM) solution because it‚Äôs easy to use, and instantly connects end-user experience with time spent in backend services. From easy-to-understand overviews to user-centric perceived performance metrics and events, Browser helps you benchmark and improve web performance and troubleshoot across your full stack. Full Support for Google‚Äôs Core Web Vitals By adding Cumulative Layout Shift, a score measuring the impact of sudden unexpected shifts in layout due to content dynamically resizing, we now offer full support for all three of Google‚Äôs Core Web Vitals for web health. Use NRQL to create dashboards for all three measurements, definitions below: Largest Contentful Paint (LCP) - measures loading performance First Input Delay (FID) - measures interactivity Cumulative Layout Shift (CLS) - measures visual stability User Centric Perceived Performance Web performance teams can use more modern metrics than just page load time to benchmark and improve end-user experience for their dynamic pages. Browser helps developers understand how code impacts customers, answering key questions on page performance. Monitor how long users wait for content to display (paint metrics), how long until users can interact with our page (interactivity metrics), and how long until marquee content renders (largest contentful paint). (see blogpost for more) Single Page App Route Changes View Single Page Application route change performance, regardless of what JavaScript framework you use. Powerful low-level instrumentation can even capture interactions beyond the route change that can be customized via API, allowing monitoring tailored to the architecture of your application, such as for custom frameworks. Session Traces Session Traces provide one of the most valuable assets an engineer requires - context. Beyond identifying long load times, and specific errors, Browser Session Traces provide the story that occurred both before and after an error or performance issue. Pivot from AJAX requests and JavaScript errors into a Session Trace and conversely pivot from a Session Trace out to a specific JavaScript error or Network error. Browser Traces Traces are snapshots of one user‚Äôs experience, surfaced as an outlier due to a longer than average load time. It provides details around when it took place, a segmented breakdown of where load time was spent, browser type, and the user‚Äôs geographic location. This report is excellent when dissecting areas of your application which are performing poorly for specific users. Page Load Time - Segmentation Chart Page load times capture metrics from the moment a user begins a transaction in the browser until the page completes loading. The reports show average page load time broken down into color-coded segments for: Request queuing, application code, network latency, DOM processing, and Page rendering. Page Load Time - Histogram and Percentiles Histograms and percentiles of browser page load times provide a holistic view of the speed of page loads, one that is not focused on averages alone. Histograms and percentiles surface every page load that occurred during a specified time window, providing the ability to drill into outliers that might have been overlooked otherwise. Geographic Reporting Understand how your end users‚Äô experience with your site varies by geographical region. Identify if more CDN‚Äôs are required, or if high value customers in specific parts of the world are having a negative experience with your site‚Äôs performance. Page-Level AJAX Calls For a specific page, see all the AJAX calls being made as well as the response time, throughput (rpm), total number of calls, error status codes, and average data transfer made for each one. Page View Throughput Throughput is measured in requests per per minute. Throughput metrics help you understand which pages are being called most frequently. Connect Browser with Backend Performance From the Page views report, you can select single page URL and see all of the associated backend APM transactions (if you have the APM Agent installed in your application). Quickly view the total call time, average response time, and call count for any individual backend transaction. You can also dive deeper into a particular transaction and see diagnostics within our APM reports. JavaScript Errors The JavaScript error dashboards help you identify production JavaScript errors impacting your users' experiences and begin pinpointing how to resolve them. JavaScript Error Summary This summary view gives you a high level understanding of the types of JavaScript errors happening, the frequency at which they occur, and the percentage of users affected by the errors. Errors by Browser For each type of error, this chart shows you which browsers are being impacted by the error and the relative contribution it is making to your total error volume. Percentage of Page Views with Errors For each type of error, this chart shows you the percentage of page views affected by it. This allows you to quickly assess the reach and impact a particular error has on your end users. Source Map Support Troubleshoot minified production JavaScript code, with source map support giving you full visibility to where in your code the front-end error is. Intuitive drag-and-drop lets you locate issues in a click, while API integrations work seamlessly with your build pipeline. Best-in-class Customer Experience Monitoring Crash analysis in New Relic Mobile lets you analyze the most impactful crashes and fix them faster. Source map support in New Relic Browser gives you more actionable visibility into front-end JS errors by showing you exactly where in the original source the error occurred, even if your code is minified. Browser Performance New Relic's Browser dashboards provide information about your end users' experience based on browser type and version, so you can understand where to focus your time testing and optimizing for performance. Browser Throughput Provides a snapshot of the average number of pageviews received per minute broken down by browser type. Browser Load Time - Segmentation Chart For each type of browser, a segmented view of time spent on request queuing, application code, network latency, DOM processing, and Page rendering. Browser Version Chart Helps you understand which versions of each browser type your customers come from based on throughput. Error Instance Details Error Instance details grabs a snapshot of a single error and captures the stack trace details available from the browser, focusing on the actionable components, down to the line of code. These are metrics are combined with unique browser combinations down to the version level, and unique url. JavaScript diagnostics doesn't get more granular than this. AJAX If your applications use AJAX to update parts of a webpage after the initial page load, our AJAX dashboards will provide you with the level of visibility you need to understand how those requests are performing and ultimately affecting your users‚Äô experience. AJAX Dashboard The main AJAX dashboard surfaces your site‚Äôs most resource intensive AJAX requests, filterable by time consumption, response time, throughput, callback time, and data transfer. From here you can drill into a particular call for detailed analysis. Calls by Page View Shows which page views are calling a particular server side controller, with page level detail around throughput, response time, total number of calls, and data transfer. Request Status Codes The status codes reporting indicates the return behavior from an AJAX call. A large number of non-200 status codes may indicate a problem with your AJAX endpoints. Data Transfer Per Request This shows data transfer which is requested and sent. Use this to look for correlations between high callback times and data transfer rates. Global Features The following features are used throughout New Relic‚Äôs product suite to help make our products easier to use and fit seamlessly into your existing workflows. Quickly View App Health New Relic uses color coded status indicators throughout to help you quickly spot performance issues. Custom dashboards Keep an eye on your most critical performance metrics quickly by adding them to a custom dashboard. Integrate with your ticketing system File tickets related to performance problems directly into your ticketing system.¬†Learn which ticketing systems we support. Alerting Check out our new Alerts Features¬†for Browser that report on JS error %, response time, throughput and much more! Filterable Geography Understand how your end users‚Äô experience with your site varies by geographical region, down to the city level. Identify how a CDN or ASN/ Internet Service Provider is performing in different regions. Security New Relic is committed to helping customers make their applications fast and secure. We take protecting our customers' data seriously, here's an overview of how we do it. U.S. and EU Data Regions Our global data-hosting structure consists of two regions: European Union and United States. You can select your preferred data region during the account setup process, regardless of your physical location. (Note: We do not support migration or aggregation of data across regions.) SOC2 Audited New Relic has successfully completed a SOC 2 audit of processes and controls relevant to security and availability. This audit reviews our security process and controls and provides both ourselves, and more importantly our customers an independent, third-party assurance that we are taking the appropriate steps to protect our systems and our customer‚Äôs data. Secure Data Center The infrastructure that runs the New Relic service and stores our customer‚Äôs data resides in a Tier III, SSAE-16 certified data center. Customer data is backed up on a regular basis. Continuous Monitoring New Relic employs both internal and third-party services to perform continuous security scanning on both our network and applications to ensure that our applications and servers remain secure. Secure by Default We strongly believe in the concept of ‚Äúsecure by default‚Äù. Customers have to explicitly enable settings within New Relic to authorize the sending of sensitive data. We want to make sure that you are not accidentally exposing anything that you don‚Äôt want to. Compliance Friendly New Relic can be configured to operate securely in regulated environments such as PCI, HIPAA, or SOX. In addition we are Swiss and EU Privacy Shield certified. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (Êó•Êú¨Ë™û) newrelic.fr (Fran√ßais) newrelic.de (Deutsch) newrelic.co.kr (ÌïúÍµ≠Ïñ¥) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.68356,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Percentage of <em>Page</em> <em>Views</em> with Errors",
        "body": "), how long until users can interact with our <em>page</em> (interactivity metrics), and how long until marquee content renders (largest contentful paint). (see blogpost for more) Single <em>Page</em> <em>App</em> Route Changes <em>View</em> Single <em>Page</em> Application route change performance, regardless of what JavaScript framework you"
      },
      "id": "5c66a952b5b9e17d23a27084"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage",
        "This site uses cookies üç™"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2021-02-25T01:51:50Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.73246,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use NerdStorage in your <em>apps</em>",
        "tags": "new relic one <em>apps</em>",
        "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this <em>page</em>, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users&#x27; configuration settings"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    }
  ],
  "/build-apps/permission-manage-apps": [
    {
      "category_2": "Original users and roles",
      "nodeid": 1101,
      "sections": [
        "Original accounts and billing",
        "Original product-based pricing",
        "Original users and roles",
        "SAML SSO (original user model)",
        "Original data retention",
        "Original pricing plan usage",
        "Users and roles (original user model)",
        "Requirements",
        "View and manage users in UI",
        "User types: basic user and full user",
        "Account roles",
        "Add-on roles",
        "Account permissions",
        "Alert permissions",
        "APM permissions",
        "Browser permissions",
        "Infrastructure permissions",
        "Insights permissions",
        "Mobile permissions",
        "Synthetics permissions",
        "Workloads",
        "For more help"
      ],
      "title": "Users and roles (original user model)",
      "category_0": "New Relic accounts",
      "type": "docs",
      "category_1": "Original accounts and billing",
      "external_id": "39c7440fe944f68b4de943d2c9619cbcc85408d2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/original-accounts-billing/original-users-roles/users-roles-original-user-model",
      "published_at": "2021-02-23T08:54:29Z",
      "updated_at": "2021-02-23T01:43:20Z",
      "breadcrumb": "Contents / New Relic accounts / Original accounts and billing / Original users and roles",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic original user model: explanation of how to manage users, and how user roles work. ",
      "body": "Original user model For users on our original user model, an introduction to how the user model works, including user roles and permissions, and how to add and manage users. Requirements This doc and the surrounding section of docs shows you how to manage users who are on our original user model. If you were a New Relic customer before July 30 2020, you likely have users on our original user model (and not the New Relic One user model). One way to quickly check your users' user model: if you can see users in the Users and roles UI, those users are on our original user model. Want to learn more about user model changes? See Overview of user models. View and manage users in UI If your New Relic account has users on our original user model, you can use the Users and roles UI. To access this UI: select the account dropdown, select Account settings, and select Users and roles. Some features in the UI are visible only to account Owners and Admins. You can also use the New Relic REST API to obtain a list of everyone and their roles in your New Relic account. Here are some instructions and tips for adding and managing users via the UI: View pending SAML SSO users New Relic accounts with SAML Single Sign On (SSO) may have a list of Pending users. These are individuals who have been added to the SAML-enabled account but have not yet confirmed. Add a new user Owner or Admins To add a new user to your New Relic account: Go to: account dropdown > Account settings > Users and roles > Users. In the upper right corner, click plus-circle New user. Enter the appropriate name and email address. Select their base role as either Admin, User, or Restricted. Select Add user. The new user will receive an email notification automatically from New Relic. New Relic recommends a maximum of 1,000 accounts per user. Additional accounts may result in limited access to some New Relic features. Update user type To update a user's type (basic user or full user): Go to: account dropdown > Account settings > Users and roles > Users. Select a user and edit its type. You can also bulk update user type changes. For more about this, see User type. Update account roles Owner or Admins To update a person's role and capabilities: Go to: account dropdown > Account settings > Users and roles > Users. Select the person's name. Under Roles and capabilities, select their base role as Admin, User, or Restricted. The account Owner must update the Owner role. Delete a user Owner or Admins To remove a user from your New Relic account: Go to: account dropdown > Account settings > Users and roles > Users. Click on the name of the person you would like to update. Click trash-o Delete User. You can also add, update, or delete users in bulk via CSV file. Update the account Owner A New Relic account can have only one Owner role at any time. You must be the current account Owner to change your role to someone who currently has an Admin role for the account. If the current Owner is unavailable, contact your account representative at New Relic, or get support at support.newrelic.com. You cannot delete or remove your assigned Owner role. However, if the account has one or more Admin role, you can change an Owner to an Admin. Go to: account dropdown > Account settings &gt; Account > Users and roles. Above the Active users list, select [exchange arrows] Change owner. If an account has no Admins, this button won't be available. Select someone who currently has an Admin role for the account. Refresh the page for changes to take effect. Your previous Owner role automatically changes to an Admin role. To find out who is the current assigned Owner: Go to: account dropdown > Account settings > Account > Users and roles. View the Base role column to locate your account Owner. The [exchange arrows] Change owner button is only visible to the current account Owner. If the current Owner is unable to change the role (for example, that person no longer is with your organization), contact your account representative at New Relic, or get support at support.newrelic.com. User types: basic user and full user On the Users and roles UI page, users on our original user model are categorized by user type: full user or basic user. Impacts of user type: If you've switched to New Relic One pricing, the number of full users is a factor in your billing. Otherwise, it's not a factor. To learn more, see Transition to new pricing. Your basic users temporarily do not have restrictions enforced and so have the same permissions as full users. Basic user restrictions will be enforced in the near future. For how to edit this, see Update user type. Account roles A New Relic account can have only one Owner. To share an account with other users in your organization, create Admins, Users, or Restricted Users. Account role Description Owner The person who initially creates the New Relic account and receives all billing queries. The Owner has complete access to all of the account information. Admin Can add, edit, and delete users, and can enable or set up features. User Can use (and optionally set up) New Relic features. In general, Admins take responsibility for setting up features, and Users and Restricted Users can use them. Restricted User One or more individuals who can view (but not set up or change) any New Relic features. The Restricted User role is useful, for example, for demos. You can change your New Relic session settings so that Restricted User logins do not time out, and then set the user interface to Kiosk mode. Add-on roles With add-on roles, you can grant variable levels of access to all users in your account, across the entire platform of New Relic products. This allows you to tailor your account permissions levels to suit the needs of Users and Restricted Users within your account. Giving a User or Restricted User add-on manager access to a product grants them the equivalent of Admin capabilities within the product. They will continue to have User or Restricted User capabilities for all other New Relic products. For example, you could make a software engineer in your company a User in most products, but assign Admin-level access to APM. For another example, you might assign the Nerdpack manager role to a user, and that gives them the ability to subscribe and unsubscribe New Relic One applications to an account. There are two types of add-on roles: Add-on Manager roles are available to grant permissions on a per-product basis. Giving a User or Restricted User managed add-on access to a product grants them the equivalent of Admin capabilities within the product. Custom add-on roles can grant feature-specific permissions across different New Relic products. For example, a group of Users could have the ability to acknowledge incidents and close violations in New Relic Alerts, but not have the ability to modify your existing alert preferences. Individuals on a master account that has sub-accounts automatically have the same level of access for all sub-accounts. Below are options for managing both managed add-on roles and custom add-on roles: View roles To view the list of individuals assigned to your account and their current roles: Go to account dropdown > Account settings > Users and roles. Assign a managed role Owner and Admins Managed add-on roles are available by default for each New Relic product. Adding a managed role for a user grants them Admin-level permissions for the assigned product. They cannot be edited or deleted. To assign a managed add-on role for a User or Restricted User in your account: Go to account dropdown > Account settings > Users and roles. From the list of users associated with your account, select their name. Under Add-on roles, select the type of manager role for the user. To understand which capabilities may be added, use the Capabilities preview chart. Features in the Capabilities preview chart may not exactly match what features are available for your subscription level. You can also add, update, or delete users in bulk by using a CSV file. Create a custom role To create a custom add-on role for your account: Go to account dropdown > Account settings > Users and roles > Roles. Select plus-circle New custom add-on role. Select the capabilities necessary for the new custom role, then Create role. Assign a custom role Owners and Admins You must create a custom role before assigning it to a user. To assign a custom add-on role for a User or Restricted User in your account: Go to account dropdown > Account settings > Users and roles > Users. From the list of users associated with your account, select their name ]. Under Add-on roles, select a custom role for the user. Click Update user. Edit or delete a custom role Owners and Admins You cannot edit or delete New Relic's default roles. However, you can edit or delete custom add-on roles for your account: Go to account dropdown > Account settings > Users and roles > Roles. From the Add-on roles list, select the custom add-on role, then select pencil Edit role or trash-o Delete role as appropriate. Account permissions Here is a summary of basic user rights for your New Relic account. Individuals on a master account with sub-accounts automatically have the same level of access for all sub-accounts. However, they will not receive email notifications for alerts or weekly reports for sub-accounts unless they are explicitly granted permission on these sub-accounts. Function Owner Admin User Restricted Maintain billing information. fa-check Change the account Owner. fa-check Add, update, and delete account Admins, Users, and Restricted Users. When the account Owner and Admins add individuals to the account, New Relic automatically sends them an email message. fa-check fa-check Update users' job titles and roles from Account settings in the New Relic UI. fa-check fa-check Create, modify and delete sub-accounts from Account settings in the New Relic UI. fa-check fa-check Update your own account information (name, password change or password reset request, default account, email preferences, etc.) from User preferences in the New Relic UI. fa-check fa-check fa-check fa-check Change someone else's password. You cannot reset passwords for anyone else on the account, even if you are an Owner or Admin. Instead, follow standard procedures to request a password reset from New Relic. View the list of individuals on the account from (account dropdown) > Account settings > Account > Summary in the New Relic UI. fa-check fa-check fa-check fa-check Manage flexible data retention. fa-check Subscribe and unsubscribe applications to New Relic One fa-check fa-check Alert permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Alerts. To allow a User or Restricted User to execute any of these functions in New Relic Alerts, assign an Alerts add-on manager role. Admin and manager capabilities for Alerts include: Create or name alert policies. Specify incident preferences. Disable or define alert conditions. Provide runbook instructions. Select product targets. Alter alert condition thresholds. Create, modify, or delete notification channels. APM permissions Here is a summary of Admin and Add-on manager capabilities with New Relic APM. To allow a User or Restricted User to execute any of these functions in New Relic APM, assign an APM add-on manager role. Admin and manager capabilities for APM include: Remove applications from the New Relic UI. Delete app traces and error traces. Browser permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Browser. To allow a User or Restricted User to execute any of these functions in New Relic Browser, assign a Browser add-on manager role. Admin and manager capabilities for Browser include: Add, rename, or delete applications. Manage whitelists. Manage domain conditions. Infrastructure permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Infrastructure. To allow a User or Restricted User to execute any of these functions in New Relic Infrastructure, assign an Infrastructure manager role. Admin and manager capabilities for Infrastructure include: Create alert conditions in New Relic Infrastructure, including conditions for host not reporting. Add or modify integrations. Insights permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Insights. To allow a User or Restricted User to execute any of these functions in New Relic Insights, assign an Insights manager role. These functions include: Create, view, modify, or delete Query API keys or Insert API keys. New Relic Insights includes permission levels to share your Insights dashboards with others. Mobile permissions To give permission to delete a mobile app from New Relic, you can assign an Admin or Mobile manager role. ‚Äã‚Äã‚Äã Synthetics permissions Here's a summary of Admin and Add-on manager capabilities with New Relic Synthetics. To allow a User or Restricted User to execute any of these functions in New Relic Synthetics, assign a Synthetics add-on manager role. Admin and manager capabilities for Synthetics include: Create, edit, or delete monitors. Edit monitor scripts. Create, edit, or delete private locations. Create, edit, or delete monitor downtimes. Create, view, edit, or delete secure credentials. For more information, see User roles in Synthetics. Workloads Here's a summary of Admin and Add-on manager capabilities with New Relic One workloads: Create, duplicate, modify, or delete workloads. Link dashboards to workloads and save filters. To allow a User or Restricted User to execute these functions, assign the workloads manager add-on role. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.06296,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Account <em>permissions</em>",
        "info": "For New Relic original user model: explanation of how to <em>manage</em> users, and how user roles work. ",
        "body": " for APM include: Remove applications from the New Relic UI. Delete <em>app</em> traces and error traces. Browser <em>permissions</em> Here is a summary of Admin and Add-on <em>manager</em> capabilities with New Relic Browser. To allow a User or Restricted User to execute any of these functions in New Relic Browser, assign"
      },
      "id": "5f3e194028ccbc18c7f56de3"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/2g790g7la1iot/promo-image.1573253956.png",
      "url": "https://learn.newrelic.com/live-learncast-new-relic-one-programmability",
      "sections": [
        "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications.",
        "About this Learncast",
        "Prerequisites",
        "Virtual Training Session List"
      ],
      "published_at": "2021-02-25T01:39:49Z",
      "title": "Live Learncast: New Relic One Programmability",
      "updated_at": "2021-01-02T01:38:56Z",
      "type": "",
      "external_id": "053510b559767dbde34e3f1ee9a73bbf813a5a83",
      "popularity": 1,
      "body": "Sign In Live Learncast: New Relic One Programmability Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. Not currently available Available until July 10, 2020, 3:30 p.m. PDT. Already registered? Sign In About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. ¬† During this session we will review the following topics: ¬† 1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites ¬† This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications. ¬† Must have: ¬† Permissions to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. ¬† During this session we will review the following topics: ¬† 1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites ¬† This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications. ¬† Must have: ¬† Permissions to install¬† Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) ¬© 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.88285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic <em>Applications</em>.",
        "body": " A text editor or IDE of your choice (we will be using VS Code) <em>Nerdpack</em> <em>manager</em> roll to deploy ¬† Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials"
      },
      "id": "5dc618cbe7b9d2a0a8e4649c"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Permissions for managing applications",
        "Publish and deploy apps",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Build apps",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Permissions for managing applications ¬† Learn about permissions for subscribing to apps Publish and deploy apps 30 min Start sharing the apps you build Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.70947,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "<em>Permissions</em> for <em>managing</em> <em>applications</em>",
        "body": " <em>Permissions</em> for <em>managing</em> applications ¬† Learn about <em>permissions</em> for subscribing to <em>apps</em> Publish and deploy <em>apps</em> 30 min Start sharing the <em>apps</em> you build Set up your development environment 20 min Prepare to build <em>apps</em> and contribute to this site"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "nodeid": 9921,
      "sections": [
        "Install and configure the infrastructure agent",
        "Get started",
        "Linux installation",
        "Windows installation",
        "Config management tools",
        "Configuration",
        "Update or uninstall",
        "Manage your agent",
        "Requirements for the infrastructure agent",
        "Processor architectures",
        "Operating systems",
        "Unique hostname",
        "Permissions",
        "Libraries",
        "Network access",
        "Container software",
        "CPU, memory, and disk usage",
        "Configuration management tools",
        "For more help"
      ],
      "title": "Requirements for the infrastructure agent",
      "category_0": "Infrastructure monitoring",
      "type": "docs",
      "category_1": "Install and configure the infrastructure agent",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/infrastructure/install-infrastructure-agent/get-started/requirements-infrastructure-agent",
      "external_id": "71d7349826202468aec8827527896e9bd07d0b2b",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/amazon%20linux.png",
      "url": "https://docs.newrelic.com/docs/infrastructure/install-infrastructure-agent/get-started/requirements-infrastructure-agent",
      "published_at": "2021-02-23T09:31:50Z",
      "updated_at": "2021-02-23T09:31:50Z",
      "breadcrumb": "Contents / Infrastructure monitoring / Install and configure the infrastructure agent / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "Compatibility information for infrastructure monitoring, including supported Linux and Windows versions.",
      "body": "Before installing our infrastructure agent, make sure your system and any on-host integrations you configure meet the requirements. Processor architectures The infrastructure agent supports only x86 processor architectures: Linux: 64-bit architecture (also requires 64-bit package manager and dependencies) Windows: both 32 and 64-bit architectures ARM: AWS Graviton 2 processor (using the tarball setup instructions). Support is limited to infrastructure monitoring. Integrations, such as log forwarding, may not work as expected. Operating systems The infrastructure agent supports these operating systems: Operating system Supported by the infrastructure agent Amazon Linux All versions CentOS Version 7 or higher Debian Version 8 (\"Jessie\") or higher Docker Docker 1.12 Kubernetes Tested with versions 1.10 to 1.16 Red Hat Enterprise Linux (RHEL) Version 6 or higher SUSE Linux Enterprise Server (SLES) Versions 11.4, 12.1, 12.2, 12.3, and 12.4 Ubuntu LTS versions 14.04.x, 16.04.x, 18.04.x, 20.04.x Windows Windows Server 2012, 2016, and 2019, and their service packs. Windows 10 (only the infrastructure agent is supported). Operating systems are not supported beyond end-of-life. You can monitor Amazon BottleRocket workloads: When running EC2 instances, use the containerized agent. On EKS, install the Kubernetes integration. For ECS clusters, deploy the ECS integration. Unique hostname The infrastructure agent uses the hostname to uniquely identify each server. To avoid inaccurate metrics from combining multiple servers under a single hostname, make sure that each monitored server has a unique hostname. You can use the optional display_name setting to override the default hostname. Servers named localhost are not reported: it's a default name and inherently non-unique. Permissions The infrastructure agent requires these permissions: Linux: By default, the agent runs and installs as root. You can also select privileged or unprivileged run modes. Windows: The agent must be installed from an Administrator account and requires Administrator privileges to run. Libraries For agent versions 1.1.19 or higher, you need the libcap library in order to install Infrastructure. It's available in the official repositories of your distribution. Network access In order to report data to New Relic, our infrastructure agent must have outbound access to certain domains and ports. If your system needs a proxy to connect to these domains, use the proxy setting. Container software The infrastructure agent instruments Docker containers when installed on the host server. We support Docker versions 1.12 or higher. CPU, memory, and disk usage The infrastructure agent is fairly lightweight. For typical CPU, memory, and disk usage, see our page on agent performance overhead. For more information on supported file systems, see Storage sample attributes. Configuration management tools The infrastructure agent can be deployed programmatically using several config management and deploy tools: Ansible Chef Elastic Beanstalk Puppet For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.74211,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Permissions</em>",
        "body": "Before installing our infrastructure agent, make sure your system and any on-host integrations you configure meet the requirements. Processor architectures The infrastructure agent supports only x86 processor architectures: Linux: 64-bit architecture (also requires 64-bit package <em>manager</em>"
      },
      "id": "5f57ecf0e7b9d21d5facfd7b"
    },
    {
      "category_2": "Cloud integration release notes",
      "nodeid": 42446,
      "sections": [
        "Infrastructure agent release notes",
        "Cloud integration release notes",
        "Kubernetes integration release notes",
        "Usage of AWS Resource Tagging API (RTA)",
        "New"
      ],
      "title": "Usage of AWS Resource Tagging API (RTA)",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "Infrastructure agent release notes",
      "external_id": "6a6087ba6c03e79fa4ad3cc52c6878657cdfd95e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/infrastructure-release-notes/cloud-integration-release-notes/usage-aws-resource-tagging-api-rta",
      "published_at": "2021-02-23T07:38:26Z",
      "updated_at": "2021-02-15T17:13:14Z",
      "breadcrumb": "Contents / Release notes / Infrastructure agent release notes / Cloud integration release notes",
      "document_type": "release_notes",
      "popularity": -2,
      "body": "[RSS] Released on:¬† Thursday, June 4, 2020 - 00:00 New Some of our AWS integrations now use the AWS Resource Tagging API (RTA) for fetching AWS tags. This reduces the requests related to fetching tags by approximately 90% for selected AWS integrations, and reduces throttling considerably. This feature requires new permissions: We sent a communication with instructions to all customers without the required permissions for the following integrations: ALB, CloudFront, DynamoDB, ECS, EFS, Elastic BeanStalk, ElastiCache, ElasticSearch, ELB, Kinesis Streams, Lambda, RDS, Route53, SQS and S3. The new permissions can be enabled till August 5th 2020. If you have questions or doubts about this change, reach out the New Relic account team. Azure AppService Integration: WebApp slots are now supported. AWS DocumentDB Integration: support for tags. The following integrations have been launched as beta: [Beta] GCP Cloud Run [Beta] GCP Firebase Hosting [Beta] GCP Firebase Database [Beta] GCP Firebase Storage [Beta] GCP Firestore [Beta] AWS Transit Gateway",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.77217,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". The new <em>permissions</em> can be enabled till August 5th 2020. If you have questions or doubts about this change, reach out the New Relic account team. Azure <em>App</em>Service Integration: Web<em>App</em> slots are now supported. AWS DocumentDB Integration: support for tags. The following integrations have been launched"
      },
      "id": "602aabaae7b9d28f712b2d88"
    }
  ],
  "/build-apps/set-up-dev-env": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-02-25T01:55:33Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.21507,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": "To build a¬†<em>New</em> <em>Relic</em> <em>One</em> app, you must install the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (command line interface). This page explains how to use¬†<em>CLI</em> commands¬†to: Generate"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "category_2": "Intro to APIs",
      "nodeid": 2151,
      "sections": [
        "Get started",
        "Intro to APIs",
        "New Relic API keys",
        "Manage API keys in UI",
        "Overview of API keys",
        "User key",
        "License key",
        "Browser key",
        "REST API key",
        "Insights insert key",
        "Insights query key",
        "Admin key",
        "For more help"
      ],
      "title": "New Relic API keys",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "Get started",
      "external_id": "2ddcc49d4758c7a3a8a69294ea7bd31da55438ea",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/get-started/intro-apis/new-relic-api-keys",
      "published_at": "2021-02-22T21:25:33Z",
      "updated_at": "2021-02-17T13:21:46Z",
      "breadcrumb": "Contents / APIs / Get started / Intro to APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Types of New Relic API keys, who can use them, and how to add, update, or delete API keys.",
      "body": "New Relic has several different APIs that each require their own type of API key to use. This resource describes our API keys, what they're used for, and how to access them. Manage API keys in UI Here's a direct link to the API keys UI page. To find this from the New Relic UI: From the account dropdown, select Account settings. Select API keys. Overview of API keys The table below summarizes our available API keys and their uses. Some keys are able to be used by more than one API. If you're using a specific API, see the docs for that API to understand which keys are required and recommended. Key type What it's for Where to access User key (aka \"personal API key\") Used for NerdGraph (our GraphQL API) and for accessing REST API endpoints (dependent on user permissions). API keys UI License key Allows ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. API keys UI Insights insert key (aka \"Insert key\") Allows ingestion of events via HTTPS request from our metric, log, trace, and event APIs and the tools that use those APIs. Go to the API keys UI and click Insights insert key. Browser key Allows ingestion of browser monitoring data. API keys UI Mobile key (aka \"mobile app token\") Allows mobile monitoring data to be sent to New Relic. See Mobile app token. REST API key Note: we recommend using the user key instead because it has fewer limitations. The REST API key is for using our REST APIs for Alerts, APM, Browser, Infrastructure alerts, as well as Mobile REST APIs and the API Explorer. Go to the API keys UI and click REST API key. Admin API key As of December 4, 2020, all existing admin keys have been migrated to be user keys. For more information, see Admin key and User key below. API keys UI (will appear as user keys) Insights query key (aka \"Query key\") This key allows use of the Insights query API. Note: we now recommend using NerdGraph to query New Relic data. Go to the API keys UI and click Insights query key. User key New Relic user keys (previously referred to as \"personal API keys\") are required for NerdGraph (our GraphQL API), which allows you to query most New Relic data and do some types of configuration. User keys also let you use our REST API, with restrictions based on your permissions. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a user key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select User. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a user key Go to the API keys UI. In the row of the user key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a user key Go to the API keys UI. In the row of the user key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. In December 2020, user keys supplanted Admin API keys. For details, see Admin API key. License key New Relic license keys allow the ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. If you're using a specific API, see the docs for that API to understand which keys are required or recommended. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a license key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select License. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a license key Go to the API keys UI. In the row of the license key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a license API key Go to the API keys UI. In the row of the license key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. You can't manage or delete an original license key that was created when your account was created. For that, contact New Relic support. Browser key The browser key allows the ingestion of data from New Relic browser monitoring. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a browser key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select Browser. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a browser key Go to the API keys UI. In the row of the browser API key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a browser key Go to the API keys UI. In the row of the browser API key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. You can't manage or delete an original browser key that was created when your account was created. For that, contact New Relic support. REST API key We recommend using a user key to use the REST API because that key has fewer limitations. You can use a REST API key with our REST API and the API Explorer. For parent accounts with sub-accounts, each sub-account must use its own REST API key. Availability: Each New Relic account can have only one REST API key. Activate or change REST API key Go to the API keys UI and select REST API key. Click Regenerate REST API key. Click (Show key) to view your account's new REST API key. Copy your account's REST API key to use with New Relic's REST API. View REST API keys To view REST API keys: Go to the API keys UI and select REST API key. Click (Show key) to view your account's new REST API key. Delete REST API key To delete your account's REST API key: Before you delete an API key, make sure you have the correct account or sub-account. Go to the API keys UI and select REST API key. Select the delete [trash can icon] icon for the REST API key. Confirm the deletion by typing DELETION IS FOREVER in the text field. Select Delete. Insights insert key The Insights insert key (aka the \"Insert key\") is required for the ingestion of data via our Event API, Log API, Metric API, and Trace API, or via tools that use those APIs. Tips on availability and access: Because these keys are associated with an account and not a specific user, anyone in the account with access to a key can use it. As a best practice for security purposes, we recommend you use different Insights insert keys for different applications or different data sources. Generate an Insights insert key Go to the API keys UI and select Insights insert keys. Next to the Insert keys heading, select the + button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights insert key Go to the API keys UI and select Insights insert keys. Under Insert Keys, find the key you want to modify. Select Edit or Delete. Insights query key The Insights query key is used for our Insights query API: we now recommend using NerdGraph for querying New Relic data. Generate an Insights query key You must have access to the UIs you plan to query and the correct permissions in order to register or modify this key. Insights query keys are generated per account; they're not associated with a specific user. This means that any user in an account with access to a query key can use it. To register this key: Go to the API keys UI and select Insights query keys. Next to the Query Keys heading, select the + button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights query key To edit or delete this key: Go to the API keys UI page and select Insights query keys. Under Query Keys, find the key you want to modify. Select Edit or Delete. Admin key As of December 4, 2020, all existing admin keys have been migrated to be user keys. You don‚Äôt need to do anything for existing admin keys to remain active. They will be automatically accessible via the API keys UI, labeled as user keys, and granted identical permissions. You can manage them as you would any user key via the same workflow. All migrated admin keys will have a note that says ‚ÄúMigrated from an admin user key‚Äù in the key table, so you‚Äôll be able to find them easily. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.10739,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>API</em> <em>keys</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>API</em> <em>keys</em>",
        "info": "Types of <em>New</em> <em>Relic</em> <em>API</em> <em>keys</em>, who can use them, and how to add, update, or delete <em>API</em> <em>keys</em>.",
        "category_0": "<em>APIs</em>",
        "category_2": "Intro to <em>APIs</em>",
        "body": " <em>API</em> and the <em>API</em> Explorer. For parent accounts with sub-accounts, each sub-<em>account</em> must use its own REST <em>API</em> <em>key</em>. Availability: Each <em>New</em> <em>Relic</em> <em>account</em> can have only <em>one</em> REST <em>API</em> <em>key</em>. Activate or change REST <em>API</em> <em>key</em> Go to the <em>API</em> keys UI and select REST <em>API</em> <em>key</em>. Click Regenerate REST <em>API</em> <em>key</em>. Click"
      },
      "id": "602d186a196a67d358b0020f"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Important",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2021-02-25T01:58:11Z",
      "updated_at": "2021-01-16T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Access the New Relic platform from the comfort of your terminal. You can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. In short, you can use the CLI to automate common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic user key. An instrumented application in your New Relic account. Step 1 of 10 Install the New Relic CLI Download the New Relic CLI for your operating system, as described below. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Using Snapcraft, run: bash Copy $ sudo snap install newrelic-cli macOS Using Homebrew, run: bash Copy $ brew install newrelic-cli Windows Using Scoop, run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile. After you install the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_USER_KEY -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles default -n tutorial Important You must set the region of your New Relic account. Use -r to set either us or eu. Step 3 of 10 Get your application details. Now, add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 Retrieve your application details as a JSON object. To search for your APM application, use the apm application search command: bash Copy $ newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Tip If you get an error, check that your account ID and application name are correct. Step 5 of 10 Find the guid value. If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example: [ { \"accountId\": YOUR_ACCOUNT_ID, \"applicationId\": YOUR_APP_ID, \"domain\": \"APM\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"A_LONG_GUID\", \"name\": \"NAME_OF_YOUR_APP\", \"permalink\": \"https://one.newrelic.com/redirect/entity/A_LONG_GUID\", \"reporting\": true, \"type\": \"APPLICATION\" } ] Copy When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. Step 6 of 10 Add a simple tag to your application. Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Here, you add an environment tag to your application. Add the dev:testing tag‚Å† (or any other key-value pair) to your application using the entities tags create command: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Step 7 of 10 Add tag sets. What if you want to add multiple tags? Tag sets to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags to your application at once, modify and run this snippet: bash Copy $ newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Important Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 Retrieve your application's tags. You've created and added some tags to your application, but to test that they're working, you need to retrieve them. Run the entity tags get command: bash Copy $ newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array: [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Step 9 of 10 Bonus step: create a deployment marker. Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same application ID from your earlier search: bash Copy $ newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Step 10 of 10 Check the JSON response for the revision and timestamp of the deployment. You can build this workflow into a continuous integration or continuous deployment (CI/CD) system to indicate changes in your application's behavior after deployments. Here's an example: { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands in the New Relic CLI. For example, you can create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.04945,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " apply to any <em>CLI</em> command, which is useful when switching between accounts. Run the profiles add command: bash Copy $ # Create the tutorial <em>account</em> for the US region $ newrelic profiles add -n tutorial --<em>apiKey</em> YOUR_<em>NEW_RELIC_USER_KEY</em> -r YOUR_REGION $ # Set the profile as defaults $ newrelic profiles"
      },
      "id": "5efa999c196a67c4e1766461"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Important",
        "Check that the tags are there",
        "Tip",
        "Next steps",
        "This site uses cookies üç™"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2021-01-16T01:52:06Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need a New Relic user key: You can view and create them in the API keys UI. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux Install Snapcraft, and then run: bash Copy $ sudo snap install newrelic-cli macOS Install Homebrew, and then run: bash Copy $ brew install newrelic-cli Windows Install Scoop, and then run: bash Copy $ scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git $ scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). bash Copy $ # Create the tutorial account for the US region $ newrelic profiles add -n tutorial --apiKey API_KEY -r us $ # Set the profile as default $ newrelic profiles default -n tutorial Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In this example, you're searching for all entities with \"test\" in their name. bash Copy $ # Change the `name` to match any of your existing entities $ newrelic entity search --name \"test\" Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Copy or write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity Using your entity guid, you can add tags right away. Invoke the entities tags create command. If you want to add multiple tags, use tag sets: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Important Adding tags is an asynchronous operation: it could take a little while for the tags to get created. bash Copy $ # Adding a single tag $ newrelic entity tags create --guid GUID --tag key:value $ # Adding multiple tags $ newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { \"Key\": \"tag1\", \"Values\": [\"true\"] }, { \"Key\": \"tag2\", \"Values\": [\"test\"] }, { \"Key\": \"tag3\", \"Values\": [\"testing\"] } // ... ] Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.81056,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " of your entities. Before you begin For this guide you need a <em>New</em> <em>Relic</em> user <em>key</em>: You can view and create them in the <em>API</em> keys UI. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> for macOS, Windows, and Linux. You can also download pre-built binaries for all platforms, including"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure",
        "This site uses cookies üç™"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ launchers ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json ‚îú‚îÄ‚îÄ nerdlets ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss ‚îú‚îÄ‚îÄ node_modules ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler ‚îú‚îÄ‚îÄ nr1.json ‚îú‚îÄ‚îÄ package-lock.json ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.02148,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> command nr1 create and select Nerdpack to create a Nerdpack template that includes"
      },
      "id": "5efa989e196a671300766404"
    }
  ],
  "/build-apps/add-nerdgraphquery-guide": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Permissions for managing applications",
        "Publish and deploy apps",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Build apps",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Permissions for managing applications ¬† Learn about permissions for subscribing to apps Publish and deploy apps 30 min Start sharing the apps you build Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 862.85645,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add the <em>NerdGraphQuery</em> <em>component</em> to an <em>application</em>",
        "body": " building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the <em>NerdGraphQuery</em> <em>component</em> to an application 20 minutes The <em>NerdGraphQuery</em> <em>component</em> allows you to <em>query</em> <em>data</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/nerd-graph-query/",
      "sections": [
        "NerdGraphQuery",
        "Usage",
        "Examples",
        "Example 1",
        "Props",
        "Methods",
        "NerdGraphQuery.render",
        "NerdGraphQuery.query",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:54:21Z",
      "title": "NerdGraphQuery",
      "updated_at": "2021-01-29T01:58:06Z",
      "type": "developer",
      "external_id": "1ada6e056e031c141b2bb989e4ec200b3a7ce988",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One SDK provides Query components based on ApolloClient's query components. These components are an abstraction layer making it easier to query NerdGraph without worrying about configuring Apollo Client and, for the most common use cases, without having to write GraphQL queries. A generic NerdGraph Query component that allows you to query anything from NerdGraph. Usage import { NerdGraphQuery } from 'nr1' Copy Examples Example 1 1 function render() { 2 const query = ` 3 query($id: Int!) { 4 actor { 5 account(id: $id) { 6 name 7 } 8 } 9 } 10 `; 11 12 const variables = { 13 id: 1, 14 }; 15 16 return ( 17 <NerdGraphQuery query={query} variables={variables}> 18 {({ loading, error, data }) => { 19 if (loading) { 20 return <Spinner />; 21 } 22 23 if (error) { 24 return 'Error!'; 25 } 26 27 return <BlockText>{data.actor.account.name}</BlockText>; 28 }} 29 </NerdGraphQuery> 30 ); 31 } Copy Props childrenfunction Render prop function as a child. function ( queryResult : {Object // Results of the query. ) => undefined fetchPolicyTypeenum DEFAULT NerdGraphQuery . FETCH_POLICY_TYPE . CACHE_AND_NETWORK Fetch policy to be used for the query. Allows you to specify how you want your query to interact with the cached data. CACHE_AND_NETWORK: The query returns your initial data from the cache if available. However, regardless of whether or not the full data is in your cache, the query always makes a request using your network interface and returns the updated data. This option is not available when using the static query() method of the component. CACHE_FIRST: The query makes a request using your network interface only if the data for your query is not already in the cache. CACHE_ONLY: The query never makes a request using your network interface. Instead it returns the data available in the cache. If the data for your query does not exist in the cache, then an error is thrown. NETWORK_ONLY: The query never returns your initial data from the cache. Instead it always makes a request using your network interface. NO_CACHE: The query never returns your initial data from the cache. Instead it always makes a request using your network interface. Unlike the NETWORK_ONLY policy, it does not write any data to the cache after the query completes. <One of NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_AND_NETWORK , NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_FIRST , NerdGraphQuery.FETCH_POLICY_TYPE.CACHE_ONLY , NerdGraphQuery.FETCH_POLICY_TYPE.NETWORK_ONLY , NerdGraphQuery.FETCH_POLICY_TYPE.NO_CACHE , > pollIntervalnumber DEFAULT 0 Interval in milliseconds to poll for new data. queryrequiredstring|object GraphQL query, either as a string or a GraphQL document parsed into an AST by the gql method of nr1. Example 1 1 import { ngql } from 'nr1'; 2 3 const query = ngql` 4 { 5 actor { 6 user { 7 id 8 email 9 name 10 } 11 } 12 } 13 `; Copy variablesobject Object containing all the variables your query needs to execute. Methods NerdGraphQuery.render function () => undefined NerdGraphQuery.query function () => undefined",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 534.24084,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraphQuery</em>",
        "sections": "<em>NerdGraphQuery</em>",
        "body": " <em>NerdGraph</em> <em>Query</em> <em>component</em> that allows you to <em>query</em> anything from <em>NerdGraph</em>. Usage import { <em>NerdGraphQuery</em> } from &#x27;nr1&#x27; Copy Examples Example 1 1 function render() { 2 const <em>query</em> = ` 3 <em>query</em>($id: Int!) { 4 actor { 5 <em>account</em>(id: $id) { 6 name 7 } 8 } 9 } 10 `; 11 12 const variables = { 13 id: 1, 14"
      },
      "id": "5efa999d28ccbc6bfd307ddb"
    },
    {
      "category_2": "Examples",
      "nodeid": 42656,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "Golden metrics for entities NerdGraph API tutorial",
        "Fetch golden metrics",
        "Fetch golden tags",
        "Customize golden metrics and golden tags",
        "Override golden metrics or golden tags for a specific entity type in your whole account",
        "Override golden metrics from a particular entity type in a workload",
        "Fetch the custom golden metrics and golden tags",
        "Reset custom metrics and golden tags",
        "Expected errors",
        "For more help"
      ],
      "title": "Golden metrics for entities NerdGraph API tutorial",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "956bc04201d39123c3cb69777298c967ab1c4cfd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/golden-metrics-entities-nerdgraph-api-tutorial",
      "published_at": "2021-02-23T07:47:19Z",
      "updated_at": "2021-02-21T15:35:42Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic's NerdGraph (our GraphQL API) to query or override golden metrics and tags.",
      "body": "Golden metrics and golden tags are bits of information about an entity that we consider to be the most important for that entity. We use this information to display a brief overview of an entity across all New Relic. You can see and contribute to the standard definitions of the golden metrics and tags in this public repository. This document explains how to query an entity's custom metrics using NerdGraph. For more on how to query entities using the NerdGraph API, see our tutorial. Fetch golden metrics When fetching golden metrics for a specific GUID or list of GUIDS, the provided queries are already filtered for you. You can run the resulting query as is in the query builder. The resulting metric can be either a timeseries or a single value. Here's an example of one golden metric query for an AWS DynamoDB table entity with the GUID ExampleGUID. SELECT average(provider.getSuccessfulRequestLatency.Average) FROM DatastoreSample WHERE entityGuid IN ('ExampleGUID') AND provider='DynamoDbTable' TIMESERIES You can use NerdGraph to query for the golden metrics of a specific entity; for example: { actor { entity(guid: \"ENTITY-GUID\") { goldenMetrics { query title } } } } Fetch golden tags Golden tags are always represented the same way, whether requested by GUID or by entityType. You will always receive the list of tag keys considered the most important about the entity. { actor { entity(guid: \"ENTITY-GUID\") { goldenTags { key } } } } Customize golden metrics and golden tags If you want to change the golden metrics and golden tags based on the specificities of your environment, you can override them in two different contexts, in your account, or in a workload. Override golden metrics or golden tags for a specific entity type in your whole account In this case, the new golden metrics or the new golden tags will be applied in all New Relic One, converting your new metrics and tags as the default for the specified entity type. To do that, you can use a NerdGraph mutation to override the golden metrics for a specific entity. mutation { entityGoldenMetricsOverride( context: {account: ACCOUNT_TO_OVERRIDE_GOLDEN METRICS}, domainType: {domain: DOMAIN, type: TYPE}, metrics: [ {eventId: EVENT_ID, select: NRDB_QUERY_SELECT, from: NRDB_QUERY_EVENT, where: NRDB_QUERY_WHERE, title: TITLE_OF_THE_METRIC, facet: FACET, name: NAME_OF_THE_METRIC}, ...]) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } Where: domainType: The entity type of the metrics to override. context: The context to fetch the golden metrics from. In this case, you should set the account that you want to override. metrics: The new NRDB query will be shown as golden metrics. eventId: The field used to filter the entity in the metric. How the entity GUID is defined in your event. select: The SELECT clause of the NRDB query. This field is required. from: The FROM clause of the NRDB query. where: Complementary where clause to identify the entity type field. facet: The field to FACET. title: The title of the golden metric. This field is optional. name: The name of the golden metric. This field is required. Override an APM application mutation { entityGoldenMetricsOverride( context: {account: ACCOUNT_ID}, domainType: {domain: \"APM\", type: \"APPLICATION\"}, metrics: [ {eventId: \"entity.guid\", from: \"Transaction\", name: \"cpuUsage\", select: \"max(cpuUsage)\", title: \"CPU Usage\"}, {eventId: \"guid\", from: \"Metric\", where: \"metricTimesliceName in ('HttpDispatcher', 'OtherTransaction/all')\", facet: \"appName\", select: \"count(newrelic.timeslice.value)\", name: \"throughput\", title: \"Throughput\"}]) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } The metrics input object defines the parts of an NRDB query, split into sections. One of these sections is the eventId, which is used to identify the field that defines the GUID inside the NRDB Event you want to use as a golden metric. For example: SELECT average(provider.getSuccessfulRequestLatency.Average) FROM DatastoreSample WHERE entityGuid IN ('EntityGuid') AND provider='DynamoDbTable' FACET entityName TIMESERIES It's defined as follows: { eventId: \"entityGuid\", from: \"DatastoreSample\", where: \"provider='DynamoDbTable'\", facet: \"entityName\", select: \"average(provider.getSuccessfulRequestLatency.Average)\", name: GetItem latency (ms), title: GetItem latency (ms) } As you can see in the resultant object, the where clause only contains the provider field. The system adds the where clause with the eventId field by default. You can do the same for the golden tags using this NerdGraph mutation: mutation { entityGoldenTagsOverride( context: {account: ACCOUNT_ID}, domainType: {domain: \"APM\", type: \"APPLICATION\"}, tags: [{key: \"applicationName\"} , {key: \"environment\"} ]) { errors { message type } tags { context { account } domainType { domain type } tags { key } } } } Override golden metrics from a particular entity type in a workload New Relic's workloads provide an aggregated view of health and performance data about a group of entities. The time series charts shown for each entity type in a workload are defined by the golden metrics in the workload account. If you want to further customize which time series to show for a specific entity type in a particular workload, override the golden metrics in the account with the following mutation: mutation { entityGoldenMetricsOverride( context: {guid: WORKLOAD_TO_OVERRIDE_GOLDEN METRICS}, domainType: {domain: DOMAIN, type: TYPE}, metrics: [ {eventId: EVENT_ID, select: NRDB_QUERY_SELECT, from: NRDB_QUERY_EVENT, where: NRDB_QUERY_WHERE, title: TITLE_OF_THE_METRIC, facet: FACET, name: NAME_OF_THE_METRIC}, ...]) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } See above for details on each field. In this case, context is the workload's GUID. Override an APM application mutation { entityGoldenMetricsOverride( context: {guid: WORKLOAD_ENTITY_GUID}, domainType: {domain: \"APM\", type: \"APPLICATION\"}, metrics: [ {eventId: \"entity.guid\", from: \"Transaction\", name: \"cpuUsage\", select: \"max(cpuUsage)\", title: \"CPU Usage\"}, {eventId: \"guid\", from: \"Metric\", where: \"metricTimesliceName in ('HttpDispatcher', 'OtherTransaction/all')\", facet: \"appName\", select: \"count(newrelic.timeslice.value)\", name: \"throughput\", title: \"Throughput\"}]) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } Fetch the custom golden metrics and golden tags The queries defined in the previous sections always return the default golden metrics and golden tags. If you want to fetch your custom golden metrics or golden tags, you need to send the context defined in the query, for example: { actor { entity(guid: INFRA-AWSDYNAMODBTABLE-GUID) { goldenMetricsByContext( context: {account: ACCOUNT_ID, guid: WORKLOAD_ENTITY_GUID}) { metrics { title query name } } } } } For golden tags: { actor { entity(guid: INFRA-AWSDYNAMODBTABLE-GUID) { goldenTags(context: {account: ACCOUNT_ID, guid: WORKLOAD_ENTITY_GUID}) { tags { key } } } } } You can send both contexts simultaneously for querying, if your metrics or tags have the context inside the workload. The API returns the most specific golden metric or golden tags based on the context that you defined in the requests. The priority is workload and account. Reset custom metrics and golden tags If your custom golden metrics are not relevant to you any more, you can restore the defaults defined by New Relic. In the context parameter, set the desired account or workload guid (in the guid parameter). To restore your golden metrics in an account, run this query: mutation { entityGoldenMetricsReset( context: {guid: ACCOUNT_TO_OVERRIDE_GOLDEN_METRICS}, domainType: {domain: DOMAIN, type: TYPE}) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } Where: domainType: The entity type of the metrics to override. context: The context to fetch the golden metrics from. In this case, you should set the account you want to reset. To restore your golden metrics in a workload, run this query: mutation { entityGoldenMetricsReset( context: {guid: GUID_TO_OVERRIDE_GOLDEN_METRICS}, domainType: {domain: DOMAIN, type: TYPE}) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } You can do the same for your custom golden tags: mutation { entityGoldenTagsReset( context: {guid: WORKLOAD_ENTITY_GUID}, domainType: {domain: \"APM\", type: \"APPLICATION\"}) { errors { message type } tags { key context { account guid } domainType { domain type } tags { key } } } } Expected errors All these mutations can answer with the result of the operation or a list of errors. These are all the expected errors that you can receive: INVALID_CONTEXT: The context is not valid. There can only be one context, an account or a workload's GUID. If you use both, or use any other concept, or a GUID that doesn't belong to a workload, you will get this error. INVALID_DOMAIN_TYPE: The domain type is not valid. LIMIT_EXCEEDED: The maximum amount of metrics is 9. If you exceed this limit you will get this error. NOT_AUTHORIZED: The user doesn't have the permissions to carry out this action. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 392.99237,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Golden <em>metrics</em> for entities <em>NerdGraph</em> API tutorial",
        "sections": "Golden <em>metrics</em> for entities <em>NerdGraph</em> API tutorial",
        "info": "Use New Relic&#x27;s <em>NerdGraph</em> (our <em>GraphQL</em> API) to <em>query</em> or override golden <em>metrics</em> and tags.",
        "category_1": "<em>NerdGraph</em>",
        "body": " and tags in this public repository. This document explains how to <em>query</em> an entity&#x27;s custom metrics using <em>NerdGraph</em>. For more on how to <em>query</em> entities using the <em>NerdGraph</em> API, see our tutorial. Fetch golden metrics When fetching golden metrics for a specific GUID or list of GUIDS, the provided queries",
        "breadcrumb": "Contents &#x2F; APIs &#x2F; <em>NerdGraph</em> &#x2F; Examples"
      },
      "id": "60327dcfe7b9d2f2838b3bb0"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/nerd-graph-mutation/",
      "sections": [
        "NerdGraphMutation",
        "Usage",
        "Examples",
        "Do a mutation",
        "Do mutation and refetch query",
        "Props",
        "Example 1",
        "Methods",
        "NerdGraphMutation.render",
        "NerdGraphMutation.mutate",
        "Type definitions",
        "PromiseQueryResult",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:55:31Z",
      "title": "NerdGraphMutation",
      "updated_at": "2021-01-29T01:58:06Z",
      "type": "developer",
      "external_id": "12d0744f112e48cd91b3d640657329423ab2faec",
      "document_type": "page",
      "popularity": 1,
      "body": "A generic NerdGraph mutation component that allows you to mutate anything from NerdGraph. Usage import { NerdGraphMutation } from 'nr1' Copy Examples Do a mutation 1 NerdGraphMutation.mutate({ 2 mutation: ngql` 3 mutation($guid: EntityGuid!) { 4 taggingAddTagsToEntity( 5 guid: $guid 6 tags: { key: \"team\", values: [\"ui\"] } 7 ) { 8 errors { 9 message 10 } 11 } 12 } 13 `, 14 variables: { 15 guid: 'XXXXXXXXXXX', 16 }, 17 }); Copy Do mutation and refetch query 1 function render() { 2 const mutation = ngql` 3 mutation($guid: EntityGuid!) { 4 taggingAddTagsToEntity(guid: $guid, tags: $tags) { 5 errors { 6 message 7 } 8 } 9 } 10 `; 11 const variables = { 12 guid: 'XXXXXXXXXXX', 13 tags: { key: 'team', values: ['ui'] }, 14 }; 15 16 // NOTE: Sometimes mutations take awhile so doing a refetch immediatly after a mutate 17 // doesn't show any change. 18 return ( 19 <NerdGraphQuery query={query} variables={variables}> 20 {({ data, refetch }) => ( 21 <> 22 <RenderData data={data} /> 23 <Button 24 onClick={() => 25 NerdGraphMutation.mutate({ 26 mutation, 27 variables, 28 }).then(refetch) 29 } 30 > 31 Mutate 32 </Button> 33 </> 34 )} 35 </NerdGraphQuery> 36 ); 37 } Copy Props childrenrequiredfunction Render prop function as children. function ( mutate : function, // Function to trigger a mutation from your UI. mutationResult : {Object // Results of the mutation. ) => undefined mutationrequiredstring|object GraphQL mutation, either as a string or a GraphQL document parsed into an AST by graphql-tag. Example 1 1 import { ngql } from 'nr1'; 2 3 const mutation = ngql` 4 mutation($guid: EntityGuid!) { 5 taggingAddTagsToEntity(guid: $guid, tags: $tags) { 6 errors { 7 message 8 } 9 } 10 } 11 `; Copy variablesobject Object containing all of the variables your mutation needs to execute. Methods NerdGraphMutation.render function () => undefined NerdGraphMutation.mutate Static method to use NerdGraphMutation as a Promise instead of as a React component. function ( props : Object // Object containing the mutation options. Any NerdGraphMutation prop is a valid option except children. ) => {Object} Type definitions PromiseQueryResult { loading : boolean, // Indicates that the request is in flight. data : Object, // An object containing the result of your query. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 362.7567,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraphMutation</em>",
        "sections": "<em>NerdGraphMutation</em>",
        "body": "} variables={variables}&gt; 20 {({ <em>data</em>, refetch }) =&gt; ( 21 &lt;&gt; 22 &lt;Render<em>Data</em> <em>data</em>={<em>data</em>} &#x2F;&gt; 23 &lt;Button 24 onClick={() =&gt; 25 <em>NerdGraph</em>Mutation.mutate({ 26 mutation, 27 variables, 28 }).then(refetch) 29 } 30 &gt; 31 Mutate 32 &lt;&#x2F;Button&gt; 33 &lt;&#x2F;&gt; 34 )} 35 &lt;&#x2F;<em>NerdGraphQuery</em>&gt; 36 ); 37 } Copy Props"
      },
      "id": "5efa999c64441fe20b5f7e06"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 9231,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Rules, limits, and glossary",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Troubleshooting",
        "Create NRQL alert conditions",
        "Create a NRQL alert condition",
        "NRQL alert syntax",
        "NRQL alert threshold examples",
        "Nested aggregation NRQL alerts",
        "NRQL condition creation tips",
        "Alert threshold types",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Advanced signal settings",
        "Aggregation window",
        "Evaluation offset",
        "Fill data gaps",
        "For more help"
      ],
      "title": "Create NRQL alert conditions",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "external_id": "956a7a0b84d2afac5e6236df3143085ebc4f7459",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/nr1_nrql_alert_conditions.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "published_at": "2021-02-23T12:38:14Z",
      "updated_at": "2021-02-23T12:38:13Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "How to define thresholds that trigger alert notifications based on your NRQL queries.",
      "body": "You can use NRQL queries to create alert conditions. Once you've defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Click NRQL, and then Next, define thresholds. For more information on key concepts relating to NRQL alert conditions and streaming alerts, see Streaming alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition for a policy: On one.newrelic.com, in the header click Alerts & AI, then in the left sidebar click Policies. Select an existing policy or click New alert policy to create a new policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define thresholds. NRQL alert syntax Here's the basic syntax for creating all NRQL alert conditions. The FACET clause is required for Outlier threshold types, optional for Static, and not allowed for Baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Required for outlier conditions, but not baseline or static Include an optional FACET clause in your NRQL syntax depending on the threshold type: static, baseline, or outlier. Use the FACET clause to separate your results by attribute and alert on each attribute independently. No LIMIT clause is allowed, but all queries will receive the maximum number of facets possible. Faceted queries can return a maximum of 5000 values for static conditions and a maximum of 500 values for outlier conditions. If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction SELECT percentile(databaseDuration, 75) FROM Transaction Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction SELECT average(duration) FROM Transaction Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Nested aggregation NRQL alerts Nested aggregation queries are a powerful way to query your data. However, they have a few restrictions that are important to note. Nested queries with a non-faceted innermost query are not currently supported Without a FACET, the inner query produces a single result, giving the outer query nothing to aggregate. If you're using a nested query, make sure your inner query is faceted. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu) ‚Äã‚Äã‚Äã‚Äã‚Äã Queries at all levels must have the same aggregation window size With an alert aggregation window of 1 minute, the inner query would produce two smaller windows of 30 seconds. In theory, these two windows could be aggregated by the outer query. However, this is not currently supported. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)‚Äã‚Äã Signal loss is not yet supported for nested queries For more information on signal loss, see NerdGraph API: Loss of signal and gap filling. NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. For details, see Description Query results Queries must return a number. The condition evaluates the returned number against the thresholds you've set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that violations for sporadic data, such as error counts, are closed when no signal is coming in. To learn more about signal loss and how to request access to it, see this announcement. Advanced signal settings These settings give you options for better handling continuous, streaming data signals that may sometimes be missing. These settings include the aggregation window, the evaluation offset, and an option for filling data gaps. For more on using these, see Advanced signal settings. Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions don't affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type, except you can't use a FACET clause. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. Sum of query results (limited or intermittent data) Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. You can use loss of signal, aggregation duration, and gap filling settings to minimize these false notifications. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum and the preview chart will update accordingly. Set the loss of signal threshold Loss of signal occurs when no data matches the NRQL condition over a specific period of time. You can set your loss of signal threshold duration and and also what happens when the threshold is crossed. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Loss of signal is only available for NRQL conditions. You may also manage these settings using the GraphQL API (recommended), or the REST API. Go here for specific GraphQL API examples. Loss of signal settings: Loss of signal settings include a time duration and two possible actions. Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration Expiration duration is a timer that starts and resets when we receive a data point in the streaming alerts pipeline. If we don't receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. The loss of signal expiration time is independent of the threshold duration and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we recommend using at least 3-5 minutes. Loss of signal actions Once a signal is considered lost, you can close open violations, open new violations, or both. Close all current open violations: This closes all open violations that are related to a specific signal. It won't necessarily close all violations for a condition. If you're alerting on an ephemeral service, or on a sporadic signal, you'll want to choose this action to ensure that violations are closed properly. The GraphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to a loss of signal. Based on your incident preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we'll close all open violations first, and then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: For a policy, when you create a condition, under Select a product, click NRQL, then click Next, define thresholds. Write a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in minutes or seconds in the Signal is lost after field. Choose what you want to happen when the signal is lost. You can check one or both of Close all current open violations and Open new \"lost signal\" violation . These control how loss of signal violations will be handled for the condition. Make sure you name your condition before you save it. Loss of signal detection doesn't work on NRQL queries that use nested aggregation or sub-queries. Advanced signal settings When creating a NRQL alert condition, the advanced signal settings gives you better control over streaming alert data and helps you avoid false alarms. When creating a NRQL condition, there are several advanced signal settings: Aggregation window Evaluation offset Fill data gaps To read an explanation of what these settings are and how they relate to each other, see Streaming alerts concepts. Below are instructions and tips on how to configure them. Aggregation window You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. You can set it to anything between one second and 15 minutes. The default is one minute. Baseline alert condition thresholds don't support editing the aggregation window. They use the 1 minute default. Evaluation offset You can adjust the evaluation offset to coordinate our streaming alerting algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. The total supported latency is the product of the aggregation window duration multiplied by the evaluation offset. In the example screenshot above, the supported latency is 3 minutes (a 1-minute aggregation window multiplied by three windows). If the data type comes from an APM language agent and is aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3 with 1 minute aggregation windows. When creating NRQL conditions for data collected from Infrastructure Cloud Integrations such as AWS Cloudwatch or Azure, we recommend that you start with an evaluation offset of 15 minutes, then adjust up or down depending on how long it takes to collect your data. Fill data gaps Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with one of these settings: None: (Default) Choose this if you don't want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won't be in violation. Custom static value: Choose this if you'd like to insert a custom static value into the empty aggregation windows before they're evaluated. This option has an additional, required parameter of fillValue (as named in the API) that specifies what static value should be used. This defaults to 0. Last known value: This option inserts the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. Options for editing data gap settings: In the NRQL conditions UI, go to Condition settings > Advanced signal settings > fill data gaps with and choose an option. If using our Nerdgraph API (preferred), this node is located at: actor : account : alerts : nrqlCondition : signal : fillOption | fillValue NerdGraph is the preferred API but if you are using our REST API, you can find this setting in the REST API explorer under the \"signal\" section of the Alert NRQL conditions API. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 342.02652,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Sum of <em>query</em> results (limited or intermittent <em>data</em>)",
        "info": "How to define thresholds that trigger alert notifications based on your NRQL <em>queries</em>.",
        "category_0": "Alerts and <em>Applied</em> Intelligence",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;alerts-<em>applied</em>-intelligence&#x2F;new-relic-alerts&#x2F;alert-conditions&#x2F;create-nrql-alert-conditions",
        "body": " the WHERE clause to define those conditions. SELECT average(duration) FROM <em>Transaction</em> WHERE <em>account</em>_id in (91290, 102021, 20230) SELECT percentile(duration, 95) FROM <em>Transaction</em> WHERE name LIKE &#x27;Controller&#x2F;checkout&#x2F;%&#x27; Alert on Nth percentile of your <em>data</em> Create alerts when an Nth percentile of your <em>data</em>"
      },
      "id": "5f2d992528ccbc489d88dfc1"
    }
  ],
  "/automate-workflows/get-started-terraform": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/",
      "sections": [
        "New Relic and Terraform",
        "Guides to new relic and terraform",
        "Getting started with New Relic and Terraform",
        "Using Terragrunt configurations",
        "Using Terraform modules",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:55:31Z",
      "title": "New Relic and Terraform",
      "updated_at": "2021-02-25T01:55:31Z",
      "type": "developer",
      "external_id": "a0391aa84ef8cdb8d92329efb62a1a6141f44cac",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Guides to new relic and terraform Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using Terraform modules 30 min Learn how to use Terraform modules in your configurations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 394.3063,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic and <em>Terraform</em>",
        "sections": "New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Guides to new relic and <em>terraform</em> Getting started with New Relic and <em>Terraform</em> 30 min Learn how to provision New Relic resources using <em>Terraform</em> Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using <em>Terraform</em> modules 30 min Learn how to use <em>Terraform</em> modules in your configurations"
      },
      "id": "601df6b928ccbc2507013383"
    },
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "76368b6d7b42905b1effbe6f6d7a328160d5a967",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/",
      "published_at": "2021-02-25T02:00:30Z",
      "updated_at": "2021-02-06T01:55:16Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google‚Äôs Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day ‚Äî a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you‚Äôve put in place, you‚Äôll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 329.18372,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the <em>golden</em> <em>signal</em> <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert_policy.golden_signal</em>_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your <em>golden</em> <em>signal</em> <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "5efa999d196a67300c766404"
    },
    {
      "category_2": "Core concepts",
      "nodeid": 39206,
      "sections": [
        "Use New Relic One",
        "Get started",
        "Core concepts",
        "UI and data",
        "Workloads",
        "Build on New Relic One",
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "For more help"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "category_0": "New Relic One",
      "type": "docs",
      "category_1": "Use New Relic One",
      "external_id": "f7287149a67c0f7488ef50f706371ec61d30a498",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/TimeSyntax-Lookout.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance",
      "published_at": "2021-02-23T23:38:24Z",
      "updated_at": "2021-02-23T23:38:24Z",
      "breadcrumb": "Contents / New Relic One / Use New Relic One / Core concepts",
      "document_type": "page",
      "popularity": 1,
      "info": "Lookout is a New Relic One application that provides quick visibility into your entire stack.",
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration ‚Äî you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system‚Äîno configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires a Pro or Enterprise FSO tier. If you are in a standard tier, you can still use the New Relic Lookout view in the Entity Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade your tier. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/Services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In Browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With Errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There‚Äôs also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there‚Äôs an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic‚Äôs error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you‚Äôve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you‚Äôve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you‚Äôve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you‚Äôve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Query: Compare a specific time range to the same range a month ago SINCE ‚Äò2021-03-07 07:00-0500‚Äô UNTIL ‚Äò2021-03-08 07:00-0500‚Äô COMPARE WITH 1 month ago Or: SINCE ‚Äòtoday at midnight‚Äô UNTIL ‚Äònow‚Äô COMPARE WITH 1 MONTH AGO Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 235.4924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Abnormal <em>golden</em> <em>signals</em>",
        "body": " View button on the right side panel. The panel that appears shows you all the entity-specific <em>golden</em> <em>signals</em> you can toggle between out of the box. By choosing the Browser <em>Golden</em> <em>Signal</em> or other views, you can change from the default view. Each new view will have the <em>golden</em> <em>signals</em> appropriate"
      },
      "id": "603591f028ccbcae8977d236"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:38:35Z",
      "title": "New Relic Developers",
      "updated_at": "2021-02-06T01:37:36Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes ¬† Use custom attributes for deeper analysis Show 28 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.75348,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Getting started with New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Get Started with <em>Terraform</em> Get coding Create a free account 5 min Create custom events Define, visualize, and get <em>alerts</em> on the data you want using custom events Start the guide 7 min Add tags to apps Add tags"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "sections": [
        "Using Terraform Modules and Remote Storage",
        "Before you begin",
        "Creating a Terraform Module",
        "Create a Variable",
        "Passing a variable into a module",
        "Adding default values",
        "Pass variable values using module block",
        "Reusing a module",
        "Connecting an existing alert policy",
        "Store a module in Github",
        "Create a new Github repo",
        "Using a module saved on Github",
        "Manage state remotely in Amazon S3",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Using Terraform Modules and Remote Storage",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "9199eee78d8b5a488366c74b6b4e683dd010b51d",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terraform-modules/",
      "published_at": "2021-02-25T01:55:32Z",
      "updated_at": "2021-02-06T01:55:17Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terraform](https://www.terraform.io/) modules in your configurations and store them remotely.",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn to use Terraform modules in your New Relic configurations. Specifically, you will create modules, import data, store modules on Github, and manage state remotely Amazon S3. In the video, we review additional steps installing Terraform and set up New Relic alerts. If you need help getting started with Terraform, the Getting started with New Relic and Terraform guide shows how to install Terraform, set up New Relic alerts and a notification channel. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Start by initializing a working directory: bash Copy $ mkdir terraform-config && cd terraform-config To follow the examples in this gude, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 5 Creating a Terraform Module Terraform modules allow you to reuse, share, and store your Terraform configurations using version control like Github. In the next steps, you will move your New Relic configurations into a reusable module. First, in your project root, create a new directory to store your modules named modules: bash Copy $ mkdir modules && cd modules In the modules directory, create a new directory for a new module called HostConditions and create a new file named main.tf: bash Copy $ mkdir HostConditions && cd HostConditions $ touch main.tf Remove the two alert conditions from the root project's main.tf file and copy it to the new main.tf file in the HostModules directory. In the root directory's main.tf file call the new module using a module block: module \"HostConditions\" { source = \"./modules/HostConditions\" } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Initializing modules... $ [output]- HostConditions in $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. You see an error in your console due to the lack of provider details in your modules directory. To fix the error, create a copy of the root provider.tf in your HostConditions directory : provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-zzzzzz\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 2, in resource \"newrelic_infra_alert_condition\" $ [output]\"cpuhot\": 2: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 24, in resource \"newrelic_infra_alert_condition\" $ [output]\"highDiskUsage\": 24: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. Terraform init no longer shows an error, but running terraform plan still causes an error to occur. The error is due to the policy id used in the ./modules/HostConditions/provider.tf doesn't exist. A variable is needed to pass into the module. Step 2 of 5 Create a Variable Variables pass details into your module and set default values. First, at the top of your HostConditions provider.tf create a new variable: variable \"providerId\" {} Copy Next, in the resource block, replace the existing policyId with the new variable: var.policy Copy Passing a variable into a module To make a module dynamic, you will pass your variables into the module using the module resource block. In the root directory main.tf, update the module block to add the policyId variable: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id } Copy Run terraform plan after adding your variable to the module. bash Copy $ terraform plan Now, add more variables and replace the values CPU critical, CPU warning, and disk percent. Then, pass the new variables into the module. Add the new variables to HostConditions main.tf: variable cpu_warning {} variable cpu_critical {} variable diskPercent {} Copy Update the alert conditions to use the new variables added in the HostConditons main.tf: resource \"newrelic_infra_alert_condition\" \"cpuhot\" { policy_id = var.policyId name = \"CPU hot!\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.cpu_critical time_function = \"all\" } warning { duration = 5 value = var.cpu_warning time_function = \"all\" } } resource \"newrelic_infra_alert_condition\" \"highDiskUsage\" { policy_id = var.policyId name = \"high disk usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"diskUsedPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.diskPercent time_function = \"all\" } } Copy Run terraform plan after adding your variables to the module. An error message displays due to the missing variable values. Values can be added in the module block or as default values. bash Copy $ terraform plan Adding default values Add default variable values to HostConditions main.tf: variable cpu_warning { default=80} variable cpu_critical { default=90} variable diskPercent { default=60 } Copy Pass variable values using module block In the root directory main.tf, update the module block to add the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } Copy Run terraform plan after adding your variables to the module. bash Copy $ terraform plan Step 3 of 5 Reusing a module You can reuse your module connecting to a New Relic policy that already exists. Before you start, in your New Relic account, create a new alert policy named Preexisting Policy. Connecting an existing alert policy First, In your root main.tf file add the data block to import an existing policy: data \"newrelic_alert_channel\" \"ExistingPolicy\" { name = \"Preexisting Policy\" } Copy Next, create a second module block name HostConditions2. Add the alert conditions to the Preexisting Policy. module \"HostConditions2\" { source = \"./modules/HostConditions\" policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module and run 'terraform apply' to apply the changes to your New Relic account. The terraform scripts create a new alert policy and two conditions, but it also applies the alert conditions to the Preexisting Policy. Look in your New Relic account at the Preexisting Policy and see alerts conditions added for CPU Hot and High Disk Usage. Step 4 of 5 Store a module in Github After you have created a module, if you want to store the module somewhere other people can use, Github is how you can do it. Create a new Github repo First, inside of your HostModules directory, initialize a new Github repo. Add your module.tf and provider.tf to the stage for commit: bash Copy $ git add module.tf provider.tf $ git commit -m \"init\" Next, using the commands provided in your new repo, push your commit to Github: bash Copy $ git remote add origin <repo_url> $ git branch -M main $ git push -u origin main Using a module saved on Github Check the Github repo and see the main.tf and provider.tf are now in your repo. Copy the GitHub repo's web URL to clone your repo. Update the root main.tf file using GitHub as the source for the HostConditions: module \"HostConditions\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } module \"HostConditions2\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module. When you run terraform init, Terraform clones the repository locally. Run terraform plan If you need to update your local module with updates made to the git repo, run terraform get -update Step 5 of 5 Manage state remotely in Amazon S3 The state file is the representation that terraform holds about the created resources. The state file is in the root directory, but if deleted or corrupted would cause trouble. Storing the state file remote provides security and allows sharing and remote access. In the provider.tf in the root directory, add a terraform backend block for Amazon S3: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" } } Copy Variables are needed to provide the correct S3 bucket details, and access is required. To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Add the profile to the terraform backend block: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" profile = \"<iam_user_profile_name>\" } } Copy Before saving your state to Amazon S3, destroy the current configurations to start from a clean slate: bash Copy $ terraform destroy Initialize Terraform, run Terraform init: bash Copy $ terraform init In the terminal, the output shows the backend initialized as S3. Delete the local state as it is not needed bash Copy $ rm terraform.* Run terraform apply to apply your Terraform configuration changes. bash Copy $ terraform apply The state file is now stored in S3 instead of locally. Look in your S3 bucket and see the terraform state exists. Conclusion Congratulations! You're using modules to make your terraform configuratiions more flexible. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.37299,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Using <em>Terraform</em> Modules and Remote Storage",
        "sections": "Using <em>Terraform</em> Modules and Remote Storage",
        "info": "Learn how to use [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;) modules in your configurations and store them remotely.",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " to install <em>Terraform</em>, set up New Relic <em>alerts</em> and a <em>notification</em> <em>channel</em>. Before you begin To use this guide, you should have some basic knowledge of both New Relic and <em>Terraform</em>. If you haven&#x27;t deployed a New Relic open source agent yet, install New Relic for your application. Also, install the <em>Terraform</em>"
      },
      "id": "601df70628ccbce8510133b6"
    }
  ],
  "/collect-data/custom-events": [
    {
      "category_2": "Custom events",
      "nodeid": 13661,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Insights API",
        "Data requirements and limits for custom event data",
        "General requirements",
        "Reserved words",
        "Event type limits",
        "For more help"
      ],
      "title": "Data requirements and limits for custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/event-data-sources/custom-events/data-requirements-limits-custom-event-data",
      "external_id": "8c97fd1bd86c6d80e73f36d85b36dc52f72ec8ea",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/data-requirements-limits-custom-event-data",
      "published_at": "2021-02-22T17:25:54Z",
      "updated_at": "2021-02-08T05:16:20Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic, general limits and requirements for reporting custom events and attributes. ",
      "body": "As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.284256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data requirements and limits for <em>custom</em> <em>event</em> data",
        "sections": "<em>Custom</em> <em>events</em>",
        "info": "For New Relic, general limits and requirements for reporting <em>custom</em> <em>events</em> and attributes. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "<em>Custom</em> <em>events</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;<em>event</em>-data-sources&#x2F;<em>custom</em>-<em>events</em>&#x2F;data-requirements-limits-<em>custom</em>-<em>event</em>-data",
        "body": " Explorers Hub post. This document contains general requirements and rules for inserting and using <em>custom</em> <em>events</em> and their associated attributes. Additional requirements may apply based on the method you use. You can report <em>custom</em> <em>events</em> to New Relic in several ways, including: APM <em>agent</em> <em>APIs</em> <em>Event</em> <em>API</em>",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; <em>Custom</em> <em>events</em>"
      },
      "id": "6020c92464441fa6400a6f57"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13806,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Insights API",
        "Report custom event data",
        "Value from custom events and attributes",
        "Avoid rate limits",
        "Send custom events and attributes",
        "Extend data retention",
        "For more help"
      ],
      "title": "Report custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "external_id": "b8f2a56874703ddc38bfade9c15171f34560e9bd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-custom-event-data",
      "published_at": "2021-02-23T03:20:46Z",
      "updated_at": "2021-02-08T05:20:31Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the options for sending custom event data to New Relic. ",
      "body": "As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. New Relic products report a variety of default event data to your account. This document explains how to report your own custom events and attributes. Value from custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. By reporting custom events, you can create more useful and customized queries and charts of your data. This is a key part of optimizing how New Relic works for you. Avoid rate limits Reporting a large number of custom events and/or attributes can cause degraded query performance. It may also result in approaching or passing data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser monitoring agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure monitoring agent Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile monitoring agent Use the mobile agent API to send custom events and attributes. Synthetic monitoring Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn how to extend how long events are retained in your account, see our documentation about event data retention. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.806915,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>custom</em> <em>event</em> data",
        "sections": "<em>Custom</em> <em>events</em>",
        "info": "An overview of the options for sending <em>custom</em> <em>event</em> data to New Relic. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "<em>Custom</em> <em>events</em>",
        "body": " <em>custom</em> <em>events</em> and attributes Methods for sending <em>custom</em> <em>events</em> and attributes include: Source How to send <em>custom</em> data APM <em>agent</em> Use APM <em>agent</em> <em>APIs</em> to report <em>custom</em> <em>events</em> and <em>custom</em> attributes. Browser monitoring <em>agent</em> Add <em>custom</em> attributes to the PageView <em>event</em> via the Browser <em>API</em> call",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; <em>Custom</em> <em>events</em>"
      },
      "id": "6020ca1f196a67b3a6da2da7"
    },
    {
      "category_2": "Custom events",
      "nodeid": 6256,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Insights API",
        "APM: Report custom events and attributes",
        "Data considerations",
        "Record custom events and attributes",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words",
        "For more help"
      ],
      "title": "APM: Report custom events and attributes",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/event-data-sources/custom-events/apm-report-custom-events-attributes",
      "external_id": "61ddae62d98aaaafa91b110e8008a66586d2bd75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/apm-report-custom-events-attributes",
      "published_at": "2021-02-23T04:17:51Z",
      "updated_at": "2021-02-08T02:32:42Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "How to report APM custom events and attributes in New Relic.",
      "body": "As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. For more information, check out New Relic University‚Äôs tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your New Relic APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 68.03897,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "sections": "<em>Custom</em> <em>events</em>",
        "info": "How to report APM <em>custom</em> <em>events</em> and attributes in New Relic.",
        "category_1": "<em>Event</em> data sources",
        "category_2": "<em>Custom</em> <em>events</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;<em>event</em>-data-sources&#x2F;<em>custom</em>-<em>events</em>&#x2F;apm-report-<em>custom</em>-<em>events</em>-attributes",
        "body": " the <em>Event</em> <em>API</em> (without need for APM). However, be aware that <em>custom</em> <em>events</em> sent with the <em>agent</em> <em>APIs</em> are not compatible with high security mode. For more information, check out New Relic University‚Äôs tutorial Adding <em>custom</em> data with the APM <em>agent</em> <em>API</em>. Or, go directly to the full online course <em>Custom</em> data",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; <em>Custom</em> <em>events</em>"
      },
      "id": "6020a2ca196a67f302da2d80"
    },
    {
      "sections": [
        "Collect data from any source",
        "Agent APIs",
        "Telemetry SDK",
        "Trace API",
        "Metric API",
        "Event API",
        "Log API",
        "This site uses cookies üç™"
      ],
      "title": "Collect data from any source",
      "type": "developer",
      "tags": [
        "Agent API",
        "Telemetry SDK",
        "Trace API",
        "Metric API",
        "Event API"
      ],
      "external_id": "5bfb043fffe42ea4a78d5a90bf8e92aa8b8f8c33",
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/collect-data-from-any-source/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2020-12-04T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Open source emitters. APIs. New Relic agents. Get data from anywhere. ",
      "body": "New Relic products report a lot of data ‚Äúout of the box.‚Äù When you use products like APM, Browser, Mobile, Infrastructure monitoring, or an integration, by default you receive performance data. But you may want to bring data into New Relic that isn't collected by default. Maybe you want an API-based solution that doesn't require install of an agent. Maybe you want to bring telemetry data from another analysis service into New Relic. This page describes several ways to get data into New Relic. Step 1 of 6 Agent APIs If you use our APM, Browser, or Mobile agents to report data, you can use their associated APIs to report custom data. For example, if you monitor your application with the our APM Python agent, you can use the Python agent API to set up custom instrumentation. See the agent APIs. Step 2 of 6 Telemetry SDK Our Telemetry SDKs are language wrappers for our Trace API and Metric API (and eventually our Log API and Event API). These SDKs let you easily send metrics and trace data to New Relic without needing to install an agent. For customers, we offer open-source exporters and integrations that use the Telemetry SDKs to send metrics and trace data: Istio adaptor Prometheus OpenMetrics (for Docker | for Kubernetes) OpenCensus exporter (for Go | for Python) DropWizard exporter Micrometer exporter Want to build your own solution? See our Telemetry SDK docs. Step 3 of 6 Trace API Our Trace API lets you send distributed tracing data to New Relic and consolidate tracing data from multiple sources in one place. We accept trace data in two formats: Zipkin format New Relic format (if you don‚Äôt have Zipkin-format data, you‚Äôd use this) bash Copy $ curl -i -X POST https://trace-api.newrelic.com/trace/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -H 'Data-Format: newrelic' \\ > -H 'Data-Format-Version: 1' \\ > -d '[ $ { $ \"common\": { $ \"attributes\": { $ \"service.name\": \"Test Service A\", $ \"host\": \"host123.test.com\" $ } $ }, $ \"spans\": [ $ { $ \"trace.id\": \"123456\", $ \"id\": \"ABC\", $ \"attributes\": { $ \"duration.ms\": 12.53, $ \"name\": \"/home\" $ } $ }, $ { $ \"trace.id\": \"123456\", $ \"id\": \"DEF\", $ \"attributes\": { $ \"service.name\": \"Test Service A\", $ \"host\": \"host456.test.com\", $ \"duration.ms\": 2.97, $ \"name\": \"/auth\", $ \"parent.id\": \"ABC\" $ } $ } $ ] $ } $ ]' Step 4 of 6 Metric API You can use our Metric API to send metric data to New Relic from any source. bash Copy $ curl -i -X POST https://metric-api.newrelic.com/metric/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ { $ \"metrics\": [ $ { $ \"name\": \"memory.heap\", $ \"type\": \"gauge\", $ \"value\": 2.3, $ \"timestamp\": 1531414060739, $ \"attributes\": { $ \"host.name\": \"dev.server.com\" $ } $ } $ ] $ } $ ]' Step 5 of 6 Event API For sending arbitrary events to New Relic, you can use our Event API. We save these events as a new event type, which can then be queried via NRQL. (Eventually, the Telemetry SDKs will support the Event API.) bash Copy $ curl -i -X POST https://insights-collector.newrelic.com/v1/accounts/$ACCOUNT_ID/events \\ > -H \"Content-Type: application/json\" \\ > -H \"x-insert-key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ { $ \"eventType\": \"LoginEvent\", $ \"service\": \"login-service\", $ \"customerId\": \"xyz\" $ } $ ]' Step 6 of 6 Log API If our existing logging integrations don‚Äôt meet your needs, you can use our Log API to send any arbitrary log data to New Relic. (Eventually, the Telemetry SDKs will support the Log API.) bash Copy $ curl -i -X POST https://log-api.newrelic.com/log/v1 \\ > -H \"Content-Type: application/json\" \\ > -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ > -d '[ $ \"logs\": [ $ { $ \"timestamp\": 1593538496000, $ \"message\": \"User xyz logged in\", $ \"service\": \"login-service\", $ \"hostname\": \"login.example.com\" $ } $ ] $ ]'",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 55.68549,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> <em>APIs</em>",
        "info": "Open source emitters. <em>APIs</em>. New Relic <em>agents</em>. Get data from anywhere. ",
        "tags": "<em>Agent</em> <em>API</em>",
        "body": " their associated <em>APIs</em> to report <em>custom</em> data. For example, if you monitor your application with the our APM Python <em>agent</em>, you can use the Python <em>agent</em> <em>API</em> to set up <em>custom</em> instrumentation. See the <em>agent</em> <em>APIs</em>. Step 2 of 6 Telemetry SDK Our Telemetry SDKs are language wrappers for our Trace <em>API</em> and Metric"
      },
      "id": "5efa997128ccbc3c9a307dfd"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/23m1bvitohob1/promo-image.1536276861.png",
      "url": "https://learn.newrelic.com/new-relic-apis",
      "sections": [
        "Learn how to use a variety of New Relic APIs, including the GraphQL API, the Insights Insert API, and the APM Agent API.",
        "About this course",
        "Curriculum"
      ],
      "published_at": "2021-02-25T01:43:41Z",
      "title": "New Relic APIs",
      "updated_at": "2021-01-02T01:37:53Z",
      "type": "",
      "external_id": "e85a8158d02fefc00692d0c34843df4cb3c8b873",
      "popularity": 1,
      "body": "Sign In This video is still being processed. Please check back later. New Relic APIs Learn how to use a variety of New Relic APIs, including the GraphQL API, the Insights Insert API, and the APM Agent API. Register | FREE Already registered? Sign In About this course In this course, you'll learn how to use a variety of New Relic APIs, including the GraphQL API, the Insights Insert API, and the APM Agent API. Learn how to use these powerful APIs to retrieve data from New Relic products, insert data into those products, and adjust settings.¬† Curriculum GraphQL API Intro to New Relic GraphQL API Learn how to use the New Relic GraphQL API, an efficient and flexible query language that gives you the power to request exactly the data you need. REST API Using the REST API Learn how to use the New Relic REST API to retrieve data from your account, extract data via GET requests, and change some account configurations. Managing Insights dashboards with the New Relic REST API Learn how to use the New Relic REST API to create dashboard templates to share across your organization, instantly create dashboards, and save JSON files for source control and backups. Manage your Categories and Labels with the REST API Use the REST API to manage multiple categories and labels.¬† Deployment Tracking Learn how to mark deployments on charts to understand the effect of human-initiated change, including deployments that cause problems and the associated fixes. Rest API Knowledge Check Knowledge check for the New Relic REST API. Insights API Custom Data Overview with Insights Learn about the types of data captured automatically within Insights and take your analysis to the next level by adding your own business data. Add important context to your existing data with custom attributes or import additional data sets with custom events for more detailed user analytics. Adding Custom Events with the Insights API Learn how to import data as JSON to the Insights API endpoint - enrich existing data streams and add important context to your data to make full use of Insights' capabilities and visualizations for analyzing your data in real time. APM Agent API Adding Custom Data with the APM Agent API Learn how to use the New Relic APM agent API to send custom data about your app for a more detailed and in-depth view of your app‚Äôs performance and the ways your users engage with your app. Adding Custom Attributes with the Ruby Agent API Learn how to use the New Relic Ruby agent API to add custom attributes about your app for a more detailed and in-depth view of your app‚Äôs performance and the ways your users engage with your app. Adding Custom Events with the Ruby Agent API Learn how to insert custom event data the New Relic language agent APIs, which you can then query in New Relic Insights. Course Evaluation: New Relic APIs About this course In this course, you'll learn how to use a variety of New Relic APIs, including the GraphQL API, the Insights Insert API, and the APM Agent API. Learn how to use these powerful APIs to retrieve data from New Relic products, insert data into those products, and adjust settings.¬† Curriculum GraphQL API Intro to New Relic GraphQL API Learn how to use the New Relic GraphQL API, an efficient and flexible query language that gives you the power to request exactly the data you need. REST API Using the REST API Learn how to use the New Relic REST API to retrieve data from your account, extract data via GET requests, and change some account configurations. Managing Insights dashboards with the New Relic REST API Learn how to use the New Relic REST API to create dashboard templates to share across your organization, instantly create dashboards, and save JSON files for source control and backups. Manage your Categories and Labels with the REST API Use the REST API to manage multiple categories and labels.¬† Deployment Tracking Learn how to mark deployments on charts to understand the effect of human-initiated change, including deployments that cause problems and the associated fixes. Rest API Knowledge Check Knowledge check for the New Relic REST API. Insights API Custom Data Overview with Insights Learn about the types of data captured automatically within Insights and take your analysis to the next level by adding your own business data. Add important context to your existing data with custom attributes or import additional data sets with custom events for more detailed user analytics. Adding Custom Events with the Insights API Learn how to import data as JSON to the Insights API endpoint - enrich existing data streams and add important context to your data to make full use of Insights' capabilities and visualizations for analyzing your data in real time. APM Agent API Adding Custom Data with the APM Agent API Learn how to use the New Relic APM agent API to send custom data about your app for a more detailed and in-depth view of your app‚Äôs performance and the ways your users engage with your app. Adding Custom Attributes with the Ruby Agent API Learn how to use the New Relic Ruby agent API to add custom attributes about your app for a more detailed and in-depth view of your app‚Äôs performance and the ways your users engage with your app. Adding Custom Events with the Ruby Agent API Learn how to insert custom event data the New Relic language agent APIs, which you can then query in New Relic Insights. Course Evaluation: New Relic APIs ¬© 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 54.77777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>APIs</em>",
        "sections": "Learn how to use a variety of New Relic <em>APIs</em>, including the GraphQL <em>API</em>, the Insights Insert <em>API</em>, and the APM <em>Agent</em> <em>API</em>.",
        "body": " about your app for a more detailed and in-depth view of your app‚Äôs performance and the ways your users engage with your app. Adding <em>Custom</em> <em>Events</em> with the Ruby <em>Agent</em> <em>API</em> Learn how to insert <em>custom</em> <em>event</em> data the New Relic language <em>agent</em> <em>APIs</em>, which you can then query in New Relic Insights. Course Evaluation: New Relic <em>APIs</em> ¬© 2021 powered by"
      },
      "id": "5c2eb923e621f428b7cca76f"
    }
  ],
  "/terraform/terragrunt-configuration": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/",
      "sections": [
        "New Relic and Terraform",
        "Guides to new relic and terraform",
        "Getting started with New Relic and Terraform",
        "Using Terragrunt configurations",
        "Using Terraform modules",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:55:31Z",
      "title": "New Relic and Terraform",
      "updated_at": "2021-02-25T01:55:31Z",
      "type": "developer",
      "external_id": "a0391aa84ef8cdb8d92329efb62a1a6141f44cac",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Guides to new relic and terraform Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using Terraform modules 30 min Learn how to use Terraform modules in your configurations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 394.3063,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic and <em>Terraform</em>",
        "sections": "New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Guides to new relic and <em>terraform</em> Getting started with New Relic and <em>Terraform</em> 30 min Learn how to provision New Relic resources using <em>Terraform</em> Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using <em>Terraform</em> modules 30 min Learn how to use <em>Terraform</em> modules in your configurations"
      },
      "id": "601df6b928ccbc2507013383"
    },
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "76368b6d7b42905b1effbe6f6d7a328160d5a967",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/",
      "published_at": "2021-02-25T02:00:30Z",
      "updated_at": "2021-02-06T01:55:16Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google‚Äôs Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day ‚Äî a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you‚Äôve put in place, you‚Äôll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.68794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "5efa999d196a67300c766404"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:38:35Z",
      "title": "New Relic Developers",
      "updated_at": "2021-02-06T01:37:36Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes ¬† Use custom attributes for deeper analysis Show 28 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.75348,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Getting started with New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Get Started with <em>Terraform</em> Get coding Create a free account 5 min Create custom events Define, visualize, and get <em>alerts</em> on the data you want using custom events Start the guide 7 min Add tags to apps Add tags"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "sections": [
        "Using Terraform Modules and Remote Storage",
        "Before you begin",
        "Creating a Terraform Module",
        "Create a Variable",
        "Passing a variable into a module",
        "Adding default values",
        "Pass variable values using module block",
        "Reusing a module",
        "Connecting an existing alert policy",
        "Store a module in Github",
        "Create a new Github repo",
        "Using a module saved on Github",
        "Manage state remotely in Amazon S3",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Using Terraform Modules and Remote Storage",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "9199eee78d8b5a488366c74b6b4e683dd010b51d",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terraform-modules/",
      "published_at": "2021-02-25T01:55:32Z",
      "updated_at": "2021-02-06T01:55:17Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terraform](https://www.terraform.io/) modules in your configurations and store them remotely.",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn to use Terraform modules in your New Relic configurations. Specifically, you will create modules, import data, store modules on Github, and manage state remotely Amazon S3. In the video, we review additional steps installing Terraform and set up New Relic alerts. If you need help getting started with Terraform, the Getting started with New Relic and Terraform guide shows how to install Terraform, set up New Relic alerts and a notification channel. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Start by initializing a working directory: bash Copy $ mkdir terraform-config && cd terraform-config To follow the examples in this gude, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 5 Creating a Terraform Module Terraform modules allow you to reuse, share, and store your Terraform configurations using version control like Github. In the next steps, you will move your New Relic configurations into a reusable module. First, in your project root, create a new directory to store your modules named modules: bash Copy $ mkdir modules && cd modules In the modules directory, create a new directory for a new module called HostConditions and create a new file named main.tf: bash Copy $ mkdir HostConditions && cd HostConditions $ touch main.tf Remove the two alert conditions from the root project's main.tf file and copy it to the new main.tf file in the HostModules directory. In the root directory's main.tf file call the new module using a module block: module \"HostConditions\" { source = \"./modules/HostConditions\" } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Initializing modules... $ [output]- HostConditions in $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. You see an error in your console due to the lack of provider details in your modules directory. To fix the error, create a copy of the root provider.tf in your HostConditions directory : provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-zzzzzz\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 2, in resource \"newrelic_infra_alert_condition\" $ [output]\"cpuhot\": 2: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 24, in resource \"newrelic_infra_alert_condition\" $ [output]\"highDiskUsage\": 24: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. Terraform init no longer shows an error, but running terraform plan still causes an error to occur. The error is due to the policy id used in the ./modules/HostConditions/provider.tf doesn't exist. A variable is needed to pass into the module. Step 2 of 5 Create a Variable Variables pass details into your module and set default values. First, at the top of your HostConditions provider.tf create a new variable: variable \"providerId\" {} Copy Next, in the resource block, replace the existing policyId with the new variable: var.policy Copy Passing a variable into a module To make a module dynamic, you will pass your variables into the module using the module resource block. In the root directory main.tf, update the module block to add the policyId variable: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id } Copy Run terraform plan after adding your variable to the module. bash Copy $ terraform plan Now, add more variables and replace the values CPU critical, CPU warning, and disk percent. Then, pass the new variables into the module. Add the new variables to HostConditions main.tf: variable cpu_warning {} variable cpu_critical {} variable diskPercent {} Copy Update the alert conditions to use the new variables added in the HostConditons main.tf: resource \"newrelic_infra_alert_condition\" \"cpuhot\" { policy_id = var.policyId name = \"CPU hot!\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.cpu_critical time_function = \"all\" } warning { duration = 5 value = var.cpu_warning time_function = \"all\" } } resource \"newrelic_infra_alert_condition\" \"highDiskUsage\" { policy_id = var.policyId name = \"high disk usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"diskUsedPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.diskPercent time_function = \"all\" } } Copy Run terraform plan after adding your variables to the module. An error message displays due to the missing variable values. Values can be added in the module block or as default values. bash Copy $ terraform plan Adding default values Add default variable values to HostConditions main.tf: variable cpu_warning { default=80} variable cpu_critical { default=90} variable diskPercent { default=60 } Copy Pass variable values using module block In the root directory main.tf, update the module block to add the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } Copy Run terraform plan after adding your variables to the module. bash Copy $ terraform plan Step 3 of 5 Reusing a module You can reuse your module connecting to a New Relic policy that already exists. Before you start, in your New Relic account, create a new alert policy named Preexisting Policy. Connecting an existing alert policy First, In your root main.tf file add the data block to import an existing policy: data \"newrelic_alert_channel\" \"ExistingPolicy\" { name = \"Preexisting Policy\" } Copy Next, create a second module block name HostConditions2. Add the alert conditions to the Preexisting Policy. module \"HostConditions2\" { source = \"./modules/HostConditions\" policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module and run 'terraform apply' to apply the changes to your New Relic account. The terraform scripts create a new alert policy and two conditions, but it also applies the alert conditions to the Preexisting Policy. Look in your New Relic account at the Preexisting Policy and see alerts conditions added for CPU Hot and High Disk Usage. Step 4 of 5 Store a module in Github After you have created a module, if you want to store the module somewhere other people can use, Github is how you can do it. Create a new Github repo First, inside of your HostModules directory, initialize a new Github repo. Add your module.tf and provider.tf to the stage for commit: bash Copy $ git add module.tf provider.tf $ git commit -m \"init\" Next, using the commands provided in your new repo, push your commit to Github: bash Copy $ git remote add origin <repo_url> $ git branch -M main $ git push -u origin main Using a module saved on Github Check the Github repo and see the main.tf and provider.tf are now in your repo. Copy the GitHub repo's web URL to clone your repo. Update the root main.tf file using GitHub as the source for the HostConditions: module \"HostConditions\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } module \"HostConditions2\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module. When you run terraform init, Terraform clones the repository locally. Run terraform plan If you need to update your local module with updates made to the git repo, run terraform get -update Step 5 of 5 Manage state remotely in Amazon S3 The state file is the representation that terraform holds about the created resources. The state file is in the root directory, but if deleted or corrupted would cause trouble. Storing the state file remote provides security and allows sharing and remote access. In the provider.tf in the root directory, add a terraform backend block for Amazon S3: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" } } Copy Variables are needed to provide the correct S3 bucket details, and access is required. To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Add the profile to the terraform backend block: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" profile = \"<iam_user_profile_name>\" } } Copy Before saving your state to Amazon S3, destroy the current configurations to start from a clean slate: bash Copy $ terraform destroy Initialize Terraform, run Terraform init: bash Copy $ terraform init In the terminal, the output shows the backend initialized as S3. Delete the local state as it is not needed bash Copy $ rm terraform.* Run terraform apply to apply your Terraform configuration changes. bash Copy $ terraform apply The state file is now stored in S3 instead of locally. Look in your S3 bucket and see the terraform state exists. Conclusion Congratulations! You're using modules to make your terraform configuratiions more flexible. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.37299,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Using <em>Terraform</em> Modules and Remote Storage",
        "sections": "Using <em>Terraform</em> Modules and Remote Storage",
        "info": "Learn how to use [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;) modules in your configurations and store them remotely.",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " to install <em>Terraform</em>, set up New Relic <em>alerts</em> and a <em>notification</em> <em>channel</em>. Before you begin To use this guide, you should have some basic knowledge of both New Relic and <em>Terraform</em>. If you haven&#x27;t deployed a New Relic open source agent yet, install New Relic for your application. Also, install the <em>Terraform</em>"
      },
      "id": "601df70628ccbce8510133b6"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Automate common tasks",
        "Set up New Relic using the Kubernetes operator",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Automate workflows",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.40016,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Getting started with New Relic and <em>Terraform</em>",
        "body": "When building today&#x27;s complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including <em>Terraform</em>, AWS CloudFormation"
      },
      "id": "5efa999c196a67dfb4766445"
    }
  ],
  "/collect-data/custom-attributes": [
    {
      "category_2": "Explore data",
      "nodeid": 11451,
      "sections": [
        "Use Insights UI",
        "Getting started",
        "Explore data",
        "Guides",
        "Manage account data",
        "Manage dashboards",
        "Simulate SQL JOIN functions in Insights",
        "Simulate SQL JOIN in Insights",
        "For more help"
      ],
      "title": "Simulate SQL JOIN functions in Insights",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Use Insights UI",
      "external_id": "f12764fe7c31144f6b4c9d4558a26526e2bab330",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/explore-data/simulate-sql-join-functions-insights",
      "published_at": "2021-02-22T19:01:48Z",
      "updated_at": "2021-02-15T11:19:02Z",
      "breadcrumb": "Contents / Insights / Use Insights UI / Explore data",
      "document_type": "page",
      "popularity": 1,
      "info": "As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience with New Relic One Dashboards.",
      "body": "As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. When you use Insights to make queries, NRQL does not have an equivalent SQL-like JOIN function for subqueries. Recommendation: Make the transition from Insights to New Relic One so that you can take advantage of nested queries. Simulate SQL JOIN in Insights If you are using Insights to gain more in-depth data, you can add custom attributes to some data types. With Insights, you can simulate a JOIN by using custom attributes in a query's WHERE or FACET clause. Example: You want to know which browser types are experiencing the highest web duration for a specific product purchase. You could add a custom attribute named Product to your application's purchase transaction method. Then you could run this NRQL query: SELECT max(duration), average(duration), max(backendDuration), average(backendDuration) FROM PageView WHERE Product = 'Hat' FACET userAgentName SINCE 7 days ago For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.15872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to gain more in-depth data, you can add <em>custom</em> <em>attributes</em> to some data types. With Insights, you can simulate a JOIN by using <em>custom</em> <em>attributes</em> in a query&#x27;s WHERE or FACET clause. Example: You want to know which browser types are experiencing the highest web duration for a specific product purchase"
      },
      "id": "6023ddd7e7b9d2938c2b2d97"
    },
    {
      "category_2": "Custom events",
      "nodeid": 6256,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Insights API",
        "APM: Report custom events and attributes",
        "Data considerations",
        "Record custom events and attributes",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words",
        "For more help"
      ],
      "title": "APM: Report custom events and attributes",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/event-data-sources/custom-events/apm-report-custom-events-attributes",
      "external_id": "61ddae62d98aaaafa91b110e8008a66586d2bd75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/apm-report-custom-events-attributes",
      "published_at": "2021-02-23T04:17:51Z",
      "updated_at": "2021-02-08T02:32:42Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "How to report APM custom events and attributes in New Relic.",
      "body": "As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. For more information, check out New Relic University‚Äôs tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your New Relic APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.50046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> events and <em>attributes</em>",
        "sections": "APM: Report <em>custom</em> events and <em>attributes</em>",
        "info": "How to report APM <em>custom</em> events and <em>attributes</em> in New Relic.",
        "category_2": "<em>Custom</em> events",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;event-data-sources&#x2F;<em>custom</em>-events&#x2F;apm-report-<em>custom</em>-events-<em>attributes</em>",
        "body": " documentation about limits and restricted characters and <em>NRQL</em> reserved words. You can then add <em>custom</em> <em>attributes</em> for your .NET app. You can turn off <em>custom</em> events entirely by setting <em>custom</em>Events.enabled to false in newrelic.config. Node.js <em>Custom</em> event collection is enabled by default in Node.js",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; Event data sources &#x2F; <em>Custom</em> events"
      },
      "id": "6020a2ca196a67f302da2d80"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Collect data - any source",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:58:10Z",
      "title": "Collect data",
      "updated_at": "2021-02-07T01:49:34Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Add custom attributes ¬† Use custom attributes for deeper analysis Collect data - any source 15 min APIs, agents, OS emitters - get any data Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.940506,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>custom</em> <em>attributes</em>",
        "body": " <em>custom</em> <em>attributes</em> ¬† Use <em>custom</em> <em>attributes</em> for deeper analysis Collect data - any source 15 min APIs, agents, OS emitters - get any data Create <em>custom</em> events 5 min Define, visualize, and get alerts on the data you want using <em>custom</em> events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with <em>NRQL</em> 10 min Query default data, <em>custom</em> events, and <em>attributes</em>"
      },
      "id": "5efa997328ccbc768c307de2"
    },
    {
      "category_2": "Custom events",
      "nodeid": 7256,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Insights API",
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "PageAction and PageView attributes",
        "Troubleshooting",
        "For more help"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "external_id": "4371fdcdf32a9425546c34604f5051a32e146478",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-browser-monitoring-custom-events-attributes",
      "published_at": "2021-02-23T07:54:55Z",
      "updated_at": "2021-02-08T02:35:57Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "How to report custom events and attributes with browser monitoring in New Relic. ",
      "body": "As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the Browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Subscription level This feature requires a Browser Pro subscription. The instrumentation level setting for an application does not affect the availability of JavaScript API functions. Agent version Your New Relic Browser agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 60 events per 30-second harvest cycle, per browser. After the 60-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the Browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default Browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute Browser API call To add a custom attribute to the PageView event via the Browser agent, use the setCustomAttribute Browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> If you are using manual Browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.152466,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring <em>custom</em> events and <em>attributes</em>",
        "sections": "Report browser monitoring <em>custom</em> events and <em>attributes</em>",
        "info": "How to report <em>custom</em> events and <em>attributes</em> with browser monitoring in New Relic. ",
        "category_2": "<em>Custom</em> events",
        "body": " Explorers Hub post. You can use browser monitoring in New Relic to add <em>custom</em> events and <em>attributes</em>. Page actions and views Use the Browser API&#x27;s addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; Event data sources &#x2F; <em>Custom</em> events"
      },
      "id": "6020a38de7b9d2f742801a8a"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/course_series/3d167nnnx1zcd/promo-image.1532624322.png",
      "url": "https://learn.newrelic.com/series/cloud-adoption-application-baseline",
      "sections": [
        "This course series has been retired"
      ],
      "published_at": "2021-02-24T01:53:34Z",
      "title": "Planning a Cloud Adoption: Establish an Application Baseline",
      "updated_at": "2021-02-22T09:11:49Z",
      "type": "",
      "external_id": "3807381e682a6f1b2ca7be5ff240556c22b4365f",
      "popularity": 1,
      "body": "Back Sign In Searching... Plans Courses Lessons Reset ¬† This course series has been retired Please refer to the main course catalog for our most up-to-date learning resources! ¬† Getting started with Dashboards & NRQL Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations. FREE What‚Äôs New - The New Relic Data Exploration Experience Exploring your data in New Relic is now more intuitive than ever. In this session we‚Äôll take a look at what‚Äôs changed with our latest Data Exploration release and how it makes your life easier. FREE New Relic APIs Learn how to use a variety of New Relic APIs, including the GraphQL API, the Insights Insert API, and the APM Agent API. FREE IntroductoryCustomize DataAdvancedTutorialGraphQL APIAPINew Relic APIs Navigating APM Learn how to navigate New Relic APM UI and interpret chart data so you can improve your application's performance and troubleshoot complex applications faster. FREE Go Deeper: Advanced Alerting & NRQL Alerts Delve deeper into Alerts and move beyond the basics to implement an effective alerting strategy in this FREE 2 hour workshop. With scenario based labs, you‚Äôll create specific policies and conditions for typical use cases, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios. FREE New Relic Infrastructure Fundamentals In this course, you'll learn how New Relic Infrastructure provides deep visibility into cloud and on-premises environments. New Relic Infrastructure connects the health and performance of infrastructure to the richest metrics, events, logs, and traces to provide context for supporting our customers‚Äô applications. FREE APM for Power Users Level up your digital intelligence and become an APM Power User. In this course, you learn to use advanced performance monitoring features. FREE Become a power userAPMPower UserAdvancedTutorialAPM for Power Users New Relic APM Fundamentals In this course, you'll learn how to use New Relic APM to see what's happening in your application, understand where the problems are, discover opportunities for optimizing your entire application ecosystem, and make sure you never miss an issue that needs attention. FREE New Relic APM Fundamentals New Relic Insights + APM Fundamentals In this course, you'll learn how to create an Insights dashboard in the UI and from a JSON template, add APM charts, and edit your Dashboard. This course culminates in a live virtual training where you'll learn how to analyze your APM data in Insights. FREE New Relic Insights + APM FundamentalsNew Relic APM Fundamentalsabracadabra New Relic Alerts Fundamentals (Legacy) Learn how to use the New Relic platform Alerts tool to monitor performance and know when leading performance indicators spike or drop so you can catch problems before they reach your end user. Enable team members to get the alerts they need faster and achieve lower response times. FREE New Relic Alerts Fundamentals New Relic One Overview New Relic One is the industry‚Äôs largest and most comprehensive cloud-based observability platform built to help customers create more perfect software. In the pursuit of our vision, we have enhanced New Relic One to provide a simplified and frictionless experience for customers. FREE Live Learncast: New Relic One Programmability Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. FREE GraphQL APIAPIUpcoming WebcastsNew Relic OneNew Relic APIs Performance Monitoring Fundamentals In this course, you‚Äôll learn how you can use the New Relic Digital Intelligence Platform to get end-to-end visibility into the performance of your websites and apps, the customer experiences they deliver, and their effect on your business. FREE APMTutorialBrowserself-serveNew Relic InsightsNew Relic InfrastructureNew Relic FundamentalsPerformance Monitoring Fundamentals Performance Monitoring with New Relic In this course, you‚Äôll learn how you can use the New Relic Digital Intelligence Platform to get end-to-end visibility into the performance of your websites and apps, the customer experiences they deliver, and their effect on your business. FREE AlertsGet StartedInfrastructureIntroductoryAPMInsightsTutorialSyntheticsBrowserMobile monitoringself-servePerformance Monitoring with New Relic New Relic Distributed Tracing: Tracking Across Your Application Stacks In this practical session you‚Äôll find out about how New Relic Distributed Tracing can extend your transaction tracing capabilities for distributed systems, and understand how Distributed Tracing works and can be configured for different environments. FREE Maximizing Observability with New Relic Logs This workshop is a comprehensive introduction to understanding and working with Logs in New Relic. Get hands-on with your data. Practice importing logs and then parsing, filtering, dropping, and alerting on log data in New Relic One. FREE Getting Started with Synthetics Learn how to use Synthetics to test your app from different global locations, simulate user flows and interactions, check the performance of individual page components, and fix problems before they affect the end-user's experience. FREE Get StartedMonitor PerformancePower UserTutorialSyntheticsNew Relic Synthetics Getting Started with Insights Learn how to use New Relic Insights to analyze and present custom, real-time data visualizations. FREE Get StartedIntroductoryInsightsTutorialNew Relic Insights Getting Started with Infrastructure Learn New Relic Infrastructure fundamentals to get a precise picture of your dynamically changing systems. New Relic Infrastructure delivers real-time health metrics correlated with recent configuration changes, so you can quickly resolve issues, scale rapidly, and deploy intelligently. FREE Get StartedInfrastructureMonitor PerformancePower UserTutorialNew Relic Infrastructure New Relic Alerts Fundamentals In this engaging FREE 2 hour workshop is an introduction to understanding and working with Alerts in New Relic. It will enable you to set up a range of Alert policies, understand how different conditions operate, and learn how to work with incidents when issues arise. FREE Get Started with APM Let's get started together. We're going to take you through the basics to manage your application and services. FREE Get StartedGet CertifiedIntroductoryAPMTutorialGetting-Startedself-serveGet Started with APMNew Relic APM Insights Dashboards and Data Apps Learn how to use Insights Dashboards and Data Apps to analyze any data type from across all New Relic products in real-time and present a variety of metrics and visualizations in a meeting or on the go, embed charts into your own application, or create self-service dashboards for other teams. FREE Get StartedMonitor PerformanceGet CertifiedPower UserInsightsTutorialInsights DashboardsDashboards and Data Apps Writing NRQL Queries Learn how to ask questions about your data using NRQL, New Relic's SQL-flavored query language, and create beautiful visualizations for analyzing your data in real-time. FREE Get StartedBecome a power userGet CertifiedIntroductoryInsightsTutorialCloud AdoptionApplication Baselineself-serveWriting NRQL Queries New Relic Alerts Learn how to use the New Relic platform Alerts tool to monitor performance and know when leading performance indicators spike or drop so you can catch problems before they reach your end user. Enable team members to get the alerts they need faster and achieve lower response times. FREE AlertsGet StartedIntroductoryAPMPower UserTutorialNew Relic Alerts Custom Data with Insights Learn how to take your application performance analysis to the next level. Add context and get more detailed results with custom attributes, or by importing additional datasets. This course will show you how to import JSON data to the Insights API endpoint, alongside default data captured natively. FREE Power UserInsightsCustomize DataAdvancedTutorialCustom Data with Insights Part of: ¬© 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.537415,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " UserTutorialNew Relic Alerts <em>Custom</em> Data with Insights Learn how to take your application performance analysis to the next level. Add context and get more detailed results with <em>custom</em> <em>attributes</em>, or by importing additional datasets. This course will show you how to import JSON data to the Insights API endpoint, alongside default data captured natively. FREE Power UserInsightsCustomize DataAdvancedTutorial<em>Custom</em> Data with Insights Part of: ¬© 2021 powered by"
      },
      "id": "5fe0211fe7b9d28075df9241"
    }
  ],
  "/terraform/terraform-modules": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/",
      "sections": [
        "New Relic and Terraform",
        "Guides to new relic and terraform",
        "Getting started with New Relic and Terraform",
        "Using Terragrunt configurations",
        "Using Terraform modules",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:55:31Z",
      "title": "New Relic and Terraform",
      "updated_at": "2021-02-25T01:55:31Z",
      "type": "developer",
      "external_id": "a0391aa84ef8cdb8d92329efb62a1a6141f44cac",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Guides to new relic and terraform Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using Terraform modules 30 min Learn how to use Terraform modules in your configurations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 394.3063,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic and <em>Terraform</em>",
        "sections": "New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Guides to new relic and <em>terraform</em> Getting started with New Relic and <em>Terraform</em> 30 min Learn how to provision New Relic resources using <em>Terraform</em> Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using <em>Terraform</em> modules 30 min Learn how to use <em>Terraform</em> modules in your configurations"
      },
      "id": "601df6b928ccbc2507013383"
    },
    {
      "sections": [
        "Getting started with New Relic and Terraform",
        "Before you begin",
        "Bootstrap Terraform and the New Relic provider",
        "Configure the New Relic provider",
        "Tip",
        "Create a New Relic alert policy with the golden signal alerts",
        "Provision alert conditions based on the four golden signals",
        "Get notified when an alert triggers",
        "Extra Credit",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Getting started with New Relic and Terraform",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "golden signals",
        "terraform"
      ],
      "external_id": "76368b6d7b42905b1effbe6f6d7a328160d5a967",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/get-started-terraform/",
      "published_at": "2021-02-25T02:00:30Z",
      "updated_at": "2021-02-06T01:55:16Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to provision New Relic resources using [Terraform](https://www.terraform.io/).",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. The four alert conditions are based on the four golden signals of monitoring introduced in Google‚Äôs Site Reliability Engineering book: Latency: The amount of time it takes your application to service a request. Traffic: The amount of requests your system receives. Errors: The rate of requests that fail. Saturation: The stress on resources to meet the demands of your application. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Step 1 of 5 Bootstrap Terraform and the New Relic provider Start by initializing a working directory and creating a Terraform configuration file: bash Copy $ mkdir terraform-project && cd terraform-project $ touch main.tf Next, instruct Terraform to install and use the New Relic provider, by setting the terraform and required_providers blocks in main.tf: terraform { # Require Terraform version 0.13.x (recommended) required_version = \"~> 0.13.0\" # Require the latest 2.x version of the New Relic provider required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.12\" } } } Copy In this code block, you're setting the required version of Terraform to 0.13.x and setting the New Relic provider to the latest 2.x version. Using the right version constraints for your setup will provide better stability with your Terraform runs. Now that you've set your Terraform and New Relic provider versions, you need to configure the New Relic provider. Step 2 of 5 Configure the New Relic provider With terraform all set, configure the New Relic provider with the following items: Your New Relic Account ID. Your New Relic user key. Most user keys begin with the prefix NRAK-. Your New Relic region. Your region is US if your account settings page is located at one.newrelic.com, and EU if your account is located at one.eu.newrelic.com. In main.tf, set those values on the provider: provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy By setting these values on the New Relic provider, you're configuring that provider to make changes on behalf of your account through New Relic APIs. Tip You can also configure the New Relic provider using environment variables. This is a useful way to set default values for your provider configuration. For more information about configuring the New Relic provider, please feel free to check out our official provider documentation. With your New Relic provider configured, initialize Terraform: bash Copy $ terraform init When Terraform finishes installing and registering the New Relic provider, you'll receive a success message and some actionable next steps, such as running terraform plan. Before you can run terraform plan, however, you need to create your resources. Step 3 of 5 Create a New Relic alert policy with the golden signal alerts With the New Relic provider configured and initialized, you can define an alerting strategy for your application. Since you're targeting a specific application, use a newrelic_entity to fetch the application information from New Relic and allow us to reference that data elsewhere in the configuration: data \"newrelic_entity\" \"example_app\" { name = \"Your App Name\" # Must be an exact match to your application name in New Relic domain = \"APM\" # or BROWSER, INFRA, MOBILE, SYNTH, depending on your entity's domain type = \"APPLICATION\" } Copy Next, create a newrelic_alert_policy. Give the policy a dynamic name based on your application's name. This helps specify the scope of the policy: resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_entity.example_app.name}\" } Copy At this point, you should be able to test your configuration with a dry run: bash Copy $ terraform plan You should see output that displays Terraform's execution plan. The plan contains the actions Terraform performs when your run terraform apply: bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"Golden Signals - Your App Name\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ In this case, the plan shows you that Terraform will create a new alert policy when you run terraform apply. After verifying the details, execute the plan to provision the alert policy resource in your New Relic account: bash Copy $ terraform apply Every time you apply changes, Terraform asks you to confirm the actions you've told it to run. Type \"yes\". While it's running, Terraform sends logs to your console: bash Copy # Example output of `terraform apply` newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=111222333] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log in to New Relic and navigate to Alert Policies to confirm that Terraform created your new policy. As you move through the next steps of creating alert conditions, you can run terraform apply after configuring each resource. Refresh your alert policy webpage to see the new resources. Step 4 of 5 Provision alert conditions based on the four golden signals Next, add alert conditions for your application based on the four golden signals: latency, traffic, errors, and saturation. Apply these alert conditions to the alert policy you created in the previous step. Latency Most folks want to avoid slow response times. You can create a newrelic_alert_condition that triggers if the overall response time of your application rises above five seconds for five minutes: # Response time resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Response Time (Web) - ${data.newrelic_entity.example_app.name}\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"response_time_web\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" term { duration = 5 operator = \"above\" priority = \"critical\" threshold = \"5\" time_function = \"all\" } } Copy Note that you're linking this alert condition to the previously configured alert policy with policy_id. Traffic Traffic represents how much demand is placed on your system at any given moment. Throughput is a metric that measures how much traffic goes to your application. Create a newrelic_alert_condition that triggers if the overall response rate of your application falls below five requests per minute for five minutes: # Low throughput resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"Low Throughput (Web)\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"throughput_web\" condition_scope = \"application\" # Define a critical alert threshold that will # trigger after 5 minutes below 5 requests per minute. term { priority = \"critical\" duration = 5 operator = \"below\" threshold = \"5\" time_function = \"all\" } } Copy This type of alert is useful when you expect a constant baseline of traffic throughout the day ‚Äî a drop off in traffic can indicate a problem. Errors If your application's error rate spikes, you need to know about it. Create a newrelic_alert_condition that triggers if your application's error rate rises above 5% for five minutes: # Error percentage resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type = \"apm_app_metric\" entities = [data.newrelic_entity.example_app.application_id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration = 5 operator = \"above\" threshold = \"5\" time_function = \"all\" } } Copy Saturation Saturation represents how \"full\" your service is and can take many forms, such as CPU time, memory allocation, or queue depth. In this example, assume you already have a New Relic Infrastructure agent installed on the hosts serving your application, and you want to configure an alert for when CPU utilization spikes above a certain threshold: # High CPU usage resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High CPU usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" runbook_url = \"https://www.example.com\" where = \"(`applicationId` = '${data.newrelic_entity.example_app.application_id}')\" # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration = 5 value = 90 time_function = \"all\" } } Copy For the Infrastructure alert, you created a newrelic_infra_alert_condition that triggers if the aggregate CPU usage on these hosts rises above 90% for five minutes. Step 5 of 5 Get notified when an alert triggers Now that you've configured some important alert conditions, add a notification channel to your alert policy to ensure the proper folks get notified when an alert triggers. To do so, use a newrelic_alert_channel. To begin, create an email notification channel to send alert notifications to your email. Use this when you want to notify a specific person or team when alerts are triggered: resource \"newrelic_alert_channel\" \"team_email\" { name = \"example\" type = \"email\" config { recipients = \"yourawesometeam@example.com\" include_json_attachment = \"1\" } } Copy If you want to specify multiple recipients, use a comma-delimited list of emails. Last, but not least, in order to apply the notification channel to your alert policy, create a newrelic_alert_policy_channel: resource \"newrelic_alert_policy_channel\" \"golden_signals\" { policy_id = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.team_email.id] } Copy A newrelic_alert_policy_channel links the notification channel you just created to your alert policy. To finalize your golden signal alerts configuration, run terraform apply one last time to make sure all of your configured resources are up to date. Extra Credit new_relic_alert_channel supports several types of notification channels, including email, Slack, and PagerDuty. So, if you want to explore this more, try creating an alert channel for a second channel type, such as Slack: # Slack notification channel resource \"newrelic_alert_channel\" \"slack_notification\" { name = \"slack-example\" type = \"slack\" config { # Use the URL provided in your New Relic Slack integration url = \"https://hooks.slack.com/services/XXXXXXX/XXXXXXX/XXXXXXXXXX\" channel = \"your-slack-channel-for-alerts\" } } Copy Before you apply this change, you need to add the New Relic Slack App to your Slack account and select a Slack channel to send the notification. With this new alert channel, triggered alerts send notifications to the Slack channel of your choice. Conclusion As your team evaluates the alerting system you‚Äôve put in place, you‚Äôll find that you may need to tweak configuration values, such as the alert threshold and duration. If you manage your Terraform project in a remote repository, you can submit a pull request so your team can review these changes alongside the rest of your code contributions. Tip You may also want to consider automating this process in your CI/CD pipeline. Use Terraform's recommended practices guide to learn more about their recommended workflow and how to evolve your provisioning practices. Congratulations! You're officially practicing observability-as-code. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.68794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with New Relic and <em>Terraform</em>",
        "sections": "Create a New Relic <em>alert</em> policy with the golden signal <em>alerts</em>",
        "info": "Learn how to provision New Relic resources using [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;).",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " = newrelic_<em>alert</em>_policy.golden_signal_policy.id <em>channel</em>_ids = [newrelic_<em>alert_channel</em>.team_email.id] } Copy A newrelic_<em>alert_policy_channel</em> links the <em>notification</em> <em>channel</em> you just created to your <em>alert</em> policy. To finalize your golden signal <em>alerts</em> configuration, run <em>terraform</em> apply one last time to make sure all"
      },
      "id": "5efa999d196a67300c766404"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:38:35Z",
      "title": "New Relic Developers",
      "updated_at": "2021-02-06T01:37:36Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes ¬† Use custom attributes for deeper analysis Show 28 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.75348,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Getting started with New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Get Started with <em>Terraform</em> Get coding Create a free account 5 min Create custom events Define, visualize, and get <em>alerts</em> on the data you want using custom events Start the guide 7 min Add tags to apps Add tags"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "sections": [
        "Using Terragrunt to Manage Multiple Environments",
        "Before you begin",
        "Create a new configuration",
        "Tip",
        "Adding to your configuration",
        "Using your Environment as a Terragrunt Variable",
        "Storing the State Remotely",
        "Creating a New Environment",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Using Terragrunt to Manage Multiple Environments",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "4bf455aad61b7703def538f147b8954af49c4e15",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terragrunt-configuration/",
      "published_at": "2021-02-25T01:54:21Z",
      "updated_at": "2021-02-06T01:54:03Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terragrunt](https://www.terraform.io/) to manage configurations in multiple environments",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. Terragrunt is a thin wrapper that provides extra tools for keeping your configurations DRY, working with multiple Terraform modules, and managing remote state. In this guide, you will use Terragrunt to generate your Terraform configurations, create files with Terragrunt, and reuse the Terragrunt configuration to manage multiple environments. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic Infrastructure agent for your host. Also, install the Terraform CLI. Start by initializing a working directory: You will also need to install Terragrunt to follow this guide: bash Copy $ brew install terragrunt To follow the examples in this guide, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 6 Create a new configuration Terragrunt is a wrapper that provides extra tooling for your Terraform configurations. In the next steps, you will create a new configuration using Terragrunt, Terraform, and New Relic. Start by initializing a working directory: bash Copy $ mkdir terragrunt-config && cd terragrunt-config In the new directory, create a terragrunt.hcl file, create a ./src directory, and create a ./environments directory: bash Copy $ touch terragrunt.hcl $ mkdir src $ mkdir environments Inside of your environments folder, create a folder named dev. In the ./src directory, create a main.tf and provider.tf files: bash Copy $ mkdir environments/dev $ touch src/main.tf $ touch src/provider.tf In the provider.tf file add the appropriate Terraform and New Relic provider configuration information: terraform { required_version = \"~> 0.14.3\" required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.14.0\" } } } Copy In the main.tf add a New Relic alert policy named DemoPolicy: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } Copy In the ./environments/dev directory create a new file named terragrunt.hcl bash Copy $ cd ./environments/dev/ $ touch terragrunt.hcl Within the dev folder update the terragrunt.hcl file by adding the following include statement. The include statement tells Terragrunt to use any .hcl confgiuration files it finds in parent folders. include { path= find_in_parent_folders() } Copy Next, add a Terraform block to provide Terragrunt with a Terraform source reference. terraform { source = \"../../src\" } Copy Now you need to configure the provider with your New Relic account details. You will need your New Relic user API key and account ID. provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Tip If you have a single account: The account ID is displayed on the API keys page. If your organization has multiple accounts: From one.newrelic.com, select Entity explorer and use the account selector dropdown near the top of the page. Tip Documentation about the New Relic provider is provided on the Terraform doc site. Update the provider.tf file to define the New Relic account variables that will help keep the Terraform configuration dynamic. variable \"newrelic_personal_apikey\" {} variable \"newrelic_account_id\" {} variable \"newrelic_region\" {} provider \"newrelic\" { account_id = var.newrelic_account_id api_key = var.newrelic_personal_apikey region = var.newrelic_region } Copy In your terminal, change directories to the environments/dev folder and run the command terragrunt init: bash Copy $ terragrunt init Terraform init sets up a bit of context, sets up environment variables, and then runs terraform init. You will see the following output: bash Copy # Example output ------------------------------------------------------------------------ Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run \"terraform init\" in the future. Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. [terragrunt] [/Users/jsius/Sites/deco/terragrunt-config/environments/dev] 2021/02/02 13:30:31 Copying lock file [output] from /Users/jsius/Sites/deco/terragrunt-config/environments/dev/.terragrunt-cache/e-PoBgWhdv3v8QGOtDQxS_WeYu4/ 69zjIFUfApJiUt8gFmi-6-dcPe8/.terraform.lock.hcl to /Users/jsius/Sites/deco/terragrunt-config/environments/dev Run terragrunt plan: bash Copy $ terragrunt plan Terragrunt starts to run but pauses to ask for the inputs to the New Relic account variables added to the provider.tf file. bash Copy # Example output ------------------------------------------------------------------------ 2/02 13:32:08 Running command: terraform plan var.newrelic_account_id Enter a value: Interrupt received. Exit the terragrunt plan process with CTRL+C . In the environments/dev/terragrunt.hcl file, add an inputs block to provide the values for your New Relic account variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy The updated terragrunt.hcl only has the include, terraform, and inputs block include { path = find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Now, when you run terragrunt plan, Terragrunt will provide the input block's values, no longer prompting the command line for values. bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.DemoPolicy will be created + resource \"newrelic_alert_policy\" \"DemoPolicy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"My Demo Policy\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if \"terraform apply\" is subsequently run. Run terragrunt apply. After Terraform finishes process, check your New Relic account for the new Demo Policy. Step 2 of 6 Adding to your configuration Now that you have a basic New Relic configuration created, add configurations built in the Getting Started with Terraform and Terraform modules guides in this step. Tip If you haven't done the previous developer guides, you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional terraform configurations. Update the email address in the alert channel to your preferred email address: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { policy_id = newrelic_alert_policy.DemoPolicy.id channel_ids = [ newrelic_alert_channel.DemoChannel.id ] } module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercent = 68 } Copy You have added a New Relic alert channel, subscribed the demo policy to the alert channel, and added a module hosted on Github. To clone the module from GitHub, run terragrunt init and then run terragrunt apply. After Terraform is done processing, You will see your Demo Policy now has two conditions in your New Relic account and one alert channel attached. Step 3 of 6 Using your Environment as a Terragrunt Variable Using Terragrunt, you can add the name of the environment you are running to the name of the data you are creating, making your resource more identifiable in New Relic. In the root terragrunt.hcl file, create a new input for env_name inputs = { env_name = \"develop\" } Copy in the main.tf file add a new variable for 'env_name' variable \"env_name\" {} Copy Using string interpolation, add the new env_name variable to the alert policy and alert channel resource blocks. resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"${var.env_name}: My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"${env_name}: My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } Copy Run terragrunt plan to see the environment variable added to the configuration name. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"develop: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Currently, the environment variable name is hardcoded into the root terragrunt.hcl file. You want to avoid having your variables hardcoded, using a terragrunt built-in function will pass the value. In the root terragrunt.hcl file, update the input to use the path_relative_to_include() built-in function and pass the value has the env_name variable: inputs = { env_name = path_relative_to_include() } Copy Run terragrunt plan. Looking at the output, the env_name variable will have the entire ./environments/dev/ path. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"environments/dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Next, update the terragrunt.hcl to only include 'dev' as the env_name variable. Adding a locals block creates a local variable, using the replace built-in function will remove the unwanted parts of the relative path, and update the inputs block to use the local variable. locals { env_name = replace(path_relative_to_include(), \"environments/\", \"\") } inputs = { env_name = local.env_name } Copy Run terragrunt plan. Looking at the output the env_name variable will now have 'dev:' added. Run terragrunt apply to update your configurations. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Step 4 of 6 Storing the State Remotely At the moment, the state file is local. The next steps will update your Terraform configurations to remove the local state file and use a file stored remotely in Amazon S3. Tip Since Terragrunt allows you to configure multiple environments, various state files will need to be store in separate S3 buckets, not to override each other. Terragrunt allows you to generate files on the fly. Adding the remote_state block into the root level terragrunt.hcl file, you will generate a new file named backend.tf. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"my-terraform-state\" key = \"${path_relative_to_include()}/terraform.tfstate\" region = \"us-east-1\" encrypt = true } } Copy After adding the remote_state block, you will need to give the configuration for the S3 bucket that will store the Terraform state. Tip To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Now, update the remote_state block to provide your S3 bucket and update the key to use the local environment variable created previously. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"YOUR_S3_BUCKET_NAME\" # Amazon S3 bucket required key = \"envs/${local.env_name}/terraform.tfstate\" region = \"us-east-1\" encrypt = true profile = \"YOUR_PROFILE_NAME\" # Profile name required } } Copy Next, run terragrunt plan. If you look in the Amazon S3 bucket, you will see a folder named envs. Within the envs folder is a directory called devs containing terraform.tfstate file. Tip To see the files created by Terragrunt, look inside of the ./environments/dev directory. There is a hidden directory named terragrunt-cache. Within the terragrunt-cache directory, you will see the backend.tf file that Terragrunt generated. Step 5 of 6 Creating a New Environment Now that you have a working configuration for your dev environment, you will create a new environment reusing the dev configurations in the next steps. In the environments directory, create a new folder names nonprod. In the nonprod folder, create a new terragrunt.hcl file: bash Copy $ mkdir nonprod && cd nonprod $ touch terragrunt.hcl In the nonprod terragrunt.hcl file copy over the configuration from the environment terragrunt.hcl: include { path= find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Tip If you are using a different account for your nonprod environment, you can update the inputs with a new New Relic account ID and API key. Inside of your nonprod directory, run terragrunt init then run terragrunt apply. In the output, you will see Terraform has created a new set of resources. The new resources should have the nonprod name prefixed. Step 6 of 6 Terragrunt has created two environments, but there is no difference between them other than the name. Adding variables in the configurations allows your configurations to be more dynamic. In the next steps, you will add variables to your configurations. In the main.tf add new variables for the Host Conditions modules cpu_critical, cpu_warning, and diskPercentage values: variable \"cpu_critical\" {default = 89} variable \"cpu_warningl\" {default = 79} variable \"diskPercentage\" {default = 69} Copy In the main.tf update the HostConditions module values to use the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = var.cpu_critical cpu_warning = var.cpu_warninig diskPercent = var.dskPercentage } Copy Run terragrunt plan. In the output, the HostConditions values have changed to use the variable defaults. Next, you want to pass the values into your environment configurations by adding the inputs block variables. In the nonprod/terragrunt.hcl file, add the cpu_critical, cpu_warning, and diskPercentage variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) cpu_critical = 50 cpu_warninig = 40 diskPercentage = 98 } Copy Run terragrunt apply. In your New Relic account, you will see a new policy with configurations changed based on the environment. Conclusion Congratulations! You've used Terragrunt to generate your New Relic configurations and manage multiple environments. Review the Terragrunt Intro Example, New Relic Terraform provider documentation, and Terragrunt quick start to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.88654,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>notification</em> <em>channel</em>",
        "body": ", you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional <em>terraform</em> configurations. Update the email address in the <em>alert</em> <em>channel</em> to your preferred email address: resource &quot;newrelic_<em>alert</em>_policy&quot; &quot;DemoPolicy&quot; { name = &quot;My"
      },
      "id": "601df6bb196a67eb59da2d81"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Automate common tasks",
        "Set up New Relic using the Kubernetes operator",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Automate workflows",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.40016,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Getting started with New Relic and <em>Terraform</em>",
        "body": "When building today&#x27;s complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including <em>Terraform</em>, AWS CloudFormation"
      },
      "id": "5efa999c196a67dfb4766445"
    }
  ],
  "/collect-data/query-data-nrql": [
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/1qf2g217c4q7m/promo-image.1608575584.png",
      "url": "https://learn.newrelic.com/getting-started-with-dashboards-nrql",
      "sections": [
        "Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations.",
        "About this workshop"
      ],
      "published_at": "2021-02-25T01:39:49Z",
      "title": "Getting started with Dashboards & NRQL",
      "updated_at": "2021-02-25T01:39:49Z",
      "type": "",
      "external_id": "20be8b6c5a3882e951f9dfd70354ea7ceaa38c7c",
      "popularity": 1,
      "body": "Sign In Getting started with Dashboards & NRQL Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations. Register | FREE Already registered? Sign In About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.¬† These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.¬† Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.¬†¬† In this hands-on session, you‚Äôll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.¬† Using a sandbox account you‚Äôll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.¬† You‚Äôll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.¬† Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL March 9, 2021, 1 p.m. - March 9, 2021, 3 p.m. GMT 114 Getting started with Dashboards & NRQL March 9, 2021, noon - March 9, 2021, 2 p.m. PST 118 About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.¬† These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.¬† Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.¬†¬† In this hands-on session, you‚Äôll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.¬† Using a sandbox account you‚Äôll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.¬† You‚Äôll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.¬† Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Live events Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL March 9, 2021, 1 p.m. - March 9, 2021, 3 p.m. GMT 114 Getting started with Dashboards & NRQL March 9, 2021, noon - March 9, 2021, 2 p.m. PST 118 ¬© 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.83609,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting started with Dashboards &amp; <em>NRQL</em>",
        "sections": "Learn to use the <em>Data</em> Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of <em>NRQL</em>. Progress to working directly with <em>NRQL</em> to create a wider range of charts and visualizations.",
        "body": " you‚Äôll get familiar with <em>NRQL</em> <em>syntax</em>, work with the Query Builder to build your own queries and charts, and create <em>data</em> rich dashboards.¬† You‚Äôll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and <em>data</em>"
      },
      "id": "5fe29f8528ccbcf532f15668"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 9231,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Rules, limits, and glossary",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Troubleshooting",
        "Create NRQL alert conditions",
        "Create a NRQL alert condition",
        "NRQL alert syntax",
        "NRQL alert threshold examples",
        "Nested aggregation NRQL alerts",
        "NRQL condition creation tips",
        "Alert threshold types",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Advanced signal settings",
        "Aggregation window",
        "Evaluation offset",
        "Fill data gaps",
        "For more help"
      ],
      "title": "Create NRQL alert conditions",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "external_id": "956a7a0b84d2afac5e6236df3143085ebc4f7459",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/nr1_nrql_alert_conditions.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "published_at": "2021-02-23T12:38:14Z",
      "updated_at": "2021-02-23T12:38:13Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "How to define thresholds that trigger alert notifications based on your NRQL queries.",
      "body": "You can use NRQL queries to create alert conditions. Once you've defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Click NRQL, and then Next, define thresholds. For more information on key concepts relating to NRQL alert conditions and streaming alerts, see Streaming alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition for a policy: On one.newrelic.com, in the header click Alerts & AI, then in the left sidebar click Policies. Select an existing policy or click New alert policy to create a new policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define thresholds. NRQL alert syntax Here's the basic syntax for creating all NRQL alert conditions. The FACET clause is required for Outlier threshold types, optional for Static, and not allowed for Baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Required for outlier conditions, but not baseline or static Include an optional FACET clause in your NRQL syntax depending on the threshold type: static, baseline, or outlier. Use the FACET clause to separate your results by attribute and alert on each attribute independently. No LIMIT clause is allowed, but all queries will receive the maximum number of facets possible. Faceted queries can return a maximum of 5000 values for static conditions and a maximum of 500 values for outlier conditions. If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction SELECT percentile(databaseDuration, 75) FROM Transaction Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction SELECT average(duration) FROM Transaction Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Nested aggregation NRQL alerts Nested aggregation queries are a powerful way to query your data. However, they have a few restrictions that are important to note. Nested queries with a non-faceted innermost query are not currently supported Without a FACET, the inner query produces a single result, giving the outer query nothing to aggregate. If you're using a nested query, make sure your inner query is faceted. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu) ‚Äã‚Äã‚Äã‚Äã‚Äã Queries at all levels must have the same aggregation window size With an alert aggregation window of 1 minute, the inner query would produce two smaller windows of 30 seconds. In theory, these two windows could be aggregated by the outer query. However, this is not currently supported. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)‚Äã‚Äã Signal loss is not yet supported for nested queries For more information on signal loss, see NerdGraph API: Loss of signal and gap filling. NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. For details, see Description Query results Queries must return a number. The condition evaluates the returned number against the thresholds you've set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that violations for sporadic data, such as error counts, are closed when no signal is coming in. To learn more about signal loss and how to request access to it, see this announcement. Advanced signal settings These settings give you options for better handling continuous, streaming data signals that may sometimes be missing. These settings include the aggregation window, the evaluation offset, and an option for filling data gaps. For more on using these, see Advanced signal settings. Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions don't affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type, except you can't use a FACET clause. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. Sum of query results (limited or intermittent data) Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. You can use loss of signal, aggregation duration, and gap filling settings to minimize these false notifications. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum and the preview chart will update accordingly. Set the loss of signal threshold Loss of signal occurs when no data matches the NRQL condition over a specific period of time. You can set your loss of signal threshold duration and and also what happens when the threshold is crossed. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Loss of signal is only available for NRQL conditions. You may also manage these settings using the GraphQL API (recommended), or the REST API. Go here for specific GraphQL API examples. Loss of signal settings: Loss of signal settings include a time duration and two possible actions. Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration Expiration duration is a timer that starts and resets when we receive a data point in the streaming alerts pipeline. If we don't receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. The loss of signal expiration time is independent of the threshold duration and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we recommend using at least 3-5 minutes. Loss of signal actions Once a signal is considered lost, you can close open violations, open new violations, or both. Close all current open violations: This closes all open violations that are related to a specific signal. It won't necessarily close all violations for a condition. If you're alerting on an ephemeral service, or on a sporadic signal, you'll want to choose this action to ensure that violations are closed properly. The GraphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to a loss of signal. Based on your incident preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we'll close all open violations first, and then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: For a policy, when you create a condition, under Select a product, click NRQL, then click Next, define thresholds. Write a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in minutes or seconds in the Signal is lost after field. Choose what you want to happen when the signal is lost. You can check one or both of Close all current open violations and Open new \"lost signal\" violation . These control how loss of signal violations will be handled for the condition. Make sure you name your condition before you save it. Loss of signal detection doesn't work on NRQL queries that use nested aggregation or sub-queries. Advanced signal settings When creating a NRQL alert condition, the advanced signal settings gives you better control over streaming alert data and helps you avoid false alarms. When creating a NRQL condition, there are several advanced signal settings: Aggregation window Evaluation offset Fill data gaps To read an explanation of what these settings are and how they relate to each other, see Streaming alerts concepts. Below are instructions and tips on how to configure them. Aggregation window You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. You can set it to anything between one second and 15 minutes. The default is one minute. Baseline alert condition thresholds don't support editing the aggregation window. They use the 1 minute default. Evaluation offset You can adjust the evaluation offset to coordinate our streaming alerting algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. The total supported latency is the product of the aggregation window duration multiplied by the evaluation offset. In the example screenshot above, the supported latency is 3 minutes (a 1-minute aggregation window multiplied by three windows). If the data type comes from an APM language agent and is aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3 with 1 minute aggregation windows. When creating NRQL conditions for data collected from Infrastructure Cloud Integrations such as AWS Cloudwatch or Azure, we recommend that you start with an evaluation offset of 15 minutes, then adjust up or down depending on how long it takes to collect your data. Fill data gaps Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with one of these settings: None: (Default) Choose this if you don't want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won't be in violation. Custom static value: Choose this if you'd like to insert a custom static value into the empty aggregation windows before they're evaluated. This option has an additional, required parameter of fillValue (as named in the API) that specifies what static value should be used. This defaults to 0. Last known value: This option inserts the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. Options for editing data gap settings: In the NRQL conditions UI, go to Condition settings > Advanced signal settings > fill data gaps with and choose an option. If using our Nerdgraph API (preferred), this node is located at: actor : account : alerts : nrqlCondition : signal : fillOption | fillValue NerdGraph is the preferred API but if you are using our REST API, you can find this setting in the REST API explorer under the \"signal\" section of the Alert NRQL conditions API. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.86185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>NRQL</em> alert conditions",
        "sections": "<em>NRQL</em> alert <em>syntax</em>",
        "info": "How to define thresholds that trigger alert notifications based on your <em>NRQL</em> queries.",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;alerts-applied-intelligence&#x2F;new-relic-alerts&#x2F;alert-conditions&#x2F;create-<em>nrql</em>-alert-conditions",
        "body": ". <em>NRQL</em> alert <em>syntax</em> Here&#x27;s the basic <em>syntax</em> for creating all <em>NRQL</em> alert conditions. The FACET clause is required for Outlier threshold types, optional for Static, and not allowed for Baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Clause Notes SELECT function"
      },
      "id": "5f2d992528ccbc489d88dfc1"
    },
    {
      "category_2": "Get started",
      "nodeid": 11431,
      "sections": [
        "NRQL: New Relic Query Language",
        "Get started",
        "NRQL query tools",
        "NRQL query tutorials",
        "Introduction to NRQL, New Relic's query language",
        "What is NRQL?",
        "Where can you use NRQL?",
        "What data can you query with NRQL?",
        "Start using NRQL",
        "NRQL query examples",
        "NRQL syntax",
        "For more help"
      ],
      "title": "Introduction to NRQL, New Relic's query language",
      "category_0": "Query your data",
      "type": "docs",
      "category_1": "NRQL: New Relic Query Language",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language",
      "external_id": "d44be2c7df7addda8679b4c842015223cfcbd1a3",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-view-chart-nrql-query_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language",
      "published_at": "2021-02-23T01:41:23Z",
      "updated_at": "2021-02-08T05:35:50Z",
      "breadcrumb": "Contents / Query your data / NRQL: New Relic Query Language / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to New Relic Query Language (NRQL) and how to use it.",
      "body": "One way to query your New Relic data is with the New Relic Query Language (NRQL). This resource explains what NRQL is, when and how you can use it, and basic syntax rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see NRQL syntax, clauses, and functions. What is NRQL? NRQL is New Relic's SQL-like query language. You can use NRQL to retrieve detailed New Relic data and get insight into your applications, hosts, and business-important activity. Reasons to use NRQL include: To answer a question for the purpose of troubleshooting or business analysis To create a new chart To make API queries of New Relic data (for example, using our NerdGraph API) NRQL is used behind the scenes to generate some New Relic charts: Some New Relic charts are built using NRQL. One way to start using NRQL is to view a chart's query and then edit it to make your own custom chart. Where can you use NRQL? You can use NRQL in these places: New Relic One query builder: Advanced mode is a NRQL query interface Basic mode provides a simplified query experience that doesn't require knowledge of NRQL but that uses NRQL to generate results New Relic Insights NerdGraph: our GraphQL-format API, which includes options for making NRQL queries one.newrelic.com > Query your data: You can run a NRQL query in both New Relic One and New Relic Insights. This NRQL query shows a count of distributed tracing spans faceted by their entity names. NRQL is one of several ways to query New Relic data. For more on all query options, see Query your data. What data can you query with NRQL? NRQL allows you to query these New Relic data types: Event data from all New Relic products, including: APM events, like Transaction Browser monitoring events, like PageView Mobile monitoring events, like Mobile Infrastructure events, like ProcessSample Synthetics events, like SyntheticCheck Custom events, like those reported by the Event API Metric timeslice data (metrics reported by New Relic APM, Browser, and Mobile) The Metric data type (metrics reported by the Metric API and data sources that use that API) The Span data type (distributed tracing data) The Log data type (data from New Relic Logs) Some data, like relationships between monitored entities, is not available via NRQL but is available using our NerdGraph API. Start using NRQL One way to start using NRQL and to understand what data you have available is to go to a NRQL interface (for example, the New Relic One query builder), type FROM, and press space. The interface will suggest available types of data: To see the attributes available for a specific data type, type FROM DATA_TYPE SELECT and press space. The interface will suggest available attributes. For example: To see the complete JSON associated with a data type, including all of its attributes, use the keyset() attribute. For example: FROM Transaction SELECT keyset() NRQL is used behind the scenes to build some New Relic charts and dashboards. One way to learn NRQL is to find one of these NRQL-generated charts and start playing with the NRQL to create new, customized queries and charts: Charts built with NRQL will have View query as an option. You can then edit and customize that query to see how your changes affect the resulting visualization. To explore your data without having to use NRQL, use the basic mode of New Relic One query builder. NRQL query examples Here's an example NRQL query of Transaction data, which is reported by New Relic APM. FROM Transaction SELECT average(duration) FACET appName TIMESERIES auto This would generate a chart that looks like: Here are some more query examples: Basic NRQL query of Browser data Here's a NRQL query of PageView data, which is reported by New Relic Browser. SELECT uniqueCount(user) FROM PageView WHERE userAgentOS = 'Mac' FACET countryCode SINCE 1 day ago LIMIT 20 Attribute name with a space in it If a custom attribute name has a space in it, use backticks around the attribute name: SELECT count(*) FROM Transaction FACET `Logged-in user` Querying multiple data sources To return data from two data sources, separate their data types with a comma. For example, this query returns a count of all APM transactions and Browser events over the last three days:‚Äã SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Query returning multiple columns To return multiple columns from a dataset, separate the aggregator arguments with a comma: SELECT function(attribute), function(attribute) ... FROM ... This query returns the minimum, average, and maximum duration for New Relic Browser PageView events over the last week: SELECT min(duration), max(duration), average(duration) FROM PageView SINCE 1 week ago See more NRQL query examples. NRQL syntax The syntax of a NRQL query is similar to standard SQL queries. Here is a breakdown of the structure of a NRQL query: SELECT function(attribute) [AS 'label'][, ...] FROM data type [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Basic rules include: NRQL condition Details Required values The SELECT statement and FROM clause are required. All other clauses are optional. You can start your query with either SELECT or FROM. Query string size The query string must be less than 4 KB. Case sensitivity The data type names and attribute names are case sensitive. NRQL clauses and functions are not case sensitive. Syntax for strings NRQL uses single quotes to designate strings. For example: ... where traceId = '030a573f0df02c57' Attribute names with spaces Use backticks `` to quote a custom attribute name that has a space in it. For example: ... FACET `Logged-in user` Data type coercion Insights does not support data type \"coercion.\" For more information, see Data type conversion. Use of math functions Basic and advanced math functions are supported in the SELECT statement. JOIN functions NRQL does not have the equivalent of the SQL JOIN function, but you can simulate a JOIN with custom attributes. Read more about NRQL syntax and functions. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.41329,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>NRQL</em>, New Relic&#x27;s query language",
        "sections": "What <em>data</em> can you query with <em>NRQL</em>?",
        "info": "An introduction to New Relic Query Language (<em>NRQL</em>) and how to use it.",
        "category_0": "Query your <em>data</em>",
        "category_1": "<em>NRQL</em>: New Relic Query Language",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;query-your-<em>data</em>&#x2F;<em>nrql</em>-new-relic-query-language&#x2F;get-started&#x2F;introduction-<em>nrql</em>-new-relics-query-language",
        "body": "One way to query your New Relic <em>data</em> is with the New Relic Query Language (<em>NRQL</em>). This resource explains what <em>NRQL</em> is, when and how you can use it, and basic <em>syntax</em> rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see <em>NRQL</em> <em>syntax</em>",
        "breadcrumb": "Contents &#x2F; Query your <em>data</em> &#x2F; <em>NRQL</em>: New Relic Query Language &#x2F; Get started"
      },
      "id": "5f2abd47196a67747343fbe1"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13661,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Insights API",
        "Data requirements and limits for custom event data",
        "General requirements",
        "Reserved words",
        "Event type limits",
        "For more help"
      ],
      "title": "Data requirements and limits for custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/event-data-sources/custom-events/data-requirements-limits-custom-event-data",
      "external_id": "8c97fd1bd86c6d80e73f36d85b36dc52f72ec8ea",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/data-requirements-limits-custom-event-data",
      "published_at": "2021-02-22T17:25:54Z",
      "updated_at": "2021-02-08T05:16:20Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic, general limits and requirements for reporting custom events and attributes. ",
      "body": "As of March 22, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.33649,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for custom event <em>data</em>",
        "sections": "Event <em>data</em> sources",
        "category_1": "Event <em>data</em> sources",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;event-<em>data</em>-sources&#x2F;custom-events&#x2F;<em>data</em>-requirements-limits-custom-event-<em>data</em>",
        "body": " types, naming <em>syntax</em>, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute <em>data</em> types Attribute values can",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; Event <em>data</em> sources &#x2F; Custom events"
      },
      "id": "6020c92464441fa6400a6f57"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 42131,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Rules, limits, and glossary",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Troubleshooting",
        "APM metric alert conditions",
        "Identify the entity",
        "Create the NRQL condition",
        "For more help"
      ],
      "title": "APM metric alert conditions",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "6a3a7e1c9bd9660aed31f654098d2462e676b85d",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/remove_nrql_clauses.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/apm-metric-alert-conditions",
      "published_at": "2021-02-23T07:36:12Z",
      "updated_at": "2021-02-14T10:09:55Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "How to create an APM metric alert condition using NRQL.",
      "body": "While there are various ways to create APM metric alert conditions, we recommend using NRQL because this provides additional controls, improved detection time, and consistency across all data types. In 2021, we will be making it easier to create alert NRQL conditions from charts and queries throughout New Relic One. Until that integration is complete, please use the method described below. We'll show an example of how to create an APM external service condition using NRQL. To set up an APM metric condition, it's a two-part process: you first need to identify the entity and then create the NRQL condition. Identify the entity Here's how to get started: Go to one.newrelic.com, and click APM in the toolbar. Find the service you‚Äôd like to alert on. Click on the service. In the left navigation pane, click External services. Under Top 20 external services, find the service you want and click on it. On the right side of the page, where you see graphs for Response time and External calls per minute (throughput), decide which of these two options you would like to alert on. In the upper-right corner of the graph you choose, click the three dots, and select View query. If you don‚Äôt see these three dots, ensure the Show new view option at the top of the page is enabled. Copy the query to your clipboard. If you choose response time, your query may look like this: If you choose external calls per minute, your query may look like this: When your query is on the clipboard, continue to the next section to create the NRQL alert condition. Create the NRQL condition After you generate the query, complete the following: Navigate to the alert's policy where you‚Äôd like to create this condition. Click Add a condition, select the NRQL tab, and click Next, define thresholds... In Define your signal, paste the query from your clipboard. Remove any LIMIT, SINCE...AGO, and TIMESERIES clauses. These must be removed for the NRQL query syntax to be valid. If no results are returned, ensure you are in the correct account using the account dropdown in the upper-left corner. Fill out the remaining fields and save your condition. See our additional information about querying APM metric timeslice data with NRQL. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.66713,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create the <em>NRQL</em> condition",
        "info": "How to create an APM metric alert condition using <em>NRQL</em>.",
        "body": "While there are various ways to create APM metric alert conditions, we recommend using <em>NRQL</em> because this provides additional controls, improved detection time, and consistency across all <em>data</em> types. In 2021, we will be making it easier to create alert <em>NRQL</em> conditions from charts and queries"
      },
      "id": "6028f6f3196a67a3f1405aaa"
    }
  ],
  "/explore-docs/query-and-store-data": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Caution",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage",
        "This site uses cookies üç™"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2021-02-25T01:51:50Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you‚Äôll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users' configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you‚Äôre authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you‚Äôre authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { \"YourNerdpackUuid\": { \"collection-1\": { \"document-1-of-collection-1\": \"{\\\"lastNumber\\\": 42, \\\"another\\\": [1]}\", \"document-2-of-collection-1\": \"\\\"userToken\\\"\" // ... }, \"another-collection\": { \"fruits\": \"[\\\"pear\\\", \\\"apple\\\"]\" // ... } // ... } } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Caution NerdStorage is not encrypted. Do not store secrets, API keys, personal access tokens or license keys here. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.454475,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "nerdstorage <em>components</em>",
        "body": ": AccountStorage<em>Query</em> and AccountStorage<em>Mutation</em> Entity access: EntityStorage<em>Query</em> and EntityStorage<em>Mutation</em> Each of these <em>components</em> can operate declaratively (for example, as part of your React rendering <em>methods</em>) or imperatively (by using the <em>static</em> <em>methods</em> for <em>query</em> and <em>mutation</em>). For more information"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "category_2": "Java agent release notes",
      "nodeid": 11976,
      "sections": [
        "APM agent release notes",
        "C SDK release notes",
        "Go agent release notes",
        "Java agent release notes",
        ".NET agent release notes",
        "Node.js agent release notes",
        "PHP agent release notes",
        "Python agent release notes",
        "Ruby agent release notes",
        "Java Agent 3.36.0",
        "Improvements",
        "Fixes"
      ],
      "title": "Java Agent 3.36.0",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "APM agent release notes",
      "external_id": "f94f5c53e522a9835ea42514e90d9a39e81fd050",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/java-release-notes/java-agent-3360",
      "published_at": "2021-02-22T14:37:06Z",
      "updated_at": "2018-04-14T23:39:35Z",
      "breadcrumb": "Contents / Release notes / APM agent release notes / Java agent release notes",
      "document_type": "release_notes",
      "popularity": -2,
      "body": "[RSS] Released on:¬† Wednesday, February 15, 2017 - 09:55 Download Improvements APIs This release adds a number of APIs that will allow you to instrument and get expanded visibility into frameworks, libraries, and any custom code that New Relic does not automatically instrument. In addition to instrumenting your web frameworks, you can also instrument calls to and from messaging systems, database calls, and external calls! By passing context about your code to the APIs, you will get the same reporting, including cross application tracing, that you get with New Relic‚Äôs built-in instrumentation. Solr This release adds support for Solr versions 5 and 6 (up to and including version 6.3.0). Fixes Fixes a bug that prevents an application from starting up when a JAX-RS annotated method contains more than 8 parameters. Fixes an issue that affected Spring and JAX-RS applications compiled with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using static methods. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page for customers injecting the X-Queue-Start or X-Request-Start HTTP headers. This fix brings the Java Agent into compliance with the behavior of other New Relic Agents. Fixes an issue in which custom Hystrix Commands that are subclassed multiple times in Groovy cause an application to throw an exception on startup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 48.63872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using <em>static</em> <em>methods</em>. The agent now reports WildFly dispatcher name and version. Fixes a bug"
      },
      "id": "58a53cf38e9c0f755a81db4e"
    },
    {
      "category_2": "API guides",
      "nodeid": 11521,
      "sections": [
        "Java agent",
        "Getting started",
        "Installation",
        "Additional installation",
        "Heroku",
        "Configuration",
        "Attributes",
        "Features",
        "Instrumentation",
        "Custom instrumentation",
        "API guides",
        "Async instrumentation",
        "Troubleshooting",
        "Guide to using the Java agent API",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples",
        "For more help"
      ],
      "title": "Guide to using the Java agent API ",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Java agent",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/agents/java-agent/api-guides/guide-using-java-agent-api",
      "external_id": "a31c751c7c29dd46effac2e568f7c0a92b033b18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api",
      "published_at": "2021-02-22T18:55:52Z",
      "updated_at": "2021-01-31T08:21:43Z",
      "breadcrumb": "Contents / APM agents / Java agent / API guides",
      "document_type": "page",
      "popularity": 1,
      "info": "A goal-focused guide to New Relic's Java agent API, with links to relevant sections of the complete API documentation on GitHub.",
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() For more on obtaining references to the current transaction and other API classes, see Obtain references. API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) For more on obtaining references to the current transaction and other API classes, see Obtain references. API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events to Insights. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the first call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 33.526318,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: <em>Static</em> <em>methods</em> on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "5a3137f4e621f4576cf1e35f"
    },
    {
      "category_2": "PHP agent API",
      "nodeid": 11821,
      "sections": [
        "PHP agent",
        "Getting started",
        "Installation",
        "Advanced installation",
        "Configuration",
        "API guides",
        "PHP agent API",
        "Attributes",
        "Features",
        "Frameworks and libraries",
        "Troubleshooting",
        "newrelic_add_custom_tracer",
        "Requirements",
        "Description",
        "Parameters",
        "Return value(s)",
        "Example(s)",
        "Instrument a function",
        "Instrument a method within a class",
        "Instrument a method within a namespaced class",
        "For more help"
      ],
      "title": "newrelic_add_custom_tracer (PHP agent API)",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "PHP agent",
      "external_id": "12242c1e6fe8cb70e2d42ff670cad04c01e9317e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_add_custom_tracer",
      "published_at": "2021-02-22T14:39:00Z",
      "updated_at": "2019-09-30T22:55:59Z",
      "breadcrumb": "Contents ¬ª APM agents / PHP agent / PHP agent API",
      "document_type": "api_doc",
      "popularity": 1,
      "info": "New Relic PHP agent API call to add custom instrumentation to particular methods in your app code. ",
      "body": "newrelic_add_custom_tracer(string $function_name) Specify functions or methods for the agent to instrument with custom instrumentation. Requirements Compatible with all agent versions. Description Specify functions or methods for the agent to target for custom instrumentation. This is the API equivalent of the newrelic.transaction_tracer.custom setting. You cannot apply custom tracing to internal PHP functions. Parameters Parameter Description $function_name string Required. The name can be formatted either as function_name for procedural functions, or as \"ClassName::method\" for methods. Both static and instance methods will be instrumented if the method syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return value(s) Returns true if the tracer was added successfully. Example(s) Instrument a function function example_function() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"example_function\"); } } Instrument a method within a class class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"ExampleClass::example_method\"); } } } Instrument a method within a namespaced class namespace Foo\\Bar; class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"Foo\\\\Bar\\\\ExampleClass::example_method\"); } } } Alternatively, on PHP 5.5 or later, the ::class syntax can be used instead: namespace Foo\\Bar { class ExampleClass { function example_method() { // ... } } } namespace { use Foo\\Bar; if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(Bar::class . \"::example_method\"); } } }",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 26.317139,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Instrument a <em>method</em> within a class",
        "info": "New Relic PHP agent API call to add custom instrumentation to particular <em>methods</em> in your app code. ",
        "body": " <em>static</em> and instance <em>methods</em> will be instrumented if the <em>method</em> syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return value(s) Returns true if the tracer was added successfully. Example(s) Instrument"
      },
      "id": "58ca4191e621f45edd466e7a"
    },
    {
      "nodeid": 9691,
      "sections": [
        "Introduction to New Relic Mobile (Unity)",
        "Contents",
        "Monitor mobile app performance",
        "Install and configure",
        "Use Unity SDK API",
        "Send custom events and attributes to Insights",
        "Track custom network requests",
        "Uninstall plugin",
        "Unity release notes",
        "For more help"
      ],
      "title": "Introduction to New Relic Mobile (Unity)",
      "type": "docs",
      "external_id": "9e03a54ec6df360532302d4dfe7484070f8ba80c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/introduction-new-relic-mobile-unity",
      "published_at": "2021-02-23T09:26:24Z",
      "updated_at": "2020-07-25T00:44:01Z",
      "breadcrumb": "Contents",
      "document_type": "page",
      "popularity": 1,
      "body": "Legacy feature This document is for historical reference. Unity is no longer supported for new customers. Contents Monitor mobile app performance The New Relic Unity plugin allows Unity developers to embed a New Relic Mobile agent (iOS or Android) in a Unity app build for mobile devices to monitor your app's performance. The plugin is written in C#, but it includes the native iOS and Android agents that embed the appropriate files for your build. Features New Relic Mobile Features Comprehensive performance data View your mobile app's performance Overview page for summary information about active sessions, or drill down to detailed information, including (note limitations below): Interaction times and trace details Crash reporting Devices Operating systems Detailed network views Available by using the API to track custom network requests For iOS apps, receive automatic instrumentation for networking for any parts of the app that are native and non-Unity (using standard Apple networking components such as NSURLConnection) Examine HTTP errors and network failures (such as DNS lookups, timeouts, SSL errors, etc.) and server error traces. Usage details at a glance Compare performance between versions of your app with detailed information for memory, CPU (iOS only), interaction speed, network requests per minute, and network failures. View a monthly report with a bar chart tracking the number of devices running your app for each month over the last year. Mobile SDK API options Use the Unity API to: Create and complete interactions Record custom metrics Send custom events to Insights Track custom network requests Known limitations The New Relic Unity plugin does not automatically instrument interactions. You must use the Unity API to track specific interactions. The New Relic Unity plugin does not automatically instrument network requests. You must use the Unity API to track network calls. Android builds: Unity still generates an Eclipse project, but Android Studio can import the Eclipse project. Install and configure The Unity plugin includes iOS and Android agent files that will embed the appropriate files for your build. To instrument interactions and network requests, you must use the Unity API to manually instrument your code. Install the Unity plugin As part of the installation process, New Relic Mobile automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile project you monitor in New Relic Mobile. For Admins with existing New Relic accounts, follow these steps to install and configure your Unity application. (If you do not have a New Relic account, see New Relic Mobile.) Go to rpm.newrelic.com/mobile. From the mobile apps index, select Add a new app. From the Get started page, select Unity as the platform for mobile monitoring. Type a name for your mobile project, then select Continue. Continue with the procedures to configure the Unity plugin. Configure the Unity plugin These procedures to configure your app also appear on the Get started page in the New Relic UI. Install NewRelic-Unity-Plugin.unitypackage into your project by going to Assets > Import package > Custom package... and selecting NewRelic-Unity-Plugin.unitypackage. Create a new GameObject in your project's initial scene by going to GameObject > Create empty and naming it NewRelicAgent. Add NewRelicAgent.cs script (located in Assets/Plugins) to the NewRelicAgent GameObject: Drag it on top of NewRelicAgent in the Hierarchy tab. OR Click Add Component button, then select New Relic Agent from the Scripts option. In the Inspector tab, set the iOS or Android application token from your New Relic Mobile apps. (Recommendation: Keep New Relic Mobile apps on separate platforms.) Build for your platform (iOS or Android), then open the resulting project (Xcode or Eclipse). For Eclipse, import the generated project into Android Studio. Android only: Ensure that your app requests the INTERNET permission through the Player Settings inspector window. In Other Settings, Configuration, ensure the Internet access dropdown is set to Required. This will result in the following permission added to the app's manifest: <uses-permission android:name=\"android.permission.INTERNET\" /> Run your app in an emulator or device to generate data. Check New Relic Mobile to ensure the data is reporting to your account. Configure crash reporting The New Relic Unity plugin cannot automatically upload dSYMs for iOS crash reporting. You must manually upload dSYMs once your iOS unity app is built for release. If the application is bitcode enabled, follow the procedures for bitcode enabled apps once the your iOS app is submitted to Apple. If you are building an Android app with ProGuard enabled, you must follow similar steps. The ProGuard mapping must be uploaded to New Relic so crash reports can be de-obfuscated. For more information, see Android agent crash reporting. Optional: Change the logging level Six logging levels are available for mobile apps monitoring: NONE ERROR WARNING INFO VERBOSE DEBUG Recommendation: Set the logging level from the Unity Inspector tab. Use Unity SDK API Use the New Relic Unity SDK API to further configure and extend the plugin's instrumentation. Create and complete interactions To start an interaction: string interactionIdentifier = NewRelicAgent.StartInteractionWithName(\"new interaction\"); To stop the current interaction: NewRelicAgent.StopCurrentInteraction(interactionIdentifier); Interactions work in conjuction with method tracing. To trace a method insert startTracingMethod, insert at the start of the method to trace, and insert endTracingMethodWithTimer at each exit point of the method. To start tracing a method: Timer methodTimer = new Timer(); NewRelicAgent.StartTracingMethod(\"MethodName\",\"ClassName\",methodTimer,NewRelicAgent.NRTraceType.None); To end tracing a method, use the same timer as the startTracingMethod:> NewRelicAgent.EndTracingMethodWithTimer(methodTimer); Set a custom build identifier Custom build identifiers are set as the Application Build property in the inspector pane for the NewRelicAgent game object, under the New Relic Agent (Script) settings. Execute a demo crash If you have trouble getting your project to crash, use the New Relic Unity plugin API to execute a demo crash. Recommendation: Add this line of code to a button click event handler as applicable: NewRelicAgent.CrashNow(\"message\")> Record custom metrics With the custom metric API, you can record arbitrary numerical data and named events. Custom metrics can help to track high level events specific to your application. You can use several API calls to record custom metrics that provide different levels of detail. To create a custom metric, use this method: NewRelicAgent.RecordMetricWithName(String name, String category) The name parameter is the textual name of the metric that will appear in the user interface for New Relic Mobile. Using clear, concise metric names will help you get the most out of the metrics. The guidelines for naming a custom metric include: Use case and white space characters appropriate for display in the user interface. Metric names are rendered as-is. Capitalize the metric name. Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. If you want to specify more details about a custom metric, three other API methods are available: NewRelicAgent.RecordMetricWithName(String name, String category, double value) NewRelicAgent.RecordMetricWithName(string name, string category, double value, string valueUnits) NewRelicAgent.RecordMetricWithName(string name, string category, double value, string valueUnits, string countUnits) With these methods, you can record additional details: Parameter Description count The number of times the event has happened totalValue The total value of the recording exclusiveValue The exclusive value of the recording; for example, if the total value contains measurements accounted for elsewhere countUnit Unit of measurement for the metric count, including PERCENT, BYTES, SECONDS, BYTES_PER_SECOND, or OPERATIONS valueUnit Unit of measurement for the metric value, including PERCENT, BYTES, SECONDS, BYTES_PER_SECOND, or OPERATIONS To view the custom metrics you collect, follow standard procedures to create custom dashboards. Send custom events and attributes to Insights The SDK can store up to 64 user-defined attributes at a time. If you attempt to store more than 64 attributes, the SDK returns false. Use the following static methods in the NewRelicAgent namespace to send custom attributes and events to New Relic Insights. Methods that return boolean results return true if they succeed, or false if the operation did not complete. The following methods are available for custom attributes and events: RecordEvent (name, attributes) NewRelicAgent.RecordEvent (string name, string dictionary attributes) Records a custom Insights event. Includes a list of attributes specified as a map. SetAttribute (name, value) NewRelicAgent.SetAttribute (string name, string value) NewRelicAgent.SetAttribute (string name, double value) Creates an attribute with the specified text name and text/float value. SetAttribute overwrites its previous value and type each time it is called. Examples boolean attributeSet = NewRelicAgent.SetAttribute(\"username\", \"SampleUserName\"); boolean attributeSet = NewRelicAgent.SetAttribute(\"rate\", 9999.99); IncrementAttribute (name [, value]) public static boolean IncrementAttribute(String name); public static boolean incrementAttribute(String name, double value) If value is not specified, this method increments the count for the specified attribute by 1. If the attribute does not exist, it creates the attribute with a value of 1. If value is specified, the method will increment the attribute by the specified amount. Examples boolean incremented = NewRelicAgent.IncrementAttribute(\"rate\"); boolean incremented = NewRelicAgent.IncrementAttribute(\"rate\", 9999.99, false); RemoveAttribute (name) NewRelicAgent.RemoveAttribute(String name) Removes the specified attribute. Example boolean attributeRemoved = NewRelicAgent.RemoveAttribute(\"rate\"); removeAllAttributes NewRelicAgent.removeAllAttributes() Removes all attributes from the session. Example boolean attributesRemoved = NewRelicAgent.RemoveAllAttributes(); Track custom network requests New Relic Mobile's API provides several methods to track network requests and network failures. For example, use the noticeHttpTransaction family of methods to record HTTP transactions with several available levels of detail. If a network request fails, you can record details about the failure with noticeNetworkFailure. NoticeNetworkRequest NewRelicAgent.NoticeNetworkRequest (\"http://newrelic.com\", \"GET\", timer, null, 200, 1024, 8192, bytes, httpParameters); Parameter Description url The URL of the request httpMethod The HTTP method used, such as GET or POST statusCode The statusCode of the HTTP response, such as 200 for OK timer A timer created when the network request was started bytesSent The number of bytes sent in the request bytesReceived The number of bytes received in the response responseBody The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. params Additional parameters included in an HTTP Error metric if the HTTP transaction is an error. NoticeNetworkFailure NewRelicAgent.NoticeNetworkFailure(String url, String httpMethod, Timer timer, NewRelicAgent.NetworkFailureCode failureCode, String message) Parameter Description url The URL of the request httpMethod The HTTP method used, such as GET or POST timer A timer created when the network request was started exception The exception that occurred. New Relic Mobile can automatically translate many common exceptions into network failure types. failure The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Uninstall plugin To uninstall the Unity plugin, use the project console to remove all related files and resources that were installed with the Unity package: Delete NewRelicAgent object from the Hierarchy pane of the Unity project console. From All Scripts, delete all the scripts that start with newrelic. Then do the following as applicable: From Assets > Plugin > iOS, delete the NewRelicIos, NewRelicUnityPlugin, post-build, and restore-framework files. Then remove the mod_pbxproj and NewRelicAgent.framework directories. From Assets > Plugin > Android, delete the newrelic.android and NewRelicAndroid files. Then remove the LICENSE and README directories. Unity release notes These release notes are for historical reference. Unity is no longer supported for new customers. Unity plugin 1.2.0 Released on: Monday, March 13, 2017 - 13:00 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.2.0.zip Notes: Updated Unity plugin to iOS agent 5.9.0 and Android agent 5.9.0 Unity plugin 1.1.0 Released on: Tuesday, September 6, 2016 - 14:53 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.1.0.zip Notes: Updated Unity plugin to iOS agent 5.8.0 and Android agent 5.7.1 Unity plugin 1.0.1 Released on: Monday, August 8, 2016 - 14:00 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.0.1.zip Notes: Bundle Android class rewriter JAR file (version 5.6.1) into the Unity package. Unity plugin 1.0.0 Released on: Wednesday, May 25, 2016 - 14:00 Download URL: http://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.0.0.zip Notes: This plugin provides New Relic Mobile agent support for iOS and Android applications built with Unity. It also gives Unity developers access to New Relic crash reporting. It provides information about app performance, sessions, devices, operating systems, and more. It also includes APIs for custom instrumentation to gain deeper insights into specific areas of your app. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 14.705725,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " The SDK can store up to 64 user-defined attributes at a time. If you attempt to store more than 64 attributes, the SDK returns false. Use the following <em>static</em> <em>methods</em> in the NewRelicAgent namespace to send custom attributes and events to New Relic Insights. <em>Methods</em> that return boolean results return"
      },
      "id": "5c52cbec8e9c0f0b286080ec"
    }
  ],
  "/collect-data/get-started-nerdgraph-api-explorer": [
    {
      "category_2": "Examples",
      "nodeid": 42646,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "Export and import dashboards using the API",
        "List your dashboards",
        "Export a dashboard",
        "Import a dashboard into a new account",
        "For more help"
      ],
      "title": "Export and import dashboards using the API",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "c1b1812b720d4b77f4717e68746206b470669a96",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/dashboards_api_paste_entity.png",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/export-import-dashboards-using-api",
      "published_at": "2021-02-23T04:33:04Z",
      "updated_at": "2021-02-21T15:35:42Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic NerdGraph to export and import dashboards. ",
      "body": "You can export your dashboards and import them into a new account using queries and mutations in NerdGraph. You can also export your dashboards as an image. To do so: Go to the GraphiQL explorer. Find out which dashboards are available. Export the desired dashboard. Import the selected dashboard into a new account. List your dashboards Use the following query to retrieve a list of your existing dashboards: { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Export a dashboard Use the following query to export, then extract the dashboard's entity information from the output: { actor { entity(guid: \" your_guid_xxxxxxx \") { ... on DashboardEntity { name permissions pages { name widgets { visualization { id } title layout { row width height column } rawConfiguration } } } } } } Example entity information in GraphiQL output: Import a dashboard into a new account Use the following mutation to import the dashboard into another account: mutation create($dashboard: Input!) { dashboardCreate(accountId: your_new_AccountID , dashboard: $dashboard) { entityResult { guid name } errors { description } } } Follow these steps: In the Query variables section, name the entity Dashboard (since we declared the input variable as $dashboard). Copy and paste the entity's output into the new account. It will be copied as an entity. Change entity to dashboard. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.11473,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>NerdGraph</em>",
        "info": "Use New Relic <em>NerdGraph</em> to export and import dashboards. ",
        "category_1": "<em>NerdGraph</em>",
        "body": "You can export your dashboards and import them into a new account using queries and <em>mutations</em> in <em>NerdGraph</em>. You can also export your dashboards as an image. To do so: Go to the GraphiQL explorer. Find out which dashboards are available. Export the desired dashboard. Import the selected dashboard",
        "breadcrumb": "Contents &#x2F; APIs &#x2F; <em>NerdGraph</em> &#x2F; Examples"
      },
      "id": "60327dcee7b9d247728b3b85"
    },
    {
      "category_2": "Core concepts",
      "nodeid": 41906,
      "sections": [
        "Use New Relic One",
        "Get started",
        "Core concepts",
        "UI and data",
        "Workloads",
        "Build on New Relic One",
        "Dashboards API migration: from Insights API to Nerdgraph",
        "Why a new dashboards API?",
        "From REST endpoints to GraphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "Show (GET) -> entity query",
        "Create (POST) -> dashboardCreate mutation",
        "Update (PUT) -> dashboardUpdate mutation",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Errors as first class citizens"
      ],
      "title": "Dashboards API migration: from Insights API to Nerdgraph",
      "category_0": "New Relic One",
      "type": "docs",
      "category_1": "Use New Relic One",
      "external_id": "b5ac1e396f08a48f318a283be906aa8b9bca7310",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph",
      "published_at": "2021-02-23T06:23:18Z",
      "updated_at": "2021-02-08T11:08:52Z",
      "breadcrumb": "Contents / New Relic One / Use New Relic One / Core concepts",
      "document_type": "page",
      "popularity": 1,
      "body": "In case you haven‚Äôt heard, NerdGraph is New Relic‚Äôs unified API in a graphQL flavor. The new dashboards API follows this unified approach and is exposed through NerdGraph for user consumption. Why a new dashboards API? Dashboards in New Relic embrace the entity concept and are now an entity in New Relic‚Äôs entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built new features for dashboards: All New Relic One dashboards are structured in pages, known as Data Apps in Insights Multiple queries from different accounts within the same widget Facet linking Facet linking with support for cases From REST endpoints to GraphQL queries/mutations One of the main benefits from a GraphQL API is that it provides a complete and understandable description of the APIs' data. By using NerdGraph GraphiQL explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new GraphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic‚Äôs entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } You can list all the dashboards by name: { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } You can list all the dashboards by the creator‚Äôs email: { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } You can list all the dashboards by the creator‚Äôs userId: { actor { entitySearch(query: \"type = 'DASHBOARD' and ownerId = \"2357322\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity GUID. Then you can access all the dashboard properties that you are interested in by adding them in the GraphQL query. In the example below we are only interested in the entity GUID and the name of our dashboard. { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid name } } } } Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in GraphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although GraphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields, like the doc about how to build dashboard widgets. The example below is not complete but can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardCreate( accountId: 1, dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard GUID and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory, but you can look up the doc about how to build dashboard widgets. The example is not complete but it can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardUpdate( guid: \"MY_EXISTING_DASHBOARD_GUID\", dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity GUID. mutation { dashboardDelete { status errors { type description } } } Errors as first class citizens As you might have noticed, all dashboard mutations offer you a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect potential issues. Every error has a type and a description to help you identify what‚Äôs the source of the problem. mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.83063,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Dashboards API migration: from Insights API to <em>Nerdgraph</em>",
        "sections": "From REST endpoints to GraphQL <em>queries</em>&#x2F;<em>mutations</em>",
        "body": " REST endpoints map to the new GraphQL queries or <em>mutations</em>. List (GET) -&gt; entitySearch <em>query</em> Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic‚Äôs entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch"
      },
      "id": "6014e93c64441f4eea3e17bc"
    },
    {
      "category_2": "Examples",
      "nodeid": 42656,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "Golden metrics for entities NerdGraph API tutorial",
        "Fetch golden metrics",
        "Fetch golden tags",
        "Customize golden metrics and golden tags",
        "Override golden metrics or golden tags for a specific entity type in your whole account",
        "Override golden metrics from a particular entity type in a workload",
        "Fetch the custom golden metrics and golden tags",
        "Reset custom metrics and golden tags",
        "Expected errors",
        "For more help"
      ],
      "title": "Golden metrics for entities NerdGraph API tutorial",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "956bc04201d39123c3cb69777298c967ab1c4cfd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/golden-metrics-entities-nerdgraph-api-tutorial",
      "published_at": "2021-02-23T07:47:19Z",
      "updated_at": "2021-02-21T15:35:42Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic's NerdGraph (our GraphQL API) to query or override golden metrics and tags.",
      "body": "Golden metrics and golden tags are bits of information about an entity that we consider to be the most important for that entity. We use this information to display a brief overview of an entity across all New Relic. You can see and contribute to the standard definitions of the golden metrics and tags in this public repository. This document explains how to query an entity's custom metrics using NerdGraph. For more on how to query entities using the NerdGraph API, see our tutorial. Fetch golden metrics When fetching golden metrics for a specific GUID or list of GUIDS, the provided queries are already filtered for you. You can run the resulting query as is in the query builder. The resulting metric can be either a timeseries or a single value. Here's an example of one golden metric query for an AWS DynamoDB table entity with the GUID ExampleGUID. SELECT average(provider.getSuccessfulRequestLatency.Average) FROM DatastoreSample WHERE entityGuid IN ('ExampleGUID') AND provider='DynamoDbTable' TIMESERIES You can use NerdGraph to query for the golden metrics of a specific entity; for example: { actor { entity(guid: \"ENTITY-GUID\") { goldenMetrics { query title } } } } Fetch golden tags Golden tags are always represented the same way, whether requested by GUID or by entityType. You will always receive the list of tag keys considered the most important about the entity. { actor { entity(guid: \"ENTITY-GUID\") { goldenTags { key } } } } Customize golden metrics and golden tags If you want to change the golden metrics and golden tags based on the specificities of your environment, you can override them in two different contexts, in your account, or in a workload. Override golden metrics or golden tags for a specific entity type in your whole account In this case, the new golden metrics or the new golden tags will be applied in all New Relic One, converting your new metrics and tags as the default for the specified entity type. To do that, you can use a NerdGraph mutation to override the golden metrics for a specific entity. mutation { entityGoldenMetricsOverride( context: {account: ACCOUNT_TO_OVERRIDE_GOLDEN METRICS}, domainType: {domain: DOMAIN, type: TYPE}, metrics: [ {eventId: EVENT_ID, select: NRDB_QUERY_SELECT, from: NRDB_QUERY_EVENT, where: NRDB_QUERY_WHERE, title: TITLE_OF_THE_METRIC, facet: FACET, name: NAME_OF_THE_METRIC}, ...]) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } Where: domainType: The entity type of the metrics to override. context: The context to fetch the golden metrics from. In this case, you should set the account that you want to override. metrics: The new NRDB query will be shown as golden metrics. eventId: The field used to filter the entity in the metric. How the entity GUID is defined in your event. select: The SELECT clause of the NRDB query. This field is required. from: The FROM clause of the NRDB query. where: Complementary where clause to identify the entity type field. facet: The field to FACET. title: The title of the golden metric. This field is optional. name: The name of the golden metric. This field is required. Override an APM application mutation { entityGoldenMetricsOverride( context: {account: ACCOUNT_ID}, domainType: {domain: \"APM\", type: \"APPLICATION\"}, metrics: [ {eventId: \"entity.guid\", from: \"Transaction\", name: \"cpuUsage\", select: \"max(cpuUsage)\", title: \"CPU Usage\"}, {eventId: \"guid\", from: \"Metric\", where: \"metricTimesliceName in ('HttpDispatcher', 'OtherTransaction/all')\", facet: \"appName\", select: \"count(newrelic.timeslice.value)\", name: \"throughput\", title: \"Throughput\"}]) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } The metrics input object defines the parts of an NRDB query, split into sections. One of these sections is the eventId, which is used to identify the field that defines the GUID inside the NRDB Event you want to use as a golden metric. For example: SELECT average(provider.getSuccessfulRequestLatency.Average) FROM DatastoreSample WHERE entityGuid IN ('EntityGuid') AND provider='DynamoDbTable' FACET entityName TIMESERIES It's defined as follows: { eventId: \"entityGuid\", from: \"DatastoreSample\", where: \"provider='DynamoDbTable'\", facet: \"entityName\", select: \"average(provider.getSuccessfulRequestLatency.Average)\", name: GetItem latency (ms), title: GetItem latency (ms) } As you can see in the resultant object, the where clause only contains the provider field. The system adds the where clause with the eventId field by default. You can do the same for the golden tags using this NerdGraph mutation: mutation { entityGoldenTagsOverride( context: {account: ACCOUNT_ID}, domainType: {domain: \"APM\", type: \"APPLICATION\"}, tags: [{key: \"applicationName\"} , {key: \"environment\"} ]) { errors { message type } tags { context { account } domainType { domain type } tags { key } } } } Override golden metrics from a particular entity type in a workload New Relic's workloads provide an aggregated view of health and performance data about a group of entities. The time series charts shown for each entity type in a workload are defined by the golden metrics in the workload account. If you want to further customize which time series to show for a specific entity type in a particular workload, override the golden metrics in the account with the following mutation: mutation { entityGoldenMetricsOverride( context: {guid: WORKLOAD_TO_OVERRIDE_GOLDEN METRICS}, domainType: {domain: DOMAIN, type: TYPE}, metrics: [ {eventId: EVENT_ID, select: NRDB_QUERY_SELECT, from: NRDB_QUERY_EVENT, where: NRDB_QUERY_WHERE, title: TITLE_OF_THE_METRIC, facet: FACET, name: NAME_OF_THE_METRIC}, ...]) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } See above for details on each field. In this case, context is the workload's GUID. Override an APM application mutation { entityGoldenMetricsOverride( context: {guid: WORKLOAD_ENTITY_GUID}, domainType: {domain: \"APM\", type: \"APPLICATION\"}, metrics: [ {eventId: \"entity.guid\", from: \"Transaction\", name: \"cpuUsage\", select: \"max(cpuUsage)\", title: \"CPU Usage\"}, {eventId: \"guid\", from: \"Metric\", where: \"metricTimesliceName in ('HttpDispatcher', 'OtherTransaction/all')\", facet: \"appName\", select: \"count(newrelic.timeslice.value)\", name: \"throughput\", title: \"Throughput\"}]) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } Fetch the custom golden metrics and golden tags The queries defined in the previous sections always return the default golden metrics and golden tags. If you want to fetch your custom golden metrics or golden tags, you need to send the context defined in the query, for example: { actor { entity(guid: INFRA-AWSDYNAMODBTABLE-GUID) { goldenMetricsByContext( context: {account: ACCOUNT_ID, guid: WORKLOAD_ENTITY_GUID}) { metrics { title query name } } } } } For golden tags: { actor { entity(guid: INFRA-AWSDYNAMODBTABLE-GUID) { goldenTags(context: {account: ACCOUNT_ID, guid: WORKLOAD_ENTITY_GUID}) { tags { key } } } } } You can send both contexts simultaneously for querying, if your metrics or tags have the context inside the workload. The API returns the most specific golden metric or golden tags based on the context that you defined in the requests. The priority is workload and account. Reset custom metrics and golden tags If your custom golden metrics are not relevant to you any more, you can restore the defaults defined by New Relic. In the context parameter, set the desired account or workload guid (in the guid parameter). To restore your golden metrics in an account, run this query: mutation { entityGoldenMetricsReset( context: {guid: ACCOUNT_TO_OVERRIDE_GOLDEN_METRICS}, domainType: {domain: DOMAIN, type: TYPE}) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } Where: domainType: The entity type of the metrics to override. context: The context to fetch the golden metrics from. In this case, you should set the account you want to reset. To restore your golden metrics in a workload, run this query: mutation { entityGoldenMetricsReset( context: {guid: GUID_TO_OVERRIDE_GOLDEN_METRICS}, domainType: {domain: DOMAIN, type: TYPE}) { errors { message type } metrics { context { account guid } domainType { domain type } metrics { definition { eventId facet from select where } name query title } } } } You can do the same for your custom golden tags: mutation { entityGoldenTagsReset( context: {guid: WORKLOAD_ENTITY_GUID}, domainType: {domain: \"APM\", type: \"APPLICATION\"}) { errors { message type } tags { key context { account guid } domainType { domain type } tags { key } } } } Expected errors All these mutations can answer with the result of the operation or a list of errors. These are all the expected errors that you can receive: INVALID_CONTEXT: The context is not valid. There can only be one context, an account or a workload's GUID. If you use both, or use any other concept, or a GUID that doesn't belong to a workload, you will get this error. INVALID_DOMAIN_TYPE: The domain type is not valid. LIMIT_EXCEEDED: The maximum amount of metrics is 9. If you exceed this limit you will get this error. NOT_AUTHORIZED: The user doesn't have the permissions to carry out this action. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.52533,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Golden metrics for entities <em>NerdGraph</em> API tutorial",
        "sections": "<em>NerdGraph</em>",
        "info": "Use New Relic&#x27;s <em>NerdGraph</em> (our GraphQL API) to <em>query</em> or override golden metrics and tags.",
        "category_1": "<em>NerdGraph</em>",
        "body": " and tags in this public repository. This document explains how to <em>query</em> an entity&#x27;s custom metrics using <em>NerdGraph</em>. For more on how to <em>query</em> entities using the <em>NerdGraph</em> API, see our tutorial. Fetch golden metrics When fetching golden metrics for a specific GUID or list of GUIDS, the provided queries",
        "breadcrumb": "Contents &#x2F; APIs &#x2F; <em>NerdGraph</em> &#x2F; Examples"
      },
      "id": "60327dcfe7b9d2f2838b3bb0"
    },
    {
      "category_2": "Examples",
      "nodeid": 19141,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "NerdGraph entities API tutorial",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Search by attribute",
        "Search by entity GUID",
        "Example queries",
        "For more help"
      ],
      "title": "NerdGraph entities API tutorial",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "6dad137791a70630e57cb10aa5f574776c26613f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial",
      "published_at": "2021-02-22T19:23:56Z",
      "updated_at": "2021-02-22T19:23:56Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic's NerdGraph (our GraphQL API) to query your monitored entities (applications, hosts, etc.)",
      "body": "To query data with New Relic's NerdGraph, we use the concept of an entity. An entity provides unified access to all the things you monitor with New Relic, including but not limited to: Applications monitored by APM. Cloud integrations, services, and hosts monitored by infrastructure monitoring. To view entity details in the our UI, use the New Relic Explorer in New Relic One. To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Each entity has similar traits: A unique entity GUID identifies it. It exists over a span of time, even if it's a short period. It provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements All you need is a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. OR Use the freeform query argument to provide your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. In addition to these examples, we highly recommend exploring the API using the NerdGraph GraphiQL explorer and searching its inline documentation. Search by attribute Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND type IN ('APPLICATION')\"} Search by entity GUID Use a specific entity's GUID to query deeper into its related data. For example: query($guids: EntityGuid! ) { actor { entities(guids: $guids) { entityType name } } } Add the following variables to the Query variables section: {\"guids\": \"entity-guid-here\"} Example queries Queries are requests that are intended to only fetch data (no side effects). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using the queryBuilder If you aren't sure how to start crafting an entity search query, you can rely on NerdGraph to help you build one, and then retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and searching its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and searching its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's Alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit and you want to view the rest of the results, you can request nextCursor in your initial request and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.18906,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> entities API tutorial",
        "sections": "<em>NerdGraph</em>",
        "info": "Use New Relic&#x27;s <em>NerdGraph</em> (our GraphQL API) to <em>query</em> your monitored entities (applications, hosts, etc.)",
        "category_1": "<em>NerdGraph</em>",
        "body": "To <em>query</em> data with New Relic&#x27;s <em>NerdGraph</em>, we use the concept of an entity. An entity provides unified access to all the things you monitor with New Relic, including but not limited to: Applications monitored by APM. Cloud integrations, services, and hosts monitored by infrastructure monitoring",
        "breadcrumb": "Contents &#x2F; APIs &#x2F; <em>NerdGraph</em> &#x2F; Examples"
      },
      "id": "5d8fd87f196a67bba0756f3f"
    },
    {
      "nodeid": 37751,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Rules, limits, and glossary",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Troubleshooting",
        "NerdGraph API: Examples",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Queries",
        "Mutations",
        "For more help"
      ],
      "title": "NerdGraph API: Examples ",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "017d6c34d340b9bc035e91483d675915fa5252eb",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples",
      "published_at": "2021-02-22T13:54:52Z",
      "updated_at": "2020-08-11T04:59:00Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alerts and Nerdgraph",
      "document_type": "page",
      "popularity": 1,
      "info": "Read about how you can manage alerts conditions, policies, and muting rules using NerdGraph.",
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer: For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.30986,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> API: Examples ",
        "sections": "<em>Mutations</em>",
        "info": "Read about how you can manage alerts conditions, policies, and muting rules using <em>NerdGraph</em>.",
        "body": " Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and <em>mutations</em> is through the <em>NerdGraph</em> API explorer. <em>NerdGraph</em> API explorer Our <em>NerdGraph</em> API explorer is a GraphiQL editor where you can prototype queries and <em>mutations</em>. Here are some examples showing",
        "breadcrumb": "Contents &#x2F; Alerts and Applied Intelligence &#x2F; New Relic Alerts &#x2F; Alerts and <em>Nerdgraph</em>"
      },
      "id": "5f2dbad864441fd15456a9eb"
    }
  ],
  "/automate-workflows/get-started-kubernetes": [
    {
      "category_2": "Get started",
      "nodeid": 40836,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Rules, limits, and glossary",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Troubleshooting",
        "Streaming alerts: key terms and concepts",
        "Why it matters",
        "Streaming alerts tools",
        "Loss of signal detection",
        "Gap filling",
        "Aggregation window",
        "Offset evaluation",
        "For more help"
      ],
      "title": "Streaming alerts: key terms and concepts",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "01517529fcf70c4c598d2f06638e3afea8ab4837",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/streaming_alerts.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/get-started/streaming-alerts-key-terms-concepts",
      "published_at": "2021-02-23T06:14:57Z",
      "updated_at": "2021-02-23T06:14:57Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Get started",
      "document_type": "page",
      "popularity": 1,
      "body": "The streaming alerts platform checks for violations based on data that‚Äôs present or missing in the stream of data coming into New Relic. The stream of data that comes into New Relic is called a signal. You can control what part of the signal is alerted on through NRQL conditions. These NRQL condition alerts are processed by the streaming algorithm. The NRQL query provides the signal filter for all of your incoming data. You can read more about the streaming alerts platform in this Explorers Hub post. Why it matters Alerts violations are easy when they're caused by a specific event happening, but trickier when looking for events not happening. Only data that matches the conditions of the NRQL WHERE clause is alerted on. As data streams into New Relic, it's filtered by the NRQL condition. Before data is evaluated, it must meet the criteria defined by the NRQL query's WHERE clause. Instead of evaluating that data immediately for violations, the NRQL alert conditions collect the data over a period of time known as the aggregation window. An additional offset delay allows for slower data to come through before it's processed. Once the aggregation window plus the offset time have elapsed, New Relic groups the aggregated data into a single data point. Alerts then evaluates the data point using the NRQL condition in order to determine whether it meets the violation threshold criteria. Even if a data point meets the criteria for a violation, a violation isn't triggered. A violation is only triggered when data points consistently meet the threshold criteria over a period of time. This is the threshold duration. If the data points are in violation for an entire threshold duration, we'll send you a notification based on your policy settings. All of these configurable delays give you more control over how you're alerted on sporadic and missing data. Streaming alerts tools Streaming alerts provide a set of tools you can use to more effectively alert on your streaming data, giving you greater control and reducing the number of false alerts notifications. They are: Loss of signal detection Gap filling Aggregation window duration customization Offset evaluation This article covers these tools at a conceptual level. You'll find direct instructions on how to use these tools in Create NRQL alert conditions. Loss of signal detection Loss of signal occurs when no data matches the NRQL condition over a specific period of time. A loss of signal is caused by different things. The WHERE clause in your NRQL query can filter out data before it's evaluated for violations. It could also mean a service or entity is offline or a periodic job has failed to run and no data is being sent to New Relic. In order to avoid unnecessary notifications, you can choose how long to wait before you're notified by a loss of signal violation. You can use loss of signal detection to open violations and be notified when a signal is lost. Alternately, you can use a loss of signal to close violations for ephemeral services or sporadic data, such as error counts. Gap filling Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with None, the last value received, or a static value. The default is None. Gaps in streaming data can be caused by network or host issues, a signal may be sparse, or some signals, such as error counts, may only have data when something is wrong. By filling the gaps with known values, the alert evaluation process can process those gaps and determine how they should affect the loss of signal evaluation. Aggregation window In order to make loss of signal detection more effective and to reduce unnecessary notifications, you can customize aggregation windows to the duration that you need. An aggregation window is a specific block of time. We gather data points together in an aggregation window, before using the aggregation function to evaluate the data. A longer aggregation window gives straggling data points more time to arrive before evaluating that data. When a data point arrives, its timestamp is used to put it in the proper aggregation window. You can set your aggregation window to anything between 1 second and 15 minutes. The default is 1 minute. Offset evaluation For data that consistently takes longer to arrive, you can use offset evaluation to consistently delay the NRQL condition evaluation. Waiting longer increases accuracy, but also increases latency. The offset time value is the number of aggregation windows you want to use. The duration for each window is set in the Aggregation window field. For example, if your aggregation window is 1 minute and your Offset evaluation is 3, then a straggling data point will have about 3 minutes to arrive before it might be dropped. In other words, streaming alerts will always keep 3 aggregation windows in the queue, waiting 1 minute before evaluating each window and adding a new one. The current default is 3. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.06026,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Streaming <em>alerts</em>: key terms and concepts",
        "sections": "<em>Alert</em> <em>conditions</em>",
        "category_0": "<em>Alerts</em> and Applied Intelligence",
        "category_1": "New Relic <em>Alerts</em>",
        "body": " of evaluating that data immediately for violations, the <em>NRQL</em> <em>alert</em> <em>conditions</em> collect the data over a period of time known as the aggregation window. An additional offset delay allows for slower data to come through before it&#x27;s processed. Once the aggregation window plus the offset time have"
      },
      "id": "5f7f39fc28ccbc39853cd100"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Automate common tasks",
        "Set up New Relic using the Kubernetes operator",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Automate workflows",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.4293,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up New Relic using the <em>Kubernetes</em> <em>operator</em>",
        "body": " to tag apps and create deployment markers Set up New Relic using the <em>Kubernetes</em> <em>operator</em> 20 min Learn how to provision New Relic resources using the <em>Kubernetes</em> <em>operator</em> Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 9231,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Rules, limits, and glossary",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Troubleshooting",
        "Create NRQL alert conditions",
        "Create a NRQL alert condition",
        "NRQL alert syntax",
        "NRQL alert threshold examples",
        "Nested aggregation NRQL alerts",
        "NRQL condition creation tips",
        "Alert threshold types",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Advanced signal settings",
        "Aggregation window",
        "Evaluation offset",
        "Fill data gaps",
        "For more help"
      ],
      "title": "Create NRQL alert conditions",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "external_id": "956a7a0b84d2afac5e6236df3143085ebc4f7459",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/nr1_nrql_alert_conditions.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "published_at": "2021-02-23T12:38:14Z",
      "updated_at": "2021-02-23T12:38:13Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "How to define thresholds that trigger alert notifications based on your NRQL queries.",
      "body": "You can use NRQL queries to create alert conditions. Once you've defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Click NRQL, and then Next, define thresholds. For more information on key concepts relating to NRQL alert conditions and streaming alerts, see Streaming alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition for a policy: On one.newrelic.com, in the header click Alerts & AI, then in the left sidebar click Policies. Select an existing policy or click New alert policy to create a new policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define thresholds. NRQL alert syntax Here's the basic syntax for creating all NRQL alert conditions. The FACET clause is required for Outlier threshold types, optional for Static, and not allowed for Baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Required for outlier conditions, but not baseline or static Include an optional FACET clause in your NRQL syntax depending on the threshold type: static, baseline, or outlier. Use the FACET clause to separate your results by attribute and alert on each attribute independently. No LIMIT clause is allowed, but all queries will receive the maximum number of facets possible. Faceted queries can return a maximum of 5000 values for static conditions and a maximum of 500 values for outlier conditions. If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction SELECT percentile(databaseDuration, 75) FROM Transaction Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction SELECT average(duration) FROM Transaction Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Nested aggregation NRQL alerts Nested aggregation queries are a powerful way to query your data. However, they have a few restrictions that are important to note. Nested queries with a non-faceted innermost query are not currently supported Without a FACET, the inner query produces a single result, giving the outer query nothing to aggregate. If you're using a nested query, make sure your inner query is faceted. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu) ‚Äã‚Äã‚Äã‚Äã‚Äã Queries at all levels must have the same aggregation window size With an alert aggregation window of 1 minute, the inner query would produce two smaller windows of 30 seconds. In theory, these two windows could be aggregated by the outer query. However, this is not currently supported. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)‚Äã‚Äã Signal loss is not yet supported for nested queries For more information on signal loss, see NerdGraph API: Loss of signal and gap filling. NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. For details, see Description Query results Queries must return a number. The condition evaluates the returned number against the thresholds you've set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that violations for sporadic data, such as error counts, are closed when no signal is coming in. To learn more about signal loss and how to request access to it, see this announcement. Advanced signal settings These settings give you options for better handling continuous, streaming data signals that may sometimes be missing. These settings include the aggregation window, the evaluation offset, and an option for filling data gaps. For more on using these, see Advanced signal settings. Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions don't affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type, except you can't use a FACET clause. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. Sum of query results (limited or intermittent data) Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. You can use loss of signal, aggregation duration, and gap filling settings to minimize these false notifications. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum and the preview chart will update accordingly. Set the loss of signal threshold Loss of signal occurs when no data matches the NRQL condition over a specific period of time. You can set your loss of signal threshold duration and and also what happens when the threshold is crossed. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Loss of signal is only available for NRQL conditions. You may also manage these settings using the GraphQL API (recommended), or the REST API. Go here for specific GraphQL API examples. Loss of signal settings: Loss of signal settings include a time duration and two possible actions. Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration Expiration duration is a timer that starts and resets when we receive a data point in the streaming alerts pipeline. If we don't receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. The loss of signal expiration time is independent of the threshold duration and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we recommend using at least 3-5 minutes. Loss of signal actions Once a signal is considered lost, you can close open violations, open new violations, or both. Close all current open violations: This closes all open violations that are related to a specific signal. It won't necessarily close all violations for a condition. If you're alerting on an ephemeral service, or on a sporadic signal, you'll want to choose this action to ensure that violations are closed properly. The GraphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to a loss of signal. Based on your incident preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we'll close all open violations first, and then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: For a policy, when you create a condition, under Select a product, click NRQL, then click Next, define thresholds. Write a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in minutes or seconds in the Signal is lost after field. Choose what you want to happen when the signal is lost. You can check one or both of Close all current open violations and Open new \"lost signal\" violation . These control how loss of signal violations will be handled for the condition. Make sure you name your condition before you save it. Loss of signal detection doesn't work on NRQL queries that use nested aggregation or sub-queries. Advanced signal settings When creating a NRQL alert condition, the advanced signal settings gives you better control over streaming alert data and helps you avoid false alarms. When creating a NRQL condition, there are several advanced signal settings: Aggregation window Evaluation offset Fill data gaps To read an explanation of what these settings are and how they relate to each other, see Streaming alerts concepts. Below are instructions and tips on how to configure them. Aggregation window You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. You can set it to anything between one second and 15 minutes. The default is one minute. Baseline alert condition thresholds don't support editing the aggregation window. They use the 1 minute default. Evaluation offset You can adjust the evaluation offset to coordinate our streaming alerting algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. The total supported latency is the product of the aggregation window duration multiplied by the evaluation offset. In the example screenshot above, the supported latency is 3 minutes (a 1-minute aggregation window multiplied by three windows). If the data type comes from an APM language agent and is aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3 with 1 minute aggregation windows. When creating NRQL conditions for data collected from Infrastructure Cloud Integrations such as AWS Cloudwatch or Azure, we recommend that you start with an evaluation offset of 15 minutes, then adjust up or down depending on how long it takes to collect your data. Fill data gaps Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with one of these settings: None: (Default) Choose this if you don't want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won't be in violation. Custom static value: Choose this if you'd like to insert a custom static value into the empty aggregation windows before they're evaluated. This option has an additional, required parameter of fillValue (as named in the API) that specifies what static value should be used. This defaults to 0. Last known value: This option inserts the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. Options for editing data gap settings: In the NRQL conditions UI, go to Condition settings > Advanced signal settings > fill data gaps with and choose an option. If using our Nerdgraph API (preferred), this node is located at: actor : account : alerts : nrqlCondition : signal : fillOption | fillValue NerdGraph is the preferred API but if you are using our REST API, you can find this setting in the REST API explorer under the \"signal\" section of the Alert NRQL conditions API. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.789825,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "sections": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "info": "How to define thresholds that trigger <em>alert</em> notifications based on your <em>NRQL</em> queries.",
        "category_0": "<em>Alerts</em> and Applied Intelligence",
        "category_1": "New Relic <em>Alerts</em>",
        "category_2": "<em>Alert</em> <em>conditions</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;<em>alerts</em>-applied-intelligence&#x2F;new-relic-<em>alerts</em>&#x2F;<em>alert</em>-<em>conditions</em>&#x2F;create-<em>nrql</em>-<em>alert</em>-<em>conditions</em>",
        "body": "You can use <em>NRQL</em> queries to create <em>alert</em> <em>conditions</em>. Once you&#x27;ve defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts &amp; AI",
        "breadcrumb": "Contents &#x2F; Alerts and Applied Intelligence &#x2F; New Relic Alerts &#x2F; <em>Alert</em> <em>conditions</em>"
      },
      "id": "5f2d992528ccbc489d88dfc1"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 7391,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Rules, limits, and glossary",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Troubleshooting",
        "View entity health status and find entities without alert conditions",
        "Exceptions",
        "Color-coded health status",
        "Health status transitions",
        "Example: App without conditions",
        "Example: App with conditions",
        "For more help"
      ],
      "title": "View entity health status and find entities without alert conditions",
      "category_0": "Alerts and Applied Intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "16c3fc543366aed467c2219a18774c5220117948",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/view-entity-health-status-find-entities-without-alert-conditions",
      "published_at": "2021-02-23T09:20:11Z",
      "updated_at": "2021-02-08T07:24:02Z",
      "breadcrumb": "Contents / Alerts and Applied Intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "The color-coded health status indicates whether app or other entity has any alerts policies assigned to it.",
      "body": "With alerts you can easily tell whether an entity (the target for the notification) has one or more conditions associated with it: If yes, its health status indicator on the selected index (APM, Browser, etc.) will be color-coded to the current state. To view a summary of current alert violations, mouse over its health status indicator. If no, its health status indicator on the selected index will appear grey. To learn more about how conditions and policies work together, see Introduction to important concepts. Exceptions The health status indicator doesn't apply for: NRQL alert conditions Infrastructure entities Dashboards Entities targeted by labels Color-coded health status The index automatically appears when you select the product from the New Relic menu bar. For example, to view the index of APM apps, go to one.newrelic.com, then click APM. The Applications index lists all APM product entities and their current health status. Color Health status Green The entity is operational. We are collecting data that you can view in the appropriate UI. No alert violations are currently reported for it. Yellow The entity is degraded. A warning threshold has been violated. Red A critical threshold has been violated: Notifications have been sent based on the selected incident rollup preference. The incident appears in the Incidents index. Gray The entity's status is unknown. We're not receiving alerts data for the entity. This could mean alerts are muted, not set up, or the reporting system is down. Health status transitions The following table describes the different health status transitions an entity can endure: From... To... Transition explanation Gray Green The entity is evaluated for at least one condition, and the results show there are no violations present. Green / Red Gray Possible explanations: The last condition associated to the entity has been deleted and therefore there's no status to report. The last condition associated to the entity has been disabled and therefore there's no status to report. The entity has stopped reporting data. There's a New Relic platform issue. Check the New Relic status page for updates. Green Yellow / Red There's at least one open violation at the time the entity is undergoing the evaluation. Yellow / Red Green The last open violation associated to the entity has been closed. Example: App without conditions Here's an example of an app listed on the APM index that is not associated with any conditions. Its color-coded health status is light grey, which indicates no alert conditions are set up for that entity. Go to one.newrelic.com, then click Entity explorer: This example shows an app that currently isn't associated with any alerts conditions. Its grey status icon means it doesn't have any conditions. Follow standard procedures to add it to an existing condition or to create a new condition for it. Example: App with conditions Here's an example of an app listed on the APM index that is associated with one or more conditions. Its color-coded health status is green, because we are collecting data for it, and currently there are no Warning (yellow) or Critical (red) violations. Go to one.newrelic.com, then click Entity explorer: This example shows an app that has one or more conditions. Its color-coded health status (green) shows the app hasn't reached any threshold violations. To view the index listing currently open incidents across all products, not just this entity, select View all violations. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 72.8067,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View entity health status and find entities without <em>alert</em> <em>conditions</em>",
        "sections": "<em>Alert</em> <em>conditions</em>",
        "info": "The color-coded health status indicates whether app or other entity has any <em>alerts</em> policies assigned to it.",
        "category_0": "<em>Alerts</em> and Applied Intelligence",
        "category_1": "New Relic <em>Alerts</em>",
        "category_2": "<em>Alert</em> <em>conditions</em>",
        "body": ", mouse over its health status indicator. If no, its health status indicator on the selected index will appear grey. To learn more about how <em>conditions</em> and policies work together, see Introduction to important concepts. Exceptions The health status indicator doesn&#x27;t apply for: <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "breadcrumb": "Contents &#x2F; Alerts and Applied Intelligence &#x2F; New Relic Alerts &#x2F; <em>Alert</em> <em>conditions</em>"
      },
      "id": "5f2edf54e7b9d2f64ec9de88"
    },
    {
      "category_2": "Core concepts",
      "nodeid": 34316,
      "sections": [
        "Use New Relic One",
        "Get started",
        "Core concepts",
        "UI and data",
        "Workloads",
        "Build on New Relic One",
        "New Relic Explorer: View performance across apps, services, hosts",
        "Why it matters",
        "View and connect the performance of your entities",
        "List view",
        "New Relic Navigator",
        "New Relic Lookout",
        "Understand the state of your system with the health (alert) status",
        "Filter entities using the filterbar",
        "Entity data retention",
        "For more help"
      ],
      "title": "New Relic Explorer: View performance across apps, services, hosts",
      "category_0": "New Relic One",
      "type": "docs",
      "category_1": "Use New Relic One",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts",
      "external_id": "b75d9832eadbb65c0e6321e85d1e7cc0ea4ecb00",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/nrnavigator.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts",
      "published_at": "2021-02-25T07:04:00Z",
      "updated_at": "2021-02-23T23:38:24Z",
      "breadcrumb": "Contents / New Relic One / Use New Relic One / Core concepts",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic's entity explorer to see all your monitored entities in one place and explore the reported data. ",
      "body": "In digital business, systems are becoming increasingly large, complex, and interdependent. You have hundreds of applications and services running at the same time, and you need to monitor thousands of elements emitting data (we call those data sources entities). With the New Relic Explorer, we give you a new, efficient front-door experience to easily observe the full stack of your software. We automatically create and maintain visibility from the data you send us. Use the New Relic Explorer to access and give context to the performance data from all your monitored applications, services, hosts, containers, synthetic monitors, etc. You can quickly see the entities related to a problem, exposing possible root causes and what other systems might be affected. To use New Relic One and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters With the New Relic Explorer, it‚Äôs more than just observing the metrics: understand the root of what‚Äôs happening, not just the symptoms. Gain extensive visibility of each entity in your solution, its alert status, and how the entities are connected, at a glance. See all your workloads, and create a new one in a click. Get a high level view of how your system‚Äôs doing with the New Relic Navigator. Quickly grasp unusual trends and behaviors with New Relic Lookout. Filter and group related entities to quickly drill down to the issues. Troubleshoot issues with tools that are faster, less cumbersome, and more accurate. Identify areas of improvement, and plan your changes. View and connect the performance of your entities The New Relic Explorer brings together data reported by any entity from across all of your New Relic accounts. Entity categories include: Services: APM-monitored applications and services monitored. Hosts: your monitored infrastructure (your servers and hosts). Mobile applications: your mobile apps. Browser applications: your front-end browser apps. Integration-reported data: data from services monitored by our integrations, including our on-host integrations (like Kubernetes, StatsD, and NGINX), and cloud platform integrations, like Amazon, Microsoft Azure, and Google Cloud Platform (GCP). Workloads, your customized entity groupings. Containers, such as Kubernetes or Docker. Synthetic monitors, for simulations. You can create new entity types to monitor any data source. Learn more about entity synthesis. To use the New Relic Explorer: Go to one.newrelic.com and select Explorer. one.newrelic.com > Explorer: Use the entity explorer to locate and examine the entities you monitor. Toggle between the Explorer's three views and the following features: List. Browse and filter from a list of all the entities in your account. Use this landing interface to navigate, group and filter your entities. New Relic Navigator. Get a high density overview of all your entities, grouped by entity type or by tags. Use this to detect any issues and health patterns at a glance. New Relic Lookout. Spot entities that have recent performance deviations. Use this to quickly identify unusual behaviors. Other components include: Filterbar. Drill down and locate problematic entities easily with our improved search capabilities, and benefit from the AND and OR operators in place. See everything. All the different entity types you have access to are listed in the collapsible sidebar on the left of the screen. This sidebar is interactive and used for exploratory purposes, and it allows you to see only entities of the selected type, updating the filter from the filterbar. Create a new workload for meaningful groupings of your monitored entities. Add more data to instrument more elements of your system and achieve full stack observability. List view Your monitored entities are on the left, in a collapsable menu. You may need to scroll your list of entities to see them all. The list view also has a collapsable activity stream on the right side. You can see different useful events related to the first 25 alerting entities which are currently being filtered. Click on any entity for more details on its performance. The entity overview also incorporates the relationship between the selected entity and other entities in your system. New Relic Navigator The New Relic Navigator makes it easy to explore large numbers of entities as it intuitively displays the entire estate of your system in a highly dense honeycomb view with traffic light colors based on alerts. With the New Relic Navigator you can: Quickly explore the health of your environment at a glance. See all the entities that belong to all your accounts, and focus on specific entity types or specific groups of entities grouped by tags. Group and filter across all your entities to quickly zero in on issues. Click on any entity to see a mini-overview of its activity, metrics, and meta-data. New Relic Lookout New Relic Lookout provides an intuitive view of entities that are deviating from normal behavior, using circle visualization with color indicating severity and size conveying the scale of recent changes. You don‚Äôt need to configure anything: New Relic Lookout automatically compares performance within the last five minutes against the previous hour. Use New Relic Lookout to: Select the entity type to see golden signals of throughput, response time, and errors across all your accounts. Zoom in with correlations, abnormal history, traces, and the ability to leverage New Relic‚Äôs profiles across your estate. Click on an entity of interest to access the mini-overview component. Read more about New Relic Lookout. You can modify the color palette to focus on clusters of interest. Understand the state of your system with the health (alert) status The entity explorer shows a color-coded health status for entities. For example, you may see a red alert status indicating a critical violation in progress. To see what an alert status means, mouse over it. To see details about an entity's alerting status, select the entity. NRQL alert conditions aren't used to determine alert status because they aren't associated with specific entities. Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI; however, key metrics will continue to be available via the New Relic REST API based on subscription level. For more information, see New Relic's Explorers Hub post. Filter entities using the filterbar The filterbar lets you select the entities displayed according to the conditions you enter: Type in a string of characters and/or numbers (for example, an environment) to find any entity that has this string in their name or ID. When typing, the UI suggests items that coincide with the string you're entering, so you can select one of those from the dropdown. You can also filter by the name of the entity, the entity type, account ID, environment, or a tag. Selection parameters, once created, have a blue background. If you filter using a string, the filter will have the = operator. If you filter using the dropdown menu, once the first element of the searched item (tag key or attribute) is entered, you need to select an operator (=, !=, LIKE, NOT_LIKE, IN, NOT IN) for your filter. Once the operator is selected, complete the filter by selecting the value to complete the search item. To add more filters, first you have to select an operator, AND or OR. Use AND to indicate you want to restrict the selection removing entities from the list of results. You can also use the AND operator to add conditions that need to be met in the list of results, for example, entityType = Services AND location = APAC. Note that entityType = Services AND entityType = Hosts doesn‚Äôt return any results, as entities can only have one type and no entity would match this condition. Use OR to add more entities to the selection. For example, the filter entityType = Services OR entityType = Hosts returns every entity you have access to that is of type Services or Hosts. Entity data retention Availability of data depends on these factors: Scope Data retention Entity explorer and search In the UI, data is available for eight days after an entity no longer exists, with one exception: data reported by integrations, such as Amazon AWS, is only available for one day after an entity ceases to exist. Our database (accessible via NRQL query) For querying our database (for example, via the query builder or data explorer), availability is dependent on the data retention for that data type. As a result of these factors, a short-lived entity (like a cloud host) may not be available in the entity explorer list or via search, but its data may still be available via NRQL query. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.57458,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Understand the state of your system with the health (<em>alert</em>) status",
        "body": " in progress. To see what an <em>alert</em> status means, mouse over it. To see details about an entity&#x27;s alerting status, select the entity. <em>NRQL</em> <em>alert</em> <em>conditions</em> aren&#x27;t used to determine <em>alert</em> status because they aren&#x27;t associated with specific entities. Starting June 8, 2020, New Relic One will not continue"
      },
      "id": "603591f064441f8aa67a0ef4"
    }
  ],
  "/explore-docs/nerdpack-file-structure": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advance configurations",
        "Extend webpack configuration",
        "Proxy browser setup",
        "Summary",
        "This site uses cookies üç™"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-02-25T01:58:11Z",
      "updated_at": "2020-12-04T01:59:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin To get started, make sure you have accounts in GitHub and New Relic. To develop projects, you need the New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete all the steps in the CLI quick start. For additional details about setting up your environment, see Set up your development environment. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two artifacts: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advance configurations Extend webpack configuration You can use our .extended-webpackrc.js file to extend the webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Proxy browser setup Generally, you don't need to know how your application code is loaded in New Relic One. But understanding how this works can help you if you encounter issues (for example, with a proxy or browser setup). When developing, your code is served from your local laptop by using an nr-local.net subdomain. This domain points to 127.0.0.1, and will use a variety of ports to connect, including 9973. In order to load third-party code into the platform, (both in development and production), New Relic One uses an <IFRAME>, as well as a separate domain (a subdomain of nr-ext.net) to perform the load, relying on same-domain policy to sandbox the code. For this reason, your network administrator may need to enable access to: Any subdomain of nr-local.net, or, at the very least, to any domain of the shape of <UserId>.nr-local.net, where UserId is a 32-hexadecimal character identifier that is unique to the user logged into the platform (you can use [0-9a-f]{32} to discriminate it). Any subdomain of nr-ext.net, or, at the very least, to any domain in the shape of <NerdpackUuid>.g <NerdpackGid>.nr-ext.net, where NerdpackUuid is the UUID assigned to your package, and NerdpackGid is zero, or a positive integer (you can use 0|[1-9]\\d+ to discriminate it). Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 378.04214,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Publish your application to <em>New</em> <em>Relic</em>",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "body": "!&quot; application The <em>CLI</em> allows you to run a local version of <em>New</em> <em>Relic</em> <em>One</em>. You can develop your application locally before you publish it in <em>New</em> <em>Relic</em> <em>One</em>. If you followed all the steps in the <em>CLI</em> quick start, you now have files under a <em>new</em> directory named after your <em>nerdpack</em> project. Here&#x27;s how you edit"
      },
      "id": "5efa9973196a67d16d76645c"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:54:22Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 270.50668,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common commands",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common commands",
        "info": "An overview of common commands you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": " The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a <em>new</em> component Creates a <em>new</em> component from our template (either a <em>Nerdpack</em>, <em>Nerdlet</em>, <em>launcher</em>, or catalog). The <em>CLI</em> will walk you through this process. To learn more about Nerdpacks and their <em>file</em> <em>structure</em>"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-02-25T01:55:33Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 252.75362,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " and publish your application, see¬†our guide on Deploying your <em>New</em> <em>Relic</em> <em>One</em> app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the <em>CLI</em>. nr1 create Creates a <em>new</em> component from a template (<em>Nerdpack</em>, <em>Nerdlet</em>, <em>launcher</em>, or catalog). nr1"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com",
        "This site uses cookies üç™"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2021-02-25T01:58:10Z",
      "updated_at": "2020-12-04T02:00:00Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 252.66995,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": ". At the end of the Quick start, you have a project consisting of the following: A <em>Nerdpack</em> - The package containing all the files required by your application. It contains two types of files that you customize to build your app: <em>Nerdlets</em>, and the <em>launcher</em>. <em>One</em> or more <em>Nerdlet</em> files - A specific UI view"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/apis/navigation/",
      "sections": [
        "navigation",
        "Usage",
        "API methods",
        "navigation.getOpenEntityLocation",
        "Example",
        "navigation.getOpenLauncherLocation",
        "Example 1",
        "Example 2",
        "navigation.getOpenNerdletLocation",
        "navigation.getOpenOverlayLocation",
        "navigation.getOpenStackedEntityLocation",
        "navigation.getOpenStackedNerdletLocation",
        "Example 3",
        "navigation.getReplaceNerdletLocation",
        "navigation.openEntity",
        "navigation.openLauncher",
        "navigation.openNerdlet",
        "navigation.openOverlay",
        "navigation.openStackedEntity",
        "navigation.openStackedNerdlet",
        "navigation.replaceNerdlet",
        "Type definitions",
        "Nerdlet",
        "UrlStateOptions",
        "Overlay",
        "Launcher",
        "Location",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:52:59Z",
      "title": "navigation",
      "updated_at": "2021-01-29T01:59:34Z",
      "type": "developer",
      "external_id": "89f86c8e0d7f52bf769051e74d77d86893306716",
      "document_type": "page",
      "popularity": 1,
      "body": "Usage import { navigation } from 'nr1' Copy API methods navigation.getOpenEntityLocation Returns a location object that can be used to redirect to an entity in its corresponding launcher (default: Explorer launcher). Location objects can be passed into <Link to={location}> component to navigate inside the platform. function ( entityGuid : string // GUID of the entity to open. ) => Location Example 1 const entityGuid = 'Mxka102Ak'; 2 3 const location = navigation.getOpenEntityLocation(entityGuid); Copy navigation.getOpenLauncherLocation Returns a location object that can be used to redirect to a given launcher. You can also specify nerdlet and stacked nerdlets with given states to be opened in this launcher. If nerdlet is not specified, the root nerdlet of the given launcher will be opened. Location objects can be passed into <Link to={location}> component to navigate inside the platform. function ( launcher : Launcher // Launcher to open. ) => Location Example 1 1 const launcher = { 2 id: 'nr1-core.explorer', 3 }; 4 5 const location = navigation.getOpenLauncherLocation(launcher); Copy Example 2 1 // You can also specify a nerdlet and stacked nerdlets to be opened. 2 // You can combine artifacts from different nerdpacks. 3 const launcher = { 4 id: '074e8260-fa9c-4d71-f7a0-51835417a423.my-launcher-id', 5 nerdlet: { 6 id: 'nr1-core.listing', 7 }, 8 stackedNerdlets: [ 9 { 10 id: 'dashboards.list', 11 }, 12 ], 13 }; 14 15 const location = navigation.getOpenLauncherLocation(launcher); Copy navigation.getOpenNerdletLocation Returns a location object that can be used to open a given nerdlet with a given state. Location objects can be passed into <Link to={location}> component to navigate inside the platform. function ( nerdlet : Nerdlet // Nerdlet to replace current nerdlet with. ) => Location Example 1 1 const nerdlet = { 2 id: 'dashboards.list', 3 }; 4 5 const location = navigation.getOpenNerdletLocation(nerdlet); Copy Example 2 1 // You can also specify nerdlet's state. 2 const nerdlet = { 3 id: 'dashboards.list', 4 urlState: { 5 foo: 'bar', 6 }, 7 }; 8 9 const location = navigation.getOpenNerdletLocation(nerdlet); Copy navigation.getOpenOverlayLocation Returns a location object that can be used to trigger opening overlay. Location objects can be passed into <Link to={location}> component to navigate inside the platform. function ( overlay : Overlay // Overlay you want to open. ) => Location Example 1 const overlay = { 2 id: 'nr1-core.search', 3 }; 4 5 const location = navigation.getOpenOverlayLocation(overlay); Copy navigation.getOpenStackedEntityLocation Returns a location object that can be used to trigger opening entity in a stacked nerdlet. Location objects can be passed into <Link to={location}> component to navigate inside the platform. function ( entityGuid : string // GUID of the entity to open. ) => Location Example 1 const entityGuid = 'Mxka102Ak'; 2 3 const location = navigation.getOpenStackedEntityLocation(entityGuid); Copy navigation.getOpenStackedNerdletLocation Returns a location object that can be used to trigger opening stacked nerdlet with a given state. Location objects can be passed into <Link to={location}> component to navigate inside the platform. function ( nerdlet : Nerdlet // Nerdlet to open as stacked nerdlet. ) => Location Example 1 1 const nerdlet = { 2 id: 'dashboards.list', 3 }; 4 5 const location = navigation.getOpenStackedNerdletLocation(nerdlet); Copy Example 2 1 // You can also specify nerdlet's state. 2 const nerdletWithState = { 3 id: 'dashboards.list', 4 urlState: { 5 foo: 'bar', 6 }, 7 }; 8 9 const location = navigation.getOpenStackedNerdletLocation(nerdletWithState); Copy Example 3 1 // If you want to open nerdlet from the current nerdpack then you can omit its nerdpackId. 2 const nerdletWithState = { 3 id: 'my-nerdlet-id', 4 urlState: { 5 foo: 'bar', 6 }, 7 }; 8 9 const location = navigation.getOpenStackedNerdletLocation(nerdletWithState); Copy navigation.getReplaceNerdletLocation Returns a location object that can be used to replace current nerdlet. Location objects can be passed into <Link to={location}> component to navigate inside the platform. function ( nerdlet : Nerdlet // Nerdlet to replace current nerdlet with. ) => Location Example 1 1 const nerdlet = { 2 id: 'dashboards.list', 3 }; 4 5 const location = navigation.getReplaceNerdletLocation(nerdlet); Copy Example 2 1 // If the nerdlet you want to replace with is in the current nerdpack then you can omit its nerdpackId. 2 const nerdlet = { 3 id: 'my-nerdlet-id', 4 }; 5 6 const location = navigation.getReplaceNerdletLocation(nerdlet); Copy Example 3 1 // You can also specify nerdlet's state. 2 const nerdlet = { 3 id: 'my-nerdlet-id', 4 urlState: { 5 foo: 'bar', 6 }, 7 }; 8 9 const location = navigation.getReplaceNerdletLocation(nerdlet); Copy navigation.openEntity Opens an entity in its corresponding launcher (default: Explorer launcher). To navigate without adding an entry to the browser history, set urlStateOptions.replaceHistory to true. function ( entityGuid : string, // GUID of the entity to open. urlStateOptions : UrlStateOptions // Options for the URL state. ) => undefined Example 1 const entityGuid = 'Mxka102Ak'; 2 3 navigation.openEntity(entityGuid); Copy navigation.openLauncher Opens launcher inside the platform. You can also specify nerdlet and stacked nerdlets with given states to be opened in this launcher. If nerdlet is not specified, the root nerdlet of the given launcher will be opened. If you wish to navigate without adding an entry to the browser history, set urlStateOptions.replaceHistory to true. function ( launcher : Launcher, // Launcher to open. urlStateOptions : UrlStateOptions // Options for the URL state. ) => void Example 1 1 const launcher = { 2 id: 'nr1-core.explorer', 3 }; 4 5 navigation.openLauncher(launcher); Copy Example 2 1 // You can also specify a nerdlet and stacked nerdlets to be opened. 2 // You can combine artifacts from different nerdpacks. 3 const launcher = { 4 id: '074e8260-fa9c-4d71-f7a0-51835417a423.my-launcher-id', 5 nerdlet: { 6 id: 'nr1-core.listing', 7 }, 8 stackedNerdlets: [ 9 { 10 id: 'dashboards.list', 11 }, 12 ], 13 }; 14 15 navigation.openLauncher(launcher); Copy navigation.openNerdlet Opens a nerdlet in the current launcher. If nerdlet.urlState is provided, it will be shallow-merged with the initial state of the nerdlet. If you wish to navigate without adding an entry to the browser history, set urlStateOptions.replaceHistory to true. function ( nerdlet : Nerdlet, // Nerdlet to open. urlStateOptions : UrlStateOptions // Options for the URL state. ) => void Example 1 1 const nerdlet = { 2 id: 'dashboards.list', 3 }; 4 5 navigation.openNerdlet(nerdlet); Copy Example 2 1 // You can also specify nerdlet's state. 2 const nerdletWithState = { 3 id: 'dashboards.list', 4 urlState: { 5 foo: 'bar', 6 }, 7 }; 8 9 const location = navigation.getOpenNerdletLocation(nerdletWithState); Copy navigation.openOverlay Opens an overlay on top of the current launcher. If overlay.urlState is provided, it will be shallow-merged with the initial state of the overlay. If you wish to navigate without adding an entry to the browser history, set urlStateOptions.replaceHistory to true. function ( overlay : Overlay, // Overlay you want to open. urlStateOptions : UrlStateOptions // Options for the URL state. ) => void Example 1 const overlay = { 2 id: 'nr1-core.search', 3 }; 4 5 navigation.openOverlay(overlay); Copy navigation.openStackedEntity Opens a stacked nerdlet with entity open in it. If triggered from a stacked nerdlet that is not the last one on the stack, the stacked nerdlet aboves it will be replaced. To navigate without adding an entry to the browser history, set urlStateOptions.replaceHistory to true. function ( entityGuid : string, // GUID of the entity to open. urlStateOptions : UrlStateOptions // Options for the URL state. ) => undefined Example 1 // Opens stacked entity. 2 const entityGuid = 'Mxka102Ak'; 3 4 navigation.openStackedEntity(entityGuid); Copy navigation.openStackedNerdlet Opens a stacked nerdlet with given state above current one. If triggered from a stacked nerdlet that is not the last one on the stack, the stacked nerdlets above it will be replaced. If you wish to navigate without adding an entry to the browser history, set urlStateOptions.replaceHistory to true. function ( nerdlet : Nerdlet, // Nerdlet to open as stacked nerdlet. urlStateOptions : UrlStateOptions // Options for the URL state. ) => void Example 1 1 const nerdlet = { 2 id: 'dashboards.list', 3 }; 4 5 navigation.openStackedNerdlet(nerdlet); Copy Example 2 1 // You can also specify nerdlet's state. 2 const nerdletWithState = { 3 id: '074e8260-fa9c-4d71-f7a0-51835417a423.my-nerdlet-id', 4 urlState: { 5 foo: 'bar', 6 }, 7 }; 8 9 navigation.openStackedNerdlet(nerdlet); Copy Example 3 1 // If you want to open nerdlet from the current nerdpack then you can omit its nerdpackId. 2 const nerdletWithState = { 3 id: 'my-nerdlet-id', 4 urlState: { 5 foo: 'bar', 6 }, 7 }; 8 9 navigation.openStackedNerdlet(nerdlet); Copy navigation.replaceNerdlet Replaces the nerdlet that is calling this API method. If you wish to navigate without adding an entry to the browser history, set urlStateOptions.replaceHistory to true. function ( nerdlet : Nerdlet, // GUID of the entity to open. urlStateOptions : UrlStateOptions // Options for the URL state. ) => void Example 1 1 const nerdlet = { 2 id: 'dashboards.list', 3 }; 4 5 navigation.replaceNerdlet(nerdlet); Copy Example 2 1 // If the nerdlet you want to replace with is in the current nerdpack then you can omit its nerdpackId. 2 const nerdlet = { 3 id: 'my-nerdlet-id', 4 }; 5 6 navigation.replaceNerdlet(nerdlet); Copy Example 3 1 // You can also specify nerdlet's state. 2 const nerdlet = { 3 id: 'my-nerdlet-id', 4 urlState: { 5 foo: 'bar', 6 }, 7 }; 8 9 navigation.replaceNerdlet(nerdlet); Copy Type definitions Nerdlet { id : string, // Id of the nerdlet. You can specify the full nerdlet id: <nerdpack-id> . <nerdlet-id> (i.e. \"8ba28fe4-5362-4f7f-8f9a-4b8c6c39d8a6.my-nerdlet\") or simply <nerdlet-id> (i.e. \"my-nerdlet\"). In the latter case, the nerdlet will be treated as if it belongs to the current nerdpack, meaning that the nerdpack id is automatically added by the platform. urlState : Object, // State of the nerdlet which is persisted in the url. } UrlStateOptions { replaceHistory : boolean, // If true, the current entry in the browser history will be replaced with the new one. } Overlay { id : string, // Id of the overlay to be opened, for example nr1-core.search. urlState : Object, // State of the overlay which is persisted in the url. } Launcher { id : string, // Id of the launcher, for example nr1-core.explorer. nerdlet : Nerdlet, // Nerdlet to be opened in the launcher. If not provided, the root nerdlet of the launcher will be opened. stackedNerdlets : Nerdlet[], // Nerdlet to be opened as stacked nerdlets. } Location { pathname : string, // String representing the path to link to. search : string, // String representing query parameters. hash : string, // String to put in the URL as hash, e.g. #entities. }",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 249.52066,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Nerdlet</em>",
        "body": " with the <em>new</em> <em>one</em>. } Overlay { id : string, &#x2F;&#x2F; Id of the overlay to be opened, for example nr1-core.search. urlState : Object, &#x2F;&#x2F; State of the overlay which is persisted in the url. } <em>Launcher</em> { id : string, &#x2F;&#x2F; Id of the <em>launcher</em>, for example nr1-core.explorer. <em>nerdlet</em> : <em>Nerdlet</em>, &#x2F;&#x2F; <em>Nerdlet</em> to be opened"
      },
      "id": "5efa98d464441f683d5f7e3e"
    }
  ],
  "/build-apps/build-visualization": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advance configurations",
        "Extend webpack configuration",
        "Proxy browser setup",
        "Summary",
        "This site uses cookies üç™"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-02-25T01:58:11Z",
      "updated_at": "2020-12-04T01:59:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin To get started, make sure you have accounts in GitHub and New Relic. To develop projects, you need the New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete all the steps in the CLI quick start. For additional details about setting up your environment, see Set up your development environment. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two artifacts: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advance configurations Extend webpack configuration You can use our .extended-webpackrc.js file to extend the webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Proxy browser setup Generally, you don't need to know how your application code is loaded in New Relic One. But understanding how this works can help you if you encounter issues (for example, with a proxy or browser setup). When developing, your code is served from your local laptop by using an nr-local.net subdomain. This domain points to 127.0.0.1, and will use a variety of ports to connect, including 9973. In order to load third-party code into the platform, (both in development and production), New Relic One uses an <IFRAME>, as well as a separate domain (a subdomain of nr-ext.net) to perform the load, relying on same-domain policy to sandbox the code. For this reason, your network administrator may need to enable access to: Any subdomain of nr-local.net, or, at the very least, to any domain of the shape of <UserId>.nr-local.net, where UserId is a 32-hexadecimal character identifier that is unique to the user logged into the platform (you can use [0-9a-f]{32} to discriminate it). Any subdomain of nr-ext.net, or, at the very least, to any domain in the shape of <NerdpackUuid>.g <NerdpackGid>.nr-ext.net, where NerdpackUuid is the UUID assigned to your package, and NerdpackGid is zero, or a positive integer (you can use 0|[1-9]\\d+ to discriminate it). Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.70284,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Subscribe</em> accounts to your application",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to New Relic <em>One</em>",
        "tags": "<em>NR</em> <em>One</em> <em>Catalog</em>",
        "body": " in your terminal: bash Copy $ <em>nr1</em> nerdpack:publish Step 2 of 4 Close your local New Relic <em>One</em> development tab, and open New Relic <em>One</em>. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic <em>One</em> <em>catalog</em>, click the launcher for your new application. When your new application opens, notice"
      },
      "id": "5efa9973196a67d16d76645c"
    },
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs",
        "This site uses cookies üç™"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.39328,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to New Relic <em>One</em> SDK",
        "sections": "Intro to New Relic <em>One</em> SDK",
        "info": "Intro to New Relic <em>One</em> SDK",
        "tags": "New Relic <em>One</em> apps",
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "category_2": "Measure DevOps success",
      "nodeid": 34966,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs",
        "For more help"
      ],
      "title": "Automate instrumentation",
      "category_0": "Solutions and best practices",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "91b25e8572d235c7f95963650848fc6ab6cf4b39",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation",
      "published_at": "2021-02-22T23:15:36Z",
      "updated_at": "2020-12-01T22:24:21Z",
      "breadcrumb": "Contents / Solutions and best practices / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "Capture tangible, measurable metrics from before and after deployments to optimize your DevOps team. ",
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors‚Äîand more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.14465,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ", the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "5f5e0c14196a67e25fce6a8a"
    },
    {
      "sections": [
        "Charts",
        "Query New Relic data",
        "Craft custom data",
        "Metadata",
        "Data",
        "Tip",
        "Special States",
        "Configure your chart",
        "Chart Groups",
        "Next Step",
        "This site uses cookies üç™"
      ],
      "title": "Charts",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure"
      ],
      "external_id": "67f2919065eb0e710d863bdbd106db85463cc788",
      "image": "",
      "url": "https://developer.newrelic.com/components/charts/",
      "published_at": "2021-02-25T01:59:20Z",
      "updated_at": "2021-01-16T01:54:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "How to use charts in your NR1 app.",
      "body": "In your application, you can display data in charts, like those used elsewhere in New Relic's user interface. The New Relic One SDK provides React components for different chart types. Once you decide the kind of data you want to present, either from New Relic or some other source, you supply that data to your chart, using props. Query New Relic data In some cases, you want to fetch data from New Relic's database. For example, you may want to display a line chart which plots the number of transactions your application receives over time. With your chart component, set the accountId and query props to query your New Relic data using NRQL: <LineChart accountId={1234} query=\"SELECT count(*) FROM Transaction\" />; Copy Alternatively, you can fetch data with a NrqlQuery and set the data prop: <NrqlQuery accountId={1234} query=\"SELECT count(*) FROM Transaction\"> {({ data }) => <LineChart data={data} />} </NrqlQuery>; Copy If you're looking to visualize New Relic data, such as your web application's response times or your server's throughput, querying data in your charts is the way to go. But what if you want to create charts that aren't focused on New Relic data? The data prop is flexible enough that you can supply any arbitrary data, as long as it matches the standardized format. Craft custom data Whether you use custom data sets or the results of a NrqlQuery, a chart's data prop must be an array of objects where each object has both of the following fields: metadata: Defines how the chart presents its data data: An array of data points that appear on the chart For example, create a chart consisting of a line between two points by supplying two x-y coordinates in its data field: const data = [ { metadata: { id: 'series-1', name: 'My series', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0, }, { x: 20, y: 10, }, ], }, ]; <LineChart data={data} />; Copy This LineChart plots a line between coordinates (0, 0) and (20, 10). Use x-y coordinates for all two-dimensional chart formats. For other formats, which you'll learn more about later, use other types of data points. Because data accepts an array, you can supply two series to the same chart: const data = [ { metadata: { id: 'series-1', name: 'My series', viz: 'main', color: 'blue', }, data: [ { x: 0, y: 0, }, { x: 20, y: 10, }, ], }, { metadata: { id: 'series-2', name: 'My second series', viz: 'main', color: 'red', }, data: [ { x: 0, y: 50, }, { x: 20, y: 100, }, ], }, ]; <LineChart data={data} />; Copy In this example, you create a single chart with two series. The first series contains the line from the last example. The second series contains a line between points (0, 50) and (20, 100). When using two series in a single chart, like this, you may want to define how the chart represents each series. Use metadata to define those elements. Metadata A series's metadata defines certain features of the series, itself, such as how it should be displayed in your chart. metadata consists of the following attributes: Attribute Description id The series's identifier. Two series having the same id are considered the same series, regardless of where they are located. In general, use a unique id for each series. However, if you use the same series for multiple charts, keeping the id consistent can help with some cross-chart functionality, like simultaneously highlighting multiple charts. name The series's name. name is used in legends, tooltips, and other areas to indicate which series you‚Äôre looking at. color The series's color. Most visualizations use this value to differentiate series. Some visualizations, like BillboardChart or JsonChart, ignore it. Use any valid CSS color representation, such as #RRGGBB, hsl(HHH, SS%, LL%), or rgba(RR, GG, BB, .AA). Avoid tweaking the alpha value, when possible, because charts use alpha to highlight or dim certain series. viz The series's visual style. While you most often use main, this field accepts several options: main: Show the series based on chart's type. For instance, a LineChart shows the series as a line, and an AreaChart shows the series as an area. line: Show the series as a line, regardless of the chart's type. This setting applies only to AreaChart and ScatterChart. Other chart types will not show the series. area: Show the series as an area, regardless of the chart's type. This setting applies only to LineChart and ScatterChart. Other chart types will not show the series. event: Show the series as an event, regardless of the chart's type. Charts represent an event as a vertical area behind the main visualization. Events are often used to show alerts. This setting applies only to AreaChart, LineChart, and ScatterChart. Other chart types will not show the series. target-line: Show the series as a vertical line. This setting applies only to AreaChart, LineChart, and ScatterChart. Other chart types will not show the series. units_data You can assign a unit type to each axis on a chart. The chart will present data according to the unit type you set with units_data. To set unit_data, pass a JSON object with maps the axis to one of the following unit types: UNKNOWN: The chart displays the series with no special units. COUNT: Each value in the chart represents a count. The chart formats values with their International System prefix. For example, \"k\" represents thousands, \"M\" represents millions, and \"G\" represents billions. PERCENTAGE: Each value in the chart represents a percentage. Typically, you provide values ranging from 0 to 1. The chart formats a value of 1 as \"100%\", a value of 2 as \"200%\", and a value of 0.01 as \"1%\". MS: Each value in the chart represents some number of milliseconds. The chart represents values higher than 1 as a human-readable time duration. For example, 60000 is represented as \"1 minute\". The chart represents values lower than 1 using SI prefixes. For example, 0.001 is represented as 1 Œºs. TIMESTAMP: Each value in the chart represents a timestamp, the number milliseconds since midnight UTC on January 1, 1970, the UNIX Epoch. The chart formats each value as a date. BITS: Each value in the chart represents some number of bits. The chart formats these values using \"b\". When upscaling, the chart will display decimal prefixes instead of binary ones. For example, the chart displays 1000 as \"1 kb\". BITS_PER_SECOND: Each value in the chart represents some number of bits per second. The chart formats these values using \"b/s\". When upscaling, the chart will display decimal prefixes instead of binary ones. For example, the chart displays 1000 as \"1 kb/s\". BYTES: Each value in the chart represents some number of bytes. The chart formats these values using \"B\". For example, the chart displays 1000 as \"1 kB\". BYTES_PER_SECOND: Each value in the chart represents some number of bytes per second. The chart formats these values using \"B/s\". For example, the chart displays 1000 as \"1 kB/s\". So, to represent the y-axis for your series in bits, set the y-value in units_data: { \"units_data\": { \"y\": \"BITS\" } } Data While a data series can contain any arbitrary values, a chart only uses values which adhere to its type. So, create your data points according to the chart type: Series Type Example Description Unidimensional [{ \"y\": 10 }, { \"y\": 20 }] The chart plots data points using y values. Use this format with BarChart, BillboardChart, PieChart, StackedBarChart. Two-dimensional [ { \"x\": 10, \"y\": 20 }, { \"x\": 20, \"y\": 30 } ] The chart plots data points using x and y values. Use this format with AreaChart, LineChart, ScatterChart, SparklineChart, Funnel [{ \"label1\": 10, \"label2\": 20 }] The chart plots data according to labels. Use this format with FunnelChart. Table [{ \"jobType\": \"SIMPLE\", \"count\": 18 }] The chart plots data according to table columns. You must specify table columns in the metadata. Use this format with TableChart. Event [ { \"x0\": 0, \"x1\": 5 }, { \"x0\": 10, \"x1\": 15 } ] The chart plots the event's width based on x0 and x1 values. Histogram [ { \"x0\": 10, \"x1\": 20, \"y\": 100 }, { \"x0\": 30, \"x1\": 40, \"y\": 150 } ] The chart plots the series's width based on x0 and x1 and height based on y. Use this format with HistogramChart and HeatmapChart. Tip JsonChart is a special case because it processes any valid data. For example, you can set an arbitrary JSON object for the chart's data: const data = { data: [ { id: 1, name: 'Foo', price: 123, tags: ['Bar', 'Eek'], stock: { warehouse: 300, retail: 20, } } ], } <JsonChart data={data} /> Copy Special States In previous sections, you learned that a chart's data is an array of series. But you can use special values to present special chart states: null or undefined: Indicates the chart is ‚Äúloading‚Äù its data. In this state, the chart shows a placeholder data set. []: Indicates there is no data to show. The chart states, \"No chart data available\". Configure your chart As you've seen, you use query or data to supply data to your chart, but you can configure other aspects of your chart, too, such as visual settings and click and hover event listeners. Read the documentation for the chart you're using for more specific information. Chart Groups Under some circumstances, you might want to synchronize events, such as dragging or scrubbing, across multiple charts. To do this, use a ChartGroup. All charts in a ChartGroup synchronize their events: <ChartGroup> <Stack> <StackItem> <LineChart accountId={1} query=\"SELECT count(*) FROM Transaction SINCE 1 hour ago\" /> </StackItem> <StackItem> <AreaChart accountId={1} query=\"SELECT count(*) FROM Synthetics SINCE 1 day ago\" /> </StackItem> </Stack> </ChartGroup>; Copy Ideally, group charts that are conceptually related, and separate charts that are conceptually unrelated. Next Step Read the documentation specific to the chart you'd like to use to learn specifics about that chart's behavior and configuration.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.21068,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "How to use charts in your <em>NR1</em> app.",
        "tags": "<em>nr1</em> <em>cli</em>",
        "body": " <em>visualizations</em>, like BillboardChart or JsonChart, ignore it. Use any valid CSS color representation, such as #RRGGBB, hsl(HHH, SS%, LL%), or rgba(RR, GG, BB, .AA). Avoid tweaking the alpha value, when possible, because charts use alpha to highlight or dim certain series. viz The series&#x27;s <em>visual</em> style"
      },
      "id": "5fdab9f1e7b9d2e1e8df9221"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-02-25T01:55:33Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.12561,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>One</em> <em>CLI</em> reference",
        "sections": "New Relic <em>One</em> <em>CLI</em> reference",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage New Relic apps.",
        "tags": "New Relic <em>One</em> app",
        "body": " and publish your application, see¬†our guide on Deploying your New Relic <em>One</em> app. Get started <em>nr1</em> help Shows all <em>nr1</em> commands or details about each command. <em>nr1</em> update Updates to the latest version of the <em>CLI</em>. <em>nr1</em> create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or <em>catalog</em>). <em>nr1</em>"
      },
      "id": "5efa989e28ccbc535a307dd0"
    }
  ],
  "/explore-docs/nr1-catalog": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information",
        "This site uses cookies üç™"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2021-02-25T01:55:33Z",
      "updated_at": "2020-12-04T01:55:37Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "To build a¬†New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use¬†CLI commands¬†to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the¬†Build your own application¬†launcher¬†and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see¬†Authentication and permissions. For more on how to serve and publish your application, see¬†our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:build Assembles your Nerdpack into bundles. nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. nr1 nerdpack:clean Cleans your developtment folders. nr1 nerdpack:validate Validates the contents of your Nerdpack. nr1 nerdpack:info Shows the state of your Nerdpack in the New Relic's registry. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.22057,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " and publish your application, see¬†our guide on Deploying your <em>New</em> <em>Relic</em> <em>One</em> app. Get started nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1 update Updates to the latest version of the <em>CLI</em>. nr1 create Creates a <em>new</em> component from a template (Nerdpack, Nerdlet, launcher, or <em>catalog</em>). nr1"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands",
        "This site uses cookies üç™"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2021-02-10T01:54:44Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options bash Copy --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic decode - Use the decode url command to print out information encrypted within the URL newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.3994,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs in GitHub. Options bash Copy"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:54:22Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.21194,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": "Here&#x27;s a list of common <em>commands</em> to get you started with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1 update Updates to the latest version"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Advance configurations",
        "Extend webpack configuration",
        "Proxy browser setup",
        "Summary",
        "This site uses cookies üç™"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2021-02-25T01:58:11Z",
      "updated_at": "2020-12-04T01:59:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin To get started, make sure you have accounts in GitHub and New Relic. To develop projects, you need the New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete all the steps in the CLI quick start. For additional details about setting up your environment, see Set up your development environment. Tip Use the New Relic One VSCode extension or the New Relic VSCode extension pack to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two artifacts: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Tip You will need an icon.png in 2 places for it to be representing properly in the New Relic One Catalog, To set a launcher icon place an icon.png file in the the launcher directory. To set the icon for the app details page place an icon in the root directory of the project. Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: bash Copy $ npm start Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: bash Copy $ nr1 nerdpack:publish Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: bash Copy $ nr1 create Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: bash Copy $ nr1 catalog:submit Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Advance configurations Extend webpack configuration You can use our .extended-webpackrc.js file to extend the webpack 4 configuration. This allows you to add your own aliases, scripts, and configurations when locally serving or deploying your app. Proxy browser setup Generally, you don't need to know how your application code is loaded in New Relic One. But understanding how this works can help you if you encounter issues (for example, with a proxy or browser setup). When developing, your code is served from your local laptop by using an nr-local.net subdomain. This domain points to 127.0.0.1, and will use a variety of ports to connect, including 9973. In order to load third-party code into the platform, (both in development and production), New Relic One uses an <IFRAME>, as well as a separate domain (a subdomain of nr-ext.net) to perform the load, relying on same-domain policy to sandbox the code. For this reason, your network administrator may need to enable access to: Any subdomain of nr-local.net, or, at the very least, to any domain of the shape of <UserId>.nr-local.net, where UserId is a 32-hexadecimal character identifier that is unique to the user logged into the platform (you can use [0-9a-f]{32} to discriminate it). Any subdomain of nr-ext.net, or, at the very least, to any domain in the shape of <NerdpackUuid>.g <NerdpackGid>.nr-ext.net, where NerdpackUuid is the UUID assigned to your package, and NerdpackGid is zero, or a positive integer (you can use 0|[1-9]\\d+ to discriminate it). Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.47716,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Publish your application to <em>New</em> <em>Relic</em>",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "NR <em>One</em> <em>Catalog</em>",
        "body": " the video, which demonstrates the steps in this guide in five minutes. Before you begin To get started, make sure you have accounts in GitHub and <em>New</em> <em>Relic</em>. To develop projects, you need the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (<em>command</em> line interface). If you haven&#x27;t already installed it, do the following: Install"
      },
      "id": "5efa9973196a67d16d76645c"
    },
    {
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Subscribe or unsubscribe apps",
        "Handle duplicate applications",
        "This site uses cookies üç™"
      ],
      "title": "Serve, publish, and deploy your New Relic One app",
      "type": "developer",
      "tags": [
        "publish apps",
        "deploy apps",
        "subscribe apps",
        "add metadata apps"
      ],
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2020-12-04T01:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Start sharing and using the custom New Relic One apps you build",
      "body": "When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. bash Copy $ nr1 update Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. bash Copy $ nr1 catalog:submit Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Subscribe or unsubscribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.976456,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and deploy your <em>New</em> <em>Relic</em> <em>One</em> app",
        "sections": "Serve, publish, and deploy your <em>New</em> <em>Relic</em> <em>One</em> app",
        "info": "Start sharing and using the custom <em>New</em> <em>Relic</em> <em>One</em> apps you build",
        "body": ": Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> enables you to provide the information and images you want to include with your application. Then it&#x27;s a matter of kicking off a <em>catalog</em> <em>command</em> that validates"
      },
      "id": "5efa999de7b9d283e67bab8f"
    }
  ],
  "/automate-workflows/kubernetes-helm-deployment": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Automate common tasks",
        "Set up New Relic using the Kubernetes operator",
        "Getting started with New Relic and Terraform",
        "Set up New Relic using Helm charts",
        "Use New Relic to diagnose problems",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Automate workflows",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job ‚Äî getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows Quickly tag resources 5 min Add tags to apps for easy filtering Automatically tag a simple \"Hello World\" Demo across the entire stack 30 min See how easy it is to leverage automation in your DevOps environment! Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Set up New Relic using the Kubernetes operator 20 min Learn how to provision New Relic resources using the Kubernetes operator Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Set up New Relic using Helm charts 20 min Learn how to set up New Relic using Helm charts Use New Relic to diagnose problems 30 min Learn to diagnose problems using New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 7305.509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em>",
        "body": " <em>using</em> <em>Helm</em> <em>charts</em> 20 min Learn how to <em>set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em> <em>Use</em> <em>New</em> <em>Relic</em> to diagnose problems 30 min Learn to diagnose problems <em>using</em> <em>New</em> <em>Relic</em>."
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Installation",
      "nodeid": 36841,
      "sections": [
        "Kubernetes integration",
        "Get started",
        "Installation",
        "Understand and use data",
        "Link apps and services",
        "Kubernetes events",
        "Logs",
        "Troubleshooting",
        "Configure control plane monitoring",
        "Features",
        "Compatibility and requirements",
        "Discovery of master nodes and control plane components",
        "Configuration",
        "ETCD",
        "API server",
        "OpenShift configuration",
        "Set up mTLS from the ETCD client CA",
        "Set up mTLS for ETCD in OpenShift",
        "See your data",
        "For more help"
      ],
      "title": "Configure control plane monitoring",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Kubernetes integration",
      "external_id": "6bfd11636535081afb3ef8058362d6bd3296e3ce",
      "image": "https://docs.newrelic.com/sites/default/files/styles/inline_660px/public/thumbnails/image/new-relic-one-k8s-cluster-explorer-control-plane-parameters.png?itok=cLymrxv6",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/configure-control-plane-monitoring",
      "published_at": "2021-02-23T02:59:22Z",
      "updated_at": "2021-02-23T02:59:22Z",
      "breadcrumb": "Contents / Integrations / Kubernetes integration / Installation",
      "document_type": "page",
      "popularity": 1,
      "info": "How to configure control plane monitoring for your Kubernetes integration with New Relic.",
      "body": "New Relic provides Control Plane support for your Kubernetes integration, allowing you to monitor and collect metrics from your cluster's Control Plane components. That data can then be found in New Relic and used to create queries and charts. Features We monitor and collect metrics from the following control plane components: ETCD: leader information, resident memory size, number of OS threads, consensus proposals data, etc. For a list of supported metrics, see ETCD data. API server: rate of apiserver requests, breakdown of apiserver requests by HTTP method and response code, etc. For the complete list of supported metrics, see API server data. Scheduler: requested CPU/memory vs available on the node, tolerations to taints, any set affinity or anti-affinity, etc. For the complete list of supported metrics, see Scheduler data. Controller manager: resident memory size, number of OS threads created, goroutines currently existing, etc. For the complete list of supported metrics, see Controller manager data. Compatibility and requirements Control plane monitoring requires Kubernetes integration version 1.11.0 or higher. Control plane monitoring support is not enabled for managed clusters. This is because providers (EKS, GKE, AKS, etc.) abstract away the concept of master nodes and control plane components, so that access to them is limited or non-existent. The unprivileged version of the Kubernetes integration does not support control plane monitoring. OpenShift 4.x uses control plane component metric endpoints that are different than the default. Discovery of master nodes and control plane components The Kubernetes integration relies on the kubeadm labeling conventions to discover the master nodes and the control plane components. This means that master nodes should be labeled with node-role.kubernetes.io/master=\"\" or kubernetes.io/role=\"master\". The control plane components should have either the k8s-app or the tier and component labels. Refer to the following table for accepted label combinations and values: Component Label Endpoint API server Kubeadm / Kops / ClusterAPI k8s-app=kube-apiserver tier=control-plane component=kube-apiserver OpenShift app=openshift-kube-apiserver apiserver=true localhost:443/metrics by default (can be configured) if the request fails falls back to localhost:8080/metrics ETCD Kubeadm / Kops / ClusterAPI k8s-app=etcd-manager-main tier=control-plane component=etcd OpenShift k8s-app=etcd localhost:4001/metrics Scheduler Kubeadm / Kops / ClusterAPI k8s-app=kube-scheduler tier=control-plane component=kube-scheduler OpenShift app=openshift-kube-scheduler scheduler=true localhost:10251/metrics Controller manager Kubeadm / Kops / ClusterAPI k8s-app=kube-controller-manager tier=control-plane component=kube-controller-manager‚Äã OpenShift app=kube-controller-manager kube-controller-manager=true localhost:10252/metrics When the integration detects that it is running inside a master node, it tries to find which components are running on the node by looking for pods that match the labels listed in the table above. For every running component, the integration makes a request to its metrics endpoint. Configuration Control plane monitoring is automatic for agents running inside master nodes. The only component that requires an extra step to run is ETCD, because it uses mutual TLS authentication (mTLS) for client requests. The API Server can also be configured to be queried using the Secure Port. Control plane monitoring for OpenShift 4.x requires additional configuration. For more information, see the OpenShift 4.x Configuration section. ETCD In order to set mTLS for querying ETCD, there are two configuration options that need to be set: Option Value ETCD_TLS_SECRET_NAME Name of a Kubernetes secret that contains the mTLS configuration. The secret should contain the following keys: cert: the certificate that identifies the client making the request. It should be signed by an ETCD trusted CA. key: the private key used to generate the client certificate. cacert: the root CA used to identify the ETCD server certificate. If the ETCD_TLS_SECRET_NAME option is not set, ETCD metrics won't be fetched. For step by step instructions on how to create a certificate and sign it with the ETCD client CA, see Set up mTLS from the ETCD client CA. ETCD_TLS_SECRET_NAMESPACE The namespace where the secret specified in the ETCD_TLS_SECRET_NAME was created. If not set, the default namespace is used. API server By default, the API server metrics are queried using the localhost:8080 unsecured endpoint. If this port is disabled, you can also query these metrics over the secure port. To enable this, set the following configuration option in the Kubernetes integration manifest file: Option Value API_SERVER_ENDPOINT_URL The (secure) URL to query the metrics. The API server uses localhost:443 by default Ensure that the ClusterRole has been updated to the newest version found in the manifest Added in version 1.15.0 Note that the port can be different according to the secure port used by the API server. For example, in Minikube the API server secure port is 8443 and therefore API_SERVER_ENDPOINT_URL should be set to https://localhost:8443 OpenShift configuration Control plane components on OpenShift 4.x use endpoint URLs that require SSL and service account based authentication. Therefore, the default endpoint URLs can not be used. To configure control plane monitoring on OpenShift, uncomment the following environment variables in the customized manifest. URL values are pre-configured to the default base URLs for the control plane monitoring metrics endpoints in OpenShift 4.x. - name: \"SCHEDULER_ENDPOINT_URL\" value: \"https://localhost:10259 - name: \"ETCD_ENDPOINT_URL\" value: \"https://localhost:9979\" - name: \"CONTROLLER_MANAGER_ENDPOINT_URL\" value: \"https://localhost:10257\" - name: \"API_SERVER_ENDPOINT_URL\" value: \"https://localhost:6443\" Even though the custom ETCD_ENDPOINT_URL is defined, ETCD requires HTTPS and mTLS authentication to be configured. For more on configuring mTLS for ETCD in OpenShift, see Set up mTLS for ETCD in OpenShift. When installing through Helm openshift, specify the config to automatically include these endpoints. Setting openshift.enabled=true and openshift.version=\"4.x\" will include the secure endpoints and enable the /var/run/crio.sock runtime. Set up mTLS from the ETCD client CA The instructions below are based on the Kubernetes documentation. For more information, see Managing TLS certificates in a cluster. For OpenShift, see Set up mTLS for ETCD in OpenShift. To set up mTLS from the ETCD client CA: Download and install the tool cfssl, selecting the correct binaries for your OS from the list. Once installed, execute the following command: cat <<EOF | cfssl genkey - | cfssljson -bare server { \"hosts\": [ \"localhost\" ], \"CN\": \"newrelic-infra.pod.cluster.local\", \"key\": { \"algo\": \"ecdsa\", \"size\": 256 } } EOF This command generates two files; server.csr containing the PEM encoded pkcs#10 certification request and server-key.pem containing the PEM encoded key to the certificate to be created. Use the generated certificate authority (CA) of ETCD to sign your CSR. Depending on your cluster configuration, you may already have this information. For default install configuration, download the CA certificate and the private key directly from ETCD with the following commands: kubectl cp $(kubectl get pods -l k8s-app=etcd-manager-main -n kube-system -o jsonpath=\"{.items[0].metadata.name}\"):/etc/kubernetes/pki/etcd-manager/etcd-clients-ca.crt ./cacert -n kube-system kubectl cp $(kubectl get pods -l k8s-app=etcd-manager-main -n kube-system -o jsonpath=\"{.items[0].metadata.name}\"):/etc/kubernetes/pki/etcd-manager/etcd-clients-ca.key ./cacert.key -n kube-system This requires that the etcd-manager-main pod has the label k8s-app=etcd-manager-main, which is a requirement for control plane monitoring . If your etc-manager-main pod is located in a different namespace, change the -n kube-system flags accordingly. With those files downloaded, use the following command to sign your CSRF: cfssl sign -ca cacert -ca-key cacert.key server.csr | cfssljson -bare cert Create the secret that is used to retrieve the TLS config for making requests to ETC. We recommend renaming the certificate and the private key: cp cert.pem cert && cp server-key.pem key kubectl -n default create secret generic newrelic-infra-etcd-tls-secret --from-file=./cert --from-file=./key --from-file=./cacert To ease future installations Use the following commands to simultaneously create the CSR, retrieve the CA, generate the certificate by signing the CSR, and create the secret with all the required fields: cat <<EOF | cfssl genkey - | cfssljson -bare server && \\ kubectl cp $(kubectl get pods -l k8s-app=etcd-manager-main -n kube-system -o jsonpath=\"{.items[0].metadata.name}\"):/etc/kubernetes/pki/etcd-manager/etcd-clients-ca.crt ./cacert -n kube-system && \\ kubectl cp $(kubectl get pods -l k8s-app=etcd-manager-main -n kube-system -o jsonpath=\"{.items[0].metadata.name}\"):/etc/kubernetes/pki/etcd-manager/etcd-clients-ca.key ./cacert.key -n kube-system && \\ cp server-key.pem key && \\ cfssl sign -ca cacert -ca-key cacert.key server.csr | cfssljson -bare cert && \\ cp cert.pem cert && \\ kubectl -n default create secret generic newrelic-infra-etcd-tls-secret --from-file=./cert --from-file=./key --from-file=./cacert { \"hosts\": [ \"localhost\" ], \"CN\": \"newrelic-infra.pod.cluster.local\", \"key\": { \"algo\": \"ecdsa\", \"size\": 256 } } EOF The last step is to update the configuration in the manifest and apply it. In the configuration section, there are two options related to ETCD mTLS: ETCD_TLS_SECRET_NAME with the name of the secret that we just created. ETCD_TLS_SECRET_NAMESPACE with the namespace that we used to create the secret. To complete the installation, add these variables to the container spec of the integration DaemonSet and apply the changes: - name: \"ETCD_TLS_SECRET_NAME‚Äù value: \"newrelic-infra-etcd-tls-secret\" - name: \"ETCD_TLS_SECRET_NAMESPACE\" value: \"default\" Set up mTLS for ETCD in OpenShift Follow these instructions to set up mutual TLS authentication for ETCD in OpenShift 4.x: Export the ETCD client certificates from the cluster to an opaque secret. In a default managed OpenShift cluster, the secret is named kube-etcd-client-certs and it is stored in the openshift-monitoring namespace. kubectl get secret/kube-etcd-client-certs -n openshift-monitoring -o yaml > etcd-secret.yaml Open the secret file and change the keys: Rename the certificate authority to cacert. Rename the client certificate to cert. Rename the client key to key. Optional: change the secret name and namespace to something meaningful. Remove these unnecessary keys in the metadata section: creationTimestamp resourceVersion selfLink uid Install the manifest with its new name and namespace: kubectl apply -f etcd-secret.yaml Go to Update manifest configuration (the last step under Set up MTL from ETCD client) to configure the required environment variables. See your data If the integration has been been set up correctly, the Kubernetes cluster explorer contains all the Control Plane components and their status in a dedicated section, as shown below. one.newrelic.com > Kubernetes Cluster Explorer: Use the Kubernetes cluster explorer to monitor and collect metrics from your cluster's Control Plane components You can also check for Control Plane data with this NRQL query: SELECT latest(timestamp) FROM K8sApiServerSample, K8sEtcdSample, K8sSchedulerSample, K8sControllerManagerSample FACET entityName where clusterName = 'MY_CLUSTER_NAME' If you still can't see Control Plane data, try the solution described in Kubernetes integration troubleshooting: Not seeing data. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.57816,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Set</em> <em>up</em> mTLS from the ETCD client CA",
        "info": "How to configure control plane monitoring for your Kubernetes integration with <em>New</em> <em>Relic</em>.",
        "body": "<em>New</em> <em>Relic</em> provides Control Plane support for your Kubernetes integration, allowing you to monitor and collect metrics from your cluster&#x27;s Control Plane components. That data can then be found in <em>New</em> <em>Relic</em> and used to create queries and <em>charts</em>. Features We monitor and collect metrics from"
      },
      "id": "5df47acc64441f8fea39263b"
    },
    {
      "category_2": "Istio",
      "nodeid": 38896,
      "sections": [
        "Open source telemetry integrations",
        "Get started",
        "OpenTelemetry",
        "Dropwizard",
        "Istio",
        "Kamon",
        "Micrometer",
        "OpenCensus",
        "Prometheus",
        "Istio adapter",
        "Enable Istio adapter",
        "Find your data",
        "For more help"
      ],
      "title": "Istio adapter",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Open source telemetry integrations",
      "external_id": "8ae4a6ec0fe4b80922bf70037addf9b1ff1e0094",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/open-source-telemetry-integrations/istio/istio-adapter",
      "published_at": "2021-02-25T02:01:24Z",
      "updated_at": "2021-02-15T18:03:27Z",
      "breadcrumb": "Contents / Integrations / Open source telemetry integrations / Istio",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic offers an integration for Istio that sends telemetry data to your New Relic account.   ",
      "body": "Istio provides a flexible model to enforce authorization policies and collect telemetry for the services in a mesh. New Relic's Istio adapter exports telemetry data from your Istio instance to your New Relic account. Resources for our Istio adapter: Enable Istio adapter To enable our Istio adapter: Follow the Istio adapter install instructions. Optional: Instead of using the native Istio trace sampling, you can enable our Infinite Tracing feature. If you use this option, you will typically want to configure Istio to send us all trace data (learn more about sampling). To enable Infinite Tracing: In the New Relic UI, set up a trace observer. Configure our Istio adapter to send data to the trace observer: Set the spansHost value with YOUR_TRACE_OBSERVER_URL when deploying the Helm chart. Find your data To find your data, go to one.newrelic.com and go to Your applications > Entity explorer. From the Entities screen, search for your service by name. From there, you can explore your metrics using the Data explorer and build dashboards using your metrics. If you're sending distributed tracing data, the distributed tracing feature is available to query and view traces. For more on how to query your data once it's in New Relic, see Query your data and Introduction to NRQL. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.74582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "<em>New</em> <em>Relic</em> offers an integration for Istio that sends telemetry data to your <em>New</em> <em>Relic</em> account.   ",
        "body": " Tracing: In the <em>New</em> <em>Relic</em> UI, <em>set</em> <em>up</em> a trace observer. Configure our Istio adapter to send data to the trace observer: <em>Set</em> the spansHost value with YOUR_TRACE_OBSERVER_URL when deploying the <em>Helm</em> <em>chart</em>. Find your data To find your data, go to one.newrelic.com and go to Your applications &gt; Entity explorer"
      },
      "id": "602ab76fe7b9d2d21e2b2dd8"
    },
    {
      "category_2": "Installation",
      "nodeid": 14966,
      "sections": [
        "Kubernetes integration",
        "Get started",
        "Installation",
        "Understand and use data",
        "Link apps and services",
        "Kubernetes events",
        "Logs",
        "Troubleshooting",
        "Kubernetes integration: install and configure",
        "Use automated installer",
        "Installs for managed services and platforms",
        "Custom manifest",
        "Make sure New Relic pods can be scheduled",
        "Unprivileged installs of the Kubernetes integration",
        "Configure the integration",
        "Configure the infrastructure agent",
        "Update to the latest version",
        "Uninstall the Kubernetes integration",
        "For more help"
      ],
      "title": "Kubernetes integration: install and configure",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Kubernetes integration",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/integrations/kubernetes-integration/installation/kubernetes-integration-install-configure",
      "external_id": "e2a0aea9a0c2461e833148e95859ee34f03bce95",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/cke.jpeg",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/kubernetes-integration-install-configure",
      "published_at": "2021-02-23T09:03:16Z",
      "updated_at": "2021-02-23T09:03:15Z",
      "breadcrumb": "Contents / Integrations / Kubernetes integration / Installation",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic's Kubernetes integration: How to install and activate the integration, and what data is reported.",
      "body": "The easiest way to install the Kubernetes integration is to use our automated installer to generate a manifest. It bundles not just the integration DaemonSets, but also other New Relic Kubernetes configurations, like Kubernetes events, Prometheus OpenMetrics, and New Relic log monitoring. To use Kubernetes integrations and infrastructure monitoring, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Use automated installer You can use the automated installer for servers, VMs, and unprivileged environments. The installer can also help you with managed services or platforms after you review a few preliminary notes. We also have separate instructions if you need a custom manifest or prefer to do a manual unprivileged installation. Start the installer If your New Relic account is in the EU region, access the installer from one.eu.newrelic.com. Installs for managed services and platforms Before starting our automated installer, check out these notes for your managed services or platforms: Amazon EKS The Kubernetes integration monitors worker nodes. In Amazon EKS, master nodes are managed by Amazon and abstracted from the Kubernetes platforms. Before starting our automated installer to deploy the Kubernetes integration in Amazon EKS, make sure you are using the version of kubectl provided by AWS. Google Kubernetes Engine (GKE) The Kubernetes integration monitors worker nodes. In GKE, master nodes are managed by Google and abstracted from the Kubernetes platforms. Before starting our automated installer to deploy the Kubernetes integration on GKE, ensure you have sufficient permissions: Go to https://console.cloud.google.com/iam-admin/iam and find your username. Click edit. Ensure you have permissions to create Roles and ClusterRoles: If you are not sure, add the Kubernetes Engine Cluster Admin role. If you cannot edit your user role, ask the owner of the GCP project to give you the necessary permissions. Ensure you have a RoleBinding that grants you the same permissions to create Roles and ClusterRoles: kubectl create clusterrolebinding YOUR_USERNAME-cluster-admin-binding --clusterrole=cluster-admin --user=YOUR_GCP_EMAIL Creating a RoleBinding is necessary because of a known RBAC issue in Kubernetes and Kubernetes Engine versions 1.6 or higher. For more information, see Google Cloud's documentation on defining permissions in a role. OpenShift container platform To deploy the Kubernetes integration with OpenShift: Add the <release_name>-newrelic-infrastructure service account to your privileged Security Context Constraints: oc adm policy add-scc-to-user privileged \\ system:serviceaccount: <namespace> :<release_name>-newrelic-infrastructure The default <release_name> provided by the installer is nri-bundle. Complete the steps in our automated installer. If you're using signed certificates, make sure they are properly configured by using the following variables in the DaemonSet portion of your manifest to set the .pem file: - name: NRIA_CA_BUNDLE_DIR value: YOUR_CA_BUNDLE_DIR - name: NRIA_CA_BUNDLE_FILE value: YOUR_CA_BUNDLE_NAME YAML key path: spec.template.spec.containers.name.env Save your changes. Azure Kubernetes Service (AKS) The Kubernetes integration monitors worker nodes. In Azure Kubernetes Service, master nodes are managed by Azure and abstracted from the Kubernetes platforms. To deploy in Azure Kubernetes Service (AKS), complete the steps in our automated installer. Pivotal Container Service (PKS / VMware Tanzu) To deploy in PKS, we recommend that you use the automated installer, or you can follow the manual instructions provided in Install the Kubernetes integration using Helm. Custom manifest If the Kubernetes automated installer doesn't provide the settings you need, you can download our manifest template and install the integration manually. To activate the Kubernetes integration, you must deploy the newrelic-infra agent onto a Kubernetes cluster as a DaemonSet: Install kube-state-metrics and get it running on the cluster. For example: curl -L -o kube-state-metrics- 1.9.5 .zip https://github.com/kubernetes/kube-state-metrics/archive/v 1.9.5 .zip && unzip kube-state-metrics- 1.9.5 .zip && kubectl apply -f kube-state-metrics- 1.9.5 /examples/standard Download the manifest file: curl -O https://download.newrelic.com/infrastructure_agent/integrations/kubernetes/newrelic-infrastructure-k8s-latest.yaml In the DaemonSet portion of your manifest, add your New Relic license key and a cluster name to identify your Kubernetes cluster. Both values are required. Recommendation: Do not change the NRIA_PASSTHROUGH_ENVIRONMENT or NRIA_DISPLAY_NAME value in your manifest. YOUR_CLUSTER_NAME is your cluster‚Äôs id in New Relic‚Äôs entity explorer. It doesn‚Äôt need to match the name of the cluster running in your environment. YAML key path: spec.template.spec.containers.name.env env: - name: NRIA_LICENSE_KEY value: YOUR_LICENSE_KEY - name: CLUSTER_NAME value: YOUR_CLUSTER_NAME If you need to adapt the manifest to fit your environment, review the configure section in this doc. Confirm that kube-state-metrics is installed. kubectl get pods --all-namespaces | grep kube-state-metrics Create the DaemonSet: kubectl create -f newrelic-infrastructure-k8s-latest.yaml Confirm that the DaemonSet has been created successfully by looking for newrelic-infra in the results generated by this command: kubectl get daemonsets To confirm that the integration is working: wait a few minutes, then look for data in the New Relic Kubernetes cluster explorer. If you don't see data, review the configuration procedures again, then follow the troubleshooting procedures. In the future, the number of labels collected on Kubernetes objects will be limited per object type (containers, pods, nodes, etc.). If objects have labels above the limit, you will be able to configure important labels that should always be sent to New Relic. When the limitation is in place, this documentation will be updated. Make sure New Relic pods can be scheduled Some of the New Relic pods are set up as DaemonSet in the manifest file so that they can run on every host. These include newrelic-infrastructure and newrelic-logging. In rare circumstances, other pods may be scheduled first and starve the New Relic pods of resources. Since each of these pods have to run on a specific host, they will stay in pending status until that host has enough resources, even if there are other hosts available. This could end up occurring for long periods of time and result in reporting gaps. To prevent this scenario, you can configure the Kubernetes scheduler to give New Relic pods a higher priority. Using the default scheduler: Ensure kube-scheduler flag disablePreemption is not set to true (by default it is false). Create a PriorityClass for the New Relic DaemonSet pods: Set the appropriate priority value, which should generally be higher than your other pods. preemptionPolicy is set to PreemptLowerPriority by default. This allows New Relic pods assigned this priority class to remove lower-priority pods that are taking up resources. Edit the manifest file to add priorityClassName to any DaemonSet specs. In the example below, the highlighted line sets the priority class for newrelic-infrastructure: apiVersion: apps/v1 kind: DaemonSet metadata: namespace: default labels: app: newrelic-infrastructure chart: newrelic-infrastructure-1.0.0 release: nri-bundle mode: privileged name: nri-bundle-newrelic-infrastructure spec: priorityClassName: your-priority-class ... If you have already deployed the New Relic pods, re-deploy them and confirm they have been created: kubectl delete -f newrelic-infrastructure-k8s-latest.yaml kubectl create -f newrelic-infrastructure-k8s-latest.yaml kubectl get daemonsets Unprivileged installs of the Kubernetes integration For platforms that have stringent security requirements, we provide an unprivileged version of the Kubernetes integration. Changes from the standard Kubernetes integration are: Runs the infrastructure agent and the Kubernetes integration as a standard user instead of root No access to the underlying host filesystem No access to /var/run/docker.sock Container's root filesystem mounted as read-only allowPrivilegeEscalation is set to false hostnetwork is set to false The tradeoff is that the solution will only collect metrics from Kubernetes, but it will not collect any metric from the underlying hosts directly. Kubernetes provides some data (metrics and metadata) about its nodes (hosts). Optional: To collect the underlying host metrics, the non-containerized infrastructure agent can be deployed on the underlying host. The infrastructure agent already supports running as non-root. The combination of the Kubernetes integration in its unprivileged version and the agent running on the host will report all the metrics that our standard solution for monitoring Kubernetes receives. Steps to complete an unprivileged install Install kube-state-metrics and get it running on the cluster. For example: curl -L -o kube-state-metrics- 1.9.5 .zip https://github.com/kubernetes/kube-state-metrics/archive/v 1.9.5 .zip && unzip kube-state-metrics- 1.9.5 .zip && kubectl apply -f kube-state-metrics- 1.9.5 /examples/standard Download the integration manifest: curl -O https://download.newrelic.com/infrastructure_agent/integrations/kubernetes/newrelic-infrastructure-k8s-unprivileged-latest.yaml In the manifest, add your New Relic license key and a cluster name to identify your Kubernetes cluster. Both values are required. YOUR_CLUSTER_NAME is your cluster‚Äôs id in New Relic‚Äôs entity explorer. It doesn‚Äôt need to match the name of the cluster running in your environment. env: - name: NRIA_LICENSE_KEY value: YOUR_LICENSE_KEY - name: CLUSTER_NAME value: YOUR_CLUSTER_NAME YAML key path: spec.template.spec.containers.name.env Confirm that kube-state-metrics is installed. kubectl get pods --all-namespaces | grep kube-state-metrics Create the DaemonSet: kubectl create -f newrelic-infrastructure-k8s-unprivileged-latest.yaml Confirm that the DaemonSet has been created successfully by looking for newrelic-infra in the results generated by this command: kubectl get daemonsets To confirm that the integration has been configured correctly, wait a few minutes, then run this NRQL query to see if data has been reported: SELECT * FROM K8sPodSample since 5 minutes ago Configure the integration The Kubernetes integration comes with a default configuration that should work in most environments. To change the configuration, modify the manifest file: Select which processes should send their data to New Relic By default, data about the processes running on your pods is not sent to New Relic. You can enable it by setting enable_process_metrics to true. To choose what metric data you want to send to New Relic, configure the include_matching_metrics environment variable in your manifest. Specify the Kubernetes API host and port This is necessary when you are using SSL and not using the default FQDN. The Kubernetes API FQDN needs to match the FQDN of the SSL certificate. You do not need to specify both variables. For example, if you only specify the HOST, the default PORT will be used. - name: \"KUBERNETES_SERVICE_HOST\" value: \"KUBERNETES_API_HOST\" - name: \"KUBERNETES_SERVICE_PORT\" value: \"KUBERNETES_API_TCP_PORT\" Kubernetes versions 1.6 to 1.7.5: Edit manifest file For Kubernetes versions 1.6 to 1.7.5, uncomment these two lines in the manifest file: - name: \"CADVISOR_PORT\" # Enable direct connection to cAdvisor by specifying the port. Needed for Kubernetes versions prior to 1.7.6. value: \"4194\" Use environment variables Use environment variables that can be passed to the Kubernetes integration if you use a proxy to configure its URL. Disable kube-state-metrics parsing You can disable kube-state-metrics parsing for the DaemonSet by using the following configuration: - name: \"DISABLE_KUBE_STATE_METRICS\" value: \"true\" Disabling kube-state-metrics also disables data collection for the following: ReplicaSets DaemonSets StatefulSets Namespaces Deployments Services Endpoints Pods (that are pending) Additionally, disabling this affects the Kubernetes Cluster Explorer in the following ways: No pending pods are shown. No filters based on services. Specify the kube-state-metrics URL If several instances of kube-state-metrics are present in the cluster, uncomment and configure the following lines to specify which one to use: - name: \"KUBE_STATE_METRICS_URL\" value: \"http://KUBE_STATE_METRICS_IP_OR_FQDN:PORT\" Even though a KUBE_STATE_METRICS_URL is defined, the KSM service should contain one of the following labels for the auto-discovery process: k8s-app=kube-state-metrics OR app=kube-state-metrics OR ‚Äã‚Äãapp.kubernetes.io/name=kube-state-metrics This configuration option overrides KUBE_STATE_METRICS_POD_LABEL. If you have both defined, KUBE_STATE_METRICS_POD_LABEL has no effect. Discover kube-state-metrics pods using a label If several instances of kube-state-metrics are present in the cluster, another option to easily target one of these instances with the Kubernetes integration is to use label-based discovery. - name: \"KUBE_STATE_METRICS_POD_LABEL\" value: \"LABEL_NAME\" When a KUBE_STATE_METRICS_POD_LABEL is defined, the label should have a value equal to true. For example, if the label name is my-ksm, ensure that my-ksm=true. This configuration option is incompatible with KUBE_STATE_METRICS_URL. If you have both defined, KUBE_STATE_METRICS_URL is used. Query kube-state-metrics behind RBAC If your instance of kube-state-metrics is behind kube-rbac-proxy, the integration can be configured in a compatible way using the combination of the label-based discovery and two other environment variables: - name: \"KUBE_STATE_METRICS_SCHEME\" value: \"https\" - name: \"KUBE_STATE_METRICS_PORT\" value: \"KSM_RBAC_PROXY_PORT\" To confirm which port should be used as the value of KUBE_STATE_METRICS_PORT, we recommend running a describe command on the kube-state-metrics pod and look for the port exposed by the container named kube-rbac-proxy-main. These two configuration options only work when using the KUBE_STATE_METRICS_POD_LABEL ‚Äãconfiguration described above. kube-state-metrics timeout: Increase the client timeout To increase the client timeout of kube-state-metrics, add a new environment variable, TIMEOUT, to the manifest file: env: - name: TIMEOUT value: 5000 # The default client timeout when calling kube-state-metrics, in milliseconds Then, add this new environment variable to the NRIA_PASSTHROUGH_ENVIRONMENT Non-default namespace deployments: Edit config file If you want to deploy in a different namespace from default, change all values of namespace in the manifest. Set the TTL for the Kubernetes API responses cache By default, the integration will cache any retrieved information from the Kubernetes API for 5 minutes. Use the API_SERVER_CACHE_TTL environment variable to set a custom cache duration for responses from the API server. Valid time unit values are: ns, us, ms, s, m, and h. To disable caching, set to 0s. env: - name: API_SERVER_CACHE_TTL value: \"1m\" Specify base URLs for control plane component endpoints Use the following environment variables if any of the Kubernetes control plane components export metrics on base URLs that are different from the defaults. This is necessary for environments such as OpenShift when a control plane component metrics endpoint is using SSL or an alternate port. Values of these environment variables must be base URLs of the form [scheme]://[host]:[port]. URLs should not include a path component. For example: - name: \"SCHEDULER_ENDPOINT_URL\" value: \"https://localhost:10259\" - name: \"ETCD_ENDPOINT_URL\" value: \"https://localhost:9979\" - name: \"CONTROLLER_MANAGER_ENDPOINT_URL\" value: \"https://localhost:10257\" - name: \"API_SERVER_ENDPOINT_URL\" value: \"https://localhost:6443\" The /metrics path segment is added automatically. In addition, if the https scheme is used, authentication to the control plane component pod(s) is accomplished via service accounts. If a FQDN (fully qualified domain name) is used in a multi-master cluster, inconsistent results may be returned. Therefore, it is recommended to use localhost only. Even though a custom base URL is defined for a given control plane component, the control plane component pod(s) must contain one of the labels supported by the auto-discovery process. Even though a custom ETCD_ENDPOINT_URL can be defined, ETCD will always require https and mTLS authentication to be configured. Here are some additional configurations to consider: Do more configuration for control plane monitoring Link New Relic APM to the Kubernetes integration Monitor services that run on Kubernetes Configure the infrastructure agent The Kubernetes integration image comes with a default configurations for the agent that can be modified if needed. When installing with the manifest, you can modify the infrastructure agent configuration by editing the manifest and adding any needed configuration option of the agent as environment variables of the newrelic-infrastructure DaemonSet. When installing with Helm, you can specify the needed infrastructure agent configuration options in the values.yaml as shown in the example in GitHub. The config object is used to populate the configMap that is mounted automatically in the location of the infrastructure agent configuration file in the pods created by the newrelic-infrastructure DaemonSet. Update to the latest version If you are already running the Kubernetes integration and want to update the newrelic-infra agent to the latest agent version: Run this NRQL query to check which version you are currently running (this will return the image name by cluster): SELECT latest(containerImage) FROM K8sContainerSample WHERE containerImage LIKE '%newrelic/infrastructure%' FACET clusterName SINCE 1 day ago If you've set a name other than newrelic/infrastructure for the integration's container image, the above query won't yield results: to make it work, edit the name in the query. Download the integration manifest file: curl -O https://download.newrelic.com/infrastructure_agent/integrations/kubernetes/newrelic-infrastructure-k8s-latest.yaml Copy the changes you made to the manifest. At a minimum, include CLUSTER_NAME and NRIA_LICENSE_KEY, and paste your changes in the manifest you downloaded. Install the latest DaemonSet with the following command (Kubernetes will automatically do a rollout upgrade for the integration's pods): kubectl apply -f newrelic-infrastructure-k8s-latest.yaml Uninstall the Kubernetes integration To uninstall the Kubernetes integration: Verify that newrelic-infrastructure-k8s-latest.yaml corresponds to the filename of the manifest as you have saved it. Example: If you are using the unprivileged version of the integration, the default filename will be newrelic-infrastructure-k8s-unprivileged-latest.yaml. After you verify the filename, use the following command: kubectl delete -f newrelic-infrastructure-k8s-latest.yaml You only need to execute this command once, regardless of the number of nodes in your cluster. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.23471,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Make sure <em>New</em> <em>Relic</em> pods can be scheduled",
        "info": "<em>New</em> <em>Relic&#x27;s</em> Kubernetes integration: How to install and activate the integration, and what data is reported.",
        "body": " end <em>up</em> occurring for long periods of time and result in reporting gaps. To prevent this scenario, you can configure the Kubernetes scheduler to give <em>New</em> <em>Relic</em> pods a higher priority. <em>Using</em> the default scheduler: Ensure kube-scheduler flag disablePreemption is not <em>set</em> to true (by default it is false"
      },
      "id": "5efd3b2e64441fd60f5f7e49"
    },
    {
      "category_2": "UI and data",
      "nodeid": 34311,
      "sections": [
        "Use New Relic One",
        "Get started",
        "Core concepts",
        "UI and data",
        "Workloads",
        "Build on New Relic One",
        "Basic UI features",
        "Observe your platform",
        "Search accounts and entities",
        "Use chart and query features",
        "Share with teammates",
        "Smooth navigation: Customize your bar and access the shortcuts",
        "Adjust account and user settings",
        "For more help"
      ],
      "title": "Basic UI features",
      "category_0": "New Relic One",
      "type": "docs",
      "category_1": "Use New Relic One",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features",
      "external_id": "36de5461da46592356028558318a7263a6f44ea3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features",
      "published_at": "2021-02-23T01:00:40Z",
      "updated_at": "2021-02-23T01:00:40Z",
      "breadcrumb": "Contents / New Relic One / Use New Relic One / UI and data",
      "document_type": "page",
      "popularity": 1,
      "info": "A description of some core New Relic UI features, including chart features, search features, account selection, and more. ",
      "body": "New Relic One has some basic UI functions that are widely available across the platform. Understanding these features will help you find and analyze your data more easily. Observe your platform New Relic One gives you full access to the data from all the entities in your stack. Go to the New Relic Explorer at one.newrelic.com to see a full list of entities, identify overall behaviors, filter them to locate sources of performance issues, or plan improvements for your system. Search accounts and entities You can access the primary search at the top of the New Relic UI. Some details about search: You can search across all your New Relic accounts with cross-account access. Entities that cease to exist are available in search for eight days. If your organization has multiple accounts, use the account picker at the top left corner to select accounts. Use chart and query features You can add most charts to a new or existing dashboard. Here are some query and chart features available across all or most of the platform: If you want to... Do this... Start querying your data Mouse over Browse data and select metrics, events, logs, or traces for a direct access to any of those types of data. Also, at the top of any UI page, select Query your data to access the data explorer and query builder. View a chart's query For some charts, you can view the NRQL query used to generate that chart. This can help you understand a chart better or use it as the basis for a new query. Choose time range Drag across a section of a chart to zoom in on that time range. Or, use the time picker in the top right corner of the UI to select pre-set time ranges or set a custom one. View chart details Mouse over a chart to see a pop-up with more detail. For some charts, selecting a point on the chart will take you to a UI page with more information about that metric. Hide or return chart elements To hide or unhide a displayed chart element, select that element's name below the chart. The chart display will adjust to reflect the absence or presence of that element. Share with teammates Here are some options for sharing New Relic UI pages and visualizations. If you want to... Do this... Share UI pages and dashboards To share an entire New Relic UI page, click Share near the top of the UI to copy the URL. Share charts If New Relic charts are built with NRQL queries, they have a [ellipsis icon] menu that exposes various options, including sharing options like Get as image and Get chart link. Some notes about sharing: The person you share with may not have access to view the data from that account. To solve that, someone on your team with New Relic user management abilities must add that person to the account. If someone can't access a custom dashboard, it may be that it is set to private. Read more about dashboard permissions. Some sharing options have associated time ranges, which may impact later viewings of it. For example, if you use a chart's Get chart link option and that chart is set to 'Last 30 minutes', when viewed it will show the last 30 minutes, not the time range displayed when it was shared. To share a specific time range, you must select that time range in the UI. Smooth navigation: Customize your bar and access the shortcuts Select the edit [pencil icon] icon at the right end of the navigation bar to customize your view. Home, Explorer, Browse data, Dashboards, and Alerts & AI are fixed, but you can favorite up to six more elements to display on the bar as well. The rest will go on the More group. Navigation shortcuts are a faster way to find entities and apps that are relevant to you. Mouse over any menu item for quick access to your favorite entities, those you recently visited, or just to search without having to navigate to a specific section. If you click on an entity, you can choose to open it in the same browser tab or in a new one. Adjust account and user settings To adjust account settings and user preferences, and to get support and docs links, use the account dropdown, located at the top right of the UI, beside your user name. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.42078,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Use</em> <em>New</em> <em>Relic</em> One",
        "info": "A description of some core <em>New</em> <em>Relic</em> UI features, including <em>chart</em> features, search features, account selection, and more. ",
        "category_0": "<em>New</em> <em>Relic</em> One",
        "category_1": "<em>Use</em> <em>New</em> <em>Relic</em> One",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;<em>new</em>-<em>relic</em>-one&#x2F;<em>use</em>-<em>new</em>-<em>relic</em>-one&#x2F;ui-data&#x2F;basic-ui-features",
        "body": " Drag across a section of a <em>chart</em> to zoom in on that time range. Or, <em>use</em> the time picker in the top right corner of the UI to select pre-<em>set</em> time ranges or <em>set</em> a custom one. View <em>chart</em> details Mouse over a <em>chart</em> to see a pop-<em>up</em> with more detail. For some <em>charts</em>, selecting a point on the <em>chart</em>",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> One &#x2F; <em>Use</em> <em>New</em> <em>Relic</em> One &#x2F; UI and data"
      },
      "id": "5f3ba695e7b9d2e35a909265"
    }
  ],
  "/explore-docs/intro-to-sdk": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Create a \"Hello, World!\" application",
        "Add a table to your app",
        "Create a custom map view",
        "Permissions for managing applications",
        "Publish and deploy apps",
        "Set up your development environment",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:59:19Z",
      "title": "Build apps",
      "updated_at": "2021-02-25T01:59:19Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps Add the NerdGraphQuery component to an application 20 minutes The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Add a time picker to your app 20 min Add a time picker to a sample application Create a \"Hello, World!\" application 15 min Build a \"Hello, World!\" app and publish it to New Relic One Add a table to your app 30 min Add a table to your New Relic One app Create a custom map view 30 min Build an app to show page view data on a map Permissions for managing applications ¬† Learn about permissions for subscribing to apps Publish and deploy apps 30 min Start sharing the apps you build Set up your development environment 20 min Prepare to build apps and contribute to this site",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 925.71,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Publish <em>and</em> deploy <em>apps</em>",
        "body": " from your account and add it to a dropdown menu in an application Add, <em>query</em>, and mutate data using Nerd<em>Storage</em> 45 min Nerd<em>Storage</em> is a document database accessible within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next. Add a time picker to your <em>app</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/1qf2g217c4q7m/promo-image.1608575584.png",
      "url": "https://learn.newrelic.com/getting-started-with-dashboards-nrql",
      "sections": [
        "Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations.",
        "About this workshop"
      ],
      "published_at": "2021-02-25T01:39:49Z",
      "title": "Getting started with Dashboards & NRQL",
      "updated_at": "2021-02-25T01:39:49Z",
      "type": "",
      "external_id": "20be8b6c5a3882e951f9dfd70354ea7ceaa38c7c",
      "popularity": 1,
      "body": "Sign In Getting started with Dashboards & NRQL Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations. Register | FREE Already registered? Sign In About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.¬† These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.¬† Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.¬†¬† In this hands-on session, you‚Äôll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.¬† Using a sandbox account you‚Äôll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.¬† You‚Äôll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.¬† Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL March 9, 2021, 1 p.m. - March 9, 2021, 3 p.m. GMT 114 Getting started with Dashboards & NRQL March 9, 2021, noon - March 9, 2021, 2 p.m. PST 118 About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.¬† These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.¬† Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.¬†¬† In this hands-on session, you‚Äôll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.¬† Using a sandbox account you‚Äôll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.¬† You‚Äôll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.¬† Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Live events Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL March 9, 2021, 1 p.m. - March 9, 2021, 3 p.m. GMT 114 Getting started with Dashboards & NRQL March 9, 2021, noon - March 9, 2021, 2 p.m. PST 118 ¬© 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 642.439,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Learn to use the Data Explorer <em>and</em> <em>Query</em> Builder Basic Mode to create <em>charts</em> <em>and</em> dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of <em>charts</em> <em>and</em> visualizations.",
        "body": "? Sign In About this workshop <em>New</em> <em>Relic</em> <em>One</em> offers a consistent, powerful, and flexible <em>query</em> language NRQL which enables you to <em>query</em> and analyze all of your collected data, and build custom charts and visualizations.¬† These charts can be combined to create powerful dashboards to help you correlate"
      },
      "id": "5fe29f8528ccbcf532f15668"
    },
    {
      "category_2": "Installation",
      "nodeid": 36841,
      "sections": [
        "Kubernetes integration",
        "Get started",
        "Installation",
        "Understand and use data",
        "Link apps and services",
        "Kubernetes events",
        "Logs",
        "Troubleshooting",
        "Configure control plane monitoring",
        "Features",
        "Compatibility and requirements",
        "Discovery of master nodes and control plane components",
        "Configuration",
        "ETCD",
        "API server",
        "OpenShift configuration",
        "Set up mTLS from the ETCD client CA",
        "Set up mTLS for ETCD in OpenShift",
        "See your data",
        "For more help"
      ],
      "title": "Configure control plane monitoring",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Kubernetes integration",
      "external_id": "6bfd11636535081afb3ef8058362d6bd3296e3ce",
      "image": "https://docs.newrelic.com/sites/default/files/styles/inline_660px/public/thumbnails/image/new-relic-one-k8s-cluster-explorer-control-plane-parameters.png?itok=cLymrxv6",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/configure-control-plane-monitoring",
      "published_at": "2021-02-23T02:59:22Z",
      "updated_at": "2021-02-23T02:59:22Z",
      "breadcrumb": "Contents / Integrations / Kubernetes integration / Installation",
      "document_type": "page",
      "popularity": 1,
      "info": "How to configure control plane monitoring for your Kubernetes integration with New Relic.",
      "body": "New Relic provides Control Plane support for your Kubernetes integration, allowing you to monitor and collect metrics from your cluster's Control Plane components. That data can then be found in New Relic and used to create queries and charts. Features We monitor and collect metrics from the following control plane components: ETCD: leader information, resident memory size, number of OS threads, consensus proposals data, etc. For a list of supported metrics, see ETCD data. API server: rate of apiserver requests, breakdown of apiserver requests by HTTP method and response code, etc. For the complete list of supported metrics, see API server data. Scheduler: requested CPU/memory vs available on the node, tolerations to taints, any set affinity or anti-affinity, etc. For the complete list of supported metrics, see Scheduler data. Controller manager: resident memory size, number of OS threads created, goroutines currently existing, etc. For the complete list of supported metrics, see Controller manager data. Compatibility and requirements Control plane monitoring requires Kubernetes integration version 1.11.0 or higher. Control plane monitoring support is not enabled for managed clusters. This is because providers (EKS, GKE, AKS, etc.) abstract away the concept of master nodes and control plane components, so that access to them is limited or non-existent. The unprivileged version of the Kubernetes integration does not support control plane monitoring. OpenShift 4.x uses control plane component metric endpoints that are different than the default. Discovery of master nodes and control plane components The Kubernetes integration relies on the kubeadm labeling conventions to discover the master nodes and the control plane components. This means that master nodes should be labeled with node-role.kubernetes.io/master=\"\" or kubernetes.io/role=\"master\". The control plane components should have either the k8s-app or the tier and component labels. Refer to the following table for accepted label combinations and values: Component Label Endpoint API server Kubeadm / Kops / ClusterAPI k8s-app=kube-apiserver tier=control-plane component=kube-apiserver OpenShift app=openshift-kube-apiserver apiserver=true localhost:443/metrics by default (can be configured) if the request fails falls back to localhost:8080/metrics ETCD Kubeadm / Kops / ClusterAPI k8s-app=etcd-manager-main tier=control-plane component=etcd OpenShift k8s-app=etcd localhost:4001/metrics Scheduler Kubeadm / Kops / ClusterAPI k8s-app=kube-scheduler tier=control-plane component=kube-scheduler OpenShift app=openshift-kube-scheduler scheduler=true localhost:10251/metrics Controller manager Kubeadm / Kops / ClusterAPI k8s-app=kube-controller-manager tier=control-plane component=kube-controller-manager‚Äã OpenShift app=kube-controller-manager kube-controller-manager=true localhost:10252/metrics When the integration detects that it is running inside a master node, it tries to find which components are running on the node by looking for pods that match the labels listed in the table above. For every running component, the integration makes a request to its metrics endpoint. Configuration Control plane monitoring is automatic for agents running inside master nodes. The only component that requires an extra step to run is ETCD, because it uses mutual TLS authentication (mTLS) for client requests. The API Server can also be configured to be queried using the Secure Port. Control plane monitoring for OpenShift 4.x requires additional configuration. For more information, see the OpenShift 4.x Configuration section. ETCD In order to set mTLS for querying ETCD, there are two configuration options that need to be set: Option Value ETCD_TLS_SECRET_NAME Name of a Kubernetes secret that contains the mTLS configuration. The secret should contain the following keys: cert: the certificate that identifies the client making the request. It should be signed by an ETCD trusted CA. key: the private key used to generate the client certificate. cacert: the root CA used to identify the ETCD server certificate. If the ETCD_TLS_SECRET_NAME option is not set, ETCD metrics won't be fetched. For step by step instructions on how to create a certificate and sign it with the ETCD client CA, see Set up mTLS from the ETCD client CA. ETCD_TLS_SECRET_NAMESPACE The namespace where the secret specified in the ETCD_TLS_SECRET_NAME was created. If not set, the default namespace is used. API server By default, the API server metrics are queried using the localhost:8080 unsecured endpoint. If this port is disabled, you can also query these metrics over the secure port. To enable this, set the following configuration option in the Kubernetes integration manifest file: Option Value API_SERVER_ENDPOINT_URL The (secure) URL to query the metrics. The API server uses localhost:443 by default Ensure that the ClusterRole has been updated to the newest version found in the manifest Added in version 1.15.0 Note that the port can be different according to the secure port used by the API server. For example, in Minikube the API server secure port is 8443 and therefore API_SERVER_ENDPOINT_URL should be set to https://localhost:8443 OpenShift configuration Control plane components on OpenShift 4.x use endpoint URLs that require SSL and service account based authentication. Therefore, the default endpoint URLs can not be used. To configure control plane monitoring on OpenShift, uncomment the following environment variables in the customized manifest. URL values are pre-configured to the default base URLs for the control plane monitoring metrics endpoints in OpenShift 4.x. - name: \"SCHEDULER_ENDPOINT_URL\" value: \"https://localhost:10259 - name: \"ETCD_ENDPOINT_URL\" value: \"https://localhost:9979\" - name: \"CONTROLLER_MANAGER_ENDPOINT_URL\" value: \"https://localhost:10257\" - name: \"API_SERVER_ENDPOINT_URL\" value: \"https://localhost:6443\" Even though the custom ETCD_ENDPOINT_URL is defined, ETCD requires HTTPS and mTLS authentication to be configured. For more on configuring mTLS for ETCD in OpenShift, see Set up mTLS for ETCD in OpenShift. When installing through Helm openshift, specify the config to automatically include these endpoints. Setting openshift.enabled=true and openshift.version=\"4.x\" will include the secure endpoints and enable the /var/run/crio.sock runtime. Set up mTLS from the ETCD client CA The instructions below are based on the Kubernetes documentation. For more information, see Managing TLS certificates in a cluster. For OpenShift, see Set up mTLS for ETCD in OpenShift. To set up mTLS from the ETCD client CA: Download and install the tool cfssl, selecting the correct binaries for your OS from the list. Once installed, execute the following command: cat <<EOF | cfssl genkey - | cfssljson -bare server { \"hosts\": [ \"localhost\" ], \"CN\": \"newrelic-infra.pod.cluster.local\", \"key\": { \"algo\": \"ecdsa\", \"size\": 256 } } EOF This command generates two files; server.csr containing the PEM encoded pkcs#10 certification request and server-key.pem containing the PEM encoded key to the certificate to be created. Use the generated certificate authority (CA) of ETCD to sign your CSR. Depending on your cluster configuration, you may already have this information. For default install configuration, download the CA certificate and the private key directly from ETCD with the following commands: kubectl cp $(kubectl get pods -l k8s-app=etcd-manager-main -n kube-system -o jsonpath=\"{.items[0].metadata.name}\"):/etc/kubernetes/pki/etcd-manager/etcd-clients-ca.crt ./cacert -n kube-system kubectl cp $(kubectl get pods -l k8s-app=etcd-manager-main -n kube-system -o jsonpath=\"{.items[0].metadata.name}\"):/etc/kubernetes/pki/etcd-manager/etcd-clients-ca.key ./cacert.key -n kube-system This requires that the etcd-manager-main pod has the label k8s-app=etcd-manager-main, which is a requirement for control plane monitoring . If your etc-manager-main pod is located in a different namespace, change the -n kube-system flags accordingly. With those files downloaded, use the following command to sign your CSRF: cfssl sign -ca cacert -ca-key cacert.key server.csr | cfssljson -bare cert Create the secret that is used to retrieve the TLS config for making requests to ETC. We recommend renaming the certificate and the private key: cp cert.pem cert && cp server-key.pem key kubectl -n default create secret generic newrelic-infra-etcd-tls-secret --from-file=./cert --from-file=./key --from-file=./cacert To ease future installations Use the following commands to simultaneously create the CSR, retrieve the CA, generate the certificate by signing the CSR, and create the secret with all the required fields: cat <<EOF | cfssl genkey - | cfssljson -bare server && \\ kubectl cp $(kubectl get pods -l k8s-app=etcd-manager-main -n kube-system -o jsonpath=\"{.items[0].metadata.name}\"):/etc/kubernetes/pki/etcd-manager/etcd-clients-ca.crt ./cacert -n kube-system && \\ kubectl cp $(kubectl get pods -l k8s-app=etcd-manager-main -n kube-system -o jsonpath=\"{.items[0].metadata.name}\"):/etc/kubernetes/pki/etcd-manager/etcd-clients-ca.key ./cacert.key -n kube-system && \\ cp server-key.pem key && \\ cfssl sign -ca cacert -ca-key cacert.key server.csr | cfssljson -bare cert && \\ cp cert.pem cert && \\ kubectl -n default create secret generic newrelic-infra-etcd-tls-secret --from-file=./cert --from-file=./key --from-file=./cacert { \"hosts\": [ \"localhost\" ], \"CN\": \"newrelic-infra.pod.cluster.local\", \"key\": { \"algo\": \"ecdsa\", \"size\": 256 } } EOF The last step is to update the configuration in the manifest and apply it. In the configuration section, there are two options related to ETCD mTLS: ETCD_TLS_SECRET_NAME with the name of the secret that we just created. ETCD_TLS_SECRET_NAMESPACE with the namespace that we used to create the secret. To complete the installation, add these variables to the container spec of the integration DaemonSet and apply the changes: - name: \"ETCD_TLS_SECRET_NAME‚Äù value: \"newrelic-infra-etcd-tls-secret\" - name: \"ETCD_TLS_SECRET_NAMESPACE\" value: \"default\" Set up mTLS for ETCD in OpenShift Follow these instructions to set up mutual TLS authentication for ETCD in OpenShift 4.x: Export the ETCD client certificates from the cluster to an opaque secret. In a default managed OpenShift cluster, the secret is named kube-etcd-client-certs and it is stored in the openshift-monitoring namespace. kubectl get secret/kube-etcd-client-certs -n openshift-monitoring -o yaml > etcd-secret.yaml Open the secret file and change the keys: Rename the certificate authority to cacert. Rename the client certificate to cert. Rename the client key to key. Optional: change the secret name and namespace to something meaningful. Remove these unnecessary keys in the metadata section: creationTimestamp resourceVersion selfLink uid Install the manifest with its new name and namespace: kubectl apply -f etcd-secret.yaml Go to Update manifest configuration (the last step under Set up MTL from ETCD client) to configure the required environment variables. See your data If the integration has been been set up correctly, the Kubernetes cluster explorer contains all the Control Plane components and their status in a dedicated section, as shown below. one.newrelic.com > Kubernetes Cluster Explorer: Use the Kubernetes cluster explorer to monitor and collect metrics from your cluster's Control Plane components You can also check for Control Plane data with this NRQL query: SELECT latest(timestamp) FROM K8sApiServerSample, K8sEtcdSample, K8sSchedulerSample, K8sControllerManagerSample FACET entityName where clusterName = 'MY_CLUSTER_NAME' If you still can't see Control Plane data, try the solution described in Kubernetes integration troubleshooting: Not seeing data. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 635.0094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Link <em>apps</em> <em>and</em> services",
        "info": "How to configure control plane monitoring for your Kubernetes integration with <em>New</em> <em>Relic</em>.",
        "body": "<em>New</em> <em>Relic</em> provides Control Plane support for your Kubernetes integration, allowing you to monitor and collect metrics from your cluster&#x27;s Control Plane <em>components</em>. That data can then be found in <em>New</em> <em>Relic</em> and used to create queries and charts. Features We monitor and collect metrics from"
      },
      "id": "5df47acc64441f8fea39263b"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/800w/public/2021-02/platform_fso_experience_july2020.png?itok=cNJ03YCK",
      "url": "https://newrelic.com/platform/full-stack-observability",
      "sections": [
        "Full-Stack Observability",
        "Full-Stack Observability includes:",
        "One place to explore your entire system",
        "APM",
        "Infrastructure Monitoring",
        "Serverless Monitoring",
        "Digital Experience Monitoring",
        "Logs in Context",
        "Experience Full-Stack Observability",
        "Free access to New Relic. Forever."
      ],
      "published_at": "2021-02-25T01:41:29Z",
      "title": "Full Stack Observability | New Relic",
      "updated_at": "2021-02-25T01:41:29Z",
      "type": "",
      "external_id": "d62202a5e448becf8db9ed0c894dfd409d3a555a",
      "popularity": 1,
      "body": "Skip to main content New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Full-Stack Observability Visualize, analyze, and troubleshoot your entire software stack in one curated, unified platform. And by automatically connecting infrastructure health with application performance and end-user behavior, you can cut through the noise to find the signal. Fast. That means less time troubleshooting, and more time building great software. Sign up for free Full-Stack Observability includes: New One place to explore your entire system Move faster than ever with New Relic Explorer. Catch sudden changes before they‚Äôre problems with New Relic Lookout. And see your estate‚Äôs health in a glance with New Relic Navigator. All new, and only with Full-Stack Observability. Explore what's new APM Find root causes and fix issues fast. In-depth transaction details show exact method calls with line numbers, including external dependencies for apps of any size and complexity. Get a complete picture by combining key metrics from mobile and browser apps with supporting services, data stores, and hosts. Capabilities include: Application Monitoring Distributed Tracing (New Relic Edge) Infrastructure Monitoring Gain visibility into all of your infrastructure‚Äîincluding servers and VMs on-premises, cloud resources and cloud-native infrastructure. Then connect the health and performance of all of your hosts, services, containers, and resources with the richest application context, logs, and configuration changes, so you can understand, identify, and troubleshoot problems faster. Learn more about Infrastructure Monitoring Serverless Monitoring Deliver serverless apps with confidence by rapidly identifying when something goes wrong and quickly pinpointing the problem‚Äîwithout wading through millions of invocation logs. Auto-instrument monitoring and observability to your serverless functions without requiring code changes. And auto-instrument tracing for your legacy application components alongside the performance of modern serverless components‚Äîfrom backend infrastructure to client-side apps. Learn more about Serverless Monitoring Digital Experience Monitoring Combine RUM, synthetic, and native app monitoring to proactively ensure uptime and performance across services, URLs, APIs, and third party resources on web and mobile. Benchmark and improve end-user experience for every deployment and code change. End-to-end visibility of latency and errors makes it easy to troubleshoot customer-impacting issues faster, and user-centric perceived performance metrics help you optimize page loads. Capabilities include: Browser Monitoring Mobile Monitoring Synthetics Monitoring Logs in Context On top of complete Log Management provided in Telemetry Data Platform, Full-Stack Monitoring provides Logs in Context. Logs are automatically correlated with curated content for errors, traces, and spans ensuring the deepest and fastest root-cause analysis. Learn more about Log Management Learn more about configuring Logs in Context Experience Full-Stack Observability Full-Stack Observability lets you easily visualize and troubleshoot your entire software stack in one connected experience.¬† Learn more about Full-Stack Observability. Free access to New Relic. Forever. Monitoring your stack should never include host-based guessing games or hidden costs‚Äîjust simple pricing with no surprises. Sign up now Customers trust New Relic. Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International Êó•Êú¨Ë™û Fran√ßais Deutsch ÌïúÍµ≠Ïñ¥ Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ¬©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 628.0421,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Full Stack Observability | <em>New</em> <em>Relic</em>",
        "sections": "Free access to <em>New</em> <em>Relic</em>. Forever.",
        "body": "Skip to main content <em>New</em> <em>Relic</em> logo Search Submit Products Products <em>New</em> <em>Relic</em> <em>One</em> <em>Platform</em> Overview Telemetry Data <em>Platform</em> Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open"
      },
      "id": "5f22638664441f8d032a48d9"
    },
    {
      "category_2": "Workloads",
      "nodeid": 39081,
      "sections": [
        "Use New Relic One",
        "Get started",
        "Core concepts",
        "UI and data",
        "Workloads",
        "Build on New Relic One",
        "Use workloads",
        "Create a workload",
        "Use the API",
        "For more help"
      ],
      "title": "Use workloads",
      "category_0": "New Relic One",
      "type": "docs",
      "category_1": "Use New Relic One",
      "external_id": "ceb8cc0a7f379f735e0a0fee73f4456837868f91",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/Disrupted_workload_with_breakdown.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads",
      "published_at": "2021-02-23T08:10:40Z",
      "updated_at": "2021-02-23T08:10:39Z",
      "breadcrumb": "Contents / New Relic One / Use New Relic One / Workloads",
      "document_type": "page",
      "popularity": 1,
      "info": "In New Relic, use workloads to group together entities that make up a specific business service, making it easier to isolate and troubleshoot issues.",
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. A Workload looks like this: Important components in the New Relic One workload UI. The screenshot numbers are important parts of the workload UI we'd like to describe to you: The Overview tab shows the most relevant entity performance and alert data that you need to operate the workload. View of workload components. This is useful for understanding the workload‚Äôs architecture, especially if the workload‚Äôs entities change over time because they are dynamically defined. Important charts. These are charts with key metrics for each entity type, such as number of requests, response time and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level. Workload status. You can configure the status to inform about how your workload is performing, based on the individual alerting status of the entities in your workload. Open violations. You can filter the workload to only the alerting entities to make it easier to troubleshoot the most important issues. Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. The Entities tab shows the entities that make up the workload. If you‚Äôve used queries to dynamically select entities, the workload entities will change over time. Edit workload. Edit the workload to define the entities that are part of the workload and to link dashboards to the workload. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's GUID and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Apps > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload‚Äôs dashboard: From a workload‚Äôs Overview page, select a dashboard. Add search terms to filter the dashboard to a view that‚Äôs relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 624.44885,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use <em>New</em> <em>Relic</em> <em>One</em>",
        "info": "In <em>New</em> <em>Relic</em>, use workloads to group together entities that make up a specific business service, making it easier to isolate <em>and</em> troubleshoot issues.",
        "category_0": "<em>New</em> <em>Relic</em> <em>One</em>",
        "category_1": "Use <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "To view workloads, go to <em>one</em>.newrelic.com and find them on the Explorer. A Workload looks like this: Important <em>components</em> in the <em>New</em> <em>Relic</em> <em>One</em> workload <em>UI</em>. The screenshot numbers are important parts of the workload <em>UI</em> we&#x27;d like to describe to you: The Overview tab shows the most relevant entity",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> <em>One</em> &#x2F; Use <em>New</em> <em>Relic</em> <em>One</em> &#x2F; Workloads"
      },
      "id": "5f246157196a67553f94f5cd"
    }
  ],
  "/terraform/get-started-terraform": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/terraform/",
      "sections": [
        "New Relic and Terraform",
        "Guides to new relic and terraform",
        "Getting started with New Relic and Terraform",
        "Using Terragrunt configurations",
        "Using Terraform modules",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:55:31Z",
      "title": "New Relic and Terraform",
      "updated_at": "2021-02-25T01:55:31Z",
      "type": "developer",
      "external_id": "a0391aa84ef8cdb8d92329efb62a1a6141f44cac",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Guides to new relic and terraform Getting started with New Relic and Terraform 30 min Learn how to provision New Relic resources using Terraform Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using Terraform modules 30 min Learn how to use Terraform modules in your configurations",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 394.3063,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic and <em>Terraform</em>",
        "sections": "New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Guides to new relic and <em>terraform</em> Getting started with New Relic and <em>Terraform</em> 30 min Learn how to provision New Relic resources using <em>Terraform</em> Using Terragrunt configurations 30 min Learn how to use Terragrunt to manage configurations in multiple environments Using <em>Terraform</em> modules 30 min Learn how to use <em>Terraform</em> modules in your configurations"
      },
      "id": "601df6b928ccbc2507013383"
    },
    {
      "category_2": "Core concepts",
      "nodeid": 39206,
      "sections": [
        "Use New Relic One",
        "Get started",
        "Core concepts",
        "UI and data",
        "Workloads",
        "Build on New Relic One",
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "For more help"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "category_0": "New Relic One",
      "type": "docs",
      "category_1": "Use New Relic One",
      "external_id": "f7287149a67c0f7488ef50f706371ec61d30a498",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/TimeSyntax-Lookout.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance",
      "published_at": "2021-02-23T23:38:24Z",
      "updated_at": "2021-02-23T23:38:24Z",
      "breadcrumb": "Contents / New Relic One / Use New Relic One / Core concepts",
      "document_type": "page",
      "popularity": 1,
      "info": "Lookout is a New Relic One application that provides quick visibility into your entire stack.",
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration ‚Äî you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system‚Äîno configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires a Pro or Enterprise FSO tier. If you are in a standard tier, you can still use the New Relic Lookout view in the Entity Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade your tier. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/Services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In Browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With Errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There‚Äôs also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there‚Äôs an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic‚Äôs error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you‚Äôve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you‚Äôve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you‚Äôve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you‚Äôve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Query: Compare a specific time range to the same range a month ago SINCE ‚Äò2021-03-07 07:00-0500‚Äô UNTIL ‚Äò2021-03-08 07:00-0500‚Äô COMPARE WITH 1 month ago Or: SINCE ‚Äòtoday at midnight‚Äô UNTIL ‚Äònow‚Äô COMPARE WITH 1 MONTH AGO Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 235.4924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Abnormal <em>golden</em> <em>signals</em>",
        "body": " View button on the right side panel. The panel that appears shows you all the entity-specific <em>golden</em> <em>signals</em> you can toggle between out of the box. By choosing the Browser <em>Golden</em> <em>Signal</em> or other views, you can change from the default view. Each new view will have the <em>golden</em> <em>signals</em> appropriate"
      },
      "id": "603591f028ccbcae8977d236"
    },
    {
      "image": "https://developer.newrelic.com/static/dev-champion-badge-0d8ad9c2e9bbfb32349ac4939de1151c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Getting started with New Relic and Terraform",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:38:35Z",
      "title": "New Relic Developers",
      "updated_at": "2021-02-06T01:37:36Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Terraform is a popular infrastructure-as-code software tool software tool software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic alerts. In this guide, you learn how to set up New Relic alerts with Terraform. More specifically, you provision an alert policy, four alert conditions, and a notification channel. Get Started with Terraform Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes ¬† Use custom attributes for deeper analysis Show 28 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.75348,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Getting started with New Relic and <em>Terraform</em>",
        "body": " provision an <em>alert</em> policy, four <em>alert</em> conditions, and a <em>notification</em> <em>channel</em>. Get Started with <em>Terraform</em> Get coding Create a free account 5 min Create custom events Define, visualize, and get <em>alerts</em> on the data you want using custom events Start the guide 7 min Add tags to apps Add tags"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "sections": [
        "Using Terraform Modules and Remote Storage",
        "Before you begin",
        "Creating a Terraform Module",
        "Create a Variable",
        "Passing a variable into a module",
        "Adding default values",
        "Pass variable values using module block",
        "Reusing a module",
        "Connecting an existing alert policy",
        "Store a module in Github",
        "Create a new Github repo",
        "Using a module saved on Github",
        "Manage state remotely in Amazon S3",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Using Terraform Modules and Remote Storage",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "9199eee78d8b5a488366c74b6b4e683dd010b51d",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terraform-modules/",
      "published_at": "2021-02-25T01:55:32Z",
      "updated_at": "2021-02-06T01:55:17Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terraform](https://www.terraform.io/) modules in your configurations and store them remotely.",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. In this guide, you learn to use Terraform modules in your New Relic configurations. Specifically, you will create modules, import data, store modules on Github, and manage state remotely Amazon S3. In the video, we review additional steps installing Terraform and set up New Relic alerts. If you need help getting started with Terraform, the Getting started with New Relic and Terraform guide shows how to install Terraform, set up New Relic alerts and a notification channel. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic for your application. Also, install the Terraform CLI. Start by initializing a working directory: bash Copy $ mkdir terraform-config && cd terraform-config To follow the examples in this gude, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 5 Creating a Terraform Module Terraform modules allow you to reuse, share, and store your Terraform configurations using version control like Github. In the next steps, you will move your New Relic configurations into a reusable module. First, in your project root, create a new directory to store your modules named modules: bash Copy $ mkdir modules && cd modules In the modules directory, create a new directory for a new module called HostConditions and create a new file named main.tf: bash Copy $ mkdir HostConditions && cd HostConditions $ touch main.tf Remove the two alert conditions from the root project's main.tf file and copy it to the new main.tf file in the HostModules directory. In the root directory's main.tf file call the new module using a module block: module \"HostConditions\" { source = \"./modules/HostConditions\" } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Initializing modules... $ [output]- HostConditions in $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. $ [output]Error: Unreadable module directory $ [output]Unable to evaluate directory symlink: lstat modules/HostConditions: no such $ [output]file or directory $ [output]Error: Failed to read module directory $ [output]Module directory does not exist or cannot be read. You see an error in your console due to the lack of provider details in your modules directory. To fix the error, create a copy of the root provider.tf in your HostConditions directory : provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-zzzzzz\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Try testing your configurations, run terraform plan and terraform init: bash Copy # Example output ------------------------------------------------------------------------ $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 2, in resource \"newrelic_infra_alert_condition\" $ [output]\"cpuhot\": 2: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. $ [output]Error: Reference to undeclared resource on modules/HostConditions/main.tf line 24, in resource \"newrelic_infra_alert_condition\" $ [output]\"highDiskUsage\": 24: policy_id = newrelic_alert_policy.DemoPolicy.id $ [output]A managed resource \"newrelic_alert_policy\" \"DemoPolicy\" has not been declared $ [output]in module.HostConditions. Terraform init no longer shows an error, but running terraform plan still causes an error to occur. The error is due to the policy id used in the ./modules/HostConditions/provider.tf doesn't exist. A variable is needed to pass into the module. Step 2 of 5 Create a Variable Variables pass details into your module and set default values. First, at the top of your HostConditions provider.tf create a new variable: variable \"providerId\" {} Copy Next, in the resource block, replace the existing policyId with the new variable: var.policy Copy Passing a variable into a module To make a module dynamic, you will pass your variables into the module using the module resource block. In the root directory main.tf, update the module block to add the policyId variable: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id } Copy Run terraform plan after adding your variable to the module. bash Copy $ terraform plan Now, add more variables and replace the values CPU critical, CPU warning, and disk percent. Then, pass the new variables into the module. Add the new variables to HostConditions main.tf: variable cpu_warning {} variable cpu_critical {} variable diskPercent {} Copy Update the alert conditions to use the new variables added in the HostConditons main.tf: resource \"newrelic_infra_alert_condition\" \"cpuhot\" { policy_id = var.policyId name = \"CPU hot!\" type = \"infra_metric\" event = \"SystemSample\" select = \"cpuPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.cpu_critical time_function = \"all\" } warning { duration = 5 value = var.cpu_warning time_function = \"all\" } } resource \"newrelic_infra_alert_condition\" \"highDiskUsage\" { policy_id = var.policyId name = \"high disk usage\" type = \"infra_metric\" event = \"SystemSample\" select = \"diskUsedPercent\" comparison = \"above\" where = \"(hostname LIKE '%myhost%')\" critical { duration = 5 value = var.diskPercent time_function = \"all\" } } Copy Run terraform plan after adding your variables to the module. An error message displays due to the missing variable values. Values can be added in the module block or as default values. bash Copy $ terraform plan Adding default values Add default variable values to HostConditions main.tf: variable cpu_warning { default=80} variable cpu_critical { default=90} variable diskPercent { default=60 } Copy Pass variable values using module block In the root directory main.tf, update the module block to add the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"./modules/HostConditions\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } Copy Run terraform plan after adding your variables to the module. bash Copy $ terraform plan Step 3 of 5 Reusing a module You can reuse your module connecting to a New Relic policy that already exists. Before you start, in your New Relic account, create a new alert policy named Preexisting Policy. Connecting an existing alert policy First, In your root main.tf file add the data block to import an existing policy: data \"newrelic_alert_channel\" \"ExistingPolicy\" { name = \"Preexisting Policy\" } Copy Next, create a second module block name HostConditions2. Add the alert conditions to the Preexisting Policy. module \"HostConditions2\" { source = \"./modules/HostConditions\" policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module and run 'terraform apply' to apply the changes to your New Relic account. The terraform scripts create a new alert policy and two conditions, but it also applies the alert conditions to the Preexisting Policy. Look in your New Relic account at the Preexisting Policy and see alerts conditions added for CPU Hot and High Disk Usage. Step 4 of 5 Store a module in Github After you have created a module, if you want to store the module somewhere other people can use, Github is how you can do it. Create a new Github repo First, inside of your HostModules directory, initialize a new Github repo. Add your module.tf and provider.tf to the stage for commit: bash Copy $ git add module.tf provider.tf $ git commit -m \"init\" Next, using the commands provided in your new repo, push your commit to Github: bash Copy $ git remote add origin <repo_url> $ git branch -M main $ git push -u origin main Using a module saved on Github Check the Github repo and see the main.tf and provider.tf are now in your repo. Copy the GitHub repo's web URL to clone your repo. Update the root main.tf file using GitHub as the source for the HostConditions: module \"HostConditions\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercentage = 66 } module \"HostConditions2\" { source = \"git::https://github.com/<your_username>/<your_repo_name>\" # Add your repo URL policyId = data.newrelic_alert_policy.ExistingPolicy.id cpu_critical = 87 cpu_warning = 77 diskPercentage = 67 } Copy Run terraform init to initialize the new module. When you run terraform init, Terraform clones the repository locally. Run terraform plan If you need to update your local module with updates made to the git repo, run terraform get -update Step 5 of 5 Manage state remotely in Amazon S3 The state file is the representation that terraform holds about the created resources. The state file is in the root directory, but if deleted or corrupted would cause trouble. Storing the state file remote provides security and allows sharing and remote access. In the provider.tf in the root directory, add a terraform backend block for Amazon S3: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" } } Copy Variables are needed to provide the correct S3 bucket details, and access is required. To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Add the profile to the terraform backend block: terraform { backend \"s3\" { bucket = \"<s3_bucket_name>\" key = \"<s3_bucket_key>\" region = \"<s3_bucket_region>\" profile = \"<iam_user_profile_name>\" } } Copy Before saving your state to Amazon S3, destroy the current configurations to start from a clean slate: bash Copy $ terraform destroy Initialize Terraform, run Terraform init: bash Copy $ terraform init In the terminal, the output shows the backend initialized as S3. Delete the local state as it is not needed bash Copy $ rm terraform.* Run terraform apply to apply your Terraform configuration changes. bash Copy $ terraform apply The state file is now stored in S3 instead of locally. Look in your S3 bucket and see the terraform state exists. Conclusion Congratulations! You're using modules to make your terraform configuratiions more flexible. Review the New Relic Terraform provider documentation to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.37299,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Using <em>Terraform</em> Modules and Remote Storage",
        "sections": "Using <em>Terraform</em> Modules and Remote Storage",
        "info": "Learn how to use [<em>Terraform</em>](https:&#x2F;&#x2F;www.terraform.io&#x2F;) modules in your configurations and store them remotely.",
        "tags": "<em>notification</em> <em>channel</em>",
        "body": " to install <em>Terraform</em>, set up New Relic <em>alerts</em> and a <em>notification</em> <em>channel</em>. Before you begin To use this guide, you should have some basic knowledge of both New Relic and <em>Terraform</em>. If you haven&#x27;t deployed a New Relic open source agent yet, install New Relic for your application. Also, install the <em>Terraform</em>"
      },
      "id": "601df70628ccbce8510133b6"
    },
    {
      "sections": [
        "Using Terragrunt to Manage Multiple Environments",
        "Before you begin",
        "Create a new configuration",
        "Tip",
        "Adding to your configuration",
        "Using your Environment as a Terragrunt Variable",
        "Storing the State Remotely",
        "Creating a New Environment",
        "Conclusion",
        "This site uses cookies üç™"
      ],
      "title": "Using Terragrunt to Manage Multiple Environments",
      "type": "developer",
      "tags": [
        "notification channel",
        "alerts",
        "terraform"
      ],
      "external_id": "4bf455aad61b7703def538f147b8954af49c4e15",
      "image": "",
      "url": "https://developer.newrelic.com/terraform/terragrunt-configuration/",
      "published_at": "2021-02-25T01:54:21Z",
      "updated_at": "2021-02-06T01:54:03Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn how to use [Terragrunt](https://www.terraform.io/) to manage configurations in multiple environments",
      "body": "Terraform is a popular infrastructure-as-code software tool built by HashiCorp. You use it to provision all kinds of infrastructure and services, including New Relic dashboards and alerts. Terragrunt is a thin wrapper that provides extra tools for keeping your configurations DRY, working with multiple Terraform modules, and managing remote state. In this guide, you will use Terragrunt to generate your Terraform configurations, create files with Terragrunt, and reuse the Terragrunt configuration to manage multiple environments. Before you begin To use this guide, you should have some basic knowledge of both New Relic and Terraform. If you haven't deployed a New Relic open source agent yet, install New Relic Infrastructure agent for your host. Also, install the Terraform CLI. Start by initializing a working directory: You will also need to install Terragrunt to follow this guide: bash Copy $ brew install terragrunt To follow the examples in this guide, the accompanying example code is available on GitHub bash Copy $ git clone https://github.com/jsbnr/nr-terraform-intro-example.git Step 1 of 6 Create a new configuration Terragrunt is a wrapper that provides extra tooling for your Terraform configurations. In the next steps, you will create a new configuration using Terragrunt, Terraform, and New Relic. Start by initializing a working directory: bash Copy $ mkdir terragrunt-config && cd terragrunt-config In the new directory, create a terragrunt.hcl file, create a ./src directory, and create a ./environments directory: bash Copy $ touch terragrunt.hcl $ mkdir src $ mkdir environments Inside of your environments folder, create a folder named dev. In the ./src directory, create a main.tf and provider.tf files: bash Copy $ mkdir environments/dev $ touch src/main.tf $ touch src/provider.tf In the provider.tf file add the appropriate Terraform and New Relic provider configuration information: terraform { required_version = \"~> 0.14.3\" required_providers { newrelic = { source = \"newrelic/newrelic\" version = \"~> 2.14.0\" } } } Copy In the main.tf add a New Relic alert policy named DemoPolicy: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } Copy In the ./environments/dev directory create a new file named terragrunt.hcl bash Copy $ cd ./environments/dev/ $ touch terragrunt.hcl Within the dev folder update the terragrunt.hcl file by adding the following include statement. The include statement tells Terragrunt to use any .hcl confgiuration files it finds in parent folders. include { path= find_in_parent_folders() } Copy Next, add a Terraform block to provide Terragrunt with a Terraform source reference. terraform { source = \"../../src\" } Copy Now you need to configure the provider with your New Relic account details. You will need your New Relic user API key and account ID. provider \"newrelic\" { account_id = 12345 # Your New Relic account ID api_key = \"NRAK-***\" # Your New Relic user key region = \"US\" # US or EU (defaults to US) } Copy Tip If you have a single account: The account ID is displayed on the API keys page. If your organization has multiple accounts: From one.newrelic.com, select Entity explorer and use the account selector dropdown near the top of the page. Tip Documentation about the New Relic provider is provided on the Terraform doc site. Update the provider.tf file to define the New Relic account variables that will help keep the Terraform configuration dynamic. variable \"newrelic_personal_apikey\" {} variable \"newrelic_account_id\" {} variable \"newrelic_region\" {} provider \"newrelic\" { account_id = var.newrelic_account_id api_key = var.newrelic_personal_apikey region = var.newrelic_region } Copy In your terminal, change directories to the environments/dev folder and run the command terragrunt init: bash Copy $ terragrunt init Terraform init sets up a bit of context, sets up environment variables, and then runs terraform init. You will see the following output: bash Copy # Example output ------------------------------------------------------------------------ Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run \"terraform init\" in the future. Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. [terragrunt] [/Users/jsius/Sites/deco/terragrunt-config/environments/dev] 2021/02/02 13:30:31 Copying lock file [output] from /Users/jsius/Sites/deco/terragrunt-config/environments/dev/.terragrunt-cache/e-PoBgWhdv3v8QGOtDQxS_WeYu4/ 69zjIFUfApJiUt8gFmi-6-dcPe8/.terraform.lock.hcl to /Users/jsius/Sites/deco/terragrunt-config/environments/dev Run terragrunt plan: bash Copy $ terragrunt plan Terragrunt starts to run but pauses to ask for the inputs to the New Relic account variables added to the provider.tf file. bash Copy # Example output ------------------------------------------------------------------------ 2/02 13:32:08 Running command: terraform plan var.newrelic_account_id Enter a value: Interrupt received. Exit the terragrunt plan process with CTRL+C . In the environments/dev/terragrunt.hcl file, add an inputs block to provide the values for your New Relic account variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy The updated terragrunt.hcl only has the include, terraform, and inputs block include { path = find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Now, when you run terragrunt plan, Terragrunt will provide the input block's values, no longer prompting the command line for values. bash Copy # Example output ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.DemoPolicy will be created + resource \"newrelic_alert_policy\" \"DemoPolicy\" { + account_id = (known after apply) + id = (known after apply) + incident_preference = \"PER_POLICY\" + name = \"My Demo Policy\" } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if \"terraform apply\" is subsequently run. Run terragrunt apply. After Terraform finishes process, check your New Relic account for the new Demo Policy. Step 2 of 6 Adding to your configuration Now that you have a basic New Relic configuration created, add configurations built in the Getting Started with Terraform and Terraform modules guides in this step. Tip If you haven't done the previous developer guides, you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional terraform configurations. Update the email address in the alert channel to your preferred email address: resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { policy_id = newrelic_alert_policy.DemoPolicy.id channel_ids = [ newrelic_alert_channel.DemoChannel.id ] } module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = 88 cpu_warning = 78 diskPercent = 68 } Copy You have added a New Relic alert channel, subscribed the demo policy to the alert channel, and added a module hosted on Github. To clone the module from GitHub, run terragrunt init and then run terragrunt apply. After Terraform is done processing, You will see your Demo Policy now has two conditions in your New Relic account and one alert channel attached. Step 3 of 6 Using your Environment as a Terragrunt Variable Using Terragrunt, you can add the name of the environment you are running to the name of the data you are creating, making your resource more identifiable in New Relic. In the root terragrunt.hcl file, create a new input for env_name inputs = { env_name = \"develop\" } Copy in the main.tf file add a new variable for 'env_name' variable \"env_name\" {} Copy Using string interpolation, add the new env_name variable to the alert policy and alert channel resource blocks. resource \"newrelic_alert_policy\" \"DemoPolicy\" { name = \"${var.env_name}: My Demo Policy\" } resource \"newrelic_alert_channel\" \"DemoChannel\" { name = \"${env_name}: My Demo Channel\" type = \"email\" config { recipients = \"your@email_address.com\" include_json_attachment = \"1\" } } Copy Run terragrunt plan to see the environment variable added to the configuration name. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"develop: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Currently, the environment variable name is hardcoded into the root terragrunt.hcl file. You want to avoid having your variables hardcoded, using a terragrunt built-in function will pass the value. In the root terragrunt.hcl file, update the input to use the path_relative_to_include() built-in function and pass the value has the env_name variable: inputs = { env_name = path_relative_to_include() } Copy Run terragrunt plan. Looking at the output, the env_name variable will have the entire ./environments/dev/ path. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"environments/dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Next, update the terragrunt.hcl to only include 'dev' as the env_name variable. Adding a locals block creates a local variable, using the replace built-in function will remove the unwanted parts of the relative path, and update the inputs block to use the local variable. locals { env_name = replace(path_relative_to_include(), \"environments/\", \"\") } inputs = { env_name = local.env_name } Copy Run terragrunt plan. Looking at the output the env_name variable will now have 'dev:' added. Run terragrunt apply to update your configurations. bash Copy # Example output ------------------------------------------------------------------------ # newrelic_alert_policy.DemoPolicy will be updated in-place ~ resource \"newrelic_alert_policy\" \"DemoPolicy\" { id = \"1216533\" ~ name = \"My Demo Policy\" -> \"dev: My Demo Policy\" # (2 unchanged attributes hidden) } # newrelic_alert_policy_channel.ChannelSubs must be replaced -/+ resource \"newrelic_alert_policy_channel\" \"ChannelSubs\" { ~ channel_ids = [ - 4737437, ] -> (known after apply) # forces replacement ~ id = \"1216533:4737437\" -> (known after apply) # (1 unchanged attribute hidden) } Plan: 2 to add, 1 to change, 2 to destroy. Step 4 of 6 Storing the State Remotely At the moment, the state file is local. The next steps will update your Terraform configurations to remove the local state file and use a file stored remotely in Amazon S3. Tip Since Terragrunt allows you to configure multiple environments, various state files will need to be store in separate S3 buckets, not to override each other. Terragrunt allows you to generate files on the fly. Adding the remote_state block into the root level terragrunt.hcl file, you will generate a new file named backend.tf. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"my-terraform-state\" key = \"${path_relative_to_include()}/terraform.tfstate\" region = \"us-east-1\" encrypt = true } } Copy After adding the remote_state block, you will need to give the configuration for the S3 bucket that will store the Terraform state. Tip To give access to the S3 bucket in your Amazon account, create an IAM user. Give the IAM user access to the S3 bucket storing the terraform state. Now, update the remote_state block to provide your S3 bucket and update the key to use the local environment variable created previously. remote_state { backend = \"s3\" generate = { path = \"backend.tf\" if_exists = \"overwrite_terragrunt\" } config = { bucket = \"YOUR_S3_BUCKET_NAME\" # Amazon S3 bucket required key = \"envs/${local.env_name}/terraform.tfstate\" region = \"us-east-1\" encrypt = true profile = \"YOUR_PROFILE_NAME\" # Profile name required } } Copy Next, run terragrunt plan. If you look in the Amazon S3 bucket, you will see a folder named envs. Within the envs folder is a directory called devs containing terraform.tfstate file. Tip To see the files created by Terragrunt, look inside of the ./environments/dev directory. There is a hidden directory named terragrunt-cache. Within the terragrunt-cache directory, you will see the backend.tf file that Terragrunt generated. Step 5 of 6 Creating a New Environment Now that you have a working configuration for your dev environment, you will create a new environment reusing the dev configurations in the next steps. In the environments directory, create a new folder names nonprod. In the nonprod folder, create a new terragrunt.hcl file: bash Copy $ mkdir nonprod && cd nonprod $ touch terragrunt.hcl In the nonprod terragrunt.hcl file copy over the configuration from the environment terragrunt.hcl: include { path= find_in_parent_folders() } terraform { source = \"../../src\" } inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) } Copy Tip If you are using a different account for your nonprod environment, you can update the inputs with a new New Relic account ID and API key. Inside of your nonprod directory, run terragrunt init then run terragrunt apply. In the output, you will see Terraform has created a new set of resources. The new resources should have the nonprod name prefixed. Step 6 of 6 Terragrunt has created two environments, but there is no difference between them other than the name. Adding variables in the configurations allows your configurations to be more dynamic. In the next steps, you will add variables to your configurations. In the main.tf add new variables for the Host Conditions modules cpu_critical, cpu_warning, and diskPercentage values: variable \"cpu_critical\" {default = 89} variable \"cpu_warningl\" {default = 79} variable \"diskPercentage\" {default = 69} Copy In the main.tf update the HostConditions module values to use the cpu_critical, cpu_warning, and diskPercentage variables: module \"HostConditions\" { source = \"git::https://github.com/jsbnr/demo-terraform.git\" policyId = newrelic_alert_policy.DemoPolicy.id cpu_critical = var.cpu_critical cpu_warning = var.cpu_warninig diskPercent = var.dskPercentage } Copy Run terragrunt plan. In the output, the HostConditions values have changed to use the variable defaults. Next, you want to pass the values into your environment configurations by adding the inputs block variables. In the nonprod/terragrunt.hcl file, add the cpu_critical, cpu_warning, and diskPercentage variables: inputs = { newrelic_personal_apikey = \"NRAK-***\" # Your New Relic account ID newrelic_account_id = \"12345\" # Your New Relic account ID newrelic_region = \"US\" # US or EU (defaults to US) cpu_critical = 50 cpu_warninig = 40 diskPercentage = 98 } Copy Run terragrunt apply. In your New Relic account, you will see a new policy with configurations changed based on the environment. Conclusion Congratulations! You've used Terragrunt to generate your New Relic configurations and manage multiple environments. Review the Terragrunt Intro Example, New Relic Terraform provider documentation, and Terragrunt quick start to learn how you can take your configuration to the next level.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.88654,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>notification</em> <em>channel</em>",
        "body": ", you can copy the configurations for this section from the Terragrunt Intro Github Repo. Update the main.tf to include the additional <em>terraform</em> configurations. Update the email address in the <em>alert</em> <em>channel</em> to your preferred email address: resource &quot;newrelic_<em>alert</em>_policy&quot; &quot;DemoPolicy&quot; { name = &quot;My"
      },
      "id": "601df6bb196a67eb59da2d81"
    }
  ],
  "/components/charts": [
    {
      "sections": [
        "Intro to New Relic One SDK",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs",
        "This site uses cookies üç™"
      ],
      "title": "Intro to New Relic One SDK",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One SDK",
      "body": "To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.14394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "category_2": "Measure DevOps success",
      "nodeid": 34966,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Cloud adoption",
        "Optimize your cloud native environment",
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs",
        "For more help"
      ],
      "title": "Automate instrumentation",
      "category_0": "Solutions and best practices",
      "type": "docs",
      "category_1": "New Relic solutions",
      "external_id": "91b25e8572d235c7f95963650848fc6ab6cf4b39",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation",
      "published_at": "2021-02-22T23:15:36Z",
      "updated_at": "2020-12-01T22:24:21Z",
      "breadcrumb": "Contents / Solutions and best practices / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "Capture tangible, measurable metrics from before and after deployments to optimize your DevOps team. ",
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors‚Äîand more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.839096,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ", the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "5f5e0c14196a67e25fce6a8a"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL",
        "This site uses cookies üç™"
      ],
      "published_at": "2021-02-25T01:54:22Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-12-04T01:58:15Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using¬†NRQL¬†(New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 61.854965,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic One <em>CLI</em> common commands",
        "sections": "<em>nr1</em> help",
        "info": "An overview of common commands you can use with the New Relic One <em>CLI</em>.",
        "body": " The name of a particular channel. Examples $ <em>nr1</em> update $ <em>nr1</em> update somechannel <em>nr1</em> create Create a new component Creates a new component from our template (either a <em>Nerdpack</em>, Nerdlet, launcher, or catalog). The <em>CLI</em> will walk you through this process. To learn more about Nerdpacks and their <em>file</em> <em>structure</em>"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure",
        "This site uses cookies üç™"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2021-02-25T01:59:19Z",
      "updated_at": "2020-12-04T01:58:15Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ launchers ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ nr1.json ‚îú‚îÄ‚îÄ nerdlets ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-nerdlet ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.js ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nr1.json ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ styles.scss ‚îú‚îÄ‚îÄ node_modules ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ js-tokens ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ loose-envify ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ object-assign ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prop-types ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-dom ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ react-is ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ scheduler ‚îú‚îÄ‚îÄ nr1.json ‚îú‚îÄ‚îÄ package-lock.json ‚îî‚îÄ‚îÄ package.json Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 61.854965,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "sections": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "info": "An overview of the <em>Nerdpack</em> <em>File</em> <em>Structure</em>",
        "tags": "<em>file</em> <em>structure</em>",
        "body": " building guides and the New Relic One <em>CLI</em> command reference. <em>Nerdpack</em> <em>file</em> <em>structure</em> When you generate a <em>Nerdpack</em> template using the <em>nr1</em> create command, it has the following <em>file</em> <em>structure</em>: my-nerdlet ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ launchers ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-nerdlet-launcher ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icon.png ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ <em>nr1</em>.json"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "category_2": "Get started",
      "nodeid": 2481,
      "sections": [
        "Welcome to New Relic",
        "Get started",
        "New Relic University",
        "Glossary",
        "For more help"
      ],
      "title": "Glossary",
      "category_0": "Using New Relic",
      "type": "docs",
      "category_1": "Welcome to New Relic",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/using-new-relic/welcome-new-relic/get-started/glossary",
      "external_id": "b6199b4bb822a19cf31503ffe077d8a13b3632b8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/glossary",
      "published_at": "2021-02-22T21:38:49Z",
      "updated_at": "2020-12-05T21:35:35Z",
      "breadcrumb": "Contents / Using New Relic / Welcome to New Relic / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "This glossary defines common New Relic terminology, and provides links to relevant content to help better understand each subject.",
      "body": "A glossary of common terminology you may encounter. account dropdown When you're logged into New Relic, the account dropdown menu displays your login name and is located at the top right of the UI. Clicking this gives you access to various account-related abilities. administrator A type of user role on a New Relic account. For more information, see Users. agent At New Relic, an agent is a piece of monitoring software that provides integrations with various technologies (for example, web frameworks, host operating systems, or database types). The agents send that data to New Relic, usually on a specific cadence. For more information, see: New Relic integrations Install agents agent API Some New Relic agents have agent APIs that allow you to extend the functionality of an agent. You can use the API to control, customize and extend the functionality of the agent. Here are some agent API docs: APM agents: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Ruby agent API Python agent API Browser agent: Browser agent API Mobile agents: iOS SDK API Android SDK API aggregated metrics Aggregated metric data summarizes calls to specific methods in your application, including how many times each one was called and response times. In the New Relic UI, you see the class and method names along with their aggregate numbers. Metric data aggregation depends on the New Relic tool and your subscription level. For more information, see the documentation about data retention. aggregation function You can use NRQL query function, such as sum(), average(), or latest() to choose how the data points in an aggregation window should be processed into a single data point. The single aggregated data point is what's passed through the alert evaluation process. aggregation window Streaming alerts gathers data together into specific amounts of time. These windows of time are customizable. Data points are collected together based their timestamps and reported as a batch. The customizable aggregation window provides greater flexibility and fewer false violations when alerting on irregular or less frequent data points. alert An alert communicates an event or incident that designated personnel can track through Alerts. For an explanation of how basic alerts concepts are related, see Concepts and workflow. alert condition An alert condition (or condition), identified by its unique numeric condition_id, contains the criteria for creating a violation. The condition includes the threshold that is set for a metric timeslice or a custom metric over time on a chosen target. For an explanation of how a condition relates to other basic alerts concepts, see Concepts and workflow. alert evaluation Streaming data is assessed on a set of aggregation windows to determine if an alert condition is violating or recovering. The aggregation window time is how long we'll collect data before running the NRQL query condition. The offset evaluation time is how long you want us to wait for late data before assessing it. If a window doesn't have any data points, it's treated as a gap for loss of signal. alert policy A collection of one or more conditions, one or more notification channels, and an Incident preference setting. If a condition contained within the policy opens a violation, an incident may be opened depending on the Incident preference setting. Notifications will then be sent to all channels attached to the policy. For an explanation of how a policy relates to other basic alerts concepts, see Concepts and workflow. apdex Apdex is an industry-standard way to measure users' satisfaction with the response time of an application or service. New Relic rates each response as Satisfied, Tolerated, or Frustrated, and uses these ratings to calculate an overall user satisfaction score. For more information, see Apdex: Measure user satisfaction. apdex_f The response time above which a transaction are rated frustrating. Defaults to four times apdex_t. Requests that complete in less than apdex_t are rated satisfied. Requests that take longer than apdex_t, but less than four times apdex_t (apdex_f), are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. apdex_t The response time above which a transaction is considered tolerable. The default value is 0.5 seconds, but you can change this in your Apdex settings. Requests that complete in less than apdex_t are rated satisfied. Requests that take more than apdex_t, but less than apdex_f, are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. API (application programming interface) New Relic offers a variety of APIs and SDKs. For more information, see the introduction to New Relic's APIs. APM New Relic's APM (application performance monitoring) provides monitoring of your web or non-web application's performance. APM supports apps using several programming languages. application For New Relic purposes, any program instrumented by New Relic. application ID Some New Relic solutions assign a monitored application a unique application ID, often shortened to app ID. When present, this ID is available in the UI. It is also reported as an attribute and can be queried. For how to determine this, see Find app ID. application name The name that New Relic combines with your license key to uniquely identify a particular app. For more information, see Name your application. Applied Intelligence (AI) Applied Intelligence (AI) helps you find, troubleshoot, and resolve problems more quickly. Specifically, it‚Äôs a hybrid machine learning engine that reduces alert noise, correlates incidents, and automatically detects anomalies. Applied Intelligence includes Alerts, Incident Intelligence, and Proactive Detection. attribute Attributes are key-value pairs attached to data objects reported to New Relic. Attributes add detail, and they're similar to tags or labels in other SaaS software. You can explore this data by querying or searching via the UI or by using the data dictionary. Examples: APM reports a Transaction event. This includes timing data for the transaction in a duration attribute, which might have a value of .002. Our Infrastructure Monitoring reports a ProcessSample event. This includes a variety of CPU usage attributes, including a cpuSystemPercent attribute, which might have a value of .01. Our Telemetry SDK reports a Metric data type for storing metrics, with attached attributes like metricName and newrelic.source. Some New Relic tools allow you to report custom attributes to enhance your monitoring. For more information about attributes in APM, see Agent attributes. availability monitoring See Types of Synthetics monitors. browser The New Relic UI supports most browsers. For more information, see Supported browsers. For our end-user browser monitoring tool, see Browser Monitoring. Browser monitoring A Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. background external See web external. cloud-based integration New Relic offers cloud-based integrations with providers such as Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform. collector The component that collects data from New Relic agents running on an app server, mobile device, or end-user browser. While the agent is installed on a user's app server, the collectors are centrally located in New Relic's data center. In order to contact the collector, the agent must be able to reach New Relic's domains and IP addresses. (The exact domain or IP depends on the New Relic monitoring tool.) The collector receives and interprets this data, and stores it in a database. The data is then retrieved and presented in the New Relic UI and by our various REST APIs. Command line interface (CLI) Our command line interface (CLI) is a tool you can use to build a New Relic application. This is the same tool our own engineers use. Go here for quick start instructions. Go to our Developer site for sample apps and guides. compute unit (CU) A unit of measurement that determines your pricing for some New Relic products governed by our original product-based pricing plan. For more information, see Compute unit pricing. condition_id See alert condition. CPM (calls per minute) The number of calls your application receives each minute. This usually corresponds to the number of page views or external connections, and is usually the same as RPM (requests per minute). CPU burn The time consumed by code minus the wait time for a transaction. This is the time actually spent processing the transaction. It appears in the New Relic UI at the top of the transaction view for the agents that provide it (Ruby and PHP only). custom attribute A key-value pair added to a transaction or event in order to gain additional information about it. For more information, see custom attributes. custom dashboard A customizable dashboard with charts and tables that includes data from multiple New Relic data sources. For more information, see dashboards. custom event An event, in New Relic terms, is a data object with attached attributes. New Relic reports default event types, like Transaction and TransactionError. You can also create your own events. Events can be queried, and are used in some other features. You can generate custom events with APM agents, with the Browser agent, with the Mobile agent, and via the Event API. Alternatively, you can add custom attributes to some existing default New Relic events. custom instrumentation Custom instrumentation allows you to extend New Relic's monitoring to instrument code elements New Relic doesn't automatically instrument. Custom instrumentation is useful when your framework is not supported by New Relic, or when New Relic fails to pick up some element of your program. You can also use custom instrumentation to block a transaction from being reported entirely. For more information, see Custom instrumentation. custom metric Metric timeslice data that is manually recorded via an API call. Custom metrics allow you to record arbitrary metrics; for example, timing or computer resource data. All custom metric names must be prefixed with Custom/. For more information, see Custom metrics. Not to be confused with custom instrumentation data. data collector See collector. data explorer Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. For more on using the data explorer, see Introduction to the data explorer. degradation period When a data source enters a violating state, a degradation period of time begins. The degradation period is set in the condition's threshold. A violation will open if the source stays in a violating state for the entire degradation period. In addition: If the data source enters a non-violating state before the entire time has elapsed, the degradation period countdown is reset, and a violation does not open. If your alert condition threshold is configured as at least once in, the degradation period always lasts a single minute. dimensional metric A dimensional metric is a metric that has multiple attributes, also known as dimensions. At New Relic, we report dimensional metrics using the Metric data type. For more on other metric data types, see Metric data. Docker An open platform for distributed applications, which allows you to assemble multi-container portable apps. Infrastructure Monitoring includes integrated Docker monitoring. For more information about Docker, see the Docker website. downtime The period of time when customers cannot access your site and your app is not reporting to New Relic. For more information, see Synthetic Monitoring and Types of synthetic monitors. entity In New Relic, an entity is anything we can identify that has data you can monitor. An entity can be something you monitor directly, like applications and microservices, or indirectly, like data centers. You can identify one or more entities to be targets for alert conditions. In the Alerts API, the entity being monitored is identified with an entity_id. For more on this, see What are entities? event The word event is a general term that can have many meanings. At New Relic, event can have several meanings: At New Relic, event data is one of our core data types. Event data represents a record of a single event at a particular moment in time. Events can vary by type (for example, Transaction or Mobile, and will have associated attributes (for example, timestamp or transactionName). For more details, see Event data. For our infrastructure monitoring, the word event can be used to refer to important system and host activity. For example, a configuration change for a monitored host would be registered on Infrastructure's Events UI page. For alerts, the Events UI page displays a list of alerts-related incidents for your monitored entities. Events are reported for a violation opening and for closing. In some contexts, event can refer to any NRQL-queryable data type. For example, when you run a NRQL query, you will see a count of inspected events: this refers to a count of all data types queried. expected error An expected error is a common error that you don't want to affect your Apdex score or error rate. For more information, see Manage errors in APM. exporter At New Relic, an exporter is a type of integration that reports telemetry data to New Relic from a third-party (non-New Relic) telemetry tool. For examples, see Exporters, or search our integrations. Flex New Relic Flex is an application-agnostic, all-in-one integration. With it, you can build your own integration that collects metric data from a wide variety of services, and that can instrument any app that exposes metrics over a standard protocol (HTTP, file, shell) in a standard format (for example, JSON or plain text) to the terminal. It's a recommended way to create a custom integration, because it doesn't require coding skills. framework A framework is a structured collection of pre-defined functions, into which an application builder inserts their own code to build their application. A framework is not the same as a library. While a library is a collection of functions you can call as needed, a framework is a skeleton for your application. The functions in that framework then call your functions. For more about the distinction between a framework and a library, see What is the difference between a framework and a library?. New Relic automatically instruments many common frameworks. For more about the frameworks New Relic supports, see the agent-specific documentation: C SDK supported frameworks Go supported frameworks Java supported frameworks .NET supported frameworks Node.js supported frameworks PHP supported frameworks Python supported frameworks Ruby supported frameworks Full-Stack Observability The collection of features and tools you can use to easily analyze and troubleshoot problems across your entire software stack. For more information, read our Introduction to Full-Stack Observability. harvest cycle The period of time between each connection from a New Relic agent to the collector. Between harvest cycles, an agent collects and caches data. At the end of the cycle an agent reports those data to the collector, then begins a new harvest cycle. health status indicator Some New Relic UI pages have a health status indicator appearing next to an index of monitored entities. This is a colored bar (generally green, yellow, red, or gray) indicating the status of your app or other entity monitored by New Relic. It also indicates whether the entity has any alert policies assigned to it and whether there are any policy violations. In general, the colored bar will be green, yellow, red, or gray to indicate the health status. Exceptions: Our REST API (v2) uses orange instead of yellow for the application's health and reporting status. Service maps use different criteria for reporting the health of a connection between an app and an external service not monitored by New Relic (for example, a third party API). host At New Relic, a host means one of the following: A physical machine is a hardware-based device with dedicated physical resources, including memory, processing, and storage. Each machine has its own OS which applications run on. A virtual machine (VM) is the software implementation of a physical machine that executes programs like a physical machine. One or more virtual machines can run on a physical machine. Each virtual machine has its own OS and allocated virtual machine resources such as RAM and CPU. A cloud instance is a type of virtual machine that is run in the public cloud. In this context, virtual machines and cloud instances are different from Java Virtual Machines (JVMs) and containers. host ID Each host identified by APM is assigned a host ID. This ID is used to uniquely identify it, and to retrieve data about that host via the REST API. For more information, see List host ID. ignored error An error that you have told the APM agent not to report to the collector. For more information, see Manage errors in APM. incident An incident is a collection of one or more violations of the conditions defined in an alert policy. An incident record includes all of the open and close time stamps for each violation, as well as chart snapshots of the data being evaluated around the time of each violation. You can view detailed information from the Incidents pages in the user interface. You can also select your preference for how we roll up violations into the incident. For an explanation of how an incident relates to other basic alerts concepts, see Concepts and workflow. Infrastructure Monitoring By connecting changes in host performance to changes in your configuration, Infrastructure Monitoring provides real-time metrics and powerful analytics that reduce your mean-time-to-resolution (MTTR). Infrastructure is specifically designed for complex environments that need flexible, dynamic server monitoring, from a physical datacenter to thousands of Amazon Elastic Compute Cloud (Amazon EC2) instances and other types of integrations. Insights At New Relic, Insights used to be the primary way to query and chart your New Relic-reported data. Now, we have the improved query builder. instance ID Each instance identified by New Relic is assigned a unique instance ID. Instance IDs are most commonly found for JVMs (Java Virtual Machines), but can exist for each agent. This ID is used to uniquely identify it, and to retrieve data about that instance via the REST API. For more information, see List instance IDs. instrumentation The collection of data from an application or host. When New Relic instruments a framework, it detects the methods and calls used by that framework, and intelligently groups them together. integration At New Relic, an integration refers to a solution that integrates with a specific technology (like a web framework or a type of database). See Integrations. interaction In our Mobile Monitoring, an interaction is a specific code path initiated by a user interaction (usually a button press). An interaction is the mobile equivalent of a transaction, and like a transaction an interaction can be traced and monitored. interaction trace An interaction trace is a complete picture of a single interaction. With interaction traces, New Relic gives you much deeper visibility into a single slow interaction, which can help you understand a broader problem. Interaction traces are the mobile equivalent of a transaction trace. For more information, see Creating interactions (iOS) and Creating interactions (Android). inventory data Inventory data is information about the status or configuration of a service or host. Examples of inventory data include: Configuration settings Name of the host the service is on Amazon AWS region Port being used For more information, see Understand and use data. key transaction A web transaction that the user has marked as particularly important; for example, key business events (such as signups or purchase confirmations), or transactions with a high performance impact (such as searches). Key transactions have their own pages in the UI and other customized values. For more information, see Key transactions. launcher A launcher is a specific piece of code you can include when you create a New Relic One app. It creates the tile on the homepage that you click to launch the app. For more information, see the documentation about core UI components. log A log is a message about a system used to understand the activity of the system and to diagnose problems. For more information on how we use log data, see Log management. Log monitoring Our log management and monitoring features give you the tools to collect, process, explore, visualize, and alert on your log data using your existing log forwarder. With all of your log data in one place, you'll be able to make better decisions, detect and resolve problems more quickly, and see your logs in context to troubleshoot faster. Logs Our Logs feature is a scalable log management platform that allows you to connect your log data with the rest of your telemetry data. Pre-built plugins with some of the most common open-source logging tools make it simple to send your data from anywhere to New Relic. Logs in context Logs in context makes it easy to link to your log data with related data across the rest of our platform. Bringing all of this data together in a single tool allows you to quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. master account A master account is a New Relic account that has one or more subordinate accounts (sub-accounts). For details, see Account structure. metric A metric is a numeric measurement. Metric data is a broad category because there are several ways to make and report measurements. For more about how metrics are reported at New Relic, see New Relic data types. metric timeslice New Relic reports metrics in several ways. One variety of metric data is called metric timeslice data; this is the type of data used to generate many of the charts in APM, Mobile Monitoring, and Browser Monitoring (for more details, see metric timeslice data). Over time, metric timeslice data is aggregated into longer timeslice data records for more efficient storage. For more about how we aggregate this type of data, see Data aggregation. For how to query this type of data, see Query metric timeslice data. metric grouping issue A metric grouping issue occurs when an account sends too many differently named metric timeslice data points to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. For more information, see Metric grouping issues. minion The software that accepts monitor jobs from a private location. A minion is a packaged virtual appliance that runs in your hypervisor. For more information, see Private locations overview and install and configure private minions. Mobile Monitoring Mobile Monitoring allows you to monitor and manage the performance of your mobile apps on Android, iOS, tvOS, and other systems. Mobile Monitoring provides end-to-end details, including crashes, throughput, HTTP requests, error traces, and more. Not to be confused with New Relic's own mobile apps for Android, iPhone, and iPad. monitor For our Synthetic Monitoring, a monitor ensures your website or API endpoint is available. For more information, see Adding and editing monitors. NerdGraph NerdGraph is our GraphQL API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. You can use our NerdGraph GraphiQL explorer to explore the schema and find definitions. With valid New Relic API key, you can try it out yourself at https://api.newrelic.com/graphiql. Nerdlet A Nerdlet is a component of a New Relic One application. It's a specific UI view, represented by a React JavaScript package. For more information, see Nerdpack file structure. Nerdpack A Nerdpack is a component of a New Relic One application. It's the package containing all the files needed by that application. For more information, see Nerdpack file structure. New Relic Edge with Infinite Tracing New Relic Edge with Infinite Tracing is a fully managed, distributed tracing service that observes 100% of your application traces, then provides actionable data so you can solve issues faster. For more information, see /docs/understand-dependencies/distributed-tracing/get-started/how-new-relic-distributed-tracing-works. New Relic One For more information, see Introduction to New Relic One. New Relic One catalog Our catalog is a collection of applications built on the New Relic One platform. The catalog includes custom apps we've built, public open source apps, and any apps that you buid. You can browse the catalog on New Relic One. NRQL (New Relic query language) NRQL is a query language, similar in form to SQL, that allows you to query the data stored in your New Relic account. non-web transaction APM identifies transactions as either web or non-web. When New Relic does not detect a transaction was initiated by a web request, this is called a non-web transaction. For more information, see Background processes and other non-web transactions. notification The message sent when an incident opens, is acknowledged, or closes. The type of notification is defined by the alert policy's notification channel. For an explanation of how notifications relate to other basic alerts concepts, see Concepts and workflow. notification channel Where we send a notification when an incident opens, is acknowledged, or closes. Available channels include email, mobile push notifications, webhooks, and more. on-host integration On-host integrations refer to integrations that reside on your own servers or hosts and that communicate with our infrastructure agent. For more information, see Introduction to on-host integrations. owner For accounts on our original pricing plan, this is a type of user role: the user who initially created the account. For more information, see Users. page load timing With page load timing, New Relic monitors the full load time for end-user browsers. New Relic's application agents dynamically inject JavaScript into the page, then capture the following key load points: Navigation start: The user initiates the transaction. First byte: The browser receives the requested page. DOM ready: The browser has finished parsing DOM. Page ready: Page loading is complete. Page load timing is sometimes referred to as RUM, or real user monitoring. Unlike standard RUM, page load timing also captures JavaScript errors and AJAX requests. For more information, see Page load timing process. parameter Deprecated term; see attribute. permalink A unique URL that links to a view of your application at a specific point in time. Permalinks are useful for troubleshooting and for sharing interesting time windows with colleagues. pinger The component of New Relic that connects to your website to verify your website is accessible. New Relic has pingers in Europe, Asia, and the United States. Each pinger attempts to contact your website at least once every two minutes. If enough pingers are unable to reach your website, your application will be considered down. For in-depth scriptable testing, including real browser tests and tests of API endpoints, see Synthetic Monitoring. Synthetic Monitoring includes free ping monitoring, which allows you to monitor your website from locations around the world. For more information, see Types of Synthetic monitors. Plugins Plugins provides an open platform to monitor critical information about your entire stack. New Relic partners, PaAS and SaAS providers, third-party vendors, and plugin users can: Quickly install and use publicly available plugins in Plugin Central. Develop your own plugin agents to collect the metric data that matters most to your business. Publish your plugins for public or private access. polling interval (AWS) Our Amazon integrations query your AWS services according to a polling interval, which varies depending on the integration. Each polling interval occurs for every AWS entity. For example, if you have thirteen Elastic Load Balancers (ELB), each one will be polled every five minutes. Depending on the AWS integration, there may be delays in the timing between the API request and the metric data returned. If you notice unusual delays, follow the integration troubleshooting procedures. PPM (pages per minute) The number of pages per minute your application serves. private location A Synthetic monitor feature that allows you to run Synthetic monitors from within your own systems by creating private minions. Private locations allow you to extend your Synthetic coverage to new geographical locations, and to monitor websites behind your firewall such as an intranet site. For more information, see Private locations overview. recovery period A recovery period of time begins when a data source enters a non-violating state after being in a violating state. The recovery period is set in the condition's threshold. A violation will close when a source remains in a non-violating state and the recovery period time has elapsed. If the data source enters a violating state before the time has elapsed, the recovery period clock will reset and the violation won't close. response time The duration of time between a request for service and a response. For more information, see Response time. restricted user A type of user role on a New Relic account. For more information, see Users. rollup Using the same application name for multiple applications. This allows you to combine data in APM, either from multiple applications, or from multiple instances of an application. For more information, see Rolling up app data. root span For distributed tracing, the root span is the first span in a trace. In many cases, the root span duration will represent the duration of the entire trace, or be very close to it. However, for more complex, modern systems that use a lot of asynchronous, non-blocking processes, this will not be true. For those systems, the root span‚Äôs duration may be significantly less than the duration of the trace. RPM The term RPM usually refers to the number of requests per minute your application receives from users. This is usually the same as CPM (calls per minute). Historically, some New Relic monitoring solutions, like APM and Browser Monitoring, used to contain RPM in the URL; for example, https://rpm.newrelic.com. This language use originally referred to Rails performance management because the first iteration of our product monitored Ruby on Rails applications. We monitor many more languages and systems than Ruby now. RUM (real user monitoring) See page load timing. runbook A runbook contains standard procedures and operations typically used by system administrators, network operations staff, and other personnel to handle outages, alert incidents, and other situations. If your organization stores runbook instructions as URLs, you can link this information to an alerts policy so your personnel has easy access to this information when an incident violates the defined policy thresholds. SAML (Security Assertion Markup Language) SAML is an XML-based data format for sharing authentication data between two parties. New Relic accounts must obtain a SAML certificate in order to enable Single Sign On for their users. For more information, see SAML service providers. Selenium Selenium is an open-source browser testing suite. Synthetics uses Selenium to test monitored websites with real browsers. For more information, see monitor types. service A service is a cluster of runtime server processes that accomplish a particular task, usually service requests. Unlike an application, a service is not usually invoked by a human. New Relic offers a variety of integrations that allow you to report data from your services. signal The stream of telemetry data that's watched and alerted on. You use NRQL queries to define a signal. signal filter When we receive data and it's routed to the streaming alerts platform, your NRQL WHERE clause will filter the data coming in. The filtered streaming data is what's evaluated for loss of signal violations, for example. span In a distributed trace, a span is a \"named, timed operation representing a contiguous segment of work in that trace\" (from OpenTracing.io definition). For distributed tracing, spans are displayed in the distributed tracing UI, and the data type Span is available to be queried. See also root span. SSL certificate SSL certificates encrypt data that is being transmitted. While New Relic refers to security certificates as SSL because it is a more commonly used term, all certificates adhere to industry standards for secure encryption in transit. SSO (single sign on) SSO (single sign on) allows you to manage user authentication in New Relic using an external SSO provider. For more information, see Setting up SSO. streaming algorithm This is what determines when the data in an aggregation window is processed. The streaming algorithm uses your server's clock time and the aggregation window size to trigger the alert evaluation process. sub-accounts See master account. Synthetic monitoring Synthetic monitoring allows you to monitor your website or API endpoint via automated, scriptable tools. Use free ping monitor to ensure your website is accessible, or expand your monitoring with browser monitors, which test your website with real browsers. Go further with scripting, to script browsers or API monitors for sophisticated testing. target A target is a resource or component monitored by a New Relic monitoring tool that has been identified in an alert condition. When the data source for that target crosses the defined critical threshold, we will open a violation. Depending on your policy's Incident preference setting, Alerts may create an incident record and send notifications through the defined channels. See also entity. tag Tags are key:value metadata added to monitored apps, hosts, dashboards, and other entities to help you organize your data at a high level. For details, see Tags. Telemetry Data Platform The collection of features and tools you can use to ingest, visualize, and alert on all your telemetry data in one place. For more information, read the Introduction to the Telemetry Data Platform. thresholds Thresholds are alert condition settings that define a violation. Threshold values include the value a data source must pass to trigger a violation and the time-related settings that define a violation; for example: Passing a certain value for at least x minutes Passing a certain value only once in x minutes While the data source passes a certain value, a degradation period starts. Likewise, when that data source stops passing a certain value, a recovery period starts. The durations of these two time periods are defined in the alert condition threshold settings. Thresholds have a required critical (red) threshold and an optional warning (yellow) threshold. In the UI, the entity's health status indicator will change to yellow or red when a threshold has been crossed and a violation will open. For more information, see Define thresholds. For an explanation of how thresholds relate to other basic Alerts concepts, see Concepts and workflow. throughput Throughput is a measurement of user activity for a monitored application. APM throughput and Browser Monitoring throughput are measured in different ways: APM: requests per minute (RPM) Browser: page views per minute (PPM) tier A tier can refer to how New Relic categorizes or visualizes the various agent language ecosystems that we support. For example: In APM, the color-coded categories that appear on your app's main Overview chart show response time spent in various functions, processes, or agents as tiers; for example, request queuing, garbage collection, Middleware, JVMs, etc. In New Relic labels, TIER can be used to define or classify the client-server architecture; for example, front-end and back-end tiers. Tier may also refer to our pricing tiers. time picker By default the New Relic UI shows data for the past 30 minutes, ending now. To change the time window, use the time picker. time range A time range can refer to a length of time selected in the New Relic UI. New Relic displays a time range depending on the range you select using the time picker. timeslice data See metric timeslice data. trace A trace is a description of how a request travels through a system. Trace data helps you understand the performance of your system and diagnose problems. For more information on how we use trace data, see New Relic data types. traffic light See health status. transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. For more information, see documentation about web transactions and non-web transactions. The term transaction is also sometimes used in Browser Monitoring. In that case, it primarily refers to activity beginning with a browser-side web request and ending with a complete page load. transaction trace A transaction trace is a complete picture of a single transaction, down to the database queries and exact invocation patterns. With transaction traces, New Relic gives you much deeper visibility into a single slow transaction, which can help you understand a broader problem. For more information, see Transaction traces. UI The New Relic user interface. For more information, see Standard page functions. user A user can refer to a specific user role in a New Relic account. For more information, see Users. UTC Universal Time Coordinated (UTC), or Coordinated Universal Time, is a standard timestamp for synchronizing time around the world. value function (metrics) The numeric value obtained from metric timeslice data; for example, an average, minimum, maximum, total, sample size, etc. violation A violation occurs when the entity monitored by an alert condition reports a value that crosses the thresholds defined in that condition. For an explanation of how violations relate to other basic alerts concepts, see Concepts and workflow. You can view a summary of the violations for a selected incident's page. You can also view the violations for a specific entity from the product's UI. web external Web external is the term applied to the portion of time spent in transactions to external applications from within the code of the application you are monitoring. That time can be a call to a third party company (a payment provider, for example) or it could be a call to another microservice within your own company. Web external demonstrates how performance is impacted by your code executing outside the application you are measuring. web transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. Web transactions are initiated with an HTTP request. For most organizations, these represent customer-centric interactions and thus are the most important transactions to monitor. For more information, see Web transactions and Non-web transactions. WebDriverJS WebDriver is a Selenium component, used to control Synthetics scripted browsers. Specifically, Synthetics uses WebDriverJS, a Node.js-based flavor of Selenium. For more information, see Writing scripted browsers and Scripted browser examples. workload A workload represents a group of entities that work together to provide a digital service. For more information, see Workloads. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 25.424732,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " by a React JavaScript package. For more information, see <em>Nerdpack</em> <em>file</em> <em>structure</em>. <em>Nerdpack</em> A <em>Nerdpack</em> is a component of a New Relic One application. It&#x27;s the package containing all the files needed by that application. For more information, see <em>Nerdpack</em> <em>file</em> <em>structure</em>. New Relic Edge with Infinite"
      },
      "id": "5d0314cd4bb81c77f2eedaea"
    }
  ]
}