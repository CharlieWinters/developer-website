{
  "/build-apps/add-time-picker-guide": [
    {
      "image": "https://developer.newrelic.com/static/futurestack-registration-86e612c0605fb3c49cfd28f35977135d.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Futurestack: Master Observability",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2021-04-20T01:36:57Z",
      "title": "New Relic Developers",
      "updated_at": "2021-04-16T01:37:39Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Data Nerds, get ready to hack the future. Level Up your observability game at Futurestack 2021. Rack up your experience points with new tools, new skills, and whole new ways to play with your data through Observability. Connect with Nerds from across the globe to learn, share, and get inspired as we reinvent the future of software — and have lots of fun doing it. Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom attributes for deeper analysis Show 29 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.58954,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add a <em>time</em> <em>picker</em> to your <em>app</em>",
        "body": " emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an <em>app</em> to show page view data on a map Add a <em>time</em> <em>picker</em> to your <em>app</em> 20 min Add a <em>time</em> <em>picker</em> to a sample application Add custom attributes   Use custom"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "sections": [
        "Android app UI",
        "Pages",
        "Time range",
        "New Relic Synthetics",
        "Alerts",
        "Mobile apps",
        "For more help"
      ],
      "title": "Android app UI",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic Mobile apps",
        "Android app"
      ],
      "external_id": "8918a5a2454491a91421c55e26501a0e3f64cd3a",
      "image": "https://docs.newrelic.com/static/fc97ade0bbdbdef58b89495a0d91b734/edd00/deployment-markers_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/android-app-ui/",
      "published_at": "2021-04-16T21:29:14Z",
      "updated_at": "2021-03-13T01:23:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The UI for the New Relic Android app provides functionality similar to the standard user interface, with customized details for mobile users. Pages To view details of your New Relic apps, hosts, Synthetics monitors, Alerts, plugins, and key transactions, select a product from the main menu. The New Relic Android app includes: New Relic APM metrics, both real-time and historical data, including health maps. And, select the transaction icon for detailed transaction metrics, or an Overview Charts to view summary charts of your top five transactions. New Relic Infrastructure utilization. New Relic Plugins, including a list of their components or instances, and their charts and current values from the plugin's Summary. New Relic Mobile, including crash reports, network errors, API calls, and active user count. Select the filter icon to filter by labels and categories. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. Note: New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the time picker icon in the top right of the page (the 7D in the screenshot). This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth in the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). New Relic Synthetics You can use the Android app to view your New Relic Synthetics data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen and can be viewed by tapping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile apps If you have a mobile application and have installed New Relic Mobile, you can monitor its performance directly from your Android device. New Relic Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. For more help Additional documentation resources include: New Relic Android app (compatibility, requirements, installation) Android authentication (procedures to add or remove users, and for the users to authenticate with their Android device)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.86156,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Android <em>app</em> UI",
        "sections": "Android <em>app</em> UI",
        "tags": "Mobile <em>apps</em>",
        "body": " <em>picker</em> to choose a <em>time</em> range that ends now (from 30 minutes to 90 days ago). New Relic Synthetics You can use the Android <em>app</em> to view your New Relic Synthetics data, including charts of your monitor&#x27;s availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can"
      },
      "id": "6044181d28ccbc9a522c60a5"
    },
    {
      "sections": [
        "Introduction to iOS mobile app",
        "Features",
        "Time range",
        "New Relic Synthetics",
        "Alerts",
        "Mobile monitoring",
        "Data privacy"
      ],
      "title": "Introduction to iOS mobile app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic Mobile apps",
        "iOS app"
      ],
      "external_id": "371077582a50dfd2a1e7c57cfbbf9eeaf8013e1c",
      "image": "https://docs.newrelic.com/static/630c7a9a486540073ab96a2c9926e303/442cb/device-ios-synthetics-view-monitor.png",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/ios-app/introduction-ios-mobile-app/",
      "published_at": "2021-04-16T21:31:25Z",
      "updated_at": "2021-03-13T03:15:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's iPhone and iPad app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. The New Relic iOS apps show near real-time information about your apps, hosts, and more. Features New Relic's iOS app includes these New Relic products and features: New Relic's iOS app for iPhone and iPad includes these New Relic products and features: New Relic APM (iPhone and iPad). Includes real-time and historical data. Select the icon to see transaction details. Select Overview Charts to view summary charts of your top five transactions. New Relic Browser (iPhone and iPad). Provide overview dashboard, including average page load time, Browser Apdex, average throughput, and more. New Relic Infrastructure (iPhone only). New Relic Alerts (iPhone and iPad). Get alert and deployment notifications. New Relic Synthetics (iPhone only). New Relic Browser (iPhone and iPad). New Relic Mobile (iPhone and iPad). Includes crash reports, network errors, API calls, and active user count. New Relic Plugins (iPhone and iPad). New Relic's iOS app does not have all the features of the New Relic web application. For more detailed analysis, sign in to your New Relic account with a web browser. Time range When viewing an application or host, you can change the visible time frame by using the clock icon in the top right of the page. This feature is similar to the standard New Relic time picker. Features include: Scrub the New Relic charts to move back and forth across the timeline. Select the time picker to choose a time range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end time other than now, slide the toggle from Ending Now to Custom Date. New Relic Synthetics You can use the iOS app to view your New Relic Synthetics data, including charts of your monitor's availability, load times, and load sizes. Select the caret icon to view more detailed charts. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you connect the iOS app to your New Relic account, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For iOS alerts, notifications appear on your lock screen and can be viewed by swiping the alert. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile monitoring If you have a mobile application and have installed New Relic Mobile, you can monitor its performance directly from your iPhone or iPad. New Relic Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Data privacy To make troubleshooting easier, New Relic's mobile apps only record the following information about you: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.18624,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to iOS mobile <em>app</em>",
        "sections": "Introduction to iOS mobile <em>app</em>",
        "tags": "Mobile <em>apps</em>",
        "body": " Relic charts to move back and forth across the timeline. Select the <em>time</em> <em>picker</em> to choose a <em>time</em> range that ends now (from 30 minutes to 90 days ago). For iPads: to specify an end <em>time</em> other than now, slide the toggle from Ending Now to Custom Date. New Relic Synthetics You can use the iOS <em>app</em>"
      },
      "id": "6044161628ccbc96b62c6092"
    },
    {
      "sections": [
        "Introduction to New Relic Android app",
        "Requirements",
        "Install New Relic's mobile app",
        "View New Relic data",
        "New Relic product details",
        "New Relic Synthetics data",
        "Alerts",
        "Mobile app monitoring",
        "Details on setting time range",
        "Data privacy"
      ],
      "title": "Introduction to New Relic Android app",
      "type": "docs",
      "tags": [
        "Mobile apps",
        "New Relic Mobile apps",
        "Android app"
      ],
      "external_id": "ff8415c00363a49eaa062f4b0b13c795b4717ea5",
      "image": "https://docs.newrelic.com/static/ea914fce17844b32fdabefd60efc457e/e5166/navigation_nexus.jpg",
      "url": "https://docs.newrelic.com/docs/mobile-apps/new-relic-mobile-apps/android-app/introduction-new-relic-android-app/",
      "published_at": "2021-04-16T21:29:43Z",
      "updated_at": "2021-03-13T01:06:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The user interface for New Relic's Android app provides functionality similar to New Relic's standard user interface, with customized details for mobile users. Requirements Requirements include: Android 4.0 (Ice Cream Sandwich) or higher Screen size of 7 inches or less Install New Relic's mobile app You can install the New Relic Android app from the Google Play Store or learn more from the New Relic website. Follow standard procedures to install any Android app, then sign in with your New Relic user name (account email) and password if applicable. Depending on your New Relic account, additional installation or user authentication steps may be required. View New Relic data To view details of your apps monitored by New Relic, select a product from the app's main menu. See below for details on how to use specific features of the app: New Relic product details The New Relic Android app includes data about these features: New Relic APM metrics, both real-time and historical data, including health maps. Select the transaction icon to see detailed transaction metrics, or an Overview chart to view summary charts of your top five transactions. Select the icon to filter by labels and categories. New Relic Browser overview metrics, including average page load time, Browser Apdex, average throughput, and more. New Relic Infrastructure utilization. New Relic Plugins, including a list of their components or instances, and their charts and current values from the plugin's Summary. New Relic Mobile, including crash reports, network errors, API calls, and active user count. Event notifications, including mobile alerts wherever you are, plus deployment notifications and notes. New Relic's Android app does not have the full feature set of the New Relic web interface. For more detailed analysis, sign in to your New Relic account with a web browser. New Relic Synthetics data You can use the Android app to view your New Relic Synthetics data, including charts of your monitor's availability, load times, and load sizes. To view more detailed charts, select the caret icon. You can mute or disable your monitor, and view details of any recent errors. For scripted monitors, you can view and search the script log. Alerts When you log in to your New Relic account from the Android app, your device is automatically associated with your user channel. Then, you can add your user channel to your target policy to receive alerts. For Android alerts, notifications appear on your lock screen. To view them, tap the alert event. You can select any alert to view error details or acknowledge the alert. New Relic also sends a push notification when a colleague acknowledges an open event. Then, New Relic sends a final, closing notification when all Critical events end. Mobile app monitoring If you have a mobile application and have installed New Relic Mobile, you can monitor its performance directly from your Android device. New Relic Mobile monitoring includes network errors, API calls, and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Details on setting time range When viewing an application or host, you can change the visible time frame with the time picker. To move back and forth across the timeline, scrub the New Relic charts. To change the duration of the visible time slice, select the clock icon. To specify an end time other than now, slide the toggle from Ending Now to Custom Date. To save your changes and refresh the chart data, select the clock icon again. Data privacy To make troubleshooting easier, New Relic's mobile apps only record the following information about you: User's email address associated with your New Relic account, including first and last name (for authentication purposes only) IP address Device ID For more information, see our Mobile data privacy and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.84598,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic Android <em>app</em>",
        "sections": "Introduction to New Relic Android <em>app</em>",
        "tags": "Mobile <em>apps</em>",
        "body": ", and number of active users. You can also view detailed individual crash reports for a deeper understanding of a particular crash incident. Details on setting <em>time</em> range When viewing an application or host, you can change the visible <em>time</em> frame with the <em>time</em> <em>picker</em>. To move back and forth across"
      },
      "id": "604415e0196a67ff23960f46"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/mobile-apps-release-notes/new-relic-ios-release-notes/new-relic-ios-3550/",
      "sections": [
        "Mobile app for iOS v3.55.0",
        "Improvements",
        "Bug fixes"
      ],
      "published_at": "2021-04-17T04:38:53Z",
      "title": "Mobile app for iOS v3.55.0",
      "updated_at": "2021-03-16T18:57:24Z",
      "type": "docs",
      "external_id": "0dce0d058dcda297f29d114ebf1d12736bfb3900",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "Improvements Improved time picker with custom start and end time selection Added time picker to Dashboards Bug fixes Fixed a crash that sometimes occurred in the new Dashboards Fixed a crash that sometimes occurred on the iPad Fixed a crash that occurred sometimes on error charts with no data",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.10476,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Mobile <em>app</em> for iOS v3.55.0",
        "sections": "Mobile <em>app</em> for iOS v3.55.0",
        "body": "Improvements Improved <em>time</em> <em>picker</em> with custom start and end <em>time</em> selection Added <em>time</em> <em>picker</em> to Dashboards Bug fixes Fixed a crash that sometimes occurred in the new Dashboards Fixed a crash that sometimes occurred on the iPad Fixed a crash that occurred sometimes on error charts with no data"
      },
      "id": "603e928ce7b9d261282a07c4"
    }
  ],
  "/automate-workflows/5-mins-tag-resources": [
    {
      "image": "https://developer.newrelic.com/static/futurestack-registration-86e612c0605fb3c49cfd28f35977135d.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Futurestack: Master Observability",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2021-04-20T01:36:57Z",
      "title": "New Relic Developers",
      "updated_at": "2021-04-16T01:37:39Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Data Nerds, get ready to hack the future. Level Up your observability game at Futurestack 2021. Rack up your experience points with new tools, new skills, and whole new ways to play with your data through Observability. Connect with Nerds from across the globe to learn, share, and get inspired as we reinvent the future of software — and have lots of fun doing it. Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom attributes for deeper analysis Show 29 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.60773,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/32r7lf1gmda1w/promo-image.1608575562.png",
      "url": "https://learn.newrelic.com/go-deeper-advanced-alerting-nrql-alerts",
      "sections": [
        "Delve deeper into Alerts and move beyond the basics to implement an effective alerting strategy in this FREE 2 hour workshop. With scenario based labs, you’ll create specific policies and conditions for typical use cases, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance s",
        "About this workshop",
        "Go Deeper: Advanced Alerting & NRQL Alerts"
      ],
      "published_at": "2021-04-20T01:39:15Z",
      "title": "[Webinar] Go Deeper: Advanced Alerting & NRQL Alerts",
      "updated_at": "2021-04-20T01:39:15Z",
      "type": "",
      "external_id": "a44bc2bed49a8b258b97a438df3e7a0bbcf7095a",
      "popularity": 1,
      "body": "Sign In [Webinar] Go Deeper: Advanced Alerting & NRQL Alerts Delve deeper into Alerts and move beyond the basics to implement an effective alerting strategy in this FREE 2 hour workshop. With scenario based labs, you’ll create specific policies and conditions for typical use cases, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios. Register | FREE Already registered? Sign In About this workshop You’ve mastered Alerting Fundamentals and want to know more about alerting? Join this highly practical and engaging session where we delve deeper into how to move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you, and get routed effectively to relevant teams or tools.   With scenario based labs, you’ll create specific policies and conditions for typical use cases across the full stack, use tags to dynamically target entities, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.  The format of this session will include best practices, challenge based labs and activities, and takeaways you can immediately apply to your accounts, or your requirements.  Agenda and Labs Effective Alerting strategies  SLO’s, SLA’s and Thresholds Use Cases and labs:  Alerting on SLA’s Alerting on variable performance -Dynamic Baseline Alerting Using tags to dynamically target Entities NRQL Alerts; Outlier detection, and other use cases Lab: Alert on Multiple issues (Static),  Lab: Alert on Synthetic performance (Dynamic),  Lab: Alert on Outlier behaviour (Outlier - Facets) Notifying the right team: Channels, Test Channels and Webhooks  Lab: Webhook Challenge Alerts and Dashboarding  Lab: Charting alerts Managing Alerts and Conditions REST API and Muting Rules Go Deeper: Advanced Alerting & NRQL Alerts Event Date Spaces left Go Deeper: Advanced Alerting & NRQL Alerts April 22, 2021, 10 a.m. - April 22, 2021, noon BST 125 Go Deeper: Advanced Alerting & NRQL Alerts April 27, 2021, 10 a.m. - April 27, 2021, noon PDT 125 Go Deeper: Advanced Alerting & NRQL Alerts May 27, 2021, 10 a.m. - May 27, 2021, noon BST 150 Go Deeper: Advanced Alerting & NRQL Alerts May 27, 2021, 10 a.m. - May 27, 2021, noon PDT 149 Go Deeper: Advanced Alerting & NRQL Alerts June 24, 2021, 10 a.m. - June 24, 2021, noon BST 149 Go Deeper: Advanced Alerting & NRQL Alerts June 29, 2021, 10 a.m. - June 29, 2021, noon PDT 150 About this workshop You’ve mastered Alerting Fundamentals and want to know more about alerting? Join this highly practical and engaging session where we delve deeper into how to move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you, and get routed effectively to relevant teams or tools.   With scenario based labs, you’ll create specific policies and conditions for typical use cases across the full stack, use tags to dynamically target entities, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.  The format of this session will include best practices, challenge based labs and activities, and takeaways you can immediately apply to your accounts, or your requirements.  Agenda and Labs Effective Alerting strategies  SLO’s, SLA’s and Thresholds Use Cases and labs:  Alerting on SLA’s Alerting on variable performance -Dynamic Baseline Alerting Using tags to dynamically target Entities NRQL Alerts; Outlier detection, and other use cases Lab: Alert on Multiple issues (Static),  Lab: Alert on Synthetic performance (Dynamic),  Lab: Alert on Outlier behaviour (Outlier - Facets) Notifying the right team: Channels, Test Channels and Webhooks  Lab: Webhook Challenge Alerts and Dashboarding  Lab: Charting alerts Managing Alerts and Conditions REST API and Muting Rules Live events Go Deeper: Advanced Alerting & NRQL Alerts Event Date Spaces left Go Deeper: Advanced Alerting & NRQL Alerts April 22, 2021, 10 a.m. - April 22, 2021, noon BST 125 Go Deeper: Advanced Alerting & NRQL Alerts April 27, 2021, 10 a.m. - April 27, 2021, noon PDT 125 Go Deeper: Advanced Alerting & NRQL Alerts May 27, 2021, 10 a.m. - May 27, 2021, noon BST 150 Go Deeper: Advanced Alerting & NRQL Alerts May 27, 2021, 10 a.m. - May 27, 2021, noon PDT 149 Go Deeper: Advanced Alerting & NRQL Alerts June 24, 2021, 10 a.m. - June 24, 2021, noon BST 149 Go Deeper: Advanced Alerting & NRQL Alerts June 29, 2021, 10 a.m. - June 29, 2021, noon PDT 150 © 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.62684,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " stack, use <em>tags</em> to dynamically target entities, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.  The format of this session will include best practices, challenge based labs and activities, and takeaways you can immediately apply to your accounts, or your"
      },
      "id": "600789b728ccbc0c0a3f6fa8"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/adilson-somensari.jpg?h=2a479378&itok=1PmRmD7k",
      "url": "https://newrelic.com/blog/how-to-relic/new-relic-cli-ibm",
      "sections": [
        "Manage New Relic tasks and resources from the CLI",
        "Example use case 1: Create a Synthetics monitor",
        "Example use case 2: Daily backup of a Synthetics monitor",
        "A great addition for your New Relic toolbox"
      ],
      "published_at": "2021-04-16T04:25:42Z",
      "title": "Automate Your New Relic Tasks With the New Relic CLI From IBM",
      "updated_at": "2021-04-14T02:03:44Z",
      "type": "",
      "external_id": "84956b18d97b9ff7e418a703ede61342a4d315f5",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Automate Your New Relic Tasks With the New Relic CLI From IBM Nov 16, 2018 • 5 min read By Adilson Somensari Editor’s note: The New Relic CLI tool was developed by IBM. It is open sourced under the Apache License 2.0. Helping our customers go faster with confidence is a key tenet of the New Relic ethos. We provide visibility into vital data, statistics, and key performance indicators (KPIs) to help teams increase their deployment speed and cadence. But modern software teams also see automation and continuous integration and continuous delivery (CI/CD) processes as must-haves to support their Agile practices and DevOps teams. Teams want to apply the same automation concepts and tools to operate New Relic as they do other parts of their pipeline. However, writing all the standard boilerplate code to work with New Relic’s REST API (read configuration files, connect to endpoints, send payloads, receive responses, and parse them) can be a toilsome burden and a needless distraction. Fortunately, the IBM Cloud Monitoring team, a New Relic partner, noticed that multiple internal teams were spending too much time managing boilerplate code to automate their New Relic workflows, so they created a solution to solve that problem—a New Relic CLI (command line interface) tool. Manage New Relic tasks and resources from the CLI New Relic CLI, open sourced and available on GitHub from IBM, is a command line tool you can use to manage New Relic resources, such as New Relic Synthetics monitors, New Relic Alerts policies and conditions, and user accounts. You can also use the CLI to backup your New Relic configuration data and restore it as needed. Currently, you can use the New Relic CLI to manage these resources: New Relic resource Management action New Relic Synthetics Create, edit, and delete Synthetics monitors #rowspan# Back up and restore Synthetics monitors New Relic Alerts Create, edit, and delete alert conditions #rowspan# Create, edit, and delete alert policies #rowspan# Create, edit, and delete notification channels #rowspan# Back up and restore alert policies and conditions New Relic Insights dashboards Get dashboards #rowspan# Back up and restore dashboards Users List users Example use case 1: Create a Synthetics monitor This example shows you how to use the New Relic CLI to create a Synthetics monitor: Set the New Relic admin API key (NEW_RELIC_APIKEY) for your environment. This will vary depending on your operating system, but in Linux, you’d use the export command:Export NEW_RELIC_APIKEY=xxxx-xxxxxxx-xxxxx-xxxxxx Tip: Refer to the New Relic docs for instructions on locating your admin API key. Create a basic definition of the monitor in JSON format (for example test.json). { \"name\": \"Test monitorURI\", \"type\": \"SIMPLE\" \"frequency\": 5, \"uri\": \"monitorURI\", \"locations\": [ \"AWS_AP_SOUTH_1\", \"AWS_EU_WEST_3\", \"AWS_US_WEST_1\" ], \"status\": \"ENABLED\", \"slaThreshold\": 3, \"options\": { } Tip: See the documentation for a full list of public minion locations. Run a text substitution to replace the monitorURI with the actual URL you want to test, and generate a new file (in this example, result.json). .awk '{gsub(/monitorURI/,\"<URL TO BE TESTED>\")}1' test.json > result.json To create the new monitor, run ./nr-cli create monitor -f result.json. From this point, you can start working with the new monitor as needed. Example use case 2: Daily backup of a Synthetics monitor You can also use the NewRelic CLI to create daily backups of your Synthetics monitors. Using a simple shell script and a cron job, you can quickly set up a process to back up all your monitors in a safe repository. These four steps describe how to use the New Relic CLI to set up a daily backup job that will back up all monitors into a separate folder every day: Download the shell scripts file for backup monitors (backup_monitors.sh) from the New Relic CLI repo. Add a proper path to the script, and set it as an executable: $ chmod a+x backup_monitors.sh. Create a new cron job in your OS to schedule the shell script you just created. Use crontab -e to add new schedule job. 0 0 */1 * * <YOUR NEW_RELIC_APIKEY=\"xxx-xxxx-xxx>\" /<your_path>/backup-monitors.sh NOTE: Replace xxx-xxxx-xxx with your own NewRelic admin API key. (Optional) If you don't want to set the NR API key in your cron job’s configuration, you can set the key inbackup_monitors.sh. Comment out the Export NEW_RELIC_APIKEY=\"xxx-xxxx-xxx\" entry, replace the value with your API key. The cron job should now run and back up on your monitors based on the schedule you created. A great addition for your New Relic toolbox The New Relic CLI also lets you easily save New Relic settings to source-control tools like Github or BitBucket; and share central configuration and settings across multiple teams and projects. For example, if your target machine can’t connect to New Relic directly, you can configure the CLI tool to use a proxy. You can also configure retries to cope with timeouts. The CLI also includes return codes, which can be very useful for CI/CD automation. For more details on developing for the New Relic CLI, see the repo on Github. By Adilson Somensari Adilson Somensari is a senior solutions architect on the New Relic Expert Services team. An experienced APM professional, with multiple certifications in the APM industry, he has a passion for helping customers succeed with modern monitoring architectures. Adilson started his career as a Java developer, delivering distributed applications to a diverse set of industries (Auto, Banking, Telecom, Transportation) in multiple countries (United States, Canada, Portugal, Brazil), and pivoted to APM after learning that there is more to life than reading logs and stack traces. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.79684,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Automate Your <em>New</em> <em>Relic</em> Tasks With the <em>New</em> <em>Relic</em> <em>CLI</em> From IBM",
        "sections": "Manage <em>New</em> <em>Relic</em> tasks and resources from the <em>CLI</em>",
        "body": " navigation menu, 4 items How to <em>Relic</em> Best Practices Nerd Life Nerdlog Search the blog Submit How to <em>Relic</em> Automate Your <em>New</em> <em>Relic</em> Tasks With the <em>New</em> <em>Relic</em> <em>CLI</em> From IBM Nov 16, 2018 • 5 min read By Adilson Somensari Editor’s note: The <em>New</em> <em>Relic</em> <em>CLI</em> tool was developed by IBM. It is open sourced under"
      },
      "id": "60764d8028ccbca8f951c14e"
    },
    {
      "sections": [
        "newrelic_get_browser_timing_header (PHP agent API)",
        "Syntax",
        "Description",
        "Tip",
        "Parameters",
        "Return values",
        "Examples",
        "Instrument a webpage",
        "For more help"
      ],
      "title": "newrelic_get_browser_timing_header (PHP agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "PHP agent API"
      ],
      "external_id": "949a5fff6610beee2a4d4f1d7bbe3286e7438903",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_get_browser_timing_header/",
      "published_at": "2021-04-16T06:57:40Z",
      "updated_at": "2021-04-16T06:57:40Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic_get_browser_timing_header([bool $include_tags]) Copy Returns a browser monitoring snippet to inject in the head of your HTML output. Description Returns a JavaScript string to inject in the <head> of your HTML output. Use this call with newrelic_get_browser_timing_footer to manually add browser monitoring to a webpage. If possible, New Relic recommends instead enabling browser monitoring via the New Relic UI or copy/pasting the JavaScript snippet. For instructions on using these options, see browser monitoring and PHP. Tip Compare newrelic_disable_autorum, which disables the browser script on a page. Parameters Parameter Description $include_tags data type Optional. Defaults to true. If true or omitted, the JavaScript string is enclosed in a <script> element for easy inclusion into the page's HTML. Return values Returns the browser agent's JavaScript header string. Examples Instrument a webpage function example(){ if (extension_loaded('newrelic')) { // Ensure PHP agent is available $newrelic_header = newrelic_get_browser_timing_header(); } ... // Output to page if (extension_loaded('newrelic')) { // Ensure PHP agent is available $newrelic_footer = newrelic_get_browser_timing_footer(); } } Copy For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 67.347305,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>newrelic_get_browser_timing_header</em> (PHP agent API)",
        "sections": "<em>newrelic_get_browser_timing_header</em> (PHP agent API)",
        "body": " add browser monitoring to a webpage. If possible, <em>New</em> <em>Relic</em> recommends instead enabling browser monitoring via the <em>New</em> <em>Relic</em> UI or copy&#x2F;pasting the JavaScript snippet. For instructions on using these options, see browser monitoring and PHP. Tip Compare newrelic_disable_autorum, which disables"
      },
      "id": "603e9fbbe7b9d27bb52a080b"
    },
    {
      "sections": [
        "newrelic_get_browser_timing_footer (PHP agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Return values",
        "Examples",
        "Instrument a webpage",
        "For more help"
      ],
      "title": "newrelic_get_browser_timing_footer (PHP agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "PHP agent API"
      ],
      "external_id": "0eadf6444b46c63ed8cf96527e1f210cd854fec9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_get_browser_timing_footer/",
      "published_at": "2021-04-16T06:57:41Z",
      "updated_at": "2021-04-16T06:57:40Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic_get_browser_timing_footer([bool $include_tags]) Copy Returns a browser monitoring snippet to inject at the end of the HTML output. Requirements Compatible with all agent versions. Description Returns a JavaScript string to inject at the very end of the HTML output. Use this call with newrelic_get_browser_timing_header() to manually add browser monitoring to a webpage. If possible, New Relic recommends instead enabling browser monitoring via the New Relic UI or copy/pasting the JavaScript snippet. For instructions on using these options, see Browser monitoring and the PHP agent. Tip Compare newrelic_disable_autorum(), which disables the browser monitoring script on a page. Parameters Parameter Description $include_tags boolean Optional. Defaults to true. If true or omitted, the string is enclosed in a <script> element for easy inclusion in the page's HTML. Return values Returns the browser monitoring JavaScript footer string. Examples Instrument a webpage function example(){ if (extension_loaded('newrelic')) { // Ensure PHP agent is available $newrelic_header = newrelic_get_browser_timing_header(); } ... // Output to page if (extension_loaded('newrelic')) { // Ensure PHP agent is available $newrelic_footer = newrelic_get_browser_timing_footer(); } } Copy For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 67.347305,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>newrelic_get_browser_timing_footer</em> (PHP agent API)",
        "sections": "<em>newrelic_get_browser_timing_footer</em> (PHP agent API)",
        "body": " with newrelic_get_browser_timing_header() to manually add browser monitoring to a webpage. If possible, <em>New</em> <em>Relic</em> recommends instead enabling browser monitoring via the <em>New</em> <em>Relic</em> UI or copy&#x2F;pasting the JavaScript snippet. For instructions on using these options, see Browser monitoring and the PHP agent"
      },
      "id": "603eb61928ccbcb895eba792"
    }
  ],
  "/terms": [
    {
      "image": "https://newrelic.com/sites/default/files/2021-01/og_futurestack.png",
      "url": "https://newrelic.com/futurestack/terms-and-conditions",
      "sections": [
        "FutureStack Terms and Conditions",
        "Last Updated: 19 February 2021",
        "These terms and conditions (these “Terms”) govern your registration for and participation at any New Relic event (the “Event”) and are an agreement between New Relic, Inc. (\"New Relic,\" \"we,\" \"us,\" or \"our\") and you. You represent to us that you are authorized to enter into these Terms. Please see S",
        "1. Event.",
        "2. Safety and Security.",
        "3. Your Information.",
        "4. Recordings and Your Materials.",
        "5. Cancellation.",
        "7. Assumption of Risk.",
        "8. Release of Claims.",
        "9. Limitations of Liability.",
        "10. Miscellaneous.",
        "11. Definitions."
      ],
      "published_at": "2021-04-18T01:43:54Z",
      "title": "FutureStack Terms and Conditions | New Relic",
      "updated_at": "2021-04-18T01:43:54Z",
      "type": "",
      "external_id": "0f91346e25bff2b83590413be6303b1606eb5ad4",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone Nerd Island #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Nerd Island Register Main navigation menu, 1 item FutureStack Terms and Conditions FutureStack 2021 Registration Giveaway Terms and Conditions   Last Updated: 19 February 2021 These terms and conditions (these “Terms”) govern your registration for and participation at any New Relic event (the “Event”) and are an agreement between New Relic, Inc. (\"New Relic,\" \"we,\" \"us,\" or \"our\") and you. You represent to us that you are authorized to enter into these Terms. Please see Section 12 for definitions of certain capitalized terms used in these Terms. 1. Event. You may only register for and attend the Event in accordance with these Terms. To register for the Event, you must complete the Event registration process. Unless the Event’s registration webpage specifies otherwise or we expressly inform you otherwise, you must be at least 18 years of age on the first day of the Event. Event registration is subject to availability and may close earlier than the posted deadline, as determined in our sole discretion. We may also change the Event program at any time at our sole discretion. You will at all times comply with the New Relic Event Code of Conduct.  2. Safety and Security. Your safety and security is important to us. You understand that you and your property may be subject to a reasonable search upon entry to the Event. If you refuse to participate in these security measures, you may be denied  entry. We also reserve the right to ask you to leave the Event if your behavior causes us concern for the safety or security of Event attendees.  3. Your Information. 3.1 Generally. We handle your information in accordance with our General Data Privacy Notice. 3.2 Sharing with Event Sponsors. We may provide your contact information to Event Sponsors if (a) you elect to attend any sessions or other activities at the Event involving Event Sponsors (in which case we would provide your contact information only to the Event Sponsor involved in such session or other activity,) or (b) you opt in during registration or otherwise to receive communications from our Event Sponsors. If your contact information is provided to our Event Sponsors, it will be handled by that Event Sponsor in accordance with their privacy notice and you may notify that Event Sponsor if you wish to manage your communication preferences. 3.3 Voice and Image. By participating in the Event experiences, you agree that we may derive information from recordings of your voice and images of your face and retain and use all resulting information, in each case in accordance with the New Relic General Data Privacy Notice. 4. Recordings and Your Materials. You grant us, our affiliates, and our independent contractors the right to record, film, photograph, and capture your voice and image in any media at the Event (the “Recordings”). You grant to New Relic and its affiliates, agents, employees, and assigns an irrevocable, nonexclusive, perpetual, worldwide, royalty-free right and license to use, reproduce, modify, distribute, and translate, for any purpose relating to our business, all or any part of the Recordings and Your Materials.  We may edit the Recordings and Your Materials, use them alone or together with other information, and allow others to use and disseminate them. To the maximum extent permitted by law, you waive any moral rights you may have in the Recordings and Your Materials.  You represent and warrant that (a) Your Materials are true and accurate to the best of your knowledge, (b) you have the necessary rights and permissions to grant the license in this Section 4, and (c) Your Materials do not violate or infringe any copyright, trademark, or other proprietary rights of any person or entity.  5. Cancellation. 5.1 We may cancel the Event at any time for reasons including, for example, availability or suitability of venue or speakers or on security, health, or safety grounds, and we may deny, limit, or cancel your Event registration at any time. We are not responsible for any damages, direct or indirect, resulting from such cancellation.  5.2  Effect of Cancellation. If you or New Relic cancel your registration for the Event or New Relic cancels the Event, Section 3, Section 4, Section 5.2, Section 6.2, Section 7, Section 8, Section 9, Section 10, and Section 11 will remain in full force and effect.  6. Trade Compliance and Ethics. 6.1 You represent and warrant that you are not subject to sanctions or otherwise designated on any list of prohibited or restricted parties, or owned or controlled by such a party, including but not limited to the lists maintained by the United Nations Security Council, the U.S. government (e.g., the U.S. Department of Treasury’s Specially Designated Nationals list and Foreign Sanctions Evaders list and the U.S. Department of Commerce’s Entity List), the European Union or its member states, or other applicable government authority. 6.2 You certify that you have confirmed with an appropriate ethics official and/ or you have reviewed your company’s policies and are satisfied that there are no federal, state, local, or institutional ethics or procurement laws, regulations, or rules that restrict or prohibit your attendance at the Event or would otherwise create a conflict of interest for New Relic. 7. Assumption of Risk. You acknowledge and agree that your attendance and participation in the Event is voluntary, and you understand the nature of the Event. To the maximum extent permitted by law, you agree that you solely assume the risks associated with attending and participating in the Event. 8. Release of Claims. To the maximum extent permitted by law, you (for yourself, your heirs, dependents, personal representatives, assigns, and anyone else who might make a claim on your behalf or as a result of your death or injury) hereby release New Relic and its affiliates, and their respective directors, officers, employees, contractors, representatives, agents, successors, and assigns, from any and all claims, demands, causes of action, suits, damages, losses, debts, liabilities, costs and expenses (including without limitation reasonable attorneys’ fees and costs) that you may have now or in the future associated in any way with the Event, the Recordings, or Your Materials. 9. Limitations of Liability. WE AND OUR AFFILIATES AND LICENSORS WILL NOT BE LIABLE TO YOU UNDER ANY CAUSE OF ACTION OR THEORY OF LIABILITY, EVEN IF A PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, FOR (A) INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, OR EXEMPLARY DAMAGES, OR (B) LOST PROFITS, REVENUES, CUSTOMERS, OPPORTUNITIES, OR GOODWILL. IN ANY CASE, OUR AND OUR AFFILIATES’ AND LICENSORS’ AGGREGATE LIABILITY UNDER THESE TERMS WILL NOT EXCEED USD $100. THE LIMITATIONS IN THIS SECTION 9 APPLY ONLY TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW. 10. Miscellaneous. 10.1 Waiver. The failure by us to enforce any provision of these Terms will not constitute a present or future waiver of such provision nor limit our right to enforce such provision at a later time. All waivers by us must be in writing to be effective. 10.2 Severability. If any portion of these Terms is held to be invalid or unenforceable, the remaining portions of these Terms will remain in full force and effect. Any invalid or unenforceable portions will be interpreted to effect and intent of the original portion. If such construction is not possible, the invalid or unenforceable portion will be severed from these Terms, but the rest will remain in full force and effect. 10.3 Force Majeure. We and our affiliates will not be liable for any delay or failure to perform any obligation under these Terms where the delay or failure results from any cause beyond our reasonable control, including acts of God, global or local epidemics, pandemics or other circumstances that would render the holding of the Event hazardous, unsuitable or unsafe, labor disputes or other industrial disturbances, electrical or power outages, utilities or other telecommunication failures, earthquake, storms, or other elements of nature, blockages, embargoes, riots, acts or orders of government, acts of terrorism, or war. 10.4 Assignment. No Third Party Beneficiaries. You will not assign or otherwise transfer these Terms or any of your rights and obligations under these Terms, without our prior written consent. Any assignment or transfer in violation of this section will be void. We may assign these Terms without your consent (a) in connection with a merger, acquisition, or sale of all or substantially all of our assets or (b) to any affiliate or as part of a corporate reorganization; and effective upon such assignment, the assignee is deemed substituted for New Relic  as a party to these Terms, and New Relic  is fully released from all of its obligations and duties to perform under these Terms. Subject to the foregoing, these Terms will be binding upon and inure to the benefit of the parties and their respective permitted successors and assigns. These Terms do not create any third-party beneficiary rights in any individual or entity that is not a party to these Terms. 10.5 Governing Law. The laws of the State of California, without reference to conflict of law rules, govern these Terms and any dispute of any sort that might arise between the parties. The United Nations Convention for the International Sale of Goods does not apply to these Terms. 10.6 Modifications to these Terms. We may modify these Terms at any time by posting a revised version on the New Relic FutureStack  Site. The modified terms will become effective upon posting. By attending the Event after the effective date of any modifications to these Terms, you agree to be bound by the modified terms. It is your responsibility to check the Site regularly for modifications to these Terms. We last modified these Terms on the date listed at the beginning of these Terms. 10.7 Entire Agreement; English Language. These Terms are the entire agreement between you and us regarding the subject matter of these Terms. These Terms supersede all prior or contemporaneous representations, understandings, agreements, or communications between you and us, whether written or verbal, regarding the subject matter of these Terms. We will not be bound by, and specifically object to, any term, condition, or other provision that is different from or in addition to the provisions of these Terms (whether or not it would materially alter these Terms). If we provide a translation of the English version of these Terms, the English version of these Terms will control if there is any conflict. 11. Definitions. “New Relic Code of Conduct\" means the New Relic code of conduct located at https://newrelic.com/futurestack/code-of-conduct (and any successor or related site designated by us), as may be updated from time to time.    \"New Relic General Data Privacy Notice” means the privacy notice located at https://newrelic.com/termsandconditions/privacy (and any successor or related site designated by us), as may be updated from time to time. “Event Sponsor” means a third-party sponsor of the Event. \"Your Materials\" means all materials submitted (including, for example, your name and biographical information) or presented by you (in electronic copy or hard copy, verbally, or otherwise).   Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 470.81085,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "FutureStack <em>Terms</em> <em>and</em> <em>Conditions</em> | New Relic",
        "sections": "FutureStack <em>Terms</em> <em>and</em> <em>Conditions</em>",
        "body": "Skip to main content #futurestack Agenda Speakers Dev Zone Nerd Island #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Nerd Island Register Main navigation menu, 1 item FutureStack <em>Terms</em> and <em>Conditions</em> FutureStack 2021 Registration Giveaway <em>Terms</em> and <em>Conditions</em>"
      },
      "id": "6042c9ac28ccbc0f572c60ce"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/og_image/public/2021-03/OG_futurestack.png?h=2240b8e9&itok=0hjut0k7",
      "url": "https://newrelic.com/futurestack",
      "sections": [
        "FutureStack 2021",
        "Register Now to Win Big",
        "Master Observability. Level Up Your Game.",
        "What’s next for Observability:OPEN. BUILD. RUN.",
        "OPEN standards to drive game-changing innovation.",
        "BUILD beyond monitoring to empower next-generation engineers",
        "RUN production environments that dramatically reduce MTTRs",
        "Data Nerds, get ready to hack the future",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-20T01:38:27Z",
      "title": "FutureStack | New Relic",
      "updated_at": "2021-04-17T01:40:07Z",
      "type": "",
      "external_id": "050e730cc61f8ae8d1ed88c6505dde5a804a1835",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone Nerd Island #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Nerd Island Register Main navigation menu, 1 item FutureStack 2021 Virtually Everywhere Online | May 25 - 27, 2021 Register Register Now to Win Big We're leveling up FutureStack registration with swag, only until 4/30. Be one of the first 1,500 to register to qualify. Terms and conditions apply. Register Now Master Observability. Level Up Your Game. Get ready to rack up your experience points with new tools, new skills, and whole new ways to play with your data through Observability. What’s next for Observability: OPEN. BUILD. RUN. Join us to look beyond just production to plan, build, and run more perfect software. OPEN standards to drive game-changing innovation. Pixie—the new Kubernetes native-in-cluster observability platform AWS and New Relic Partnership BUILD beyond monitoring to empower next-generation engineers New Relic Student and New Startup New Relic Innovators RUN production environments that dramatically reduce MTTRs New Relic Explorer Logs in Context Data Nerds, get ready to hack the future Level Up your observability game at FutureStack 2021. Connect with Nerds from across the globe to learn, share, and get inspired as we reinvent the future of software — and have lots of fun doing it. {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 463.44876,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " We&#x27;re leveling up FutureStack registration with swag, only until 4&#x2F;30. Be one of the first 1,500 to register to qualify. <em>Terms</em> and <em>conditions</em> apply. Register Now Master Observability. Level Up Your Game. Get ready to rack up your experience points with new tools, new skills, and whole new ways"
      },
      "id": "5b34447a0755236b91a8591a"
    },
    {
      "image": "https://newrelic.com/sites/default/files/2021-01/og_futurestack.png",
      "url": "https://newrelic.com/futurestack/terms-and-conditions-giveaway",
      "sections": [
        "Terms and Conditions: FUTURESTACK 2021 Registration Giveaway"
      ],
      "published_at": "2021-04-18T01:43:01Z",
      "title": "Terms and Conditions: FUTURESTACK 2021 Registration Giveaway | New Relic",
      "updated_at": "2021-04-18T01:43:01Z",
      "type": "",
      "external_id": "151e37ce3627c69dbf642a68dcca384056f657e2",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone Nerd Island #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Nerd Island Register Main navigation menu, 1 item Terms and Conditions: FUTURESTACK 2021 Registration Giveaway New Relic, Inc. (“New Relic”) invites all eligible participants to enter the FutureStack 2021 Registration Giveaway (the “Giveaway”) which will be held from Thursday, April 1, 2021 at 8:00am PDT through Friday, April 30, 2021 at 5:00pm PDT (the “Giveaway Period”). The first one thousand five hundred (1,500) participants who have successfully completed the registration process for the FutureStack 2021: Level Up virtual event may be eligible to win the prize detailed below. Supplies are limited. Entries are limited to one event registration per participant. A participant’s entry into the Giveaway constitutes acceptance of these Terms & Conditions. NO PURCHASE OR PAYMENT IS NECESSARY TO ENTER THIS GIVEAWAY. Prizes: The first one thousand five hundred (1,500) participants who have successfully registered to attend the FutureStack 2021: Level Up virtual event via https://newrelic.com/futurestack will receive one (1) New Relic Swag Pack, with an approximate value of $40 USD. Prizes are non-transferable. Winners will be contacted via the email address associated with their FutureStack 2021: Level Up event registration by Monday, May 3, 2021. Winners shall have seventy-two (72) hours after receiving the email notification to claim their prize or else it will be forfeited. Who Can Enter: The Giveaway is strictly limited to legal residents of the United States and Washington, D.C. who are at least eighteen (18) years of age. Participants are solely responsible for ensuring their participation in the Giveaway is lawful. New Relic employees are not eligible to participate in the Giveaway. New Relic reserves the right, at its sole discretion, to disqualify participants for any reason, including if it is determined that one’s participation in the Giveaway is not lawful. Release: ALL PARTICIPANTS IN THE GIVEAWAY RELEASE NEW RELIC, INC. AND ITS RESPECTIVE EMPLOYEES, OFFICERS, DIRECTORS, AND SHAREHOLDERS (“RELEASED PARTIES”) FROM AND AGAINST ALL LIABILITY, CLAIMS, AND DAMAGES ARISING IN CONNECTION WITH THEIR PARTICIPATION OR INABILITY TO PARTICIPATE, ENTRY IN THE GIVEAWAY AND/OR ACCEPTANCE, RECEIPT, OWNERSHIP OR USE OF THE PRIZE AWARDED IN THE GIVEAWAY, INCLUDING BUT NOT LIMITED TO PERSONAL INJURY, DEATH, DAMAGE TO PROPERTY OR LOSS OF PROPERTY. Limitation of Liability: RELEASED PARTIES ARE NOT RESPONSIBLE FOR ANY CLAIMS, DAMAGES, EXPENSES, COSTS OR LOSSES TO ANY PERSON OR PROPERTY OF ANY KIND ARISING FROM OR IN CONNECTION WITH (1) TYPOGRAPHICAL OR OTHER ERRORS IN THE PRINTING OF THESE OFFICIAL RULES; (2) TECHNICAL FAILURES OF ANY KIND, INCLUDING BUT NOT LIMITED TO MALFUNCTIONS, INTERRUPTIONS OR DISCONNECTIONS OR DISCONNECTIONS IN PHONE LINES, HARDWARE, SOFTWARE OR FAILURE OF ANY EMAIL OR ENTRIES TO BE RECEIVED BY NEW RELIC DUE TO TECHNICAL PROBLEMS, HUMAN ERROR OR TRAFFIC CONGESTION, UNAVAILABLE NETWORK CONNECTIONS ON THE INTERNET OR ANY WEBSITE; (3) UNAUTHORIZED THIRD PARTY TAMPERING WITH THE GIVEAWAY; (4) TECHNICAL OR HUMAN ERROR IN THE ADMINISTRATION OF THE PRIZE; OR (5) LATE, LOST, UNDELIVERABLE, DAMAGED OR STOLEN MAIL. General: Any entries generated by a script, computer program, robotic or other automatic means will be disqualified. The Giveaway is governed by and will be construed in accordance with the laws of the State of California and the forum and venue for any dispute shall be San Francisco, California. Participants acknowledge that any contact information collected during the Giveaway Period will be used for marketing and other internal purposes. New Relic reserves the right to terminate this Giveaway for any or no reason and at any time without further notice. New Relic, Inc. 188 Spear Street, Suite 1000 San Francisco, CA 94105 Register Now Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 437.20526,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Terms</em> <em>and</em> <em>Conditions</em>: FUTURESTACK 2021 Registration Giveaway | New Relic",
        "sections": "<em>Terms</em> <em>and</em> <em>Conditions</em>: FUTURESTACK 2021 Registration Giveaway",
        "body": "Skip to main content #futurestack Agenda Speakers Dev Zone Nerd Island #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Nerd Island Register Main navigation menu, 1 item <em>Terms</em> and <em>Conditions</em>: FUTURESTACK 2021 Registration Giveaway New Relic, Inc. (“New Relic"
      },
      "id": "6073106028ccbca5ef51c129"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/16x9_600w/public/2021-03/sensoryroom.jpg?h=790be497&itok=jEQ1Z_1g",
      "url": "https://newrelic.com/futurestack/devzone",
      "sections": [
        "Join In and Nerd Out",
        "Dev Zone",
        "011y Awards",
        "Giving Back",
        "Nerd Island",
        "FutureHack",
        "Game Time",
        "Connect",
        "Side Stack",
        "Sonic Pi",
        "Energy Room",
        "Yoga",
        "Sensory Room",
        "Live LegoStack",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-18T01:43:01Z",
      "title": "FutureStack 2021 - Dev Zone | New Relic",
      "updated_at": "2021-04-18T01:43:01Z",
      "type": "",
      "external_id": "1842884dd2e2c64f4e766ceb0ab73865db4eaaff",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone Nerd Island #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Nerd Island Register Main navigation menu, 1 item Join In and Nerd Out Check out these FutureStack hands-on activities to meet, mingle, and play all day—or even keep the action going 24x7. Register Dev Zone 011y Awards Honoring our customers who find new ways to instrument everything, connect everyone with data, and simplify performance monitoring and software development.  Giving Back Level up your community by swapping your swag for charity cash.  Nerd Island Drop in and party with The Relicans as they play MInecraft, live stream, write code together, and welcome special guests. Learn More FutureHack Create your most kick-ass project at our 24-hour hackathon. Win accolades and prizes! Game Time Level up your swag by competing for points and prizes. Connect Connect with fellow Nerds at FutureStack. Side Stack Sonic Pi Creative coding and composition with Sonic Pi.  Energy Room Let loose and have some fun, but no rage quitting allowed! Yoga Have a stretch and get ready to get back in the game.  Sensory Room Unwind, recharge, and get in touch with your senses in a calming atmosphere. Live LegoStack Watch a master builder level up his Lego art. {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 413.44208,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Join In <em>and</em> Nerd Out",
        "body": " on Twitch Twitter LinkedIn newrelic.com Code of Conduct <em>Terms</em> and <em>Conditions</em> <em>Terms</em> of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved"
      },
      "id": "606a8909e7b9d2dc8c94461a"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/4x5_600w/public/2021-03/Natalie_Serrino%20FS21.jpg?h=2e0f227d&itok=xI5aRyVf",
      "url": "https://newrelic.com/futurestack/speakers/natalie-serrino",
      "sections": [
        "Natalie Serrino",
        "Sessions with Natalie Serrino",
        "Kubernetes-Native Observability Without Instrumentation",
        "Meet Our Speakers",
        "Paras Wadehra",
        "Jonathan Karon",
        "Dan Rufener",
        "Jonathan Thurman",
        "JD Weiner",
        "Aaron Judy",
        "Scot Gorman",
        "Anthony Pounds-Cornish",
        "Jemiah Sius",
        "Danny Roessner",
        "Sam Aaron",
        "Matt Shandera",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-16T04:26:28Z",
      "title": "Natalie Serrino | New Relic",
      "updated_at": "2021-04-16T04:26:28Z",
      "type": "",
      "external_id": "b07751ac88fb8968451d9e1aed356d4ff8b4e0e6",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item Natalie Serrino Principal Software Engineer, New Relic Sessions with Natalie Serrino 10:15 am - 11:15 am PT | Wednesday, May 26 | Hands-on Workshop Kubernetes-Native Observability Without Instrumentation Learn how to get visibility into your Kubernetes cluster and apps with no-instrumentation data collection, allowing you to debug in minutes. No need to update, recompile, or deploy your apps - it just works. (Join this session for live chat OR watch on-demand immediately after) Meet Our Speakers Paras Wadehra New Relic Learn more Jonathan Karon New Relic Learn more Dan Rufener New Relic Learn more Jonathan Thurman New Relic Learn more JD Weiner Forbes Media LLC Learn more Aaron Judy Maricopa County Clerk of the Superior Court Learn more Scot Gorman Chegg Learn more Anthony Pounds-Cornish Cognitran Learn more Jemiah Sius New Relic Learn more Danny Roessner WellSky Learn more Sam Aaron Sonic Pi Learn more Matt Shandera New Relic Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 380.2743,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct <em>Terms</em> and <em>Conditions</em> <em>Terms</em> of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved"
      },
      "id": "6042d15ce7b9d2c6cc579a0e"
    }
  ],
  "/collect-data/custom-attributes": [
    {
      "sections": [
        "newrelic_add_custom_span_parameter (PHP agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Important",
        "Parameters",
        "Return values",
        "Examples",
        "Report a variable as the value",
        "For more help"
      ],
      "title": "newrelic_add_custom_span_parameter (PHP agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "PHP agent API"
      ],
      "external_id": "48cad5c438588b2bd11a248848423ac96751d13d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelicaddcustomspanparameter-php-agent-api/",
      "published_at": "2021-04-16T07:05:55Z",
      "updated_at": "2021-04-16T07:05:55Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic_add_custom_span_parameter(string $key, scalar $value) Copy Attaches a custom attribute (key/value pair) to the current span. Requirements Agent version 9.12.0.268 or higher. Description Add a custom attribute (a key and a value data pair) to the current span. (The call name is newrelic_add_custom_span_parameter because \"custom attributes\" were previously called \"custom parameters.\") For example, you can add a customer's full name from your customer database. This attribute appears in any span. You can also query the Span for your custom attributes. Important On spans, attributes added with newrelic_add_custom_span_parameter will take precedence over attributes added with newrelic_add_custom_parameter. Important If you want to use your custom attributes, avoid using any of the reserved terms used by NRQL. Parameters Parameter Description $key string Required. The name of the custom attribute. Only the first 255 characters are retained. $value scalar Required. The value to associate with this custom attribute. If the value given is a float with a value of NaN, Infinity, denorm or negative zero, the behavior of this function is undefined. For other floating point values, the agent may discard 1 or more bits of precision (ULPs) from the given value. Return values Returns true if the parameter was added successfully. Examples Report a variable as the value ... if (extension_loaded('newrelic')) { // Ensure PHP agent is available // Record custom data about this web transaction newrelic_add_custom_span_parameter ('user_email', $user_email); } ... Copy - -> For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.95276,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", <em>attributes</em> added with newrelic_add_<em>custom</em>_span_parameter will take precedence over <em>attributes</em> added with newrelic_add_<em>custom</em>_parameter. Important If you want to use your <em>custom</em> <em>attributes</em>, avoid using any of the reserved terms used by <em>NRQL</em>. Parameters Parameter Description $key string Required. The name"
      },
      "id": "603e97c364441f09bb4e8895"
    },
    {
      "sections": [
        "newrelic_add_custom_parameter (PHP agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Important",
        "Parameters",
        "Return values",
        "Examples",
        "Report a variable as the value",
        "For more help"
      ],
      "title": "newrelic_add_custom_parameter (PHP agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "PHP agent API"
      ],
      "external_id": "9f562ac35bc082317e33be4164651edf38016ccd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_add_custom_parameter/",
      "published_at": "2021-04-16T06:04:54Z",
      "updated_at": "2021-04-16T06:04:54Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic_add_custom_parameter(string $key, scalar $value) Copy Attaches a custom attribute (key/value pair) to the current transaction and the current span (if enabled). Requirements Agent version 4.4.5.35 or higher. Description Add a custom attribute (a key and a value data pair) to the current web transaction. (The call name is newrelic_add_custom_parameter because \"custom attributes\" were previously called \"custom parameters.\") For example, you can add a customer's full name from your customer database. This attribute appears in any transaction trace that results from this transaction. You can also query the Transaction event for your custom attributes. Important Security recommendation—Review your Transaction attributes configuration. Any attribute include or exclude settings specific to Transaction events, should be applied to your Span attributes configuration or your Global Attributes configuration. Important If you want to use your custom attributes, avoid using any of the reserved terms used by NRQL. Parameters Parameter Description $key string Required. The name of the custom attribute. Only the first 255 characters are retained. $value scalar Required. The value to associate with this custom attribute. If the value given is a float with a value of NaN, Infinity, denorm or negative zero, the behavior of this function is undefined. For other floating point values, the agent may discard 1 or more bits of precision (ULPs) from the given value. Return values Returns true if the parameter was added successfully. Examples Report a variable as the value ... if (extension_loaded('newrelic')) { // Ensure PHP agent is available // Record custom data about this web transaction newrelic_add_custom_parameter ('user_email', $user_email); } ... Copy - -> For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.58477,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Global <em>Attributes</em> configuration. Important If you want to use your <em>custom</em> <em>attributes</em>, avoid using any of the reserved terms used by <em>NRQL</em>. Parameters Parameter Description $key string Required. The name of the <em>custom</em> attribute. Only the first 255 characters are retained. $value scalar Required. The value"
      },
      "id": "6043c95064441f61fd378eef"
    },
    {
      "sections": [
        "Node.js agent API",
        "Request names",
        "Tip",
        "Requirements",
        "Avoid metric grouping issues",
        "Guidelines",
        "URL pattern matching",
        "Load the request naming API",
        "Request API calls",
        "newrelic.setTransactionName(name)",
        "newrelic.setControllerName(name, \\[action])",
        "Custom instrumentation API calls",
        "newrelic.instrument(moduleName, onRequire \\[, onError])",
        "newrelic.instrumentDatastore(moduleName, onRequire \\[, onError])",
        "newrelic.instrumentLoadedModule(moduleName, moduleInstance)",
        "Important",
        "newrelic.instrumentMessages(moduleName, onRequire \\[, onError])",
        "newrelic.instrumentWebframework(moduleName, onRequire \\[, onError])",
        "newrelic.startWebTransaction(url, handle)",
        "newrelic.startBackgroundTransaction(name, \\[group], handle)",
        "newrelic.getTransaction()",
        "newrelic.endTransaction()",
        "newrelic.startSegment(name, record, handler, callback)",
        "Custom metrics API calls",
        "newrelic.recordMetric(name, value)",
        "newrelic.incrementMetric(name, \\[amount])",
        "Custom events API calls",
        "newrelic.recordCustomEvent(eventType, attributes)",
        "Recording a custom event",
        "Transaction handle methods",
        "transactionHandle.end(\\[callback])",
        "transactionHandle.ignore()",
        "transactionHandle.insertDistributedTraceHeaders(headers)",
        "Generating distributed trace headers",
        "transactionHandle.acceptDistributedTraceHeaders(transportType, headers)",
        "Accept incoming distributed trace headers",
        "transactionHandle.createDistributedTracePayload()",
        "Caution",
        "Link a nested background transaction",
        "Place payload on an outgoing request",
        "transactionHandle.acceptDistributedTracePayload(payload)",
        "transactionHandle.isSampled()",
        "Other API calls",
        "newrelic.addCustomAttribute(name, value)",
        "Add custom attribute",
        "newrelic.addCustomAttributes(attributes)",
        "Adding custom attributes",
        "newrelic.addCustomSpanAttribute(name, value)",
        "Add custom span attribute",
        "newrelic.addCustomSpanAttributes(attributes)",
        "Add custom span attributes",
        "newrelic.getBrowserTimingHeader()",
        "newrelic.setIgnoreTransaction(ignored)",
        "newrelic.noticeError(error, \\[customParameters])",
        "newrelic.shutdown(\\[options], callback)",
        "newrelic.getLinkingMetadata()",
        "newrelic.getTraceMetadata()",
        "Rules for naming and ignoring requests",
        "rules.name",
        "Optional rules attributes [#optional-rules]",
        "Testing your naming rules [#testing-rules]",
        "Naming rule examples [#examples-rules]",
        "Match full URL",
        "Replace first match in URL",
        "Replace all matches in any URL",
        "Match group references",
        "rules.ignore",
        "Naming rule example",
        "Ignoring rule example",
        "API calls for rules",
        "newrelic.addNamingRule(pattern, name)",
        "newrelic.addIgnoringRule(pattern)"
      ],
      "title": "Node.js agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "API guides"
      ],
      "external_id": "dd0838adbfafc7e5988ed77ad3ad039cdce29ec0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/api-guides/nodejs-agent-api/",
      "published_at": "2021-04-16T05:29:42Z",
      "updated_at": "2021-04-16T05:29:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several tools to help obtain the information needed to provide useful metrics about your Node.js application. These include: Reading the route names (if used) from the Express and Restify routers Using the API to name the current request, either with simple names or groups of controllers with actions Support rules that are stored in your agent's configuration that can mark requests to be renamed or ignored based on regular expressions matched against the request's raw URLs (also available as API calls) The number of names that New Relic tracks needs to be small enough so that the user experience is robust. It also needs to be large enough to provide the right amount of information (without overwhelming you with data) so that you can identify problem spots in your applications more easily. For more information, see the Node.js agent configuration documentation and the Node.js agent API documentation on Github. Request names The Node.js agent captures the HTTP method along with a potentially parameterized path (such as /user/:id) or a regular expression (such as /^/user/([-0-9a-f]+)$/). These pieces of information become part of the request name. If you have support for slow transaction traces and have enabled capture_params in your config file, the transaction trace will also have the request's parameters and their values attached to it. If you are dissatisfied with the request names that the Node.js agent uses, you can use API calls to create more descriptive names. Tip If grouping your requests under the generic name, then /* is sufficient, and you do not need to customize your configuration file or API calls. Requirements New Relic uses request names to group requests for many charts and tables. The value of these visualizations will drop as the number of different request names increases. For example, do not include potentially dynamic data like GUIDs, numerical IDs, or timestamps in the request names you create. If your request is slow enough to generate a transaction trace, that trace will contain the original URL. If you enable parameter capture, the parameters will also be attached to the trace. Tip Avoid having more than 50 different transaction names. For example, if you have more than a couple hundred different request names, rethink your naming strategy. Avoid metric grouping issues The request naming API helps New Relic avoid problems with trying to handle too many metrics, which sometimes is referred to as \"metric explosion.\" New Relic has several strategies to deal with these issues; the most severe is simply to add offending applications to your deny list. The main reason for you to be careful in using these request-naming tools is to prevent that from happening to your applications. For more information, see Metric grouping issues. Guidelines Define your configuration rules from the most specific to the most general. The first rules listed in your config file or added with the Node.js transaction naming API will be applied first and should be narrowly targeted. More general \"fall-through\" rules should be added toward the end of the list, because they will be evaluated in the order they were configured or added using the Node.js transaction naming API. URL pattern matching An online retailer has a URL pattern like this: /user/customers/all/prospects /user/customers/all/current /user/customers/all/returning /user/customers/John /user/customers/Jane Copy The retailer could create rules like this: // newrelic.js exports.config={ //other configuration rules:{ name:[ { pattern: \"/user/customers/all/prospects/\", name: \"/user/customers/all/prospects\" }, { pattern: \"/user/customers/all/.*\", name: \"/user/customers/all\" }, { pattern: \"/user/customers/.*\", name: \"/user/customers/:customer\" } ] } } Copy With these rules, the retailer would create three transaction names: /user/customers/:customer /user/customers/all /user/customers/all/prospects If the retailer reversed the order, the rules would catch all transactions in :customer, which would not be as useful. Load the request naming API Make sure that loading the New Relic module is the first thing your application does, as it needs to bootstrap itself before the rest of your application loads: var newrelic = require('newrelic'); Copy This returns the request naming API. You can safely require the module from multiple modules in your application, as it only initializes itself once. Request API calls Here is a summary of the Request API calls for New Relic's Node.js agent. newrelic.setTransactionName(name) newrelic.setTransactionName(name) Copy Name the current request, following the request naming requirements. You can call this function anywhere within the context of an HTTP request handler, at any time after handling of the request has started, but before the request has finished. In general, if the request and response objects are in scope, you can set the name. Explicitly calling newrelic.setTransactionName() will override any names set by Express or Restify routes. Also, calls to newrelic.setTransactionName() and newrelic.setControllerName() will overwrite each other. The last one to run before the request ends wins. newrelic.setControllerName(name, \\[action]) newrelic.setControllerName(name, \\[action]) Copy Name the current request using a controller-style pattern, optionally including the current controller action. If the action is omitted, New Relic will include the HTTP method (GET, POST, etc.) as the action. The rules for when you can call newrelic.setControllerName() are the same as they are for newrelic.setTransactionName(), including the request naming requirements. Explicitly calling newrelic.setControllerName() will override any names set by Express or Restify routes. Also, calls to newrelic.setTransactionName() and newrelic.setControllerName() will overwrite each other. The last one to run before the request ends wins. Custom instrumentation API calls Use these API calls to expand your instrumentation with custom instrumentation. newrelic.instrument(moduleName, onRequire \\[, onError]) newrelic.instrument(moduleName, onRequire \\[, onError]) Copy Sets an instrumentation callback for a specific module. The provided onRequire callback will be fired when the given module is loaded with require. The moduleName parameter should be the string that will be passed to require; for example, 'express' or 'amqplib/callback_api'. The optional onError callback is called if the onRequire parameters throws an error. This is useful for debugging your instrumentation. Use this method to: Add instrumentation for modules not currently instrumented by New Relic. Instrument your own code. Replace the Node.js agent's built-in instrumentation with your own. For more information, see New Relic's Node.js instrumentation tutorial on Github. newrelic.instrumentDatastore(moduleName, onRequire \\[, onError]) newrelic.instrumentDatastore(moduleName, onRequire \\[, onError]) Copy Sets an instrumentation callback for a datastore module. This method is just like newrelic.instrument(), except it provides a datastore-specialized shim. For more information, see New Relic's Node.js datastore instrumentation tutorial on Github. newrelic.instrumentLoadedModule(moduleName, moduleInstance) newrelic.instrumentLoadedModule(moduleName, moduleInstance) Copy The instrumentLoadedModule method allows you to add stock instrumentation to specific modules in situations where it's impossible to have require('newrelic'); as the first line of your app's main module. // load the agent const newrelic = require('newrelic') // module loaded before newrelic const expressModule = require('express') // instrument express _after_ the agent has been loaded newrelic.instrumentLoadedModule( 'express', // the module's name, as a string expressModule // the module instance ); Copy Important This method cannot instrument any arbitrary module. Its purpose is to add modules that were missed because the agent was not loaded as the first thing in your program. The instrumentLoadedModule method can only instrument modules the agent would normally instrument. You can see a list of these modules in the agent's lib/instrumentations module. newrelic.instrumentMessages(moduleName, onRequire \\[, onError]) newrelic.instrumentMessages(moduleName, onRequire \\[, onError]) Copy Sets an instrumentation callback for a message service client module. This method is just like newrelic.instrument(), except it provides a message-service-specialized shim. For more information, see New Relic's Node.js message service instrumentation tutorial on Github. newrelic.instrumentWebframework(moduleName, onRequire \\[, onError]) newrelic.instrumentWebframework(moduleName, onRequire \\[, onError]) Copy Sets an instrumentation callback for a web framework module. This method is just like newrelic.instrument(), except it provides a web-framework-specialized shim. For more information, see New Relic's Node.js web framework instrumentation tutorial on Github. newrelic.startWebTransaction(url, handle) newrelic.startWebTransaction(url, handle) Copy Instrument the specified web transaction. Using this API call, you can instrument transactions that New Relic does not automatically detect. The url defines the transaction name and needs to be static. Do not include variable data such as user ID. The handle defines the function you want to instrument. New Relic will capture any metrics that would be captured by auto-instrumentation, as well as manual instrumentation via startSegment(). You must handle custom transactions manually by calling newrelic.getTransaction() at the start of your transaction, and then call transaction.end() when you are finished. New Relic begins timing the transaction when newrelic.startWebTransaction() is called and ends the transaction when transaction.end() is called. You can also return a promise to indicate the end of the transaction. Please note that if this promise rejects, it does not automatically hook into New Relic’s error tracking. This needs to be done manually with noticeError(). newrelic.startBackgroundTransaction(name, \\[group], handle) newrelic.startBackgroundTransaction(name, \\[group], handle) Copy Instrument the specified background transaction. Using this API call, you can expand New Relic's instrumentation to capture data from background transactions. The name defines the transaction name and needs to be static. Do not include variable data such as user ID. The group is optional, and it allows you to group similar jobs together via the transaction type in the user interface. Like name, the group needs to be static. The handle defines a function that includes the entire background job you want to instrument. New Relic will capture any metrics that would be captured by auto-instrumentation, as well as manual instrumentation via startSegment(). You must handle custom transactions manually by calling newrelic.getTransaction() at the start of your transaction, and then call transaction.end() when you are finished. New Relic begins timing the transaction when newrelic.startBackgroundTransaction() is called and ends the transaction when transaction.end() is called. You can also return a promise to indicate the end of the transaction. Please note that if this promise rejects, it does not automatically hook into New Relic’s error tracking. This needs to be done manually with noticeError(). newrelic.getTransaction() newrelic.getTransaction() Copy Returns a handle on the currently executing transaction. This handle can then be used to interact with a given transaction safely from any context. It is best used with newrelic.startWebTransaction() and newrelic.startBackgroundTransaction(). Please refer to the transaction handle section for more details. newrelic.endTransaction() newrelic.endTransaction() Copy End the current web or background custom transaction. This method requires being in the correct transaction context when called. This API call takes no arguments. newrelic.startSegment(name, record, handler, callback) newrelic.startSegment(name, record, handler, callback) Copy Instrument a particular method to improve visibility into a transaction, or optionally turn it into a metric. The name defines a name for the segment. This name will be visible in transaction traces and as a new metric in the New Relic UI. The record flag defines whether the segment should be recorded as a metric. The handler is the function you want to track as a segment. The optional callback is a function passed to the handler to fire after its work is done. The agent begins timing the segment when startSegment is called. The segment is ended when either the handler finishes executing, or callback is fired, if it is provided. Custom metrics API calls Use these API calls to record additional arbitrary metrics: newrelic.recordMetric(name, value) newrelic.recordMetric(name, value) Copy Use recordMetric to record an event-based metric, usually associated with a particular duration. The name must be a string following standard metric naming rules. The value will usually be a number, but it can also be an object. When value is a numeric value, it should represent the magnitude of a measurement associated with an event; for example, the duration for a particular method call. When value is an object, it must contain count, total, min, max, and sumOfSquares keys, all with number values. This form is useful to aggregate metrics on your own and report them periodically; for example, from a setInterval. These values will be aggregated with any previously collected values for the same metric. The names of these keys match the names of the keys used by the platform API. newrelic.incrementMetric(name, \\[amount]) newrelic.incrementMetric(name, \\[amount]) Copy Use incrementMetric to update a metric that acts as a simple counter. The count of the selected metric will be incremented by the specified amount, defaulting to 1. Custom events API calls Use these API calls to record additional events: newrelic.recordCustomEvent(eventType, attributes) newrelic.recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. Recording a custom event The following example demonstrates recording a custom event with multiple attributes. const attributes = { attribute1: 'value1', attribute2: 2 } newrelic.recordCustomEvent('MessagingEvent', attributes) Copy Transaction handle methods This section details the methods provided by the TransactionHandle class instance that can be obtained through newrelic.getTransaction(). Use these methods to interact directly with the current transaction: transactionHandle.end(\\[callback]) transactionHandle.end(\\[callback]) Copy Use transactionHandle.end to end the transaction referenced by the handle instance. The callback is invoked when the transaction has fully ended. The finished transaction passed to the callback as the first argument. transactionHandle.ignore() transactionHandle.ignore() Copy Use transactionHandle.ignore to ignore the transaction referenced by the handle instance. transactionHandle.insertDistributedTraceHeaders(headers) transactionHandle.insertDistributedTraceHeaders(headers) Copy Important This API requires distributed tracing to be enabled. For context on how to use this call and its partner call acceptDistributedTraceHeaders, first read Enable distributed tracing with agent APIs. transactionHandle.insertDistributedTraceHeaders is used to implement distributed tracing. It modifies the headers map that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with distributed_tracing.exclude_newrelic_header: true in the config. This method replaces the deprecated createDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Generating distributed trace headers In the following example, by calling insertDistributedTraceHeaders with an empty object, the appropriate Distributed Trace headers and W3C Trace Context headers will be generated for the transaction. // Call newrelic.getTransaction to retrieve a handle on the current transaction. const transactionHandle = newrelic.getTransaction() // This could be a header object from an incoming request as well const headersObject = {} newrelic.startBackgroundTransaction('background task', function executeTransaction() { const transaction = newrelic.getTransaction() // generate the headers transaction.insertDistributedTraceHeaders(headersObject) }) Copy transactionHandle.acceptDistributedTraceHeaders(transportType, headers) transactionHandle.acceptDistributedTraceHeaders(transportType, headers) Copy Important This API requires distributed tracing to be enabled. For context on how to use this call and its partner call insertDistributedTraceHeaders, first read Enable distributed tracing with agent APIs. transactionHandle.acceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by insertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated (and now removed as of version 7.0.0) acceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. transportType should be one of the following strings: AMQP HTTP HTTPS IronMQ JMS Kafka Other Queue Unknown headers should be an object containing all the headers in the incoming request. The keys must be lowercase. Accept incoming distributed trace headers The following example demonstrates adding distributed trace headers retrieved from a Kafka message. In this example, we assume that the incoming Kafka message has Distributed Trace headers inserted. // incoming Kafka message headers const headersObject = message.headers // Call newrelic.getTransaction to retrieve a handle on the current transaction. const transactionHandle = newrelic.getTransaction() newrelic.startBackgroundTransaction('background task', function executeTransaction() { const transaction = newrelic.getTransaction() // accept the headers transaction.acceptDistributedTraceHeaders('Kafka', headersObject) }) Copy transactionHandle.createDistributedTracePayload() transactionHandle.createDistributedTracePayload() Copy Caution This method is deprecated and was removed in version 7.0.0! Please use insertDistributedTraceHeaders. Important This API requires distributed tracing to be enabled. For instructions on how to use this call, along with its partner call acceptDistributedTracePayload, see Enable distributed tracing with agent APIs. This call is used to implement distributed tracing. It generates a payload that is read by the receiving application with acceptDistributedTracePayload. Important Note: In order to maintain proper ordering of spans in a trace, you must generate the payload in the context of the span that sends it. The DistributedTracePayload object has two available methods used for generating the payload in different formats: DistributedTracePayload#text: returns a JSON representation of the payload. Link a nested background transaction // Call newrelic.getTransaction to retrieve a handle on the current transaction. var transactionHandle = newrelic.getTransaction() var payload = transactionHandle.createDistributedTracePayload() var jsonPayload = payload.text() newrelic.startBackgroundTransaction('background task', function executeTransaction() { var backgroundHandle = newrelic.getTransaction() // Link the nested transaction by accepting the payload with the background transaction's handle backgroundHandle.acceptDistributedTracePayload(jsonPayload) }) Copy DistributedTracePayload#httpSafe: returns a base64 encoded JSON representation of the payload. Place payload on an outgoing request // Call newrelic.getTransaction to retrieve a handle on the current transaction. var transactionHandle = newrelic.getTransaction() var payload = transactionHandle.createDistributedTracePayload() // Place the base64 encoded value on an outbound request header. req.headers[myTracingHeader] = payload.httpSafe() Copy transactionHandle.acceptDistributedTracePayload(payload) transactionHandle.acceptDistributedTracePayload(payload) Copy Caution This method is deprecated and was removed in version 7.0.0! Please use acceptDistributedTraceHeaders. Important This API requires distributed tracing to be enabled. For context on how to use this call and its partner call createDistributedTracePayload, first read Enable distributed tracing with agent APIs. transactionHandle.acceptDistributedTracePayload is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting the payload generated by createDistributedTracePayload. transactionHandle.isSampled() transactionHandle.isSampled() Copy Returns whether this trace is being sampled. Other API calls New Relic's Node.js agent includes additional API calls. newrelic.addCustomAttribute(name, value) newrelic.addCustomAttribute(name, value) Copy Set a custom attribute value to be displayed along with the transaction trace in the New Relic UI. This must be called within the context of a transaction so it has a place to set the custom attributes. Custom attributes will appear in New Relic APM's transaction trace detail view and in errors for the transaction. Add custom attribute newrelic.addCustomAttribute('attribute1', 'value1') Copy Caution If you want to use your custom attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomAttributes(attributes) newrelic.addCustomAttributes(attributes) Copy Set multiple custom attribute values to be displayed along with the transaction trace in the New Relic UI. The attributes should be passed as a single object. This must be called within the context of a transaction so it has a place to set the custom attributes. Custom attributes will appear in the transaction trace detail view and in errors for the transaction. Adding custom attributes const attributes = { attribute1: 'value1', attribute2: 2 } newrelic.addCustomAttributes(attributes) Copy Caution If you want to use your custom attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomSpanAttribute(name, value) newrelic.addCustomSpanAttribute(name, value) Copy Set a custom span attribute value to be displayed along with a transaction trace span in the New Relic UI. This must be called within the context of an active segment/span so it has a place to set the custom span attributes. Custom span attributes will appear in the Attributes section of the span detail view. Add custom span attribute newrelic.addCustomSpanAttribute('attribute1', 'value') Copy Important This API requires distributed tracing and span events to be enabled. Caution If you want to use your custom span attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomSpanAttributes(attributes) newrelic.addCustomSpanAttributes(attributes) Copy Set multiple custom span attribute values to be displayed along with the transaction trace spans in the New Relic UI. The attributes should be passed as a single object. This must be called within the context of an active segment/span so it has a place to set the custom span attributes. Custom span attributes will appear in the Attributes section of the span detail view. Add custom span attributes const attributes = { attribute1: 'value1', attribute2: 'value2' } newrelic.addCustomSpanAttributes(attributes) Copy Important This API requires distributed tracing and span events to be enabled. Caution If you want to use your custom span attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.getBrowserTimingHeader() newrelic.getBrowserTimingHeader() Copy Returns the HTML snippet to be inserted into the header of HTML pages to enable New Relic Browser. The HTML will instruct the browser to fetch a small JavaScript file and start the page timer. newrelic.setIgnoreTransaction(ignored) newrelic.setIgnoreTransaction(ignored) Copy Tell the module whether or not to ignore a given request. This allows you to explicitly filter long-polling, irrelevant routes or requests you know will be time-consuming. This also allows you to gather metrics for requests that otherwise would be ignored. To ignore the transaction, set the parameter to true will ignore the transaction. To prevent a transaction from being ignored with this function, pass the parameter false. Passing null or undefined will not change whether the transaction is ignored. Caution This method is deprecated and was removed in version 7.0.0. Please use transactionHandle.ignore() newrelic.noticeError(error, \\[customParameters]) newrelic.noticeError(error, \\[customParameters]) Copy Use this call if your app is doing its own error handling with domains or try/catch clauses, but you want all of the information about how many errors are coming out of the app to be centrally managed. Unlike other Node.js calls, this can be used outside of route handlers, but it will have additional context if called from within transaction scope. Caution Errors recorded using this method do not obey the ignore_status_codes configuration value. newrelic.shutdown(\\[options], callback) newrelic.shutdown(\\[options], callback) Copy Use this method to gracefully shut down the agent. options options.collectPendingData - type boolean - Tell the agent whether to send any pending data to the New Relic collector before shutting down. options.timeout - type number (ms) - The default time before forcing a shutdown. When collectPendingData is true, the agent will wait for a connection before shutting down. This timeout is useful for short lived processes, like AWS Lambda, in order to keep the process from staying open too long, while trying to connect. Example: newrelic.shutdown({collectPendingData: true, timeout: 3000}, (error) => { process.exit() }) Copy newrelic.getLinkingMetadata() newrelic.getLinkingMetadata() Copy Returns key/value pairs which can be used to link traces or entities. It will only contain items with meaningful values. For instance, if distributed tracing is disabled, trace.id will not be included. newrelic.getTraceMetadata() newrelic.getTraceMetadata() Copy Returns and object containing the current trace ID and span ID. Important This API requires distributed tracing to be enabled or an empty object will be returned. Rules for naming and ignoring requests If you do not want to put calls to the New Relic module directly into your application code, you can use pattern-based rules to name requests. There are two sets of rules: one for renaming requests, and one to mark requests to be ignored by New Relic's instrumentation. Here is the structure for rules in New Relic's Node.js agent. rules.name A list of rules of the format {pattern : \"pattern\", name : \"name\"} for matching incoming request URLs to pattern and naming the matching New Relic transaction's name. This acts as a regex replace, where you can set the pattern either as a string, or as a JavaScript regular expression literal, and both pattern and name are required. When passing a regex as a string, escape backslashes, as the agent does not keep them when given as a string in a pattern. Define your configuration rules from the most specific to the most general, as the patterns will be evaluated in order and are terminal in nature. For more information, see the naming guidelines. This can also be set with the environment variable NEW_RELIC_NAMING_RULES, with multiple rules passed in as a list of comma-delimited JSON object literals: NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}' Copy Optional rules attributes [#optional-rules] Additional optional attributes are available: Optional rules attributes Description terminate_chain Default: true When set to true (default), no further rules will be evaluated if this rule is a match. Setting this to false is useful when multiple rules should be used together. For example, one rule could be replacing a common pattern in many different URLs, while subsequent rule(s) would be more specific. replace_all Default: false When set to true, all matches of the pattern will be replaced. Otherwise, only the first match will be replaced. Using the g flag with regular expression literal will have the same effect. For example: pattern: '[0-9]+', replace_all: true Copy This has the same effect as pattern: /[0-9]+/g. precedence By default the rules are evaluated in order, from first to last. If you prefer to have complete control over the order, you can give each rule a precedence attribute. The precedence is an integer number, and rules are evaluated in ascending order. If precedence is not explicitly defined, it will be set to 500 by default. Additional attributes are ignored. Testing your naming rules [#testing-rules] The Node.js agent comes with a command-line tool for testing naming rules. For more information, run the following command in terminal window in a directory where your app is installed: node node_modules/.bin/newrelic-naming-rules Copy Naming rule examples [#examples-rules] Here are some examples of naming rules and the results. Match full URL pattern: \"^/items/[0-9]+$\", name: \"/items/:id\" Copy will result in: /items/123 => /items/:id /orders/123 => /orders/123 (not replaced since the rule is a full match) Copy Replace first match in URL pattern: \"[0-9]+\", name: \":id\" Copy will result in: /orders/123 => /orders/:id /items/123 => /items/:id /orders/123/items/123 => /orders/:id/items/123 Copy Replace all matches in any URL pattern: \"[0-9]+\", name: \":id\", replace_all: true Copy will result in: /orders/123/items/123 => /orders/:id/items/:id Copy Match group references Using regular expression match group references: pattern: '^/(items|orders)/[0-9]+$', name: '/\\\\1/:id' Copy will result in: /orders/123 => /orders/:id /items/123 => /items/:id Copy rules.ignore This can also be set via the environment variable NEW_RELIC_IGNORING_RULES, with multiple rules passed in as a list of comma-delimited patterns. Currently there is no way to escape commas in patterns. NEW_RELIC_IGNORING_RULES='^/socket\\.io/\\*/xhr-polling,ignore_me' Copy Here are full examples of how rules are included in the configuration file: Naming rule example // newrelic.js exports.config = { // other configuration rules : { name : [ { pattern: \"/tables/name-here\", name: \"/name-hererule1\" } ] } Copy Ignoring rule example If you are using socket.io, you will have a use case for ignoring rules right out of the box. To keep socket.io long-polling from dominating your response-time metrics and affecting the Apdex metrics for your application, add a rule such as: // newrelic.js exports.config = { // other configuration rules : { ignore : [ '^\\/socket\\.io\\/.*\\/xhr-polling' ] } }; Copy API calls for rules Here are the API calls for naming and ignoring rules with New Relic's Node.js agent. newrelic.addNamingRule(pattern, name) Programmatic version of rules.name. Once naming rules are added, they cannot be removed until the Node process is restarted. They can also be added via the Node.js agent's configuration. Both parameters are required. newrelic.addIgnoringRule(pattern) Programmatic version of rules.ignore. Once ignoring rules are added, they cannot be removed until the Node process is restarted. They can also be added via the Node.js agent's configuration. This parameter is required.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.29012,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Adding <em>custom</em> <em>attributes</em>",
        "body": " newrelic.add<em>Custom</em>Attribute(&#x27;attribute1&#x27;, &#x27;value1&#x27;) Copy Caution If you want to use your <em>custom</em> <em>attributes</em>, avoid using any of the reserved terms used by <em>NRQL</em> when naming them. newrelic.add<em>CustomAttributes</em>(<em>attributes</em>) newrelic.add<em>CustomAttributes</em>(<em>attributes</em>) Copy Set multiple <em>custom</em> attribute values"
      },
      "id": "6043daa7196a67e488960f4f"
    },
    {
      "sections": [
        "Guide to using the PHP agent API",
        "Tip",
        "Notice or ignore errors",
        "Enhance the metadata of a transaction",
        "Name reporting app",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Instrument asynchronous work",
        "Send custom event and metric data from your app",
        "Instrument calls to external services",
        "Monitor specific browser pages",
        "For more help"
      ],
      "title": "Guide to using the PHP agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "API guides"
      ],
      "external_id": "c1e218a22dcfaec484847c97b50bc452b6155a5a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/api-guides/guide-using-php-agent-api/",
      "published_at": "2021-04-16T09:19:32Z",
      "updated_at": "2021-04-16T09:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's PHP agent provides an API for customizing agent behavior. The agent automatically instruments many popular PHP frameworks, but you can use the PHP API to instrument activity that the agent doesn't already instrument by default. This guide describes PHP API calls for several common tasks; for example: Notice or ignore specific errors. Name a transaction. Rename the application reporting the data. Tip You can also set many of these options per directory or in newrelic.ini. If setting via API, the API takes precedence over the other methods. Notice or ignore errors Usually, the agent detects errors automatically. However, you can manually mark an error with the agent. If you want to... Do this... Report an error the agent does not report automatically See newrelic_notice_error(). Ignore an error Edit error_collector.ignore_exceptions or error_collector.ignore_errors in thenewrelic.ini file. Enhance the metadata of a transaction Sometimes the code you target is visible in New Relic, but some details of the method are not useful. For example: The default name is not helpful, or it is causing a metric grouping issue. You want to add custom attributes to your transactions or spans so you can filter them with NRQL queries. Use these methods when you want to change how New Relic instruments a transaction that's already visible in New Relic: If you want to... Do this... Change the name of a transaction See newrelic_name_transaction(). Add metadata (such as your customer's account name or subscription level) to your transactions or spans Use custom attributes. For custom attributes which will be added to transactions and spans (if enabled), see newrelic_add_custom_parameter(). For custom attributes which will be added only to spans, see newrelic_add_custom_span_parameter(). Mark a transaction as a background job See newrelic_background_job(). Prevent a transaction from affecting your Apdex score See newrelic_ignore_apdex(). Name reporting app The New Relic UI organizes data by how you name your application. Each name appears as a different app. You can rename the reporting app for any part of your code to better help you: Organize and analyze your data on New Relic UI pages (for example, APM's Applications index page, the Summary page, the Transactions page, etc.). Query your data. Create alert policies. This is especially useful if you have a multi-site application or distinct sets of application code using the same PHP installation. Alternatively, you can set the app name at a higher level instead via the newrelic.appname config value, via Apache, or via PHP-FPM. If you want to... Do this... Rename the reporting app for a specific part of your code Set the app name. See newrelic_set_appname(). Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. For more information about transactions, see transaction and transaction trace. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Start timing a method New Relic is not instrumenting automatically Start a transaction. See newrelic_start_transaction(). Stop timing a method after its work is completed Stop a transaction. See newrelic_end_transaction(). Prevent a transaction from reporting to New Relic Ignore the transaction. See newrelic_ignore_transaction(). Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. Use this methods when you want to instrument a method within an existing transaction: If you want to... Do this... Time a particular method See newrelic_add_custom_tracer(). Instrument asynchronous work The only async work the PHP agent instruments is Guzzle, which is instrumented by default. Send custom event and metric data from your app New Relic includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in New Relic Create a custom event. See Insert custom events via APM agent (PHP). Tag your events with metadata to filter and facet them Add custom attributes. See newrelic_add_custom_parameter(). Report custom performance data Create a custom metric. See newrelic_custom_metric(). Instrument calls to external services Use these methods to collect data about your app's connections to other apps or datastores: If you want to... Do this... Time a call to a datastore not instrumented by default See newrelic_record_datastore_segment(). See the path that a request takes as it travels through a distributed system For PHP agent versions lower than 9.8, see these API calls: newrelic_create_distributed_trace_payload() newrelic_accept_distributed_trace_payload() newrelic_accept_distributed_trace_payload_httpsafe() For PHP agent versions 9.8 or higher, see these API calls: newrelic_insert_distributed_trace_headers() newrelic_accept_distributed_trace_headers() For examples, see the documentation to manually instrument distributed tracing. Monitor specific browser pages You can install the browser agent by automatically adding it to your pages or by deploying it on specific pages by copying and pasting our JavaScript snippet. You can also control the browser agent by using APM agent API calls. For more information, see Browser monitoring and the PHP agent. For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.05959,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Send <em>custom</em> event and metric data from your app",
        "body": " in thenewrelic.ini file. Enhance the metadata of a transaction Sometimes the code you target is visible in New Relic, but some details of the method are not useful. For example: The default name is not helpful, or it is causing a metric grouping issue. You want to add <em>custom</em> <em>attributes</em> to your transactions"
      },
      "id": "60441c1ee7b9d2aa685799c5"
    },
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Important",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "9a5edf6068acc3b7187d217bd7932f0478e5467c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-04-16T15:03:37Z",
      "updated_at": "2021-03-30T06:37:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your New Relic APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.77078,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> events and <em>attributes</em>",
        "sections": "APM: Report <em>custom</em> events and <em>attributes</em>",
        "tags": "<em>Custom</em> events",
        "body": ". For restrictions on event type names, see our documentation about limits and restricted characters and <em>NRQL</em> reserved words. You can then add <em>custom</em> <em>attributes</em> for your .NET app. You can turn off <em>custom</em> events entirely by setting <em>custom</em>Events.enabled to false in newrelic.config. Node.js <em>Custom</em> event"
      },
      "id": "603ecece28ccbcc865eba7a0"
    }
  ],
  "/terraform/terraform-modules": [
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-04-16T14:38:31Z",
      "updated_at": "2021-04-06T07:43:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirements: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more sub-accounts, the notification channel includes only users for the currently selected master or sub-account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.13406,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to select existing account team members and admins. To view the Users list or to add users to <em>alert</em> policies: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. If a user has configured the New Relic mobile app, the user <em>notification</em> <em>channel</em> also sends push"
      },
      "id": "603ecfbf64441f4ee54e885f"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/07-saturation-condition-1024x558.png",
      "url": "https://newrelic.com/blog/how-to-relic/observability-as-code-new-relic-terraform-provider",
      "sections": [
        "About the Terraform New Relic provider",
        "Before you begin",
        "Step1: Initialize your working folder",
        "Step 2: Provision an alert policy resource",
        "Step 3: Provision alert conditions based on the four golden signals",
        "1. Latency",
        "2. Traffic",
        "3. Errors",
        "4. Saturation",
        "Linking a notification channel",
        "Observability as code in practice"
      ],
      "published_at": "2021-04-16T04:24:42Z",
      "title": "Practicing Observability as Code: Defining New Relic Alert Policies with Terraform",
      "updated_at": "2021-04-14T00:08:56Z",
      "type": "",
      "external_id": "f6ed141e784fb49eb7e1a31fe5752bf78186209c",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Practicing Observability as Code: Defining New Relic Alert Policies with Terraform Apr 6, 2020 • 11 min read By Chris Trombley Observability is an essential part of operating modern, complex architectures. But building an observability system that consumes a wide breadth of data from numerous data sources to drive alerts with a high signal-to-noise ratio can be overwhelming. Furthermore, maintaining such configurations manually across a large organization with distributed teams creates the potential for human error and configuration drift. A ThoughtWorks Technology Radar report suggested software teams treat “observability ecosystem configurations” as code—making observability as code an important practice for any teams adopting infrastructure as code (IaC) for their monitoring and alerting infrastructure. At New Relic, we believe that observability as code through automation is a best practice, and recommend a single source of truth for observability configurations. In this blog post, we’ll use the IaC tool Terraform and the New Relic Terraform provider to practice observability as code. We’ll use the provider to create a monitoring and alerting configuration for a sample application based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: Measures the amount of time it takes your application to service a request. In other words, how responsive is your application? Traffic: Measures how much demand is being placed on your system. How many requests or sessions are aimed at your application? Errors: Measures the rate of requests that fail. How much traffic is unable to fulfill its requests or sessions? Saturation: Measures how “full” your service is. How are resources being stressed to meet the demands of your application? You can combine these four signals to create a fairly thorough depiction of the health of your system. We’ll build the alerting strategy for our sample application based on these signals. About the Terraform New Relic provider Terraform is an open-source infrastructure as code tool teams use to define and provision their infrastructure (physical machines, VMs, network switches, containers, SaaS services, and more) through repeatable automation. In Terraform, any infrastructure type can be represented as a resource, and providers expose how developers can interact with their APIs. The Terraform New Relic provider, officially supported by New Relic, integrates with core Terraform to allow for provisioning and managing resources in your New Relic account. Note: We wrote this post using version 0.12.21 of the Terraform CLI and version 1.14.0 of the Terraform New Relic provider. Future releases may impact the correctness of the examples included below. Before you begin To complete this walkthrough, you’ll need to install the Terraform CLI. Homebrew users can run brew install terraform. If you’re not a Homebrew user, check the Terraform download page for install instructions. Step1: Initialize your working folder Terraform configuration is based on a declarative language called HCL, which defines resources in terms of blocks, arguments, and identifiers. We’ll represent our New Relic resources in HCL to allow Terraform to provision and manage them. In your working folder, create a file called main.tf. Include the provider block to signal to Terraform that the New Relic provider will be used for the plan we are about to create: provider \"newrelic\" { api_key = var.newrelic_api_key } You can now initialize Terraform, which will facilitate the download of the New Relic provider. To run the initialization, run terraform init from the console. You should see a message that shows Terraform has been initialized successfully. Still, in your working folder, create a file called variables.tf. Include the newrelic_api_key variable definition to allow the Terraform CLI to prompt for your New Relic Admin’s API key for your user and account, then run the plan: variable \"newrelic_api_key\" { description = \"The New Relic API key\" type = string } Tip: If you want to suppress user prompts, you can also provide the API key via the NEWRELIC_API_KEY environment variable. You can combine this with a secret manager like Hashicorp's Vault to automate your Terraform runs while keeping secret values out of source control. See Terraform’s provider documentation for details. Your working folder is now initialized, and you’re ready to begin defining your New Relic resources with Terraform. Step 2: Provision an alert policy resource Now we’ll define an alerting strategy for a sample app—called “Web Portal”—already reporting to our New Relic account. We want to apply the principles of golden signal monitoring and alerting to this application. To do so, we’ll first need some details about the application we’re targeting and an alert policy in which we can define the appropriate alert conditions. In the main.tf file, define these resources in HCL: data \"newrelic_application\" \"web_portal\" { name = \"Web Portal\" } resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_application.web_portal.name}\" } These two blocks define a data source to retrieve application context for a New Relic application named “Web Portal” and a resource for provisioning a simple alert policy with the name “Golden Signals - Web Portal.” Take note that we’ve included two strings at the start of each block: The first represents the data source we are provisioning, as defined by the provider. Here we are using the newrelic_application data source and the newrelic_alert_policy (See the provider documentation for a full list of the available New Relic resource types.) The second is an identifier used for referencing this element from within the plan. In this case, we interpolate the application’s name, stored in its name attribute, into the alert policy name to avoid duplication in our configuration. The policy name defined here will be the one that shows in the New Relic UI, but the golden_signal_policy identifier is for use inside our Terraform configuration only.   Run terraform plan. You’ll be prompted for your admin API key. Once you enter it, you will see a diff-style representation of the execution plan Terraform is about to carry out on your behalf: ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + created_at          = (known after apply) + id                  = (known after apply) + incident_preference = \"PER_POLICY\" + name                = \"Golden Signals - WebPortal\" + updated_at          = (known after apply) } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ After verifying the details of the execution plan, run terraform apply to execute the plan and provision the resource: newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=643964]Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log into New Relic and navigate to the Alert Policies page for your account. You should see your alert policy has been created. When you created the alert policy in step 1.3, Terraform began tracking the state of your resource. If you ran terraform apply again, Terraform would compare the configuration in your main.tf file to the internally tracked state of the resource and determine that no action is necessary—this is the power of observability as code. You can delete the policy, with terraform destroy. Step 3: Provision alert conditions based on the four golden signals Next, we’ll want to add alert conditions for our application based on the four golden signals: latency, traffic, errors, and saturation. 1. Latency As described earlier, latency is a measure of the time it takes to service a request. Use the newrelic_alert_condition resource to create a basic alert condition resource for the response time of our sample application: resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name            = \"High Response Time (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"response_time_web\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above 5 seconds per request. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } Here, we defined a condition named High Response Time (web) that will trigger if the overall response time of our application rises above five seconds for five minutes. Note that for the value of the policy_id attribute, we can link the alert policy we defined earlier with a reference to its identifier and its id attribute. We’re also using the ID of the application by referencing the application’s data source we defined in the previous section and by using its id attribute. Run terraform apply and verify that your alert condition has been created and linked to your alert policy. After Terraform runs, you can review the latency condition in New Relic. 2. Traffic The traffic signal represents how much demand is being placed on your system at any given moment. Use the application’s throughput as a metric for measuring the application’s traffic: resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id   name            = \"Low Throughput (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"throughput_web\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes below 1 request per minute. term { duration      = 5 operator      = \"below\" priority      = \"critical\" threshold     = \"1\" time_function = \"all\" } } Here, we define a condition named Low Throughput (web) that will trigger if the overall response time of our application falls below five requests per minute for five minutes. This type of alert is useful if we expect a constant baseline of traffic at all times throughout the day—a drop-off in traffic indicates a problem. Run terraform apply to create this condition. After Terraform runs, you can review the throughput condition in New Relic. 3. Errors Define a condition based on the error rate generated by our application: resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type  = \"apm_app_metric\" entities = [data.newrelic_application.web_portal.id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } This condition, error percentage, will trigger if the overall error rate for our application rises above 5% for five minutes. Run terraform apply to create the condition. After Terraform runs, you can review the error condition in New Relic. 4. Saturation Saturation represents how “full” your service is and can take many forms, such as CPU time, memory allocation, or queue depth. Let’s assume that in this case, we have a New Relic Infrastructure agent on the hosts serving our sample application, and we’d like to measure their overall CPU utilization. Use the newrelic_infra_alert_condition resource to create an alert condition based on this metric: resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name        = \"High CPU usage\" type        = \"infra_metric\" event       = \"SystemSample\" select      = \"cpuPercent\" comparison  = \"above\" runbook_url = \"https://www.example.com\" where       = \"(`applicationId` = '${data.newrelic_application.web_portal.id}')\"   # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration      = 5 value         = 90 time_function = \"all\" } } This alert will trigger if the aggregate CPU usage on these hosts rises above 90% for five minutes. Note that the definition for this resource is slightly different from the definition of newrelic_alert_condition—the New Relic provider documentation is the best source of information about the required or optional attributes on the resource. Run terraform apply to create the condition. After Terraform runs, you can review the saturation condition in New Relic. Your resources are now fully defined in code, and you can run terraform destroy or terraform apply at any time to remove or re-provision these resources in your New Relic account in a matter of seconds. Linking a notification channel We’ve created alert conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those alerts. Our team uses PagerDuty, so let’s create a notification channel to integrate with that service. (For a full list of the supported notification channels, see the newrelic_alert_channel documentation.) Create a variable to store the PagerDuty service key to avoid storing sensitive values in your codebase. In variables.tf, create a new variable: variable \"pagerduty_service_key\" { description = \"The Pagerduty service key\" type = string } Define the channel with the newrelic_alert_channel resource, and link it to your policy defined earlier with the newrelic_alert_policy_channel resource: resource \"newrelic_alert_channel\" \"pagerduty_channel\" { name = \"Page Developer Toolkit Team\" type = \"pagerduty\" config { service_key = var.pagerduty_service_key } # The following block prevents configuration drift for channels that use sensitive data. # See the Getting Started guide for more info: # https://www.terraform.io/docs/providers/newrelic/guides/getting_started.html lifecycle { ignore_changes = [config] } } resource \"newrelic_alert_policy_channel\" \"golden_signal_policy_pagerduty\" { policy_id  = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.pagerduty_channel.id] } Run terraform apply to apply your configuration. A PagerDuty notification channel set up in New Relic Alerts. Observability as code in practice Congratulations, you’re now a practitioner of observability as code. Now it’s time to create a repository—perhaps in GitHub—for your observability configuration and place it under version control. As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. You can do this with a pull request to your alerting repository. Since you’re practicing observability as code, your team can review these changes right alongside the rest of your code contributions. You may also want to consider automating this process in your CI/CD pipeline, taking your observability as code practice to the next level. Don’t miss our latest video quick tip: Terraform Provider for New Relic—Getting Started Guide [embed]https://www.youtube.com/watch?v=UwJ-7BLylJo[/embed]   By Chris Trombley Chris Trombley is a Software Engineer at New Relic Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.99991,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Practicing Observability as Code: Defining New Relic <em>Alert</em> Policies with <em>Terraform</em>",
        "sections": "Linking a <em>notification</em> <em>channel</em>",
        "body": "-provision these resources in your New Relic account in a matter of seconds. Linking a <em>notification</em> <em>channel</em> We’ve created <em>alert</em> conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those <em>alerts</em>. Our team uses PagerDuty, so let’s"
      },
      "id": "60763298196a679eea64a7a3"
    },
    {
      "sections": [
        "Test alert notification channels",
        "Request the test",
        "Troubleshoot the test results",
        "Tip"
      ],
      "title": "Test alert notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "c001fca5128a2fb8128ff655c44f9d51b6d5fa2a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/test-alert-notification-channels/",
      "published_at": "2021-04-16T14:39:15Z",
      "updated_at": "2021-03-16T06:45:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must save a new notification channel or any changes to an existing notification channel before testing it. Alerts will then send a test message to your chosen destination. Request the test To test a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Follow standard procedures to add a new notification channel or to update an existing notification channel, and save it. Select a notification channel, and then click Send a test notification. Review the test confirmation message, and then click Got it. Troubleshoot the test results A confirmation message will automatically show up in the user interface that indicates where the test was sent (for example, email) and whether it was successful. Also, the test notification message itself includes detailed information, including: The person who requested the test Links to policies for the channel Links to all notification channels and policies for the account Tip When troubleshooting problems, review the test notification message, and verify the setup requirements for the type of notification channel you selected. If necessary, make additional changes to your notification channel, and test it again as needed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.60461,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Test <em>alert</em> <em>notification</em> <em>channels</em>",
        "sections": "Test <em>alert</em> <em>notification</em> <em>channels</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": "You must save a new <em>notification</em> <em>channel</em> or any changes to an existing <em>notification</em> <em>channel</em> before testing it. <em>Alerts</em> will then send a test message to your chosen destination. Request the test To test a <em>notification</em> <em>channel</em>: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click"
      },
      "id": "603ec9ffe7b9d25b3d2a07a7"
    },
    {
      "sections": [
        "Update alert notification channels",
        "Reference for updating channels",
        "Add or remove policies assigned to a channel",
        "Assign a channel to policies",
        "Change a channel's name",
        "Check for policies assigned to a user",
        "Check how many policies are assigned to a channel",
        "Create more channels",
        "Delete a channel",
        "Test a saved channelView assigned alert policies",
        "Basic process"
      ],
      "title": "Update alert notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "521bed5aa6fdcea5c1cffd11d01e6dad19bc7c40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/update-alert-notification-channels/",
      "published_at": "2021-04-16T14:39:15Z",
      "updated_at": "2021-03-16T08:08:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Depending on the selected channel type, different values appear. Reference for updating channels Here's a quick reference for updating channels which also includes links to more detailed information and procedures. Add or remove policies assigned to a channel To add or remove policies assigned to a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Choose a channel, and then click Alert policies. From the selected policy, use the windows to select, remove, or clear all notification channels. Assign a channel to policies To add a notification channel to one or more policies: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies. Choose a policy, click Notification channels, and then click Add notification channels. Choose a channel, and then click Update policy. Change a channel's name To rename an existing notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, then choose a channel. From the Channel details, change the name (maximum 64 characters) based on the channel type if applicable, and then save. Check for policies assigned to a user To check whether an account user has any policies assigned: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Optional: Search by \"user\" to browse users or a specific username or email. Choose the user, then click Alert policies. Check how many policies are assigned to a channel To check whether a notification channel has any policies assigned: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create more channels To create a new notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Click New notification channel. Delete a channel To delete a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. In the list, click the Delete icon. Test a saved channelView assigned alert policies To view the policies assigned to a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, choose a channel, and then click Alert policies. OR To view the notification channels assigned to a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, choose a policy, then click Notification channels. Basic process Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, then choose a channel. From the Channel details page, make any necessary changes, and then save. The user interface shows a Last modified time stamp for any changes to policies, including their conditions and notification channels.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.89485,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update <em>alert</em> <em>notification</em> <em>channels</em>",
        "sections": "Update <em>alert</em> <em>notification</em> <em>channels</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to a <em>notification</em> <em>channel</em>: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, click <em>Notification</em> channels. Choose a <em>channel</em>, and then click <em>Alert</em> policies. From the selected policy, use the windows to select, remove, or clear all <em>notification</em> channels. Assign a <em>channel</em> to policies To add"
      },
      "id": "603eca45e7b9d2d1d82a0806"
    },
    {
      "sections": [
        "Delete alert notification channels",
        "Caution",
        "Delete a channel"
      ],
      "title": "Delete alert notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "4462298a5f026be9672d24ea2b452eb4c00a51c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/delete-alert-notification-channels/",
      "published_at": "2021-04-16T14:35:43Z",
      "updated_at": "2021-03-16T08:07:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Caution If you delete a channel, you cannot restore it. If you want to keep the notification channel, you can remove it from any associated policy. Delete a channel To delete a channel permanently: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Optional: To find the notification channel easily, search the Notification channels index. From the Notification channels index, select the channel's delete icon, and then select the confirmation prompt to cancel or continue. When you delete (or remove) a channel, any policies associated with it will still remain. You must delete policies separately.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.38046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Delete <em>alert</em> <em>notification</em> <em>channels</em>",
        "sections": "Delete <em>alert</em> <em>notification</em> <em>channels</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": "Caution If you delete a <em>channel</em>, you cannot restore it. If you want to keep the <em>notification</em> <em>channel</em>, you can remove it from any associated policy. Delete a <em>channel</em> To delete a <em>channel</em> permanently: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. Optional"
      },
      "id": "603ec9ff64441fd0e84e885b"
    }
  ],
  "/automate-workflows/get-started-new-relic-cli": [
    {
      "image": "https://developer.newrelic.com/static/futurestack-registration-86e612c0605fb3c49cfd28f35977135d.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Futurestack: Master Observability",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2021-04-20T01:36:57Z",
      "title": "New Relic Developers",
      "updated_at": "2021-04-16T01:37:39Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Data Nerds, get ready to hack the future. Level Up your observability game at Futurestack 2021. Rack up your experience points with new tools, new skills, and whole new ways to play with your data through Observability. Connect with Nerds from across the globe to learn, share, and get inspired as we reinvent the future of software — and have lots of fun doing it. Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom attributes for deeper analysis Show 29 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.25252,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/DEPLOYMENT-ANALYZER-SCREENSHOT-1.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-3",
      "sections": [
        "Container Explorer",
        "Specific requirements for this app",
        "Deployment Analyzer",
        "Page View Map",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:25:05Z",
      "title": "Most Popular New Relic One Applications (Round up #3)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "6f0be6c93ebcc052fac27513c1e849c0dfd256e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic Most Popular New Relic One Applications (Round up #3) Nov 26, 2019 • 7 min read By Joel Worrall Hopefully, you’ve heard the news that the New Relic One observability platform is now programmable. As central component of an observability platform, we believe programmability gives you the ability to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the possibilities—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications … and then we kept going. In fact, new apps are coming in every day. And we hope to see app contributions by New Relic users continue. This blog series is our opportunity to spotlight the most popular apps available today from our GitHub repository. The best part: Every app is available under an open source license and can be deployed right now! In this edition, we cover: Container Explorer Deployment Analyzer Page View Map Container Explorer This app includes a launcher that gives you a global view of all containers associated with an account. You can also employ tags to segment and drill down into subsets of your global container inventory. The app also presents container CPU, memory, and disk I/O usage in the form of intuitive and efficient heat map visualizations. Container Explorer presents CPU, memory, and disk I/O usage for all containers associated with an account—displaying this data via intuitive and efficient heat map visualizations. In the New Relic One entity explorer, we provide a nerdlet that will show all of the containers that are running for a selected APM application (service). We can also detect whether infrastructure data is coming from third-party sources and can, if necessary, automatically present this container telemetry in-context. Container Explorer can detect whether infrastructure data is coming from third-party sources—and can, if necessary, automatically ingest and present this container telemetry in-context. Clicking on a node in the heatmap reveals details about that container, and you can also jump to its host in the entity explorer. Clicking on a node in the Container Explorer heatmap reveals details about that container, and users can also jump to its host in the entity explorer. Fork or deploy the Container Explorer app from GitHub. Specific requirements for this app The New Relic Infrastructure agent must be deployed on any host you want to monitor. Note: We generate per-container CPU and other metrics by summarizing all processes in a given containerId. This will, however, report an accurate value only if the agent reports one ProcessSample per process every 30 seconds. Deployment Analyzer Deployments of applications can be risky events, but you can correlate those events to the performance of your applications, using deployment markers in New Relic. This app builds further on this process—enabling teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Deployment Analyzer enables teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Fork or deploy the Deployment Analyzer app from GitHub. Specific requirements for this app You'll need an active New Relic APM Pro subscription in order to access deployment marker functionality. Page View Map This app creates geographic visualizations of New Relic Browser application data using the React Leaflet mapping library. Leaflet is a leading open-source JavaScript library for mobile-friendly interactive maps. In addition to providing a new way to visualize your business data, this app offers a great example of what's possible for developers working with our GraphQL service and a third party library. Page View Map creates geographic visualizations of New Relic Browser application data Fork or deploy the Page Views Map app from GitHub Specific requirements for this app You must have the New Relic Browser Agent(s) installed, as well as related access to New Relic One. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer.git cd nr1-container-explorer nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Container Explorer to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer cd nr1-container-explorer nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app's launcher (unless otherwise noted above). Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications: New Relic Developer Edition: Early access to the Developer Edition of New Relic One gives you a free, personal sandbox account where you can build your own experience with all the available New Relic tools. developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome contributions to any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series.   Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.38676,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Most Popular <em>New</em> <em>Relic</em> One Applications (Round up #3)",
        "sections": "<em>Deployment</em> Analyzer",
        "body": " as related access to <em>New</em> <em>Relic</em> One. What are you waiting for? <em>Deploy</em> these apps now! To <em>deploy</em> any of these apps you need: Access to <em>New</em> <em>Relic</em> One (Requires a paid <em>New</em> <em>Relic</em> account and use of a supported browser) The <em>New</em> <em>Relic</em> One <em>CLI</em> A personal <em>New</em> <em>Relic</em> <em>API</em> <em>key</em>  Node v10 or higher A GitHub account  Once"
      },
      "id": "60762e1f196a673d0a64a782"
    },
    {
      "sections": [
        "Report Zipkin-format traces via Trace API",
        "Zipkin version requirements",
        "Overview of using the Trace API",
        "Send sample Zipkin trace payload",
        "Send Zipkin-format payload",
        "Send data from existing Zipkin instrumentation",
        "Transformation of Zipkin data",
        "Add other tags/attributes"
      ],
      "title": "Report Zipkin-format traces via Trace API",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Distributed tracing",
        "Trace API"
      ],
      "external_id": "dba8334d1f068236c741ff04c13ecc2be2c184fc",
      "image": "https://docs.newrelic.com/static/96e69137f0dd86b313ec72d5f0c1ad83/119c7/Screen-Shot-2020-08-13-at-1.26.17-PM.png",
      "url": "https://docs.newrelic.com/docs/distributed-tracing/trace-api/report-zipkin-format-traces-trace-api/",
      "published_at": "2021-04-16T01:27:27Z",
      "updated_at": "2021-04-10T16:18:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you want to create your own tracing implementation, you can use our Trace API. This doc explains how to send Zipkin-format trace data to our Trace API. (For our general data format, see New Relic format.) Zipkin version requirements The Trace API supports data from Zipkin JSON v2 (or higher) without any modification. For details on this version, see Zipkin v2 release details and the Zipkin v2 schema. Overview of using the Trace API Using our Trace API is as simple as: Sending trace data in the expected format (in this case, zipkin format). Sending that data to the appropriate endpoint Our send-data instructions have options for enabling Infinite Tracing. To learn more about this, see Intro to Infinite Tracing and Sampling considerations. To get started using the Trace API, choose an option: Send a sample trace: This shows a curl example of sending a trace to New Relic. This is useful for understanding how the Trace API works, and to verify you're seeing data in New Relic. Report data from existing Zipkin instrumentation: if you have an existing Zipkin implementation, you can simply change the endpoint of where your data gets sent. Send sample Zipkin trace payload This section describes how to send a simple Zipkin-format trace to our Trace API via curl request. You might choose to do this in order to learn how our API works and to verify that data is showing up in New Relic before doing in-depth instrumentation. To get started sending a sample payload: (Optional, to enable Infinite Tracing) First, you must set up a trace observer. That procedure includes instructions for sending a sample trace using our general new-relic format. When you get to that step, return here to instead learn how to send a Zipkin-format trace. Send a Zipkin-format payload following the instructions below. Send Zipkin-format payload To send a sample Zipkin-format trace: Get an Insights insert key: Go to the API keys UI and select Insights insert keys. If you don't already have a key, create a new one by selecting Insert keys +. You'll be executing a curl request, below. Notes on this: Replace the insert key placeholder with your insert key. If you're using Infinite Tracing, use the YOUR_TRACE_OBSERVER_URL value in place of the standard endpoint. If you want to send more than one post, change the trace ID to a different value. Sending the same payload or span id multiple times for the same traceId may result in fragmented traces in the UI. curl -i -H 'Content-Type: application/json' \\ -H 'Api-Key: $NEW_RELIC_INSERT_KEY' \\ -H 'Data-Format: zipkin' \\ -H 'Data-Format-Version: 2' \\ -X POST \\ -d '[ { \"traceId\": \"test-zipkin-trace-id-1\", \"id\": \"3e0f5885710776cd\", \"kind\": \"CLIENT\", \"name\": \"post\", \"duration\": 508068, \"localEndpoint\": { \"serviceName\": \"service-1\", \"ipv4\": \"127.0.0.1\", \"port\": 8080 }, \"tags\": { } }, { \"traceId\": \"test-zipkin-trace-id-1\", \"parentId\": \"3e0f5885710776cd\", \"id\": \"asdf9asdn123lkasdf\", \"kind\": \"CLIENT\", \"name\": \"service 2 span\", \"duration\": 2019, \"localEndpoint\": { \"serviceName\": \"service-2\", \"ipv4\": \"127.0.0.1\", \"port\": 8080 }, \"tags\": { \"error.message\": \"Invalid credentials\" } } ]' 'https://trace-api.newrelic.com/trace/v1' Copy Within a minute, the trace should be available in the our distributed tracing UI. To find it, run a query for the trace.id. In this example, it was test-zipkin-trace-id-1. Note that you search by the transformed attribute of trace.id (not traceId). To learn more: Learn where Trace API data shows up in the UI. Send data from an existing Zipkin instrumentation. Learn how to decorate spans by adding tags. This helps you customize how traces are displayed in our UI for a richer, more helpful experience. Learn about general endpoint information (data limits, required metadata, and response validation). Learn about how Zipkin data is transformed and stored in our format. If you don't see your trace data, see Troubleshooting. Send data from existing Zipkin instrumentation Preliminary notes: If you want to enable Infinite Tracing, you first must set up a trace observer. It can be helpful to first send a sample payload to verify things are working properly. To report data from an existing Zipkin instrumentation, you'll point the Zipkin tracer at the appropriate Trace API endpoint with some required request metadata. You can send the required metadata as headers or query parameters (some Zipkin tracer versions don't allow specifying HTTP headers). Here's an example of what it might look like to create a Zipkin OkHttpSender in Java configured for the Trace API: OkHttpSender.create(\"https://trace-api.newrelic.com/trace/v1?Api-Key=NEW_RELIC_INSERT_API_KEY&Data-Format=zipkin&Data-Format-Version=2\"); Copy Note that if you were using Infinite Tracing, or had an EU-region New Relic account, the endpoint would be different. For an explanation of Api-Key and the other metadata, see Request metadata. Transformation of Zipkin data To create a consistent search/query experience, some Zipkin data will be transformed to match New Relic attribute naming. For more on how we store and structure trace data, see How distributed tracing works. Zipkin tag Stored in New Relic as... Details traceId trace.id Unique identifier for a trace. id id Unique identifier for a span. parentId parent.id Identifier of the upstream span that called the service. kind kind Either Client or Server. name name Name of span. duration duration.ms Zipkin v2 spans must have durations specified in microseconds, and will be converted to milliseconds. localEndpoint: serviceName service.name We use the Zipkin v2 service name to identify the entity that created this span. localEndpoint: port localEndpoint.port All values in the localEndpoint object will be flattened to a span attribute called localEndpoint.key tags reported as attributes Key:value pairs in the tags object in Zipkin v2 will be written as span attributes. annotations not supported We do not currently support annotations in the Trace API. Spans will not be rejected if they contain annotations, but the annotations data will not be written. Add other tags/attributes You can add any tags you want to the tags block, with the exception of the restricted tags. For example, you might want to add attributes like customer.id or user.id to help you analyze your trace data. Tags will be converted to New Relic attributes. To learn how to control how spans appear in New Relic (for example, adding errors or setting a span as a datastore span), see Decorate spans.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.10995,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report Zipkin-format traces via Trace <em>API</em>",
        "sections": "Add other <em>tags</em>&#x2F;attributes",
        "tags": "Trace <em>API</em>",
        "body": " for the same traceId may result in fragmented traces in the UI. curl -i -H &#x27;Content-Type: application&#x2F;json&#x27; \\ -H &#x27;<em>Api</em>-<em>Key</em>: $<em>NEW_RELIC_INSERT_KEY</em>&#x27; \\ -H &#x27;Data-Format: zipkin&#x27; \\ -H &#x27;Data-Format-Version: 2&#x27; \\ -X POST \\ -d &#x27;[ { &quot;traceId&quot;: &quot;test-zipkin-trace-id-1&quot;, &quot;id&quot;: &quot;3e0f5885710776cd&quot;, &quot;kind&quot;: &quot;CLIENT"
      },
      "id": "6071cfc864441fa88f9d8530"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/adilson-somensari.jpg?h=2a479378&itok=1PmRmD7k",
      "url": "https://newrelic.com/blog/how-to-relic/new-relic-cli-ibm",
      "sections": [
        "Manage New Relic tasks and resources from the CLI",
        "Example use case 1: Create a Synthetics monitor",
        "Example use case 2: Daily backup of a Synthetics monitor",
        "A great addition for your New Relic toolbox"
      ],
      "published_at": "2021-04-16T04:25:42Z",
      "title": "Automate Your New Relic Tasks With the New Relic CLI From IBM",
      "updated_at": "2021-04-14T02:03:44Z",
      "type": "",
      "external_id": "84956b18d97b9ff7e418a703ede61342a4d315f5",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Automate Your New Relic Tasks With the New Relic CLI From IBM Nov 16, 2018 • 5 min read By Adilson Somensari Editor’s note: The New Relic CLI tool was developed by IBM. It is open sourced under the Apache License 2.0. Helping our customers go faster with confidence is a key tenet of the New Relic ethos. We provide visibility into vital data, statistics, and key performance indicators (KPIs) to help teams increase their deployment speed and cadence. But modern software teams also see automation and continuous integration and continuous delivery (CI/CD) processes as must-haves to support their Agile practices and DevOps teams. Teams want to apply the same automation concepts and tools to operate New Relic as they do other parts of their pipeline. However, writing all the standard boilerplate code to work with New Relic’s REST API (read configuration files, connect to endpoints, send payloads, receive responses, and parse them) can be a toilsome burden and a needless distraction. Fortunately, the IBM Cloud Monitoring team, a New Relic partner, noticed that multiple internal teams were spending too much time managing boilerplate code to automate their New Relic workflows, so they created a solution to solve that problem—a New Relic CLI (command line interface) tool. Manage New Relic tasks and resources from the CLI New Relic CLI, open sourced and available on GitHub from IBM, is a command line tool you can use to manage New Relic resources, such as New Relic Synthetics monitors, New Relic Alerts policies and conditions, and user accounts. You can also use the CLI to backup your New Relic configuration data and restore it as needed. Currently, you can use the New Relic CLI to manage these resources: New Relic resource Management action New Relic Synthetics Create, edit, and delete Synthetics monitors #rowspan# Back up and restore Synthetics monitors New Relic Alerts Create, edit, and delete alert conditions #rowspan# Create, edit, and delete alert policies #rowspan# Create, edit, and delete notification channels #rowspan# Back up and restore alert policies and conditions New Relic Insights dashboards Get dashboards #rowspan# Back up and restore dashboards Users List users Example use case 1: Create a Synthetics monitor This example shows you how to use the New Relic CLI to create a Synthetics monitor: Set the New Relic admin API key (NEW_RELIC_APIKEY) for your environment. This will vary depending on your operating system, but in Linux, you’d use the export command:Export NEW_RELIC_APIKEY=xxxx-xxxxxxx-xxxxx-xxxxxx Tip: Refer to the New Relic docs for instructions on locating your admin API key. Create a basic definition of the monitor in JSON format (for example test.json). { \"name\": \"Test monitorURI\", \"type\": \"SIMPLE\" \"frequency\": 5, \"uri\": \"monitorURI\", \"locations\": [ \"AWS_AP_SOUTH_1\", \"AWS_EU_WEST_3\", \"AWS_US_WEST_1\" ], \"status\": \"ENABLED\", \"slaThreshold\": 3, \"options\": { } Tip: See the documentation for a full list of public minion locations. Run a text substitution to replace the monitorURI with the actual URL you want to test, and generate a new file (in this example, result.json). .awk '{gsub(/monitorURI/,\"<URL TO BE TESTED>\")}1' test.json > result.json To create the new monitor, run ./nr-cli create monitor -f result.json. From this point, you can start working with the new monitor as needed. Example use case 2: Daily backup of a Synthetics monitor You can also use the NewRelic CLI to create daily backups of your Synthetics monitors. Using a simple shell script and a cron job, you can quickly set up a process to back up all your monitors in a safe repository. These four steps describe how to use the New Relic CLI to set up a daily backup job that will back up all monitors into a separate folder every day: Download the shell scripts file for backup monitors (backup_monitors.sh) from the New Relic CLI repo. Add a proper path to the script, and set it as an executable: $ chmod a+x backup_monitors.sh. Create a new cron job in your OS to schedule the shell script you just created. Use crontab -e to add new schedule job. 0 0 */1 * * <YOUR NEW_RELIC_APIKEY=\"xxx-xxxx-xxx>\" /<your_path>/backup-monitors.sh NOTE: Replace xxx-xxxx-xxx with your own NewRelic admin API key. (Optional) If you don't want to set the NR API key in your cron job’s configuration, you can set the key inbackup_monitors.sh. Comment out the Export NEW_RELIC_APIKEY=\"xxx-xxxx-xxx\" entry, replace the value with your API key. The cron job should now run and back up on your monitors based on the schedule you created. A great addition for your New Relic toolbox The New Relic CLI also lets you easily save New Relic settings to source-control tools like Github or BitBucket; and share central configuration and settings across multiple teams and projects. For example, if your target machine can’t connect to New Relic directly, you can configure the CLI tool to use a proxy. You can also configure retries to cope with timeouts. The CLI also includes return codes, which can be very useful for CI/CD automation. For more details on developing for the New Relic CLI, see the repo on Github. By Adilson Somensari Adilson Somensari is a senior solutions architect on the New Relic Expert Services team. An experienced APM professional, with multiple certifications in the APM industry, he has a passion for helping customers succeed with modern monitoring architectures. Adilson started his career as a Java developer, delivering distributed applications to a diverse set of industries (Auto, Banking, Telecom, Transportation) in multiple countries (United States, Canada, Portugal, Brazil), and pivoted to APM after learning that there is more to life than reading logs and stack traces. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.478806,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Automate Your <em>New</em> <em>Relic</em> Tasks With the <em>New</em> <em>Relic</em> <em>CLI</em> From IBM",
        "sections": "Manage <em>New</em> <em>Relic</em> tasks and resources from the <em>CLI</em>",
        "body": " <em>Relic</em> <em>CLI</em> to create a Synthetics monitor: Set the <em>New</em> <em>Relic</em> admin <em>API</em> <em>key</em> (<em>NEW_RELIC</em>_APIKEY) for your environment. This will vary depending on your operating system, but in Linux, you’d use the export command:Export <em>NEW_RELIC</em>_APIKEY=xxxx-xxxxxxx-xxxxx-xxxxxx Tip: Refer to the <em>New</em> <em>Relic</em> docs"
      },
      "id": "60764d8028ccbca8f951c14e"
    },
    {
      "sections": [
        "Record and monitor deployments",
        "Options for tracking deployments",
        "Tip",
        "Record deployments with the REST API",
        "Record a deployment with POST",
        "Record a deployment with PowerShell",
        "View a list of deployments with GET",
        "Sample output from GET",
        "Delete a deployment with DELETE",
        "Character limits and JSON parameters",
        "Important",
        "Record deployments using the New Relic agent",
        "Notify your team of deployments",
        "End of life notification: Hipchat, Campfire"
      ],
      "title": "Record and monitor deployments",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Maintenance"
      ],
      "external_id": "00b24338386fd261daea0733fe03c01639cce083",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/record-monitor-deployments/",
      "published_at": "2021-04-16T11:26:11Z",
      "updated_at": "2021-03-16T07:15:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Deploying an app can be a risky event—when your app breaks, a bad deployment is often the cause. New Relic allows you to track deployments so you can correlate deploy to your app's performance. Tracking deployments creates deployment markers that appear in APM charts. Options for tracking deployments You can use the New Relic REST API v2 to record new deployments, retrieve a list of past deployments, and delete past deployments on your APM application. In addition, some APM agents have agent-specific methods to record deployments automatically. You can use your Slack integration with New Relic, or a simple webhook, to notify your team in real time of deployments for applications monitored by APM. Slack provides a webhook URL that allows you to post generic JSON that will appear formatted in a chosen Slack channel. There are a few places where you can view deployments in the New Relic UI after they have been recorded. You can view deployments in the UI: In the activity feed of the APM Summary, New Relic One Service summary, and entity summary pages. On APM performance charts as a chart marker. On the Deployments page for summary performance. Tip Deployment markers are not available for Browser applications, but see Browser releases for a way to tag errors with release versions. Record deployments with the REST API You can use the New Relic REST API v2 to record deployments, get a list of past deployments, and delete deployments. The examples in this document use curl as a command line tool. However, you can use any method to make your REST requests. You can also create, view, and delete deployments with the API Explorer. JSON uses double quotes \" for element names and content. Using single quotes ' will cause errors. Record a deployment with POST To record a new deployment, send a POST request that includes your API key to the deployments endpoint. Attach the payload in JSON format (see Character limits and JSON parameters). All payload parameters are optional except revision. For example: curl -X POST \"https://api.newrelic.com/v2/applications/$APP_ID/deployments.json\" \\ -H \"Api-Key:$API_KEY\" \\ -i \\ -H \"Content-Type: application/json\" \\ -d \\ '{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' Copy Record a deployment with PowerShell To record a deployment with PowerShell, send a POST request that includes your API key to the deployments endpoint. Attach the payload in JSON format (see Character limits and JSON parameters). All payload parameters are optional except revision. This example uses PowerShell version 3 or higher: Invoke-WebRequest -Uri https://api.newrelic.com/v2/applications/YOUR_APP_ID/deployments.json -Method POST -Headers @{'Api-Key'='$API_KEY'} -ContentType 'application/json' -Body '{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' Copy This example uses PowerShell version 2 (requires .NET framework 3.5 or higher): $encoding = [System.Text.Encoding]::GetEncoding(\"ASCII\") $data ='{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' $postData = $encoding.GetBytes($data) $request = [System.Net.WebRequest]::Create('https://api.newrelic.com/v2/applications/$APP_ID/deployments.json') $request.Method = 'POST' $request.Headers.add('Api-Key','$API_KEY') $request.ContentType='application/json' $stream = $request.GetRequestStream() $stream.Write($postData,0,$postData.Length) $request.GetResponse() Copy View a list of deployments with GET To retrieve a list of all past deployments for your app, send a GET request that includes your API key to the deployments endpoint. GET requests do not use a JSON payload. For example: curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/deployments.json\" \\ -H \"Api-Key:$API_KEY\" \\ -i Copy Sample output from GET This example requests a list of deployments for app ID 9999999: curl -X GET \"https://api.newrelic.com/v2/applications/9999999/deployments.json\" \\ -H \"Api-Key:ABCDEFGHIJKLMNOPQRSTUVWXabcdefghijklmnopqrstuvwx\" \\ -i Copy The API returns this list of deployments: HTTP/1.1 200 OK ETag: \"ABCDEFGHIJKabcdefghijk0123456789\" Cache-Control: max-age=0, private, must-revalidate Content-Type: application/json { \"deployments\": [ { \"id\": 1234567, \"revision\": \"1234123412341234123412341234123412341234\", \"changelog\": \"Fixed the bugs for real this time\", \"description\": \"Example description two\", \"user\": \"Data Nerd\", \"timestamp\": \"2016-02-24T10:09:27-08:00\", \"links\": { \"application\": 9999999 } }, { \"id\": 2345678, \"revision\": \"7890789078907890789078907890789078907890\", \"changelog\": \"Think I fixed all the bugs\", \"description\": null, \"user\": \"Dren Atad\", \"timestamp\": \"2014-10-22T12:23:47-07:00\", \"links\": { \"application\": 9999999 } } ], \"links\": { \"deployment.agent\": \"/v2/applications/{application_id}\" } } Copy Delete a deployment with DELETE To delete a deployment, send a DELETE request that includes your API key to the deployments endpoint. DELETE requests do not use a JSON payload, but you must specify the ID for the deployment you want to delete. To retrieve the ID for a deployment, use the GET request. For example: curl -X DELETE \"https://api.newrelic.com/v2/applications/$APP_ID/deployments/$EMPLOYMENT_ID.json\" \\ -H \"Api-Key:$API_KEY\" \\ -i Copy Character limits and JSON parameters The JSON payload can include the following parameters. Important UTF-8 4 byte characters, such as Emojis and some non-Latin language glyphs, cannot be used in the deployment text. Parameter Data type Description revision String, 127 character maximum Required. A unique ID for this deployment, visible in the Summary page and on the Deployments page. Can be any string, but is usually a version number or a Git checksum. changelog String, 65535 character maximum Optional. A summary of what changed in this deployment, visible in the Deployments page when you select (selected deployment) > Change log. description String, 65535 character maximum Optional. A high-level description of this deployment, visible in the Summary page and on the Deployments page when you select an individual deployment. user String, 31 character maximum Optional. A username to associate with the deployment, visible in the Summary page and on the Deployments page. timestamp ISO 8601 Optional. When the deployment occurred, down to the second. If not specified, the deployment will be recorded at the time when the API call was received. Timestamp requirements: Must be in UTC time. Must be after the most recent deployment timestamp. Cannot be in the future. Must be in ISO8601 format; for example, \"2019-10-08T00:15:36Z\". Record deployments using the New Relic agent Some agents have additional methods to record deployments: All agents: Use the New Relic REST API v2. C: No SDK-specific methods. Use the REST API. Go: No agent-specific methods. Use the REST API. Java: Call the Java agent jar. .NET: Use PowerShell and the REST API. Node.js: No agent-specific methods. Use the REST API. PHP: Use a PHP script. Python: Use the record-deploy subcommand of the newrelic-admin script. Ruby: Use a Capistrano recipe. Notify your team of deployments After a deployment is recorded using the REST API, you can optionally notify a webhook endpoint of the deployment. The destination of the webhook can be your Slack instance. To use webhooks to set up a deployment notification for a Slack channel: Log in to your Slack account as an admin, then go to App directory > Manage > Apps. Search for your New Relic app, then select Add configuration. From Post to channel, select an existing Slack channel or add a new channel, then Add configuration. From the list of options, copy the webhook URL. Go to one.newrelic.com > (account dropdown) > Account settings > Integrations > Deploy notifications > Webhook. Paste the Slack webhook URL, then save. Optional: Send a test message. Tip You can also use webhooks, Slack channels, and other options for alert notifications with New Relic Alerts. End of life notification: Hipchat, Campfire As of September 9, 2019, integrations with Hipchat and Campfire for APM deployment notifications will no longer be available. Recommendation: If you are still using Hipchat or Campfire, use webhooks with Slack channels instead. For more information, see the New Relic Explorers Hub post.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.844894,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Record and monitor <em>deployments</em>",
        "sections": "Record <em>deployments</em> using the <em>New</em> <em>Relic</em> agent",
        "tags": "<em>New</em> <em>Relic</em> APM",
        "body": " after they have been recorded. You can view deployments in the UI: In the activity feed of the APM Summary, <em>New</em> <em>Relic</em> One Service summary, and <em>entity</em> summary pages. On APM performance charts as a chart <em>marker</em>. On the Deployments page for summary performance. Tip <em>Deployment</em> <em>markers</em> are not available"
      },
      "id": "603eb1c364441fd58b4e888b"
    }
  ],
  "/automate-workflows/automated-tagging": [
    {
      "sections": [
        "NerdGraph tagging API tutorial",
        "Read tags for an entity",
        "Add tags for an entity",
        "Remove a tag from an entity",
        "Delete specific tag values for an entity",
        "Replace all tag values for an entity"
      ],
      "title": "NerdGraph tagging API tutorial",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "b62313b6fa10ab235c031feae23d6fe52163b703",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-tagging-api-tutorial/",
      "published_at": "2021-04-16T14:51:53Z",
      "updated_at": "2021-03-16T07:06:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can add tags to your data to help improve data organization and findability. Learn more about tagging at New Relic. This doc explains how to use our NerdGraph API to add and manage tags. For a guide to automating tags using our CLI tool, see our developer site. Read tags for an entity To construct these queries and see responses: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to find the entity and then fetch its tags. Use NerdGraph's tag API to read the existing tags and their values. In this example, our entity is a browser app called Cookie Checkout: { actor { entitySearch (query: \"name like 'Cookie Checkout'\") { results { entities { tags { key values } } } } } } Copy The actual values vary depending on your data. Use the New Relic GraphiQL explorer to experiment with queries. Add tags for an entity To add new tags for an entity: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity you want to tag. Use the taggingAddTagsToEntity mutation to add a tag with a value to the entity. In this example, we have a browser application called Cookie Checkout owned by a UI team. We want to add a team tag with a ui value to this instance. Once the tag is added, we can filter by the tag team:ui and find the Cookie Checkout app in the New Relic One UI. mutation { taggingAddTagsToEntity ( guid: \"ENTITY_GUID\", tags: { key: \"team\", values: [\"ui\"]}) { errors { message } } } Copy Remove a tag from an entity To delete a tag and all of its associated values from an entity: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagFromEntity mutation. The following example mutation removes the team tag from an entity: mutation { taggingDeleteTagFromEntity ( guid: \"ENTITY_GUID\", tagKeys: [\"team\"]) { errors { message } } } Copy Delete specific tag values for an entity Instead of deleting an entire tag and all of its values, you can delete a single tag value. Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagValuesFromEntity mutation. The following example mutation deletes the ui value from the tag key: mutation { taggingDeleteTagValuesFromEntity ( guid: \"ENTITY_GUID\", tagValues : [{key: \"team\" value: \"ui\"}]) { errors { message } } } Copy Because tagValues is an array, you can delete multiple specific values from a single entity in one mutation. Replace all tag values for an entity To replace the entity’s entire set of tags with the provided tag set: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingReplaceTagsOnEntity mutation. In this example, the Cookie Checkout browser application was transferred from the ui team to the cookie-dev team. You can replace the tag values for team with the following mutation: mutation { taggingReplaceTagsOnEntity ( guid: \"ENTITY_GUID\", tags: {key: \"team\" values: [\"cookie-dev\"]}) { errors { message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.96883,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NerdGraph <em>tagging</em> API tutorial",
        "sections": "NerdGraph <em>tagging</em> API tutorial",
        "body": " the <em>taggingDeleteTag</em>FromEntity mutation. The following example mutation removes the team <em>tag</em> from an entity: mutation { <em>taggingDeleteTag</em>FromEntity ( guid: &quot;ENTITY_GUID&quot;, <em>tag</em>Keys: [&quot;team&quot;]) { errors { message } } } Copy Delete specific <em>tag</em> values for an entity Instead of deleting an <em>entire</em> <em>tag</em> and all of its values, you can"
      },
      "id": "603ec1c6196a67eeada83d9a"
    },
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Use tags to filter the UI",
        "Custom queries and charts"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-04-16T22:09:47Z",
      "updated_at": "2021-03-29T20:39:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). And you can also add your own custom tags. You can use tags in the UI to filter down to relevant data, as shown here: Here you can see an accountId tag being used to filter workloads for a specific account. You can use tags to: Help organize data coming from a large number of sources and/or to a large number of New Relic accounts Identity teams, roles, environment, or regions to know who’s responsible for what (see example use cases) Better organize and search dashboards and workloads Tags are useful for organizing data at a high level. If you wanted to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events would be a better solution. Tip At New Relic, tags were previously called \"labels.\" You may sometimes see \"label\" used in our code; for example, some of our APM agent config files use a label config option for tags. Keep reading to learn more about tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters When using our API to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, read the best practices below to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Be consistent with capitalization. For example, avoid using both env: staging and env: Staging (although tag searching is case-insensitive in the UI and API) Tips on cross-team implementation: One reason for using tags is to improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Keep this reference manual up-to-date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can apply tags via the UI and API or you can add tags using APM agent configuration: C SDK: not available Go .NET Node.js PHP Python Ruby Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries and charts As explained in Tag sources, some attributes are available as tags. You can query attributes and create custom charts using NRQL.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 95.534424,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>tags</em> to help organize and find <em>your</em> data",
        "sections": "Use <em>tags</em> to help organize and find <em>your</em> data",
        "body": " reports that identify entities that are non-compliant with <em>your</em> <em>tagging</em> standards. <em>Tag</em> examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "New Relic Flex: 独自のインテグレーションを構築する",
        "Flexとは?",
        "要件",
        "Flexの動作のしくみ",
        "設定の例",
        "詳細情報",
        "その他のヘルプ"
      ],
      "title": "New Relic Flex: 独自のインテグレーションを構築する",
      "type": "docs-jp",
      "tags": [
        "Full-Stack Observability",
        "Instrument everything",
        "Develop your own integrations"
      ],
      "external_id": "97d59bd52c8219850d6ea5ae34a226698b84d022",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/integrations/host-integrations/host-integrations-list/flex-integration-tool-build-your-own-integration/",
      "published_at": "2021-04-16T16:40:48Z",
      "updated_at": "2021-04-06T10:51:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicは、多くの一般的なサービスやフレームワーク向けのインテグレーションを提供しています。New Relicを使用しており、インテグレーションの対象外のサービスからデータのレポートを行う場合、次のいくつかの方法でNew Relicにより独自のインテグレーションを作成できます。 New Relic インフラストラクチャモニタリングを使用して、軽量のFlexツール（以下で推奨、文書化）を使用できます。完全なインフラストラクチャオンホストインテグレーションを構築するには、Integrations SDKをご覧ください。 テレメトリー（メトリックス、トレース）モニターソリューション：当社のテレメトリーSDKを使用します。 独自のJavaScript UI機能を使用する、カスタムのNew Relic Oneアプリケーションを構築します。 Flexとは? New Relic Flexは、アプリケーションに依存しないすべてを兼ね備えたツールで、このツールを使用して広範なサービスからメトリックデータを収集できます。Flexはインフラストラクチャエージェントとバンドルで提供されます。標準形式（例：JSONまたはプレーンテキスト）で標準プロトコル（HTTP、ファイル、シェル）にメトリックスを露呈するアプリをインストゥルメントできます：YAML設定ファイルを作成し、Infrastructureエージェントを開始し、データをNew Relicにレポートします。 Flexは、広範なソースから、New Relicにイベントとメトリックデータを送信できます。簡単なYAML設定ファイルを使用して、HTTP/HTTPSリクエストを実行し、シェルコマンドを実行し、ファイルコンテンツのパースを行えます。また、標準の正規表現を使用して、この入力から収集したデータのカスタマイズと制御も行えます。設定の例をご覧ください。 データの収集とクリーンアップを行った後、New RelicでFlexデータのクエリを行い、カスタムチャートを作成し、そのデータをダッシュボードで使用できます。 要件 Flexはインフラストラクチャエージェントとバンドルで提供されます。Flexを使用するには、次のものが必要です。 LinuxまたはWindows、Kubernetesで実行している、Infrastructureエージェントバージョン1.10.7以上（アップデート | チェックバージョン）。 Flexの動作のしくみ Flexはインフラストラクチャエージェントを使用して、レポートするデータを生成するコマンドを実行します。データのレポートでのFlexのしくみの概要は次のとおりです。 インフラストラクチャエージェントパッケージにある、YAML設定ファイルでレポートするデータを定義します。設定の例をご覧ください： 設定の例 LinuxサーバーのアップデートをモニターするためのFlex設定の例は次のとおりです。この設定は、flex-uptime.ymlという名前のファイルにあります。この設定は、/etc/newrelic-infra/integrations.d/flex-uptime.ymlにある、インフラストラクチャエージェントのインテグレーション設定セクションにあります。 integrations: - name: nri-flex config: name: linuxUptimeIntegration apis: - name: Uptime commands: - run: 'cat /proc/uptime' split: horizontal split_by: \\s+ set_header: [uptimeSeconds,idletimeSeconds] コピー この設定で行うことについての注： runでは、実行するコマンドを定義します。 名前: アップタイムで示される名前には、UptimeSampleと呼ばれるイベントを生成するためのサンプルが付けられます。 名前の先頭には、ESXまたはPCFプレフィックスを付けないでください。 split_by: \\s+は、空白文字に基づきフィールドを分割します。 このコマンドは、UptimeSampleイベントに添付された属性を生成します。属性の名前はuptimeSecondsおよびidletimeSecondsとなります。 インフラストラクチャエージェントは、独自の設定（デフォルト：30秒おき）に基づく頻度でFlexを実行し、データをNew Relicに送信します。 その後データのクエリを行い、そのデータを使用してカスタムチャートを作成し、データをダッシュボードに追加できます。 詳細情報 Flexインテグレーションは、インフラストラクチャエージェントとバンドルで提供されます。要件の詳細を表示する。 詳細については、GitHubのドキュメント： READMEをご覧ください チュートリアル その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.02205,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Full-<em>Stack</em> Observability"
      },
      "id": "60533092196a67649e2d166a"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/canary_watch_4_best_practices.png",
      "url": "https://newrelic.com/blog/best-practices/best-practices-automating-monitoring",
      "sections": [
        "Automate it #1: Install monitoring agents in application builds",
        "Automate it #2: Add markers and tags in your deploy system",
        "Automate it #3: Bootstrap applications and monitoring",
        "Automate it #4: Use APIs and DSLs for dashboards and alerting",
        "Monitoring should reduce toil"
      ],
      "published_at": "2021-04-16T04:26:29Z",
      "title": "Automate It! 4 Best Practices for Scalable Monitoring",
      "updated_at": "2021-04-14T05:20:45Z",
      "type": "",
      "external_id": "0414be031cb241bfc7f42149f257cc353f1cbf3f",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Best Practices Automate It! 4 Best Practices for Scalable Monitoring Feb 7, 2019 • 11 min read By Kevin Scaldeferri Operating applications at scale means we have to be thoughtful and vigilant about our monitoring strategies, so we monitor everything consistently. As applications scale, it becomes increasingly important—and increasingly complicated— to effectively monitor the entire software lifecycle, from code deployment through build and deploy to alerting. So how does a fast-growing organization do it? At New Relic, it’s all about automation. As we’ve grown to more than 50 engineering teams around the globe regularly pushing new code to production, we’ve gone from infrastructure as code to “monitoring as code,” embracing four key best practices: Install monitoring agents in application builds Add markers and tags in your deploy system Bootstrap applications and monitoring Use APIs and DSLs for dashboarding and alerting Let’s take a closer look at each one. Automate it #1: Install monitoring agents in application builds Let’s start with build systems. Modern build tools, like Gradle, can do almost anything, and you should take advantage of that power. At New Relic, we automate our build processes using the full power and expressiveness of the programming languages in which we write our applications. We use APIs and code against them within our build systems. For example, to install the New Relic agent into a Java app, you have to download the agent, add the New Relic API as a dependency, generate a YAML config file, modify our run command, and include all that in a deployable artifact. Ok: How do we automate that? We could write a build script that captures all the dependencies and tasks to complete the agent install, but we’d have to copy/paste this boilerplate script for every application we deploy. We’d never write actual application code like this, so why do so with build scripts? This is where build plugins come into play. Consider this example build.gradle file: apply plugin: ‘application’ apply plugin: ‘newrelic-agent-plugin’ apply plugin: … application { name 'my_app' mainClass 'com.example.MyAppMain' } newrelic { version ‘4.10.0’ includeAgentApi true distribution { configFilePath 'config/newrelic.yml' agentJarPath 'agent/newrelic.jar' } } … This is workable, but it’s still not ideal. We’d still need this boilerplate in all our applications, and if we wanted to, say, change something about our monitoring configurations, we’d have to update the config blocks in hundreds of build files. So why not reach toward the nirvana of “zero-configuration builds?” apply plugin: ‘company-java-service’ dependencies { … } Here we’ve written a “mega-plugin” that pulls in all the other plugins we want to use, and provides them with sensible default configurations. From here, an individual service can apply this plugin and its build dependencies, and that’s it—including monitoring is now a zero-effort default in the application’s build. Automate it #2: Add markers and tags in your deploy system Most modern software teams have a common, automated deploy system. Not necessarily a continuous deployment system, but a standard, centralized way to get code into production. But you have to know when you’ve deployed that code. When something changes in your monitored data, the first question anyone asks is, “Was this related to a deploy?” There are two ways to track this information: deploy markers and version tags. Both are useful, so this isn’t an either/or choice but a both/and situation. Markers and tags provide the critical information you need to scale and automate monitoring of your deployments Deploy markers are event logs that get recorded somewhere off to the side of your primary monitoring telemetry. They provide a chronological record of everything that’s changed across all your systems. If you want to record deploy markers, it’s usually just a matter of making a REST API call as part of your deploy process. From there, you can use a charting library or New Relic to automatically display the markers on your dashboards. But deploy markers do have some shortcomings. As techniques like canary deploys, phased rollouts, and blue-green deploys gain popularity, it’s increasingly hard to know exactly what a deploy marker is marking. Is it marking the start of a deploy, or the end of one? What happens if you’re halfway through a deploy and you detect a problem and need to abort and roll it back? In such situations, version tags are more useful. At New Relic, our deploy system injects the version number into the application as an environment variable. Here’s an example of a dashboard where all our telemetry data has been tagged with the version number of the application. Monitoring applications by version tag. By tracking the number of instances reporting each version (in the Router count chart) we can see that this was a phased rollout over the course of 90 minutes. And while that’s happening, we can compare performance between the versions (in the Query 95th Percentile chart) and see that, outside of a bit of Java virtual machine (JVM) warmup in the first canaries, the two versions track very close to one another, even though from minute to minute things jump around a bit based on changing workload. We use tags to track other types of information as well. When we’re responding to an incident or a support request, we frequently need to know how to scope the problem—is the issue restricted to a single instance, or is it widespread? Often we need to compare or restrict data based on clusters or cells, or by region and availability zone, or by what team owns an application—all of which can be done with tags. Additionally, in the containerized world, applications typically don’t know what host machine they’re running on, which can be a problem if we need to shut down a misbehaving instance. For this reason, we have our deploy system tell the container where it is running when it’s launched, so we know exactly where to look should we encounter a problem. Your deploy system is a powerful tool, and it gives you all the information you need to know exactly where your monitoring data is coming from: which version of which application is running on which machines in which region, and so on. Automate it #3: Bootstrap applications and monitoring We’ve looked at how we automate the installation of monitoring agents in our application builds and monitor our deploys, so now we can look at how we automate monitoring in our applications themselves. Earlier, I said it’s important to eliminate as much boilerplate code as you can, but the truth is you can never get rid of it all. If you have to copy/paste boilerplate code to create a new service, at least make a machine do it for you using a uniform template-based build system, like Apache Maven Archetype. When you define an organization-wide best practice to use templates to bootstrap new services, you’re taking proactive steps to ensure uniformity in your microservices architecture. As mentioned, the New Relic deploy system injects environment variables into our applications that describe exactly what the applications are and where they’re running. But this information is of limited value unless we actually do something with it. To this end, we wrote simple wrapper libraries that allow us to attach attributes such as our applications’ names, versions, and hostnames to all the data we collect when monitoring them: public void recordEvent(String eventType, Map<String, Object> attributes) { // Add standard attributes Map<String, String> envVars = System.getenv(); attributes.put(\"appName\", envVars.getOrDefault(\"NEW_RELIC_APP_NAME\", \"unknown\")); attributes.put(\"version\", envVars.getOrDefault(\"GC_VERSION\", \"unknown\")); attributes.put(\"jvmId\", ManagementFactory.getRuntimeMXBean().getName()); attributes.put(\"ipPort\", envVars.getOrDefault(\"CF_PRIMARY_IP_PORT\", \"unknown\")); attributes.put(\"hostname\", envVars.getOrDefault(\"CF_FQDN\", \"unknown\")); attributes.put(\"region\", envVars.getOrDefault(\"CF_REGION\", \"unknown\")); attributes.put(\"zone\", envVars.getOrDefault(\"CF_ZONE\", \"unknown\")); attributes.put(\"subnet\", envVars.getOrDefault(\"CF_SUBNET_ID\", \"unknown\")); NewRelic.recordCustomEvent(eventType, attributes); } With this in place, we’re able to slice and dice the monitoring data from all of our applications along a consistent set of dimensions, even as they continue to scale. Automate it #4: Use APIs and DSLs for dashboards and alerting So now you’re building and deploying monitoring all your services—but that doesn’t do you much good if no one is paying attention. With a monolithic application architecture, it may be enough to simply start creating dashboards and setting up alerts. But large microservices architectures operate at scale, and manual GUI-driven dashboard and alerting configurations are too repetitive, too error prone, and too easy to abandon. This is why modern software teams embrace APIs as first-class alternatives to GUIs. New Relic gives you APIs to create dashboards, APIs to define synthetic monitors, APIs to set up alert conditions, and so on. But you need to decide how you’ll interact with those APIs—obviously you don’t want people manually typing out JSON payloads and cURL commands; that would barely be an improvement over making changes in a GUI. The good news, though, is that you have choices for how to approach this. Recently, for example, IBM open-sourced a command-line tool it uses to automate management of its New Relic tasks and resources (for example, creating, editing, and deleting alert policies). This is the kind of tool you’d want to build more complicated workflows on top of; for example, you could use it to download all your existing dashboard configurations and manage those configs programmatically, essentially as templates. In fact, this is how we manage our synthetic monitoring scripts at New Relic. New Relic Synthetics monitors are just JavaScript programs, but if you’re monitoring several clusters providing a single service, you need to update those scripts if the clusters have different URLs. With such questions in mind, we turned our Synthetics scripts into embedded Ruby (ERB) templates so that we can loop over all of our clusters and generate a unique version of the script for each cluster. For other tasks, we embrace Domain Specific Languages (DSLs). The term “DSL” can mean a lot of things, but I’m talking about a templating or configuration language that is capable of driving an API in an automated way. At New Relic, for example, we manage our alert policies via a Ruby-based DSL: policy \"Unified Data Streams CF Alerts” do rollup 'condition’ team_low_priority_channels condition \"WARNING Service(s) OOMing\" do type 'nrql’ query \"SELECT count(*) FROM cf_docker_event where action = 'oom’” since 2.minutes value 'single_value’ critical above: 0, for: 1.minutes end end Because this is all Ruby code, we can add loops and function calls—which makes things a little more interesting. In the example below, we loop over clusters and use the cluster identity in a few different ways: We inject the cluster name into the alert policy, and select notification channels per cluster. Notifications from the production clusters go to PagerDuty, but notifications from pre-production clusters go to email. This ensures the right people are notified for the right reasons, and no one gets woken up in the middle of the night unnecessarily. clusters.each do |cluster| policy \"#{cluster} MyApp Lag\" do rollup 'condition' team_alert_channels(cluster) condition \"#{sev_and_cluster('SEV3’, cluster)} MyApp\" do entities [config[cluster][‘lag_monitor_app_name']] metric 'Custom/ConsumerLag/appendSecondsLag/my_topic/my_app' value 'max' critical above: 60, for: 5.minutes end end end The critical part of these configuration choices is making the right thing the easy thing. Your engineers are going to configure alert policies hundreds or thousands of times, which creates a lot of opportunities for them to take shortcuts or make mistakes. Limit those opportunities with automated management of your alert configurations—there are countless ways to do that, so find what works best for your organization. Nothing will keep your dev and ops teams up at night like wondering if something might be silently breaking and having no alerts from which to find out. Monitoring should reduce toil At New Relic, we obviously have plenty of opinions about monitoring modern software. But we also know that microservices architectures come with the risk of increasing toil and uncertainty in your operations. Your monitoring strategies don’t have to contribute to that toil. Using techniques like these will help you get ahead—and stay ahead—of the game as your applications and infrastructure continue to grow. By Kevin Scaldeferri Kevin Scaldeferri is a Principal Software Engineer and Architect for the New Relic Database system. He likes math and distributed systems, and probably says “monoid” too much. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.14714,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Automate</em> It! 4 Best Practices for Scalable Monitoring",
        "sections": "<em>Automate</em> it #2: Add markers and <em>tags</em> in <em>your</em> deploy system",
        "body": " Add markers and tags in <em>your</em> deploy system Bootstrap applications and monitoring Use APIs and DSLs for dashboarding and alerting Let’s take a closer look at each one. <em>Automate</em> it #1: Install monitoring agents in application builds Let’s start with build systems. Modern build tools, like Gradle, can"
      },
      "id": "60767bad64441f3ae79d8596"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/NRBlog_20181107_S7_AWS-EC2-tagging-integration.png",
      "url": "https://newrelic.com/blog/how-to-relic/new-relic-infrastructure-getting-started-best-practices",
      "sections": [
        "Getting organized and getting started",
        "Create a naming convention",
        "Implement a tagging structure",
        "Create a filter set",
        "Understanding your UI",
        "Apply a filter",
        "Making data actionable",
        "Using New Relic Insights queries",
        "Set up New Relic Alerts",
        "Monitor your apps, and their hosts, in one place",
        "Ready to learn more?",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:26:29Z",
      "title": "Getting Started with New Relic Infrastructure: Best Practices That Set You up for Success",
      "updated_at": "2021-04-14T00:02:29Z",
      "type": "",
      "external_id": "78d3925eba18b334c1df9469f34071151e6d3b82",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Infrastructure Monitoring Getting Started with New Relic Infrastructure: Best Practices That Set You up for Success Nov 8, 2018 • 7 min read By New Relic Community Team The following is adapted from a series of best practice guides that reflect the New Relic Community Team’s work with thousands of customers—identifying challenges and coming up with actionable solutions for organizations getting started with New Relic Infrastructure. Also, check out our guides to getting started with New Relic APM, New Relic Mobile, New Relic Insights, New Relic Browser, and New Relic Synthetics; and discover the New Relic Community Team’s latest Best Practice Guide offerings. Improving application performance involves more than just your company’s software. It also demands visibility into your application infrastructure: the servers and hosts, and the supporting network and storage resources, that power your applications and make them available to users. New Relic Infrastructure offers a powerful set of solutions to your organization’s infrastructure visibility challenges. Infrastructure lets you look into host resource usage—locally or in the cloud—and also lets you monitor events on your hosts, inventory metrics, and network or storage availability.  Infrastructure makes it easy to track all of these resources, and to correlate any changes to potential impacts on your host and application performance. In this post, we will show you how to set up New Relic Infrastructure to make the most of this added visibility into your environment. (After reviewing these best practices—and, when possible, actually working with them in your organization's own environment—you’ll be ready to demonstrate your new skills by taking our Infrastructure Best Practices Quiz): Let’s dive into our list of best practices, organized based on the Infrastructure capabilities and tasks they address. Getting organized and getting started Create a naming convention Let’s begin with two of the most important tips for New Relic Infrastructure users: Decide upon an appropriate naming scheme and use it consistently. First, a simple naming scheme for all of the elements in your account can greatly reduce the amount of time you spend looking for pertinent information. When you devise a naming scheme and apply it consistently within a specific New Relic account—for example, <env (Prod/Staging)>-<Service Name>-<AWS Region>—the host name can supply the information you need to locate a problem and to identify the right person to fix it.  Learn more about applying a naming scheme to your New Relic Infrastructure environment in our docs: Updating display names in your Infrastructure configuration file. Implement a tagging structure Tags are integral to organizing the hosts within your environment. They allow you to spot problems more easily by sorting and filtering groups of hosts; for example, you can add the same attribute to a number of hosts to identify them later, using the Infrastructure UI or NRQL queries. If your hosts are in Amazon Web Services (AWS), then New Relic Infrastructure’s Amazon EC2 integration makes the process of implementing tagging remarkably simple. Any EC2 tags you add to your hosts within AWS will carry over to New Relic, allowing you to group your hosts without extra configuration. New Relic Infrastructure's Amazon EC2 integration is one of more than 50 cloud and on-host integrations that make tasks such as tagging simpler—yet also more powerful. If you’re not using AWS EC2, New Relic Infrastructure supports more than 50 other cloud and on-host integrations, in addition to offering custom attributes that you can tailor to meet your organization’s needs. Learn more about implementing tagging using either AWS EC2 integration or custom attributes in our documentation: AWS EC2 Monitoring Integration Configure the Infrastructure Agent: Custom Attributes Create a filter set Filter sets let you target any number of hosts based on a variety of attributes, including tags, hostNames, etc. You can then target filter sets with alert conditions, which saves you the time required to apply a condition to multiple hosts manually. You can also alter the charts in the Infrastructure UI to focus in on a specific filter set—letting you concentrate on the hosts that matter most to you. Learn more about using Infrastructure Filter Sets in our docs: Filter Sets: Organize Your Hosts. Understanding your UI Apply a filter By default, the New Relic Infrastructure UI shows you data for all reporting hosts. Depending on the number of hosts that you’re monitoring, applying a filter set to the UI can make your monitoring data much easier to assess and interpret. You can create filter sets that apply to hostnames, or EC2 tags, or any other attributes that matter to you. When you apply them, the UI will focus only on matching hostnames. When you apply a filter set, it carries through to all parts of the Infrastructure UI—keeping you informed only on the hosts you need to know about. Learn more about using New Relic Infrastructure filter sets in New Relic University: Using Filter Sets and Groups in New Relic Infrastructure. New Relic Infrastructure makes it easy to configure filter sets based on a wide range of attributes, and to target filter sets by alert conditions. Making data actionable Using New Relic Insights queries New Relic Insights gives you a powerful way to ask questions of your data—and that’s especially true for New Relic Infrastructure users. We work hard, for example, to ensure that Infrastructure data is tracked as event-based data that you can query quickly and easily, and that any chart created within Infrastructure is also available within Insights at the click of a button. In addition, when you set up Infrastructure integrations, the setup process automatically creates a number of Insights dashboards—helping to make these integrations more valuable, more quickly, for you. Learn more about the shared data and views within New Relic Infrastructure and Insights in our documentation: Share Infrastructure data and view in Insights. New Relic Insights gives users a powerful yet easy to use set of tools for querying data generated while working with New Relic Infrastructure. Set up New Relic Alerts Alerts are critical factor to the monitoring process: What’s the point of monitoring if you don’t know when your applications or infrastructure is having problems are misbehaving?  New Relic Alerts allows you to configure notifications using a variety of popular messaging and communication platforms (Slack, OpsGenie, PagerDuty, etc.), as well as a generic webhook to which you can send notifications. When you get started with Infrastructure Alerts, one of the first conditions we recommend is a “Host Not Reporting” condition. Learn more about alerting best practices, including tips on setting up a “Host Not Reporting” condition with these resources: Guide to Effective Alerting in Practice Intro to APM Alerting Create Infrastructure ‘Host Not Reporting’ condition New Relic supports quick and easy configuration of alert notifications using a variety of messaging programs. Monitor your apps, and their hosts, in one place Health maps provide a high-level view of your host and application health in relation to one another, prioritized by health status. As long as you have both an APM and Infrastructure subscription, you can use health maps to gain dashboard-style visibility into potential problems—making it easier to find, diagnose, and fix them quickly. Learn more about New Relic health maps in the video demo below, or in the New Relic docs: Introduction to health maps. Ready to learn more? Looking for more Infrastructure best practices and tips? Check out the Infrastructure Level Up page in the New Relic Explorers Hub for a wealth of community-generated resources on these and related topics. And when you feel you’re ready, test your new Infrastructure skills by taking our Infrastructure Best Practices Quiz and earning your proficiency badge! Related Topics Infrastructure Monitoring By New Relic Community Team Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.66339,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Implement a <em>tagging</em> structure",
        "body": " environment in our docs: Updating display names in <em>your</em> Infrastructure configuration file. Implement a <em>tagging</em> structure Tags are integral to organizing the hosts within <em>your</em> environment. They allow you to spot problems more easily by sorting and filtering groups of hosts; for example, you can add the same"
      },
      "id": "6076311528ccbc61fd51c159"
    }
  ],
  "/collect-data/collect-data-from-any-source": [
    {
      "sections": [
        "FedRAMP-compliant endpoints",
        "Customer FedRAMP obligations",
        "Overview of data sources",
        "Agents",
        "APM agents",
        "Mobile agents",
        "Infrastructure monitoring",
        "Infrastructure agent versions below 1.15.0",
        "Browser agent",
        "Data-ingest APIs",
        "Metric API",
        "Telemetry integrations",
        "Telemetry SDKs",
        "Event API",
        "Log API",
        "Log forwarders",
        "Trace API"
      ],
      "title": "FedRAMP-compliant endpoints",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Compliance"
      ],
      "external_id": "ffce8ad6f802717392aca80e0965c9f3fe77ffdf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/compliance/fedramp-compliant-endpoints/",
      "published_at": "2021-04-17T01:15:55Z",
      "updated_at": "2021-04-05T21:48:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides information on FedRAMP-compliant endpoints in New Relic. For more information about our security accreditation for the Federal Risk and Authorization Management Program (FedRAMP), see our data encryption documentation. Customer FedRAMP obligations New Relic customers must meet all of the following requirements for New Relic’s FedRAMP environment: New Relic-approved customers: New Relic’s FedRAMP-Moderate authorized environment is only available to New Relic-approved customers. For more information, contact your New Relic account representative. Order form: Customer’s order form with New Relic must include customer’s eligibility for FedRAMP. Subscription level: Customer must have a current and valid subscription to New Relic Full-Stack Observability Enterprise or New Relic-approved subscription. Authorized New Relic endpoints: Customer must send its data only to New Relic’s FedRAMP-designated endpoints. Authorized services and features: Customer must use only FedRAMP audited and authorized New Relic services and features (see below). Overview of data sources There are multiple ways to get data into New Relic. This doc has two sections: Agent settings: for our APM agents, infrastructure agent, browser agent, and mobile agent. Data-ingest APIs: for our Metric API, Event API, Trace API, and Log API, and the integrations that use those APIs. Agents New Relic has several agents for reporting data, like our APM agents, infrastructure agents, mobile agents, and browser agent. Setting these agents to send FedRAMP-compliant data involves setting a configuration setting to use the relevant FedRAMP endpoint. APM agents To ensure FedRAMP compliance, all APM agent configurations must report to gov-collector.newrelic.com rather than the default. Depending on the agent, you can either use code-based configuration or an environment variable. Here are details on enabling this: Language Code or environment variable C SDK In code: strcpy(_newrelic_app_config_t->redirect_collector, \"gov-collector.newrelic.com\"); Copy Environment variable: none Go In code: app, err = newrelic.NewApplication( newrelic.ConfigAppName(\"App Name\"), newrelic.ConfigLicense(os.Getenv(\"NEW_RELIC_LICENSE_KEY\")), func(cfg *newrelic.Config) { cfg.Host = \"gov-collector.newrelic.com\" }, ) Copy Environment variable: NEW_RELIC_HOST Java In newrelic.yml: common: &default_settings host: gov-collector.newrelic.com Copy Or set a system property of: newrelic.config.host Copy Environment variable: NEW_RELIC_HOST .NET In your XML config next to the license key: <service licenseKey=\"YOUR_LICENSE_KEY\" host=\"gov-collector.newrelic.com\"/> Copy Environment variable: NEW_RELIC_HOST Node.js In newrelic.js: host: 'gov-collector.newrelic.com' Copy Environment variable: NEW_RELIC_HOST PHP In newrelic.ini: newrelic.daemon.collector_host = gov-collector.newrelic.com Copy Environment variable: none Python In newrelic.ini: [newrelic] host = gov-collector.newrelic.com Copy Environment variable: NEW_RELIC_HOST Ruby In newrelic.yml: common: &default_settings host: gov-collector.newrelic.com Copy Environment variable: NEW_RELIC_HOST Elixir (open source agent) In config.exs: config :new_relic_agent, host: \"gov-collector.newrelic.com\" Copy Environment variable: NEW_RELIC_HOST For more on configuring APM agents, see APM configuration. Mobile agents To ensure FedRAMP compliance when using our mobile monitoring agents, all agent configurations must report to gov-mobile-collector.newrelic.com rather than the default. You must use code-based configuration. Environment variables are not available. Framework-specific configurations: Agent Code or environment variable Android In code: NewRelic.withApplicationToken({APP_TOKEN}) .usingCollectorAddress(\"gov-mobile-collector.newrelic.com\") .usingCrashCollectorAddress(\"gov-mobile-crash.newrelic.com\") .start(this.getApplication()); Copy Environment variable: none iOS In code: [NewRelic startWithApplicationToken:@\"{APP_TOKEN}\" andCollectorAddress:@\"gov-mobile-collector.newrelic.com\" andCrashCollectorAddress:@\"gov-mobile-crash.newrelic.com\"]; Copy Environment variable: none Infrastructure monitoring If you have infrastructure agent version 1.15.0 or higher, simply enable the FedRAMP configuration option. If you have an older agent version, use the following values to edit your YAML configuration: Infrastructure agent versions below 1.15.0 If you have an infrastructure agent version below 1.15.0, you must change three of the endpoints used for reporting. To set these endpoints, you can change your YAML configuration or use environment variables. YAML config field Endpoint URL collector_url https://gov-infra-api.newrelic.com Copy identity_url https://gov-identity-api.newrelic.com Copy command_channel_url https://gov-infrastructure-command-api.newrelic.com Copy To edit environment variables, use these values: Environment variable Endpoint URL NRIA_COLLECTOR_URL https://gov-infra-api.newrelic.com Copy NRIA_IDENTITY_URL https://gov-identity-api.newrelic.com Copy NRIA_COMMAND_CHANNEL_URL https://gov-infrastructure-command-api.newrelic.com Copy Browser agent To configure the browser agent to use a FedRAMP-compliant endpoint, you must use the copy-paste method method (other browser agent install methods are not supported) and edit the browser code’s script element tag so that the domain is gov-bam.nr-data.net for both beacon and error_beacon, like this: window.NREUM||(NREUM={});NREUM.info={\"beacon\":\"gov-bam.nr-data.net\",\"errorBeacon\":\"gov-bam.nr-data.net\"... Copy Data-ingest APIs Below are details about the FedRAMP endpoint for our ingest APIs: Metric API, the Event API, the Log API, and the Trace API. Metric API To ensure FedRAMP compliance when using the Metric API, instead of sending metric data to the default Metric API endpoint of https://metric-api.newrelic.com/metric/v1, it must be sent to https://gov-metric-api.newrelic.com/metric/v1. The Metric API can be used directly but it's mainly used by various New Relic tools. Below are instructions showing where to edit the configuration for setting the FedRAMP endpoint. Telemetry integrations Here are instructions for our open source telemetry integrations that report metric data: Dropwizard: use the overrideUri configuration. Kamon: use the metric-ingest-url configuration. See Override endpoints. Micrometer: override the public String uri() method on your NewRelicRegistryConfig to return the new endpoint. See an example. Prometheus: Prometheus OpenMetrics: if you are using our nri-prometheus helm chart, you can change the endpoint in your values.yml file, like in this example. If you're using the nri-bundle chart, you need to nest this value under the nri-prometheus key to propagate it to the sub-chart. Remote write integration: not available. Telemetry SDKs Here are instructions for our Telemetry SDKs that report metric data: Go: use the MetricsURLOverride configuration. Java: in the MetricBatchSender section, configure the endpoint. See an example. .NET: use the MetricUrlOverride configuration. Node.js: edit the METRIC_HOST = 'metric-api.newrelic.com' configuration. Python: edit the HOST = \"metric-api.newrelic.com\" configuration. Event API To ensure FedRAMP compliance for the Event API, all traffic reporting to insights-collector.newrelic.com must instead report to gov-insights-collector.newrelic.com. The Event API endpoint is configurable for the following Telemetry SDKs. The Telemetry SDKs are used by our open-source telemetry integrations. Language Solution Java Telemetry SDK In code: SenderConfiguration configuration = SenderConfiguration .builder( \"gov-insights-collector.newrelic.com\", EventBatchSender.EVENTS_PATH) .build(); EventBatchSender eventBatchSender = EventBatchSender.create(configuration); Copy Python Telemetry SDK In code: event_client = EventClient(host=\"gov-insights-collector.newrelic.com\") Copy For more information, see our Telemetry API documentation in GitHub. Log API To ensure FedRAMP compliance for data sent via the Log API, the solution for almost all our logging tools is to replace the https://log-api.newrelic.com/log/v1 endpoint with https://gov-log-api.newrelic.com/log/v1. Here are details for various tools: Log forwarders Here are details on changing the endpoint for our log forwarders: AWS Firelens: Add the endpoint property to the options field of the logConfiguration, similar to to the EU account endpoint change shown in these Firelens endpoint configuration instructions. Fluentbit: Use our Fluentbit endpoint configuration. Fluentd: Use our Fluentd endpoint instructions. Infrastructure agent: See FedRAMP for infrastructure. Kubernetes: Our Kubernetes integration logs are based on fluentbit’s output plugin. Use these endpoint instructions. Logstash: Use our Logstash endpoint configuration. Syslog: For configuring syslog clients, see TCP endpoint configuration. S3: Not available. Vector: Not available. To use the Log API directly, you'd edit the Log API endpoint configuration. Trace API FedRAMP is not yet available for the Trace API itself, but note that some of our agents report trace data and you can enable FedRAMP for some of those agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.82927,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Metric</em> <em>API</em>",
        "body": " APM agents, infrastructure <em>agent</em>, browser <em>agent</em>, and mobile <em>agent</em>. Data-ingest APIs: for our <em>Metric</em> <em>API</em>, <em>Event</em> <em>API</em>, <em>Trace</em> <em>API</em>, and Log <em>API</em>, and the integrations that use those APIs. Agents New Relic has several agents for reporting data, like our APM agents, infrastructure agents, mobile agents"
      },
      "id": "603e945164441f64384e8872"
    },
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Tip",
        "Requirements and compatibility",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "4cc9878a6fd53a3602eedd978303457aab82ac4e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-manage-data/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-04-16T22:59:48Z",
      "updated_at": "2021-03-16T15:37:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Tip To use our Telemetry SDKs and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Requirements and compatibility To build with the Telemetry SDKs, you will need an Insights insert key. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.57114,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "sections": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "tags": "<em>Telemetry</em> Data Platform",
        "body": "Our <em>Telemetry</em> SDKs are an open source set of <em>API</em> client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the <em>Metric</em> <em>API</em>, <em>Trace</em> <em>API</em>, Log <em>API</em>, and <em>Event</em> <em>API</em>. We offer open-source integrations for <em>telemetry</em> tools like Prometheus, Istio"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "Report custom event data",
        "Important",
        "Value from custom events and attributes",
        "Avoid rate limits",
        "Send custom events and attributes",
        "Extend data retention"
      ],
      "title": "Report custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "9c787cb83d5d7d1722bcbec25f4eb8698f5be6e9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-custom-event-data/",
      "published_at": "2021-04-16T11:54:20Z",
      "updated_at": "2021-03-29T16:54:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. New Relic products report a variety of default event data to your account. This document explains how to report your own custom events and attributes. Value from custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. By reporting custom events, you can create more useful and customized queries and charts of your data. This is a key part of optimizing how New Relic works for you. Avoid rate limits Reporting a large number of custom events and/or attributes can cause degraded query performance. It may also result in approaching or passing data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser monitoring agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure monitoring agent Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile monitoring agent Use the mobile agent API to send custom events and attributes. Synthetic monitoring Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn how to extend how long events are retained in your account, see our documentation about event data retention.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.43173,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report custom <em>event</em> data",
        "sections": "Report custom <em>event</em> data",
        "tags": "<em>Event</em> data sources",
        "body": " of custom data, see: <em>Metric</em> <em>API</em> Logs <em>Trace</em> <em>API</em> Extend data retention To learn how to extend how long events are retained in your account, see our documentation about <em>event</em> data retention."
      },
      "id": "6043f0b1196a67451d960f86"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Agent APIs",
        "Telemetry SDKs",
        "APIs for sending metrics, traces, logs, and events",
        "New Relic One applications"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "3fa26c40c4e8304f45c465d5565f6b428ba085da",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-data-new-relic/getting-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-04-17T01:54:53Z",
      "updated_at": "2021-03-16T18:25:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our Telemetry Data Platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. To browse all New Relic-built tools and solutions, see New Relic integrations. Agent APIs Some of our monitoring solutions come with APIs and/or SDKs that allow you to customize the data reported and how it reports. For more information, see the relevant product: APM agent APIs Browser API Mobile API Infrastructure monitoring: the Flex integration tool Telemetry SDKs If our more curated solutions don't work for you, our open source Telemetry SDKs let you build your own solution. These SDKs are language wrappers for our data-ingest APIs (below) that let you send telemetry data to New Relic without requiring install of an agent. APIs for sending metrics, traces, logs, and events If our more curated solutions don't work for you, we also have data-ingest APIs: Trace API Event API Metric API Log API To learn about the differences between these data types, see Data types. New Relic One applications You can build entirely custom applications that reside in New Relic One and make use of any data you want. You can use existing open source New Relic One apps, or share your own with the open source community. For details, see New Relic One applications.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.68265,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>APIs</em> for sending <em>metrics</em>, <em>traces</em>, logs, and <em>events</em>",
        "tags": "<em>Telemetry</em> Data Platform",
        "body": " also have data-ingest APIs: <em>Trace</em> <em>API</em> <em>Event</em> <em>API</em> <em>Metric</em> <em>API</em> Log <em>API</em> To learn about the differences between these data types, see Data types. New Relic One applications You can build entirely custom applications that reside in New Relic One and make use of any data you want. You can use existing open source New Relic One apps, or share your own with the open source community. For details, see New Relic One applications."
      },
      "id": "603eae7b196a671ea3a83dc7"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/ranna_unthank-300x300.jpg?h=6c83441f&itok=4Mgvu_0J",
      "url": "https://newrelic.com/blog/nerdlog/open-instrumentation",
      "sections": [
        "New Relic Metrics",
        "New Relic Traces",
        "Availability and pricing",
        "Related Topics"
      ],
      "published_at": "2021-04-15T22:48:25Z",
      "title": "New Relic Open Instrumentation: APIs for New Relic One, the First Observability Platform",
      "updated_at": "2021-04-13T23:51:22Z",
      "type": "",
      "external_id": "0285a344a3eb748444ebc5848ca388ddbc53565d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Observability New Relic Open Instrumentation: APIs for New Relic One, the First Observability Platform Sep 19, 2019 • 8 min read By Ranna Unthank Jan. 27, 2020, update: We've extended our list of open source integrations built on the Telemetry SDK to include Node/TypeScript and .NET. Metrics, events, logs, and traces are the core telemetry data types that enable observability within the modern software stack. The continual maturation of DevOps and open source tooling has put developers in the driver’s seat with observability-driven instrumentation. In fact, more data than ever is available from sources within business-critical applications and infrastructure, and methods for correlating and visualizing that data in meaningful ways are just as numerous. OpenTelemetry, part of the Cloud Native Computing Foundation (CNCF), is poised to become the one standard for open source instrumentation and telemetry collection, and W3C Trace Context will become the standard for propagating trace context across process boundaries. Both of these projects are building for a future in which instrumentation and tracing becomes easier for everybody. And pre-existing projects like OpenCensus, Zipkin, Prometheus, and statsd (just to name a few) are also well established in the open source community. As software teams orient their practices around these open source APIs and standards, they need the flexibility to send metrics and trace data from a number of sources as well as from custom solutions. But this has led to a proliferation of tools from which teams are unable to achieve a single source of truth about the entities that define their systems. These issues pose real barriers to achieving true observability. At New Relic, we’re more excited than ever to say that we’re all in on the future of observability, and we believe this future holds huge promise for New Relic customers. It’s our goal to provide modern software teams a single observability platform in which they can combine log data, agent-based APM and Infrastructure data, and third-party telemetry data to create an entity-centric system of record that illuminates their entire stack. Aggregating data from disparate sources and storing it in one place provides customers with the ability to analyze, visualize, and troubleshoot their systems from a single platform. To that end, we’ve added two new APIs to support open instrumentation in the New Relic One observability platform: New Relic Metrics and New Relic Traces. Both APIs can be used directly via their HTTP endpoints or via the new Telemetry SDK, which facilitates sending telemetry data to those APIs. With these capabilities, you’ll: Deliver more complete observability. Collect metric and trace data from any number of open source, vendor-agnostic tools; and display that information alongside data gathered from New Relic instrumentation. Reduce the cost of observability. By sending your business-critical observability data to our SaaS platform, you’ll reduce the cost and operational burden of maintaining different systems for storing, querying, and viewing that data. Avoid vendor lock-in from instrumentation. Instrumentation based on open standards is more portable than vendor-specific instrumentation, so DevOps teams can focus on the value of their full observability platform—not on the value of the instrumentation alone. Embrace simplicity and transparency. Open and transparent protocols, formats, and APIs for ingesting data from any source, such as OpenTelemetry, Envoy, and Prometheus, enhance New Relic’s ability to work with data from popular open source tools. Let’s look at how this will work in New Relic: New Relic Metrics A metric is an aggregation of values collected over time, and they’re extremely useful when you know what you want to collect from a large body of data. With the New Relic Metrics API, you’ll use open source data exporters and scrapers built by New Relic, or contributed by third-party developers, to collect data already available through standard metric emitters. You can also build exporters and scrapers using our open source Telemetry SDK, which provides a language-specific, client-side interface for accepting and transforming metric data, so that it can be batched and sent to New Relic via the Metrics API. Today, we’re providing the following open source integrations built on the Telemetry SDK: Prometheus OpenMetrics integration OpenCensus exporter (Python and Go) Micrometer exporter DropWizard exporter Istio exporter The Metrics API is a simple HTTP endpoint that accepts JSON-formatted data for ingest and storage in New Relic's platform. Metrics data is stored as dimensional metric data consisting of a measurement and its associated key:value pairs. In fact, when integration with the Telemetry SDK isn’t a good option—for example, if you want more control over how the data is packaged or sent—you can send well-formed data directly to the Metrics API via HTTP. You can access this data with the New Relic One chart builder (and with the New Relic Query Language (NRQL)) to create New Relic One dashboards; or use the data in New Relic One applications. You’ll also be able to set fine-grained alerts on these metrics, with the ability to focus in on any condition defined in a NRQL alert. Note: At this time, for New Relic Metrics, the Telemetry SDK supports only Java, Go, and Python. For more specifics on the New Relic Metrics API, including details on rate limits, JSON payload format, and metrics types, see our documentation.  New Relic Traces Distributed tracing helps you find the sources of latency and errors in a distributed system by stitching together operations across all services involved in a single request. New Relic agents automatically instrument your services to time and collect information about operations and create the “spans” that make up a distributed trace. There are many tools available for instrumenting and creating tracing data. The New Relic Trace API is a new HTTP endpoint that accepts tracing data in the Zipkin JSON v2 format or the New Relic-specific format. If you’ve instrumented parts of your system with Zipkin, you can now send that tracing data to New Relic with no changes to your instrumentation. And you’ll no longer need to manage the complex, high-availability storage systems necessary for storing trace data because we do that for you! If you’re using OpenCensus or Istio, you can now use the New Relic OpenCensus exporters and Istio adapter to send tracing data created by those tools as well. And like with the Metrics API, you can also use the Telemetry SDK’s language-specific client-side interface to accept and transform trace data, so that it can be batched and sent to the New Relic Trace API. Once you’ve sent distributed tracing data to New Relic, you’ll be able to take advantage of New Relic’s powerful trace visualizations, querying capabilities, anomaly detection and analytics tools to understand and troubleshoot systems in context with the rest of their New Relic instrumented ecosystem. For more information on the New Relic Trace API, including details on the Zipkin- and New Relic-format, see our documentation. Note: At this time, for New Relic Traces, the Telemetry SDK supports only Go, Python, and Java. Availability and pricing Modern software developers widely embrace open source frameworks and tools that include built-in telemetry, and we know that. But we also know that you need one primary place where you can analyze that data. The New Relic One observability platform provides the curated and customized visualizations you need to understand your telemetry data—and the entities from which it comes—in the context of your entire business or enterprise, and it does so without requiring you to operate any additional software. New Relic Metrics and New Relic Traces provide efficient and easy integrations for getting your telemetry data into New Relic. These APIs are available to all customers on New Relic Pro or equivalent subscription plans—visit newrelic.com to find out more. Related Topics Observability By Ranna Unthank Ranna Unthank is a Principal Product Marketing Manager at New Relic. She has over 10 years of experience in product marketing and sales enablement. Her technology experience and knowledge spans from storage to server and desktop virtualization to cloud computing and modern architecture technologies. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.3784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic Open Instrumentation: <em>APIs</em> for New Relic One, the First Observability Platform",
        "sections": "New Relic <em>Metrics</em>",
        "body": " source <em>Telemetry</em> <em>SDK</em>, which provides a language-specific, client-side interface for accepting and transforming <em>metric</em> data, so that it can be batched and sent to New Relic via the Metrics <em>API</em>. Today, we’re providing the following open source integrations built on the <em>Telemetry</em> <em>SDK</em>: Prometheus"
      },
      "id": "60762e7a28ccbcdd3751c168"
    }
  ],
  "/build-apps/publish-deploy": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/attributory-screenshot-main.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-6",
      "sections": [
        "Subscribe to apps in the New Relic One Catalog",
        "Flex Manager",
        "GraphiQL Notebook",
        "Attributory",
        "What are you waiting for? Deploy these apps now.",
        "Check out these other resources for using—and building—New Relic One apps",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:26:51Z",
      "title": "The Most Popular New Relic One Applications (Roundup #6)",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "76394d24aebbff40a68e9bd6a7f867313e814d74",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #6) Jul 2, 2020 • 8 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the visibility and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source, so you can use them out-of-the-box, or submit a pull request for feedback and feature requests. In this edition, we cover three apps that help engineers do their jobs: Flex Manager GraphiQL Notebook Attributory Subscribe to apps in the New Relic One Catalog You can manage and deploy apps directly within New Relic One. To explore available apps, navigate to New Relic One and click on the New Relic One Catalog launcher. From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. If you deploy an app from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Flex Manager New Relic Flex is an application-agnostic, all-in-one tool that makes sending data to New Relic from third party sources easier than ever. Use Flex Manager to simplify the work of creating, managing, and deploying new integrations you’ve built with Flex. Fork or deploy the Flex Manager app from GitHub. Specific requirements for this app Flex Manager requires New Relic Infrastructure and the Flex integration. GraphiQL Notebook GraphiQL Notebook allows you to explore and learn about the NerdGraph—the New Relic GraphQL API—using a Jupyter Notebook style interface. Notebooks intermix GraphQL requests with data exploration links. You can create, update, save, and delete notebooks. You can also export and share notebooks as blocks of Base64-encoded JSON. Fork or deploy the GraphQL Notebook app from GitHub. Attributory Attributory is a dictionary of attributes from your APM, Browser, or Mobile applications stored in New Relic. It displays a list of attributes for each application. When you open a service or application from the entity explorer, you’ll find Attributes Dictionary listed as an application in the left-hand navigation. New Relic stores event data as key-value pairs. Built-in New Relic attributes include the definition of the attribute. For custom attributes, you can choose to add your own definitions. Fork or deploy the Attributory app from GitHub. Specific requirements for this app Applications with New Relic APM, Browser, or Mobile agents reporting into New Relic. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account Once you have these requirements in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Attributory to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One apps Here are resources to help you build your own New Relic One apps. If you can imagine it, you can build it: New Relic Developers: Build applications using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Open Source: New Relic’s open source website makes it easy for you to explore the open source projects we maintain and the open standards projects we participate in. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, review our Contributors Guide. Keep in mind that when you submit your Pull Request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 71.560165,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic One <em>Applications</em> (Roundup #6)",
        "sections": "<em>Subscribe</em> to <em>apps</em> in the New Relic One Catalog",
        "body": " to your New Relic account using the following commands: nr1 nerdpack:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;nr1-attributory.git cd nr1-attributory nr1 nerdpack:<em>publish</em> nr1 nerdpack:<em>deploy</em> -c STABLE nr1 nerdpack:<em>subscribe</em> -c STABLE Then go to the homepage of one.newrelic.com and select the <em>app’s</em> launcher"
      },
      "id": "60762e1e28ccbcb5fd51c147"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/4x5_600w/public/2021-03/Natalie_Serrino%20FS21.jpg?h=2e0f227d&itok=xI5aRyVf",
      "url": "https://newrelic.com/futurestack/speakers/natalie-serrino",
      "sections": [
        "Natalie Serrino",
        "Sessions with Natalie Serrino",
        "Kubernetes-Native Observability Without Instrumentation",
        "Meet Our Speakers",
        "Paras Wadehra",
        "Jonathan Karon",
        "Dan Rufener",
        "Jonathan Thurman",
        "JD Weiner",
        "Aaron Judy",
        "Scot Gorman",
        "Anthony Pounds-Cornish",
        "Jemiah Sius",
        "Danny Roessner",
        "Sam Aaron",
        "Matt Shandera",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-16T04:26:28Z",
      "title": "Natalie Serrino | New Relic",
      "updated_at": "2021-04-16T04:26:28Z",
      "type": "",
      "external_id": "b07751ac88fb8968451d9e1aed356d4ff8b4e0e6",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item Natalie Serrino Principal Software Engineer, New Relic Sessions with Natalie Serrino 10:15 am - 11:15 am PT | Wednesday, May 26 | Hands-on Workshop Kubernetes-Native Observability Without Instrumentation Learn how to get visibility into your Kubernetes cluster and apps with no-instrumentation data collection, allowing you to debug in minutes. No need to update, recompile, or deploy your apps - it just works. (Join this session for live chat OR watch on-demand immediately after) Meet Our Speakers Paras Wadehra New Relic Learn more Jonathan Karon New Relic Learn more Dan Rufener New Relic Learn more Jonathan Thurman New Relic Learn more JD Weiner Forbes Media LLC Learn more Aaron Judy Maricopa County Clerk of the Superior Court Learn more Scot Gorman Chegg Learn more Anthony Pounds-Cornish Cognitran Learn more Jemiah Sius New Relic Learn more Danny Roessner WellSky Learn more Sam Aaron Sonic Pi Learn more Matt Shandera New Relic Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 48.819485,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", May 26 | Hands-on Workshop Kubernetes-Native Observability Without Instrumentation Learn how to get visibility into your Kubernetes cluster and <em>apps</em> with no-instrumentation data collection, allowing you to debug in minutes. No need to update, recompile, or <em>deploy</em> your <em>apps</em> - it just works. (Join"
      },
      "id": "6042d15ce7b9d2c6cc579a0e"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Figure8-e1570028252480.png",
      "url": "https://newrelic.com/blog/best-practices/what-is-serverless-architecture",
      "sections": [
        "What is serverless architecture?",
        "What are the advantages of using serverless architecture?",
        "Decomposing drives better observability",
        "Serverless is event-based",
        "Faster deployments, greater flexibility, and accelerated innovation",
        "Reducing architecture costs",
        "Focusing more on UX",
        "What are the limitations of using serverless architecture?",
        "Long-running application inefficiencies",
        "Third-party dependency",
        "Cold starts",
        "Is serverless architecture for you?",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:26:29Z",
      "title": "What Is Serverless Architecture? Key Benefits and Limitations",
      "updated_at": "2021-04-13T23:36:03Z",
      "type": "",
      "external_id": "e2071d6d8b01e362ac308565b88598fce2d04ac3",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Cloud What Is Serverless Architecture? Key Benefits and Limitations Aug 28, 2020 • 6 min read By Nočnica Fee As organizations and their technology ecosystems mature, they often find that managing architecture is a challenge. Rather than becoming professionals at managing a platform, software teams would rather devote their time and resources to applications and development. The new alternative is serverless architecture. But what is serverless architecture? And is it the right move for you? What is serverless architecture? Serverless architecture describes a way for companies to build and run applications but not have to manage infrastructure. It provides a way to remove architecture responsibilities from your workload, including provisioning, scaling, and maintenance. Scaling can be automatic, and you only pay for what you use. Since the development of this new technology, we’ve seen substantial growth through Amazon Web Services (AWS). A recent O’Reilly survey found that 40 percent of organizations adopted serverless architecture. The main reasons behind the adoption include reduced costs, scalability, developer productivity, and more, per the chart below. Image courtesy of OReilly.com. Not everyone is ready to go all-in with serverless. The study found concerns around security, fear of the unknown, and not having the right staff. That last concern deserves to be highlighted: even though serverless should be “easier,” it still takes team expertise to be competent in a new tool. Let’s look specifically at the benefits and limitations of serverless architecture. What are the advantages of using serverless architecture? The leading advantage is that your developers can focus their attention on product development. They no longer have to account for managing and operating servers. Components like network configuration or the physical security of your servers are handled by the vendor rather than your team. Many other benefits come from serverless architecture as well. Decomposing drives better observability With serverless, you break down applications into smaller and smaller pieces, known as decomposition. By doing so, you’ll gain better observability across the application. With smaller pieces, the knowledge necessary to make changes or create fixes is smaller. Serverless is event-based Serverless uses an event-based system versus stream-based. With event-based architecture, each subpart of the application is independent. Events trigger one another. In stream-based, there are connections to each service. If there is a failure, it just impacts that event, not the entire log. Faster deployments, greater flexibility, and accelerated innovation Speed is often a contributing factor in choosing to use a serverless architecture. You can rapidly deploy apps in hours because there’s no infrastructure construction to weigh you down. With faster deployments also comes ease in scalability. By using such an agile architecture, you can be very flexible in your releases. Because it’s a quicker process, you can accelerate innovation. This flexibility is especially valuable in situations where pivoting is urgent. These types of scenarios are playing out all over the world in response to the pandemic. Organizations have to change their focus to meet emerging needs. This could be internal with a move to remote work. Another example is the adoption of customer-facing applications like those of retailers and restaurants. Reducing architecture costs Being serverless, an organization is essentially outsourcing server and database management. You are no longer responsible for the huge investments required for internal architecture administration. Ultimately your use case will define how much you can save. Focusing more on UX If your applications have end users, which they probably do, they have high expectations around digital experiences. If architecture is no longer a concern, it leaves more time to work on the user experience (UX). You can’t afford to not invest in the user interface, so serverless can provide you with a way to reallocate resources. What are the limitations of using serverless architecture? Serverless architecture isn’t perfect. It’s still an evolving architecture, leaving some not ready to adopt. Long-running application inefficiencies Running workloads, which are long-running, could be more costly on serverless. Using a dedicated server is often more efficient. Third-party dependency Serverless architecture requires you to be reliant on your provider. You don’t have full control, and changes may impact you without notice. The platform’s availability is subject to its terms. Cold starts A “cold start” occurs when a platform must initiate internal resources. It may take some time for your serverless architecture to handle that first function request. You can avoid a “cold start” by ensuring the function remains in an active state. You do this by sending requests to it periodically. Is serverless architecture for you? Serverless architecture is just one more option for deploying applications. Being able to monitor and troubleshoot serverless is also critical. Explore how we make this possible with New Relic Serverless for AWS Lambda. Get a serverless overview and a free trial. Related Topics Cloud By Nočnica Fee Nočnica Fee is a Dev Advocate for New Relic specializing in serverless. She's a frequent contributor to The New Stack and Dev.to. In her downtime, she enjoys drum machines and woodworking. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 36.3019,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Faster <em>deployments</em>, greater flexibility, and accelerated innovation",
        "body": ", not the entire log. Faster deployments, greater flexibility, and accelerated innovation Speed is often a contributing factor in choosing to use a serverless architecture. You can rapidly <em>deploy</em> <em>apps</em> in hours because there’s no infrastructure construction to weigh you down. With faster deployments also"
      },
      "id": "60762ae3196a675ccd64a76a"
    },
    {
      "sections": [
        "Install New Relic Node.js agent in GAE flexible environment",
        "Use native deploy",
        "Build a custom runtime",
        "1. Set up the GAE project and install dependencies",
        "2. Configure your app.yaml",
        "3. Configure and deploy",
        "Optional: Disable health checks",
        "Get New Relic agent troubleshooting logs from GAE"
      ],
      "title": "Install New Relic Node.js agent in GAE flexible environment",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Hosting services"
      ],
      "external_id": "28df1194ff848b2c26e5c966843d2bf5f0adbf9e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/hosting-services/install-new-relic-nodejs-agent-gae-flexible-environment/",
      "published_at": "2021-04-16T09:09:51Z",
      "updated_at": "2021-03-11T07:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's Node.js agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. This document explains how to add New Relic to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Use native deploy To use Google App Engine's \"native mode\" installation with your Node.js app: Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. Optional: Set environment variables to configure the Node.js agent's GAE app.yaml file. Use the Google Cloud SDK's gcloud command line tool to deploy GAE apps. To deploy your Node.js app to your initialized GAE flexible environment, run the following command: gcloud --project new-relic-apm-nodejs app deploy Copy Google App Engine automatically includes your Node.js app's newrelic.js configuration file in the deployed package. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by building a custom runtime for Docker. You can deploy the app without any special configuration. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Google App Engine's documentation for Node.js Google App Engine's tutorial to deploy a Node.js app 1. Set up the GAE project and install dependencies Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Copy Optional: Set environment variables. 3. Configure and deploy The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. To create the Dockerfile, build the container, and deploy your app, follow the GAE procedures for Node.js. Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Optional: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in New Relic APM. If you notice performance issues, disable GAE health checks. In your app.yaml, add: health_check: enable_health_check: False Copy Get New Relic agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect New Relic Node.js agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.js configuration file to: log_file_name: STDOUT Copy To view the logs, use the Cloud Platform Console's Log Viewer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 32.037834,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use native <em>deploy</em>",
        "body": ". This document explains how to <em>add</em> New Relic to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime Use native <em>deploy</em> To use Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with your"
      },
      "id": "6043d8da28ccbc08242c60a6"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/deployment_marker_service_map.jpg",
      "url": "https://newrelic.com/blog/best-practices/distributed-monolith-vs-microservices",
      "sections": [
        "Question 1: Does a change to one microservice require changes to or deployments of other microservices?",
        "Question 2: Are your microservices overly chatty?",
        "Question 3: Do several microservices share a datastore?",
        "Question 4: Do my services scale dynamically?",
        "Be honest in your answers",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:26:29Z",
      "title": "Distributed Monolith vs. Microservices Architecture: 4 Ways New Relic Can Tell You Which Is Which",
      "updated_at": "2021-04-14T00:47:16Z",
      "type": "",
      "external_id": "f0804c58a20b23addd0db35e199e9b1e0dbd27fa",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Cloud Distributed Monolith vs. Microservices Architecture: 4 Ways New Relic Can Tell You Which Is Which Jun 19, 2018 • 7 min read By Chris McCarthy As more and more software organizations adopt DevOps processes and culture, a major initiative they commonly undertake is breaking their monoliths into microservices. However, even after organizations have put in a considerable amount of work, it sometimes turns out that these monoliths weren’t actually turned into collections of microservices so much as they became “distributed monoliths.” In You’re Not Actually Building Microservices (a post that inspired me to write this one), SimpleThread’s Justin Etheredge writes that a distributed monolith is the “worst of all worlds. You’ve taken the relative simplicity of a single monolithic codebase, and you’ve traded it in for a deeply intertwined distributed system.\" So, how do you tell if you actually have a true microservices architecture or just a distributed monolith? Let’s walk through four questions to see how New Relic can help you find out. Keep in mind, though, that while these questions will give you insight into the true nature of your systems, the final answer may not always be clear-cut exceptions—after all, modern software is nothing if not complicated. Question 1: Does a change to one microservice require changes to or deployments of other microservices? A major benefit of microservices is the decoupling of development and deployment. In a true microservices architecture, a team can make changes (within reason) to the service they own without having to communicate those changes to other upstream or downstream teams responsible for other services. If your team does synchronized deployments or creates pull requests across multiple services to make a change to your service, you’re not really running decoupled microservices. A examination of your deployment processes or version control strategy can provide an immediate answer to this question. You can also get a good idea of service interdependencies by looking at deployment markers in New Relic service maps. Application deployment markers shown in a service map If you see deployment markers lining up across the multiple services in your map, you haven’t effectively decoupled your services. To monitor deployment dependencies in New Relic Insights, record your deployments as custom events using the New Relic rest API (v2) and insert those custom events via the Insights API. Then build an NRQL query to create a widget for your Insights dashboard. If your widget shows spikes of many deploys occurring simultaneously, that’s a sign of poor decoupling. Ideally, in a microservice architecture, you deploy apps using continuous integration and continuous delivery (CI/CD), in which case the graphs in your widget will appear chaotic, rather than organized. Question 2: Are your microservices overly chatty? Each microservice should have a clearly defined purpose that it can execute with minimal communication with other services. If you see a service that has to send many back-and-forth requests to the same downstream services, that’s a red flag. Use New Relic APM to look at the central service in question and examine its interaction with external services. APM external services page A distributed monolith can actually perform pretty well, and may never experience significant issues with response times. With that in mind, we typically want to examine services by highest throughput. If the number of calls per minute (cpm) for a given external service is greater than the throughput of the application itself by a large factor, you most likely have not decoupled your services. You can also investigate this on a per-transaction level in APM. The same logic applies here—if the average calls per transaction is greater than 2 or 3 calls per external service, that’s a good sign of “chattiness” and poor decoupling. APM Breakdown table showing per-transaction external calls For larger and more complex environments, use New Relic Insights to monitor external call counts across all your applications. To create a widget to track external calls made by each of your applications over time, use this NRQL query: SELECT average(externalCallCount) FROM Transaction FACET appName SINCE 1 week ago TIMESERIES To create a widget to track all external calls made by each of your applications, use this NRQL query: SELECT max(externalCallCount) FROM Transaction FACET appName SINCE 1 week ago It’s important to remember that some microservices (such as payment gateways) can record a lot of external calls because of the function they perform. If you identify such services in your environment, just filter them out in the NRQL queries for these widgets: SELECT max(externalCallCount) FROM Transaction WHERE appName != “name-of-payment-gateway” FACET appName SINCE 1 week ago Question 3: Do several microservices share a datastore? Even a set of microservices that appears to be well separated can fall prey to this problem. It’s typical that most of a monolith’s services will use the same datastore. But this should not be the case in a distributed microservices architecture. In a microservices architecture, shared datastores create deployment problems and database contention issues; and schema changes can create problems for the services communicating with the database. Therefore, each service should have its own datastore. As with tracking interdependent deployments for services, you can use service maps to discover the dependencies between services and datastores. Service map showing one datastore per app In this case, we see that each service in our WebPortal app has its own datastore. This greatly simplifies deployment and data management for each service. With New Relic, you can monitor your databases using New Relic Infrastructure on-host integrations. If, for example, your application is running in Amazon Web Services (AWS) and uses the Amazon Relational Database Service (RDS), you can use New Relic’s AWS RDS integration to monitor this information and create a widget using this NRQL query: SELECT uniqueCount(appName)/uniqueCount(entityName) as 'Applications per Datastore' FROM DatastoreSample,Transaction SINCE 1 week ago (Note that the DataStoreSample datatype in this example is unique to AWS RDS. If you’re hosting your services in Microsoft Azure, for example, you could use an Azure monitoring integration and the AzureSqlDatabaseSample datatype. Or see the Infrastructure integrations documentation for other databases we integrate with.) Question 4: Do my services scale dynamically? One of the main reasons to use microservices is to isolate bottlenecks to small units that may be scaled independently as needed, rather than having to scale your entire architecture. A healthy microservices deployment should be very dynamic, with throughput swings resulting in non-uniform scaling across the services. For example, for a spike in global throughput, I’d expect to see certain applications (the bottlenecks) scaling up more rapidly than, say, a payment gateway service that serves as a request router and includes little logic. You can use Insights to determine if your services do scale dynamically. A couple of widgets that monitor throughput per application and hosts per application are a good way to start. To create a widget to track throughput per application, use this NRQL query: SELECT count(*) FROM Transaction FACET appName TIMESERIES since 1 month ago To create a widget to track hosts per application, use this NRQL query: SELECT count(*) FROM Transaction FACET host TIMESERIES since 1 month ago In a full microservices architecture, you should see spikes in services populating on hosts correspond to spikes in throughput on individual services, which would indicate dynamic scaling of services. If instead you see corresponding spikes across all services and hosts, this is good indication that your services aren’t truly decoupled. Be honest in your answers If your system is able to cleanly pass all these checks, it may very well be a fully functioning microservices architecture. If one or more of these questions raise red flags for you, however, it may be time to re-evaluate or redesign your approach to properly tame the complexity of microservices. This programatic shift requires that you not only build this architecture piece by piece but that you also never stop developing it. Related Topics Cloud By Chris McCarthy Chris McCarthy is a solutions engineer at New Relic. He began his career as a backend and performance engineer and now uses his background to advise New Relic customers in their cloud migrations or their cultural shifts to DevOps. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 30.820358,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Question 1: Does a change to one microservice require changes to or <em>deployments</em> of other microservices?",
        "body": ", that’s a sign of poor decoupling. Ideally, in a microservice architecture, you <em>deploy</em> <em>apps</em> using continuous integration and continuous delivery (CI&#x2F;CD), in which case the graphs in your widget will appear chaotic, rather than organized. Question 2: Are your microservices overly chatty? Each"
      },
      "id": "60763b94196a67d93664a76b"
    }
  ],
  "/collect-data/custom-events": [
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "Important",
        "General requirements",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "ee49e0ca9bf17447e8349123bfb470ff9964c4fe",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-04-16T15:03:36Z",
      "updated_at": "2021-03-30T06:37:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.41547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data requirements and limits for <em>custom</em> <em>event</em> data",
        "sections": "Data requirements and limits for <em>custom</em> <em>event</em> data",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " <em>Event</em> <em>API</em> (There are additional requirements when using the <em>Event</em> <em>API</em>.) Browser monitoring <em>agent</em> <em>APIs</em> (There are additional requirements with the <em>custom</em> PageAction <em>event</em>.) Mobile monitoring SDK General requirements When reporting <em>custom</em> <em>events</em> and attributes, follow these general requirements"
      },
      "id": "6043ef69e7b9d2da1f5799f8"
    },
    {
      "sections": [
        "Report custom event data",
        "Important",
        "Value from custom events and attributes",
        "Avoid rate limits",
        "Send custom events and attributes",
        "Extend data retention"
      ],
      "title": "Report custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "9c787cb83d5d7d1722bcbec25f4eb8698f5be6e9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-custom-event-data/",
      "published_at": "2021-04-16T11:54:20Z",
      "updated_at": "2021-03-29T16:54:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. New Relic products report a variety of default event data to your account. This document explains how to report your own custom events and attributes. Value from custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. By reporting custom events, you can create more useful and customized queries and charts of your data. This is a key part of optimizing how New Relic works for you. Avoid rate limits Reporting a large number of custom events and/or attributes can cause degraded query performance. It may also result in approaching or passing data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser monitoring agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure monitoring agent Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile monitoring agent Use the mobile agent API to send custom events and attributes. Synthetic monitoring Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn how to extend how long events are retained in your account, see our documentation about event data retention.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.88312,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>custom</em> <em>event</em> data",
        "sections": "Value from <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " policy. Send <em>custom</em> <em>events</em> and attributes Methods for sending <em>custom</em> <em>events</em> and attributes include: Source How to send <em>custom</em> data APM <em>agent</em> Use APM <em>agent</em> <em>APIs</em> to report <em>custom</em> <em>events</em> and <em>custom</em> attributes. Browser monitoring <em>agent</em> Add <em>custom</em> attributes to the PageView <em>event</em> via the Browser <em>API</em> call"
      },
      "id": "6043f0b1196a67451d960f86"
    },
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Important",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "9a5edf6068acc3b7187d217bd7932f0478e5467c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-04-16T15:03:37Z",
      "updated_at": "2021-03-30T06:37:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your New Relic APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.30418,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "sections": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " using the <em>Event</em> <em>API</em> (without need for APM). However, be aware that <em>custom</em> <em>events</em> sent with the <em>agent</em> <em>APIs</em> are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding <em>custom</em> data with the APM <em>agent</em> <em>API</em>. Or, go directly to the full online course"
      },
      "id": "603ecece28ccbcc865eba7a0"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Important",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute Browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "cabf27e5367fcf6473d105983c030b653e3bd9c7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-04-16T14:02:57Z",
      "updated_at": "2021-03-29T16:54:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the Browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Subscription level This feature requires a Browser Pro subscription. The instrumentation level setting for an application does not affect the availability of JavaScript API functions. Agent version Your New Relic Browser agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 60 events per 30-second harvest cycle, per browser. After the 60-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the Browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default Browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute Browser API call To add a custom attribute to the PageView event via the Browser agent, use the setCustomAttribute Browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual Browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.02582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " add to the PageView <em>event</em> are also automatically added to the PageAction <em>event</em>. There are two ways to add <em>custom</em> attributes to the PageView <em>event</em>: Use set<em>Custom</em>Attribute Browser <em>API</em> call To add a <em>custom</em> attribute to the PageView <em>event</em> via the Browser <em>agent</em>, use the set<em>Custom</em>Attribute Browser <em>API</em>"
      },
      "id": "6043ebbee7b9d227105799b2"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Important",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations",
        "Deprecated methods"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "dba656da4a2978b01b6647a4a0011d08e6b9c4a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-04-16T15:40:11Z",
      "updated_at": "2021-03-29T16:54:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default Mobile events using the New Relic Mobile SDK. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple Mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the Mobile crash event trail. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default Mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations. Deprecated methods As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create custom events. The recordEvent methods for Android and iOS are deprecated. The deprecated recordEvent events do not have their own event type; they are recorded as a Mobile event type with a category attribute value of custom. recordCustomEvent creates an event with an eventType you can assign. But the eventType should only be used for one or two high-level event types, not for naming events. For example, you might have one event type Gestures, with many different names under that one type. For more context on this, see the recordCustomEvent query example.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.02582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " and MobileHandledException <em>events</em>. These <em>events</em> are available for querying and also displayed in the Mobile crash <em>event</em> trail. For more on creating <em>custom</em> attributes and <em>custom</em> <em>events</em>, see: Android SDK <em>API</em> guide iOS SDK <em>API</em> guide NRQL query examples MobileRequestError examples MobileRequest examples Limits"
      },
      "id": "6043ee0de7b9d21975579a25"
    }
  ],
  "/try-our-apis": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/graphql_aws_services-1024x593.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/graphql-api",
      "sections": [
        "Using GraphQL in New Relic",
        "Example 1: Querying Infrastructure cloud integrations with NerdGraph",
        "Example 2: Modifying integration configurations with NerdGraph",
        "Transfering NerdGraph data to the terminal",
        "New Relic and GraphQL—easing the path for developers"
      ],
      "published_at": "2021-04-16T04:24:43Z",
      "title": "Getting Started With NerdGraph—The New Relic GraphQL API Explorer",
      "updated_at": "2021-04-14T00:03:23Z",
      "type": "",
      "external_id": "381e6b1a3bca81ebc8b6efc8199d2b75983befca",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Getting Started With NerdGraph—The New Relic GraphQL API Explorer Jun 11, 2020 • 12 min read By Mark Weitzel As you build observability into your workflows and processes, you need the ability to quickly retrieve, sort, and process all kinds of telemetry through APIs. With New Relic, you can gather a lot of data, but when you’re building dashboards and applications for working with your data, you want to minimize superfluous API operations. With the NerdGraph API explorer—built on GraphQL—you can more easily query the data you need, without over-or under-fetching, and reduce manual toil in your data analysis workflows. More specifically, in New Relic you can use NerdGraph to: Query all the entities associated with your account Query, create, and update the workloads associated with your account Create, manage, and add tags to entities Query distributed tracing data Fetch data when building a New Relic One application Understand upstream and downstream relationships with your services Configure your New Relic Infrastructure cloud integrations Query event data and custom event data with NRQL In this post, I’ll walk through two examples using NerdGraph to query information about New Relic Infrastructure cloud integrations and update their configuration values. But first a bit of history. Using GraphQL in New Relic Unlike typical REST APIs that often require loading from multiple endpoints, GraphQL provides a single endpoint that can manage complex queries so developers can get all the data their app needs from many services in one request. GraphQL is strongly typed, which allows developers to explicitly declare what information is available via queries to the GraphQL service. This declaration is done via a GraphQL schema. Schemas give developers the flexibility they need to express information about the data they return. For example, each field has a description, which developers can use to indicate the proper usage of the data. Schemas also provide the API blueprint developers need to build tools for properly constructing queries and guiding proper usage of any returned data. For example, developers can use the schema to indicate if a field has been deprecated so tools like IDEs can surface this fact and discourage use of that data. And “schema stitching”—creating a single schema from several underlying GraphQL APIs—allows developers to deliver a unified access experience across all of their APIs, as we’ve done at New Relic: The New Relic GraphQL implementation includes several underlying GraphQL APIs—including accounts, Infrastructure, and the New Relic database (for constructing NRQL queries). For more information on GraphQL, the following examples of querying cloud integration configuration data use GraphQL queries and mutations: Queries: GraphQL requests that only fetch data Mutations: GraphQL requests that modify and fetch data NerdGraph has a single endpoint: https://api.newrelic.com/graphiql. This launches (after authenticating the user) the NerdGraph API interface—an interactive, browser-based IDE for running GraphQL requests. In the NerdGraph API explorer, you build and run your query on the left, and the result is returned on the right. You can click into fields to drill into their definitions. For example, if you drill into actor, you’ll see it contains fields for user and accounts: { actor { user { name email } accounts { id name } } } The fields under actor expose data from different downstream services that are unified in the GrahQL schema delivered by the GraphQL server. When you issue a query, the GraphQL server pulls apart the query and invokes a resolver for each of the services. When the queries complete (or time out or encounter errors), the GraphQL server assembles the result and returns it to you. In the example above, we get information about the user and all the accounts that they have access to. Let’s walk through our examples to show the full power of GraphQL’s data collection capabilities. Example 1: Querying Infrastructure cloud integrations with NerdGraph In my first example, I’ll use NerdGraph to query for various data about the AWS integrations that are running in my New Relic account. I’ll use the data I gather in this example to update some specific settings in the next section. Tip: If you’re planning on following along, make sure you generate an API key that you can use with New Relic’s GraphQL API. In fact, you can generate one directly from NerdGraph. Let's start with a list of the AWS integrations I have available in New Relic Infrastructure: AWS integrations installed in New Relic Infrastructure. Next, let's retrieve some information about these AWS services via a GraphQL query. I’m going to query for the cloud provider (in this case, AWS) that’s linked to my account and the set of integrations from AWS that I’ve installed. To do this, I need to pass the ID of the account I want to query—this is the account(id: MY ACCOUNT ID) part of the query. Notice that I’m “nesting” requests to get information about the cloud provider and the integrations I’m using. If I were using a REST API, this would require multiple calls, but with the GraphQL API, I can gather this information with just one query.   { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { id name slug } integrations { id name service { id slug name createdAt updatedAt provider { name id } } } } } } } } When the query completes, the GraphQL server assembles the results about the AWS integrations I’ve installed, as shown below (note that I’ve truncated the example): { \"data\": { \"actor\": { \"account\": { \"cloud\": { \"linkedAccounts\": [ { \"authLabel\": \"arn:aws:iam::8xxxxxxx7:role/NewRelicInfrastructure-Integrations-Origami\", \"externalId\": \"8xxxxxxx7\", \"id\": 3542, \"integrations\": [ { \"id\": 75540, \"name\": \"RDS\", \"service\": { \"createdAt\": 1470991744, \"id\": 3, \"name\": \"RDS\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"rds\", \"updatedAt\": 1534242454 } }, { \"id\": 14233, \"name\": \"S3\", \"service\": { \"createdAt\": 1470991745, \"id\": 4, \"name\": \"S3\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"s3\", \"updatedAt\": 1534242454 } }, { \"id\": 12223, \"name\": \"Lambda\", \"service\": { \"createdAt\": 1477910055, \"id\": 14, \"name\": \"Lambda\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"lambda\", \"updatedAt\": 1534242454 } }, { \"id\": 172534, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 } }, } } ] } } } } } But what if I want more specific information about one of the integrations? Specifically, I want to see what tags (user-defined metadata) I’ve applied to a particular integration as well as its metrics polling interval (how often New Relic polls the integration for data), and when these settings were last updated. To do this, I’ll need to use one of the more nuanced features of GraphQL—interfaces, an abstract type that represents a collection of common fields that other object types can implement. So in my original query, I’ll add two new clauses: ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } Now, if my query hits a result that is of type CloudDynamodbIntegration or CloudReshiftIntegration, it also return the fields metricsPollingInterval, tagKey, tagValue, and updatedAt. Here's what my (truncated) query will like now: { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { ... } integrations { id name service { ... } } ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } } } } } } In the result, notice that the DynamoDb and Redshift configuration information contain the extra fields that I specified in the query using their interfaces. { \"id\": 173397, \"metricsPollingInterval\": 900, \"name\": \"Redshift\", \"service\": { \"createdAt\": 1497364366, \"id\": 21, \"name\": \"Redshift\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"redshift\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1544435410 }, { \"id\": 112183, \"metricsPollingInterval\": 900, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1549499902 }, OK! I’ve successfully queried information about my AWS integrations in New Relic Infrastructure, and I’ve used an interface to get additional information about a specific integration. Now, I’ll use the GraphQL API to update the metrics data polling intervals in one of these integrations. Example 2: Modifying integration configurations with NerdGraph In GraphQL, when you modify data with a write operation, it’s called a mutation. In this example, I’ll build a mutation to update the polling intervals of an AWS integration. First, though, I’ll set a polling interval so that we'll notice when I change it with NerdGraph. Here are the configuration options for my AWS DynamoDB integration: DynamoDB integration configuration options in New Relic Infrastructure. As you can see, I’ve set the metrics data and inventory data polling intervals to every 5 minutes, and I’ve also toggled Collect tags to ON. Now I’ll build the mutation query. First, I'll start with the keyword mutation, and like any GraphQL API request, enclose it in a pair of curly braces,{ }. Next, I want to specify that I’m configuring a cloud integration; so I’ll add cloudConfigureIntegration, which takes two arguments: accountId and integrations. For accountId, I’ll use the same account id from the first example to get information about the Infrastructure-linked accounts. The second argument is the integrations that I want to update. Again, integrations are specified by cloud provider, so here I want to include aws. So far my mutation looks like this: mutation{ cloudConfigureIntegration( accountId:MY ACCOUNT ID integrations:{aws I want to specify that I’m updating the configuration for DynamoDB, so I’ll pass in an object with dynamodb as the key and an array that contains objects with the values I want to to set. Remember, for our mutation, we want to update the metricsPollingInterval (valid values are 300, 900, 1800, and 3600 seconds) and add a tagKey (metadata about the function of the integration). The final part of the mutation adds a set of fields to return if my request is successful and a set of fields to return if there are any errors. Here's the full query: mutation{ cloudConfigureIntegration( accountId:630060 integrations:{aws:{ dynamodb:[ { linkedAccountId:4912 metricsPollingInterval:1800 tagKey:\"mdw-test\" }] } } ) { integrations{ id name updatedAt ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } errors{ linkedAccountId message integrationSlug } } } And here’s the result, which shows no errors and indicates DynamoDB’s configuration was successfully updated: { \"data\": { \"cloudConfigureIntegration\": { \"errors\": [], \"integrations\": [ { \"id\": 177184, \"metricsPollingInterval\": 1800, \"name\": \"DynamoDB\", \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1551139957 } ] } } } I can now return to New Relic Infrastructure and refresh the DynamoDB configuration page: Refreshing the DynamoDB configuration in New Relic Infrastructure. Our mutation changed the metric polling interval from 300 seconds (5 minutes) to 1800 seconds (30 minutes), and entered tag key value of mdw-test. That's it! I've successfully updated the configuration of a New Relic Infrastructure integration using NerdGraph. Transfering NerdGraph data to the terminal So, now you know how to explore the New Relic data available to you in NerdGraph, and you know how to create queries and mutations, but how do you transfer this data to your code? To capture code-ready queries and mutations, select the Tools drop down in the NerdGraph explorer. To copy a curl statement with the in-scope query to your clipboard, select Copy as CURL. Paste this code snippet into your terminal, or use it to populate an HTTP request in your code. If you’re working with the New Relic CLI, select Copy as New Relic CLI from the drop down to generate a command-line ready query or mutation. New Relic and GraphQL—easing the path for developers As these examples show, GraphQL is extremely flexible and lightweight, and dramatically reduces the overhead of working with your New Relic data. If you want to challenge yourself even more, create some more complex queries in the Query Builder. For example, can you create a query to grab the count of all of your reporting entities? Hint: check out NerdGraph’s entity search field. We’re passionate about making life for developers as easy as possible. Check out the resources available at developer.newrelic.com, and engage in the discussion with fellow developers on the Explorer’s Hub. By Mark Weitzel Mark Weitzel is General Manager, New Relic One at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 480.74908,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Started With <em>NerdGraph</em>—The <em>New</em> <em>Relic</em> <em>GraphQL</em> <em>API</em> Explorer",
        "sections": "Using <em>GraphQL</em> in <em>New</em> <em>Relic</em>",
        "body": " to quickly retrieve, sort, and process all kinds of <em>telemetry</em> through <em>APIs</em>. With <em>New</em> <em>Relic</em>, you can gather a lot of data, but when you’re building dashboards and applications for working with your data, you want to minimize superfluous <em>API</em> operations. With the <em>NerdGraph</em> <em>API</em> explorer—built on <em>GraphQL</em>"
      },
      "id": "6076314c64441f483e9d8576"
    },
    {
      "sections": [
        "NerdGraph cloud integrations API tutorial",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph cloud integrations API tutorial",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-04-16T14:50:03Z",
      "updated_at": "2021-04-12T04:27:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to https://api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } }</integration_slug></provider_slug> Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } }</integration_slug></provider_slug> Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 412.74664,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> cloud integrations <em>API</em> tutorial",
        "sections": "<em>NerdGraph</em> cloud integrations <em>API</em> tutorial",
        "tags": "<em>APIs</em>",
        "body": "This document provides examples of how to use <em>New</em> <em>Relic</em> <em>NerdGraph</em> to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud <em>Platform</em> (GCP). Using the <em>NerdGraph</em> Graphi<em>QL</em> explorer, you can also query NRQL data. These examples for querying"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/16x9_600w/public/2021-04/iStock-842120096-2-min_6.jpg?h=77039d24&itok=FcAtK923",
      "url": "https://newrelic.com/blog/authors/mark-weitzel",
      "sections": [
        "Mark Weitzel",
        "All Posts From Author",
        "New Capabilities to Extend Development On New Relic One",
        "Getting Started With NerdGraph—The New Relic GraphQL API Explorer",
        "New Relic One: The First Programmable Observability Platform"
      ],
      "published_at": "2021-04-16T04:25:53Z",
      "title": "Mark Weitzel | New Relic",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "af07ee0bdcb27ea325c9c5262f7f935b4865f7cd",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Mark Weitzel Mark Weitzel is General Manager, New Relic One at New Relic. All Posts From Author Extend New Relic New Capabilities to Extend Development On New Relic One Mar 30, 2020 • 4 min read Read the article How to Relic Getting Started With NerdGraph—The New Relic GraphQL API Explorer Jun 11, 2020 • 12 min read Read the article Extend New Relic New Relic One: The First Programmable Observability Platform Sep 19, 2019 • 9 min read Read the article Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 402.2917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Mark Weitzel | <em>New</em> <em>Relic</em>",
        "sections": "Getting Started With <em>NerdGraph</em>—The <em>New</em> <em>Relic</em> <em>GraphQL</em> <em>API</em> Explorer",
        "body": " the article How to <em>Relic</em> Getting Started With <em>NerdGraph</em>—The <em>New</em> <em>Relic</em> <em>GraphQL</em> <em>API</em> Explorer Jun 11, 2020 • 12 min read Read the article Extend <em>New</em> <em>Relic</em> <em>New</em> <em>Relic</em> One: The First Programmable Observability <em>Platform</em> Sep 19, 2019 • 9 min read Read the article Company Careers and Culture Partner Program Investor"
      },
      "id": "60762e1e64441fc25b9d854d"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/muting_alerts4-1024x788.png",
      "url": "https://newrelic.com/blog/nerdlog/muting-rule-new-relic-alerts",
      "sections": [
        "What is a muting rule?",
        "How muting rules work",
        "How to set up a muting rule",
        "Creating complex rule filters",
        "Creating and managing muting rules with NerdGraph",
        "Try it now!"
      ],
      "published_at": "2021-04-16T04:26:20Z",
      "title": "Muting Rules Now Available in New Relic Alerts",
      "updated_at": "2021-04-13T23:56:45Z",
      "type": "",
      "external_id": "dbbcbffafdf0cbc54b4bd8b29149919115187a5f",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Nerdlog Muting Rules Now Available in New Relic Alerts Jun 8, 2020 • 7 min read By Brian Goleno During times of planned system disruptions, a steady stream of noisy, unnecessary alerts can be a major distraction. You need to find a balance that allows you to filter out the noise yet still maintain observability and alerting on the rest of your system. With muting rules in New Relic Alerts, you can silence notifications during planned disruptions like maintenance windows, deployments, and testing. By applying muting rules, you’ll minimize the risks of overmuting by creating rules that identify violations using all of the contextual metadata we know about the entity and signal, which provides more depth than merely enabling or disabling alert conditions. This way, you can target your system’s specific subsets that are being affected by planned disruptions. Additionally, by keeping alert conditions running but silent during these periods, you can continue to observe when entities have recovered from maintenance and have returned to a healthy state. You create and manage muting rules using either New Relic Alerts UI or the NerdGraph API explorer. What is a muting rule? A muting rule overrides alert policies and conditions you’ve defined in New Relic, so you can suppress notifications during times of known system disruptions. A muting rule contains a set of conditions that match a large number of attributes and tags present in a violation event, including: Alert policy and condition names Application and service names Host names AWS tags Kubernetes tags Any other tags associated with your entities or open telemetry How muting rules work Muting rules tell New Relic how to identify individual violations after they are created, but before an incident is opened. They override the default life cycle of an alert to indicate that it should not send notifications. With muting rules, your normal alert incident life cycle is maintained; the only change is whether or not an incident triggers a notification. Violations and incidents are still opened, and health indicators show the current state of your entities as you progress through your maintenance window. When the conditions defined in a muting rule match a violation event, the violation is marked as “muted.” When a violation is muted, the incident life cycle is modified in the following ways: When a muted violation opens an incident, an “open incident” notification will not be sent. If any other violation that is not muted is associated with that incident, then an “open incident” notification will be sent. If an incident sends an “open incident” notification, then all subsequent events will trigger notifications. If an incident never sent an “open incident” notification, then subsequent events will not trigger notifications. (Tip: You can find a detailed workflow chart in the docs.) Enterprise-scale issue detection and incident management require flexibility and automation. Muting notifications is the first in a series of life cycle override actions that we will be releasing this year, including allowing you to schedule muting. All of these controls will be manageable through our API and UI. How to set up a muting rule Muting rules are available to everyone using New Relic. To set up a muting rule: Navigate to  New Relic One > Applied Intelligence. From the left-hand navigation, select Muting rules. The Muting rules page in New Relic One. Note: Since New Relic One is a cross-account experience, the Muting rules page lists all muting rules that exist across all of the accounts to which you have access. However, a muting rule currently only operates in one account at a time. Set up your rule: Click Add a Rule. Choose a name and description, and select the appropriate account. Build a violation filter to set conditions that describe the criteria used to match the attributes of a violation object. Enable the rule when you are ready for it to be active. Set up your muting rule and enable it when you are ready for it to be active   You can view violations and incidents that have been muted in New Relic Alerts. Creating complex rule filters Use complex rule filters for greater precision when muting alerts. For example, if your maintenance only touches specific hosts within a cluster, a subset of services on a host, or if you’re making updates to a data center or availability zone that affects a large number of separately monitored services, complex rule filters can help ensure you only mute the relevant alerts. Create complex rule filters by combining sets of matching conditions. Filters can either use operators like or or and to combine conditions, and most attribute evaluations can accept an array of possible values. Creating a complex filter for a muting rule. Creating and managing muting rules with NerdGraph NerdGraph is an interactive, browser-based IDE for running GraphQL requests. With NerdGraph, you can create and manage muting rules, and perform the same advanced functions available in the UI, including creating muting rules for specific hosts or products and fetching rules for a specific account. Find multiple NerdGraph API examples in the documentation. Try it now! The ability to mute notifications is one way we give you more control over your monitoring and help reduce alert fatigue. If you’re ready to give it a try, sign up for a trial and get started for free. By Brian Goleno Brian Goleno is a Sr. Product Manager in the Applied Intelligence group at New Relic. Brian has been a product manager in the SaaS-based monitoring and observability space for over five years, and has been with New Relic for the past two years. Brian is currently focused on accelerating New Relic’s issue detection capabilities and supporting the New Relic One platform. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 396.30356,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Muting Rules Now Available in <em>New</em> <em>Relic</em> Alerts",
        "sections": "Creating and managing muting rules with <em>NerdGraph</em>",
        "body": " either <em>New</em> <em>Relic</em> Alerts UI or the <em>NerdGraph</em> <em>API</em> explorer. What is a muting rule? A muting rule overrides alert policies and conditions you’ve defined in <em>New</em> <em>Relic</em>, so you can suppress notifications during times of known system disruptions. A muting rule contains a set of conditions that match a large"
      },
      "id": "60762fbd196a6709bb64a784"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/docs_code1.png",
      "url": "https://newrelic.com/blog/how-to-relic/docs-as-code-docs-in-code",
      "sections": [
        "When words in code are forgotten",
        "How the Product Language team contributes to docs in code",
        "Help us do docs in code"
      ],
      "published_at": "2021-04-16T00:17:38Z",
      "title": "Docs As the Code, Docs In the Code At New Relic",
      "updated_at": "2021-04-14T00:08:55Z",
      "type": "",
      "external_id": "b02a91dc068f658f050710d3a7b63284fa9e8f2b",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Docs As the Code, Docs In the Code At New Relic Aug 25, 2020 • 6 min read By Fabrizio Ferri-Benedetti func (c *Command) Run() (string, error) { // set the locale BLAAARGH — An old comment in our source code   Software is made of words. Some words, such as UI text or command-line messages, are for human-computer interaction; some, like API calls and error codes, target other software; and some form the documentation—README files, user guides, online help, and more. The vast majority of words in software, though, are its source code: those words that make it run. Code, too, contains human-readable text. Consider any piece of software: Whatever the programming language (except maybe Malbolge and its esoteric companions), chances are that you'll find plenty of meaningful and useful words in the source: Embedded reference docs, which can be used to build docs automatically (for example, GoDoc, Javadoc, GraphQL, and OpenAPI) String literals, from log messages to errors to input prompts Examples and comments in configuration files Names of CLI commands, variables, functions, and methods Comments in the source code (like the one I quoted above) Now that we’ve made our software open source, the idea of docs in our code has even greater importance to us. When words in code are forgotten If code isn't documented, it doesn't exist. In many cases, code may lack embedded documentation, making it hard for developers to understand how it works or is intended to be used. But that's not the only thing that can go wrong: Undocumented API schemas result in poor user experiences when loaded into API explorers; configuration files without comments are hard to tweak, and badly-written errors can make troubleshooting needlessly difficult. Plenty can go wrong when software lacks embedded documentation. At the end of the day, our software is also measured by the quality of its words, the way it speaks to users, and how well it’s documented. Great docs unlock a great developer experience. If we expect our dev community to pull our code and enrich it, we should ensure it’s well commented and documented. How the Product Language team contributes to docs in code It’d be a long blog post if I detailed every bit of our work, so here are a few recent examples of docs-in-code work that the Product Language team has accomplished: In preparation for the open source release of the Infrastructure agent, we reviewed the entire code base for typos, formatting issues, forbidden words, and sensitive information in code comments. At the same time, we fixed capitalization issues and grammar in the CLI and debug messages, and edited the README. We regularly edit NerdGraph GraphQL schemas for embedded documentation. Docs in schemas are key to good GraphQL experiences; see, for example, the screenshot below: All fields have basic reference documentation. The same applies to OpenAPI specifications for REST APIs. We also write and edit comments in sample configuration files that help users install our agents and integrations faster. The sample configuration file for the Windows services integration, for instance, provides a brief explanation that builds on the existing documentation, so that users in a hurry can still get some guidance even if they skip our docs. # To include services, create a list of filters to be applied to the service names. # Services that find a match with any of the matching lists are included. By default, # no service is included. # # Currently, only windowsService.name metadata is supported for filtering. # Prepend \"regex\" to indicate that the pattern is a regular expression. # include_matching_entities: windowsService.name: # - regex \"^*$\" # - \"ServiceNameToBeIncluded\" Help us do docs in code We’re dedicated to bringing clear, concise, and thoughtful documentation to our open source projects—from our agents to New Relic One applications to our open source and developer sites. If you have any questions or needs concerning the docs you encounter in our code, don't hesitate to reach out to us in the appropriate repo with a comment or pull request. Happy docs-as-coding! By Fabrizio Ferri-Benedetti Fabrizio Ferri-Benedetti is a Senior Product Language Writer based in Barcelona, Spain. He loves writing and technology. A cognitive psychologist by training, he jokingly refers to himself as “computer shrink.” Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 390.96545,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Docs As the Code, Docs In the Code At <em>New</em> <em>Relic</em>",
        "body": " in the CLI and debug messages, and edited the README. We regularly edit <em>NerdGraph</em> <em>GraphQL</em> schemas for embedded documentation. Docs in schemas are key to good <em>GraphQL</em> experiences; see, for example, the screenshot below: All fields have basic reference documentation. The same applies to Open<em>API</em>"
      },
      "id": "60763298196a67968464a7ba"
    }
  ],
  "/explore-docs/newrelic-cli": [
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/adilson-somensari.jpg?h=2a479378&itok=1PmRmD7k",
      "url": "https://newrelic.com/blog/how-to-relic/new-relic-cli-ibm",
      "sections": [
        "Manage New Relic tasks and resources from the CLI",
        "Example use case 1: Create a Synthetics monitor",
        "Example use case 2: Daily backup of a Synthetics monitor",
        "A great addition for your New Relic toolbox"
      ],
      "published_at": "2021-04-16T04:25:42Z",
      "title": "Automate Your New Relic Tasks With the New Relic CLI From IBM",
      "updated_at": "2021-04-14T02:03:44Z",
      "type": "",
      "external_id": "84956b18d97b9ff7e418a703ede61342a4d315f5",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Automate Your New Relic Tasks With the New Relic CLI From IBM Nov 16, 2018 • 5 min read By Adilson Somensari Editor’s note: The New Relic CLI tool was developed by IBM. It is open sourced under the Apache License 2.0. Helping our customers go faster with confidence is a key tenet of the New Relic ethos. We provide visibility into vital data, statistics, and key performance indicators (KPIs) to help teams increase their deployment speed and cadence. But modern software teams also see automation and continuous integration and continuous delivery (CI/CD) processes as must-haves to support their Agile practices and DevOps teams. Teams want to apply the same automation concepts and tools to operate New Relic as they do other parts of their pipeline. However, writing all the standard boilerplate code to work with New Relic’s REST API (read configuration files, connect to endpoints, send payloads, receive responses, and parse them) can be a toilsome burden and a needless distraction. Fortunately, the IBM Cloud Monitoring team, a New Relic partner, noticed that multiple internal teams were spending too much time managing boilerplate code to automate their New Relic workflows, so they created a solution to solve that problem—a New Relic CLI (command line interface) tool. Manage New Relic tasks and resources from the CLI New Relic CLI, open sourced and available on GitHub from IBM, is a command line tool you can use to manage New Relic resources, such as New Relic Synthetics monitors, New Relic Alerts policies and conditions, and user accounts. You can also use the CLI to backup your New Relic configuration data and restore it as needed. Currently, you can use the New Relic CLI to manage these resources: New Relic resource Management action New Relic Synthetics Create, edit, and delete Synthetics monitors #rowspan# Back up and restore Synthetics monitors New Relic Alerts Create, edit, and delete alert conditions #rowspan# Create, edit, and delete alert policies #rowspan# Create, edit, and delete notification channels #rowspan# Back up and restore alert policies and conditions New Relic Insights dashboards Get dashboards #rowspan# Back up and restore dashboards Users List users Example use case 1: Create a Synthetics monitor This example shows you how to use the New Relic CLI to create a Synthetics monitor: Set the New Relic admin API key (NEW_RELIC_APIKEY) for your environment. This will vary depending on your operating system, but in Linux, you’d use the export command:Export NEW_RELIC_APIKEY=xxxx-xxxxxxx-xxxxx-xxxxxx Tip: Refer to the New Relic docs for instructions on locating your admin API key. Create a basic definition of the monitor in JSON format (for example test.json). { \"name\": \"Test monitorURI\", \"type\": \"SIMPLE\" \"frequency\": 5, \"uri\": \"monitorURI\", \"locations\": [ \"AWS_AP_SOUTH_1\", \"AWS_EU_WEST_3\", \"AWS_US_WEST_1\" ], \"status\": \"ENABLED\", \"slaThreshold\": 3, \"options\": { } Tip: See the documentation for a full list of public minion locations. Run a text substitution to replace the monitorURI with the actual URL you want to test, and generate a new file (in this example, result.json). .awk '{gsub(/monitorURI/,\"<URL TO BE TESTED>\")}1' test.json > result.json To create the new monitor, run ./nr-cli create monitor -f result.json. From this point, you can start working with the new monitor as needed. Example use case 2: Daily backup of a Synthetics monitor You can also use the NewRelic CLI to create daily backups of your Synthetics monitors. Using a simple shell script and a cron job, you can quickly set up a process to back up all your monitors in a safe repository. These four steps describe how to use the New Relic CLI to set up a daily backup job that will back up all monitors into a separate folder every day: Download the shell scripts file for backup monitors (backup_monitors.sh) from the New Relic CLI repo. Add a proper path to the script, and set it as an executable: $ chmod a+x backup_monitors.sh. Create a new cron job in your OS to schedule the shell script you just created. Use crontab -e to add new schedule job. 0 0 */1 * * <YOUR NEW_RELIC_APIKEY=\"xxx-xxxx-xxx>\" /<your_path>/backup-monitors.sh NOTE: Replace xxx-xxxx-xxx with your own NewRelic admin API key. (Optional) If you don't want to set the NR API key in your cron job’s configuration, you can set the key inbackup_monitors.sh. Comment out the Export NEW_RELIC_APIKEY=\"xxx-xxxx-xxx\" entry, replace the value with your API key. The cron job should now run and back up on your monitors based on the schedule you created. A great addition for your New Relic toolbox The New Relic CLI also lets you easily save New Relic settings to source-control tools like Github or BitBucket; and share central configuration and settings across multiple teams and projects. For example, if your target machine can’t connect to New Relic directly, you can configure the CLI tool to use a proxy. You can also configure retries to cope with timeouts. The CLI also includes return codes, which can be very useful for CI/CD automation. For more details on developing for the New Relic CLI, see the repo on Github. By Adilson Somensari Adilson Somensari is a senior solutions architect on the New Relic Expert Services team. An experienced APM professional, with multiple certifications in the APM industry, he has a passion for helping customers succeed with modern monitoring architectures. Adilson started his career as a Java developer, delivering distributed applications to a diverse set of industries (Auto, Banking, Telecom, Transportation) in multiple countries (United States, Canada, Portugal, Brazil), and pivoted to APM after learning that there is more to life than reading logs and stack traces. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 705.51135,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Automate Your <em>New</em> <em>Relic</em> Tasks With the <em>New</em> <em>Relic</em> <em>CLI</em> From IBM",
        "sections": "Manage <em>New</em> <em>Relic</em> tasks and resources from the <em>CLI</em>",
        "body": " navigation menu, 4 items How to <em>Relic</em> Best Practices Nerd Life Nerdlog Search the blog Submit How to <em>Relic</em> Automate Your <em>New</em> <em>Relic</em> Tasks With the <em>New</em> <em>Relic</em> <em>CLI</em> From IBM Nov 16, 2018 • 5 min read By Adilson Somensari Editor’s note: The <em>New</em> <em>Relic</em> <em>CLI</em> tool was developed by IBM. It is open sourced under"
      },
      "id": "60764d8028ccbca8f951c14e"
    },
    {
      "image": "https://developer.newrelic.com/static/futurestack-registration-86e612c0605fb3c49cfd28f35977135d.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Futurestack: Master Observability",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2021-04-20T01:36:57Z",
      "title": "New Relic Developers",
      "updated_at": "2021-04-16T01:37:39Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Data Nerds, get ready to hack the future. Level Up your observability game at Futurestack 2021. Rack up your experience points with new tools, new skills, and whole new ways to play with your data through Observability. Connect with Nerds from across the globe to learn, share, and get inspired as we reinvent the future of software — and have lots of fun doing it. Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom attributes for deeper analysis Show 29 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 528.42065,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " emitters - get any data Automate common tasks 20 min Use the <em>New</em> <em>Relic</em> <em>CLI</em> to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "sections": [
        "Partial or missing logs for RDS, VPC, AWS Lambda",
        "Problem",
        "Solution"
      ],
      "title": "Partial or missing logs for RDS, VPC, AWS Lambda",
      "type": "docs",
      "tags": [
        "Integrations",
        "Amazon integrations",
        "Troubleshooting"
      ],
      "external_id": "66a81a2fa3b8b27bf6172c9bb2c3ecf28bbe13e9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/amazon-integrations/troubleshooting/partial-or-missing-logs-rds-vpc-aws-lambda/",
      "published_at": "2021-04-16T17:00:09Z",
      "updated_at": "2021-03-13T01:15:24Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You are using NewRelic-log-ingestion, the lambda function for pushing logs from AWS to our RDS Enhanced Monitoring, VPC Flow Logs integrations, or early versions (alpha and beta) of monitoring for AWS Lambda. It is not working or it is sending partial data. Solution The NewRelic-log-ingestion lambda versions prior to 2.1 are being deprecated. Update to the latest lambdas published in the AWS Serverless Repository. You can either use the New Relic CLI or update manually. Recommended: The main way to update the log ingestion lambda function is to follow standard procedures to update the function using the New Relic CLI. You can also update the function manually: Avoid false positives in alerting: Follow UI procedures or API procedures to disable all alert conditions associated with monitoring integrations with AWS Lambda, RDS Enhanced Monitoring, and VPC Flow Logs. Remove the outdated lambda version of the lambda: Go to your AWS Lambda Console, and remove newrelic-log-ingestion. Be aware that this stops the RDS Enhanced Monitoring and the VPC Flow Logs integration until the next step is completed. Re-enable the service: Follow the instructions in RDS Enhanced Monitoring or VPC Flow Logs, or follow the step to configure CloudWatch logs to stream to New Relic Lambda. Check that your data is flowing through the new lambda.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 468.58127,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "-ingestion lambda versions prior to 2.1 are being deprecated. Update to the latest lambdas published in the AWS Serverless Repository. You can either use the <em>New</em> <em>Relic</em> <em>CLI</em> or update manually. Recommended: The main way to update the log ingestion lambda function is to follow standard procedures to update"
      },
      "id": "60450c97196a672ffa960f57"
    },
    {
      "sections": [
        "Secrets management",
        "Define secrets",
        "Important",
        "Tip",
        "Using environment variables",
        "Secrets variables",
        "AWS KMS secrets",
        "Vault secrets",
        "tls_config properties",
        "CyberArk command line interface",
        "CyberArk REST API",
        "New Relic CLI Obfuscation"
      ],
      "title": "Secrets management",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "Installation"
      ],
      "external_id": "8e05204a80a9475aee87d85a4be07cff710faa31",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/installation/secrets-management/",
      "published_at": "2021-04-16T17:02:35Z",
      "updated_at": "2021-03-16T06:02:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With secrets management, you can configure the agent and on-host integrations to use sensitive data (such as passwords) without having to write them as plain text into the configuration files. Currently, Hashicorp Vault, AWS KMS, CyberArk and New Relic CLI obfuscation are supported. Define secrets To use secrets in a configuration YAML file: Define a variables section, where each entry is a name for a secret object. In each entry, include the source of the secret and the proper configuration to retrieve those secrets. In the general configuration section, set ${variable.property} placeholders that will be automatically replaced by the properties of the secret object. The secret object can be defined as a simple string or json object. Important If the secrets retrieval fails, the integration won't be executed, as the infrastructure agent does not have all the data it requires to execute. For example, the following configuration will retrieve an object named creds from Vault (you can define the object's name for the secret.) Let's assume that the stored object is a valid JSON with a property named user and another property named password. We want to use them to set the basic HTTP credentials of the status_url property from an Nginx on-host integration: integration_name: com.newrelic.nginx variables: creds: vault: http: url: http://my.vault.host/v1/newengine/data/secret headers: X-Vault-Token: my-vault-token instances: - name: nginx-server-metrics command: metrics arguments: status_url: http://${creds.user}:${creds.password}@example.com/status status_module: discover remote_monitoring: true labels: env: production role: load_balancer Copy Tip Both simple strings and valid JSON objects can be retrieved from variables. When using JSON objects make sure both keys and values are enclosed with double-quotes. Using environment variables Environment variables can be used into the variables section with the {{MY_ENV_VAR}} notation. When doing so, environment variables are expanded and their value is replaced at runtime. Use this method to avoid having sensitive values such as tokens or obfuscation keys included in the configuration file. When using environment variables in on-host integration configuration files the passthrough_environment setting must be defined. Secrets variables Define secrets in each configuration under a variables section. Each entry is a user-defined secret name that will store the properties of the retrieved secrets. Each variable can contain the following properties: YAML key Description ttl Type: String Amount of time before a secret is refreshed. This can be a number followed by a time unit (s, m or h). Examples: 30s, 10m, 1h Default: 1h aws-kms AWS KMS secret retrieval configuration vault Vault secret retrieval configuration cyberark-cli CyberArk command line interface configuration cyberark-api CyberArk REST API configuration obfuscated New Relic CLI obfuscation AWS KMS secrets To retrieve your secrets from Amazon KMS, you can set the following properties in your aws-kms section. Not all fields are required. For example, you will need either data, file, or http to provide the encoded KMS string. YAML key Description data Type: String Base64 encoded KMS string to decrypt file Type: String Path to file containing Base64 encoded KMS string to decrypt http Type: YAML properties HTTP configuration to use to request Base64 encoded KMS string to decrypt. For more information, see Vault http. credential_file Type: String Path to AWS credentials file config_file Type: String Path to AWS config file region Type: String AWS KMS region type Type: String (plain, equal, or json) Secret value format: plain: a raw string to be stored directly into the destination variable. equal: a key=property one-line string to be stored as object properties into the destination variable. json: a JSON object to be stored as properties into the destination variable. Secrets of type plain or json use dot notation; for example, ${mysecret.nestedkey}. The following example will allow retrieving a plain password string from AWS KMS. It must be decrypted from the provided data encoded string. variables: myPassword: aws-kms: data: T0hBSStGTEVY region: ap-southeast-2 credential_file: \"./my-aws-credentials-file\" config_file: \"./my-aws-config-file\" type: plain Copy Vault secrets Vault must enable an http field containing the HTTP configuration used to connect to Vault. The http entry can contain the following entries: YAML key Description url Type: String URL to request data from tls_config Type: YAML properties Use the TLS configuration properties headers Type: YAML map Request headers tls_config properties Important Secrets must use dot notation, for example, ${mysecret.nestedkey}. YAML key Description enable Type: Boolean Enable TLS Default: false insecure_skip_verify Type: Boolean Skip verifying server’s certificate chain and host Default: false min_version Type: UInt16 The minimum SSL/TLS version that is acceptable Default: 0 (which uses TLS version 1.0) max_version Type: UInt16 The maximum SSL/TLS version that is acceptable Default: 0 (which uses TLS version 1.3) ca Type: String TLS certificate \"\" The following example will retrieve a secret using a Vault token from a secured server, and skip the server certificates verification: variables: mydata: vault: http: url: https://my.vault.host/v1/newengine/data/secret headers: X-Vault-Token: my-vault-token tls_config: insecure_skip_verify: true Copy CyberArk command line interface To retrieve secrets from the CyberArk command line interface (CLI) use the following configuration, all keys are required YAML Key Description cli Type: string Full path to the CyberArk CLI executable Default: \"\" app-id Type: string Application id of the secret holder Default: \"\" safe Type: string Safe containing the secret Default: \"\" folder Type: string Folder containing the secret Default: \"\" object Type: string The object the secret is associated with Default: \"\" The following example will retrieve a CyberArk secret using the command line interface: variables: credentials: cyberark-cli: cli: /full/path/to/clipasswordsdk app-id: my-appid safe: my-safe folder: my-folder object: my-object Copy CyberArk REST API To retrieve secrets using the CyberArk REST API there must be a http key containing the HTTP configuration. The http key contains these sub-keys, only url is required: YAML key Description url Type: String URL to request data from, this key is required Default: none tls_config Type: YAML properties Use the TLS configuration properties headers Type: YAML map Request headers The following example will retrieve a secret using the CyberArk REST API, skipping server certificate verification: variables: credentials: cyberark-api: http: url: https://hostname/AIMWebService/api/Accounts?AppID=myAppID&Query=Safe=mySafe;Object=myObject tls_config: insecure_skip_verify: true Copy New Relic CLI Obfuscation Important We recommend using any of the supported secrets providers instead of the simple obfuscation when possible. See our guidelines below to define environment variables to avoid having the obfuscation key in configuration files. Tip Infrastructure Agent 1.14.0 or above is required You can use the New Relic CLI obfuscate command to obscure sensitive information in the infrastructure agent or any on-host integration configuration file. Steps: Install the New Relic CLI on any host (it can be your development host). Run the CLI obfuscate command in order to generate the obfuscated value: newrelic agent config obfuscate --value '<plain_text_config_value>' --key '<obfuscation_key>' Copy Copy the result of the cli command into the text argument in the obfuscated section as shown in the examples below. YAML key Description key Type: String The string used when obfuscating the clear-text value using New Relic CLI Default: none secret Type: String The output of the newrelic-cli command Default: none Integrations configuration example The following example will allow retrieving the Nginx user and password that has been obfuscated using the New Relic CLI: integration_name: com.newrelic.nginx variables: creds: obfuscated: key: 'random_key_used_in_cli' secret: 'obscured_output_from_cli' instances: - name: nginx-server-metrics command: metrics arguments: status_url: http://${creds.user}:${creds.password}@example.com/status status_module: discover remote_monitoring: true Copy It's recommended to use environment variables for the obfuscation arguments as shown in the example below: integration_name: com.newrelic.nginx variables: creds: obfuscated: key: {{OBFUSCATION_KEY}} secret: {{OBFUSCATION_TEXT}} instances: - name: nginx-server-metrics command: metrics arguments: status_url: http://${creds.user}:${creds.password}@example.com/status status_module: discover remote_monitoring: true Copy Agent configuration example This example allows retrieving a string that contains the proxy details (user, password and host): variables: obfuscated_proxy: obfuscated: key: 'random_key_used_in_cli' secret: 'obscured_output_from_cli' proxy: ${obfuscated_proxy} Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 444.3048,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> Obfuscation",
        "body": "With secrets management, you can configure the agent and on-host integrations to use sensitive data (such as passwords) without having to write them as plain text into the configuration files. Currently, Hashicorp Vault, AWS KMS, CyberArk and <em>New</em> <em>Relic</em> <em>CLI</em> obfuscation are supported. Define secrets"
      },
      "id": "603eaeeae7b9d28cdf2a07dd"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/16x9_600w/public/2021-04/alphabet-background-min.jpg?h=0b6c7057&itok=EagyT0GQ",
      "url": "https://newrelic.com/blog/authors/adilson-somensari",
      "sections": [
        "Adilson Somensari",
        "All Posts From Author",
        "What’s in an App Name? How to Create an App-Naming Convention",
        "Automate Your New Relic Tasks With the New Relic CLI From IBM",
        "The Twelve-Factor App: What It Is and How to Monitor It"
      ],
      "published_at": "2021-04-15T22:50:04Z",
      "title": "Adilson Somensari | New Relic",
      "updated_at": "2021-04-14T05:03:02Z",
      "type": "",
      "external_id": "33d515774d0adb915fcb2ffc95d65b0fe5e616ad",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Adilson Somensari Adilson Somensari is a senior solutions architect on the New Relic Expert Services team. An experienced APM professional, with multiple certifications in the APM industry, he has a passion for helping customers succeed with modern monitoring architectures. Adilson started his career as a Java developer, delivering distributed applications to a diverse set of industries (Auto, Banking, Telecom, Transportation) in multiple countries (United States, Canada, Portugal, Brazil), and pivoted to APM after learning that there is more to life than reading logs and stack traces. All Posts From Author Best Practices What’s in an App Name? How to Create an App-Naming Convention May 22, 2018 • 5 min read Read the article How to Relic Automate Your New Relic Tasks With the New Relic CLI From IBM Nov 16, 2018 • 5 min read Read the article Best Practices The Twelve-Factor App: What It Is and How to Monitor It Apr 10, 2018 • 12 min read Read the article Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 441.78397,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adilson Somensari | <em>New</em> <em>Relic</em>",
        "sections": "Automate Your <em>New</em> <em>Relic</em> Tasks With the <em>New</em> <em>Relic</em> <em>CLI</em> From IBM",
        "body": " to APM after learning that there is more to life than reading logs and stack traces. All Posts From Author Best Practices What’s in an App Name? How to Create an App-Naming Convention May 22, 2018 • 5 min read Read the article How to <em>Relic</em> Automate Your <em>New</em> <em>Relic</em> Tasks With the <em>New</em> <em>Relic</em> <em>CLI</em> From"
      },
      "id": "6076778628ccbc6c0051c152"
    }
  ],
  "/terraform/terragrunt-configuration": [
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-04-16T14:38:31Z",
      "updated_at": "2021-04-06T07:43:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirements: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more sub-accounts, the notification channel includes only users for the currently selected master or sub-account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.13406,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to select existing account team members and admins. To view the Users list or to add users to <em>alert</em> policies: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. If a user has configured the New Relic mobile app, the user <em>notification</em> <em>channel</em> also sends push"
      },
      "id": "603ecfbf64441f4ee54e885f"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/07-saturation-condition-1024x558.png",
      "url": "https://newrelic.com/blog/how-to-relic/observability-as-code-new-relic-terraform-provider",
      "sections": [
        "About the Terraform New Relic provider",
        "Before you begin",
        "Step1: Initialize your working folder",
        "Step 2: Provision an alert policy resource",
        "Step 3: Provision alert conditions based on the four golden signals",
        "1. Latency",
        "2. Traffic",
        "3. Errors",
        "4. Saturation",
        "Linking a notification channel",
        "Observability as code in practice"
      ],
      "published_at": "2021-04-16T04:24:42Z",
      "title": "Practicing Observability as Code: Defining New Relic Alert Policies with Terraform",
      "updated_at": "2021-04-14T00:08:56Z",
      "type": "",
      "external_id": "f6ed141e784fb49eb7e1a31fe5752bf78186209c",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Practicing Observability as Code: Defining New Relic Alert Policies with Terraform Apr 6, 2020 • 11 min read By Chris Trombley Observability is an essential part of operating modern, complex architectures. But building an observability system that consumes a wide breadth of data from numerous data sources to drive alerts with a high signal-to-noise ratio can be overwhelming. Furthermore, maintaining such configurations manually across a large organization with distributed teams creates the potential for human error and configuration drift. A ThoughtWorks Technology Radar report suggested software teams treat “observability ecosystem configurations” as code—making observability as code an important practice for any teams adopting infrastructure as code (IaC) for their monitoring and alerting infrastructure. At New Relic, we believe that observability as code through automation is a best practice, and recommend a single source of truth for observability configurations. In this blog post, we’ll use the IaC tool Terraform and the New Relic Terraform provider to practice observability as code. We’ll use the provider to create a monitoring and alerting configuration for a sample application based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: Measures the amount of time it takes your application to service a request. In other words, how responsive is your application? Traffic: Measures how much demand is being placed on your system. How many requests or sessions are aimed at your application? Errors: Measures the rate of requests that fail. How much traffic is unable to fulfill its requests or sessions? Saturation: Measures how “full” your service is. How are resources being stressed to meet the demands of your application? You can combine these four signals to create a fairly thorough depiction of the health of your system. We’ll build the alerting strategy for our sample application based on these signals. About the Terraform New Relic provider Terraform is an open-source infrastructure as code tool teams use to define and provision their infrastructure (physical machines, VMs, network switches, containers, SaaS services, and more) through repeatable automation. In Terraform, any infrastructure type can be represented as a resource, and providers expose how developers can interact with their APIs. The Terraform New Relic provider, officially supported by New Relic, integrates with core Terraform to allow for provisioning and managing resources in your New Relic account. Note: We wrote this post using version 0.12.21 of the Terraform CLI and version 1.14.0 of the Terraform New Relic provider. Future releases may impact the correctness of the examples included below. Before you begin To complete this walkthrough, you’ll need to install the Terraform CLI. Homebrew users can run brew install terraform. If you’re not a Homebrew user, check the Terraform download page for install instructions. Step1: Initialize your working folder Terraform configuration is based on a declarative language called HCL, which defines resources in terms of blocks, arguments, and identifiers. We’ll represent our New Relic resources in HCL to allow Terraform to provision and manage them. In your working folder, create a file called main.tf. Include the provider block to signal to Terraform that the New Relic provider will be used for the plan we are about to create: provider \"newrelic\" { api_key = var.newrelic_api_key } You can now initialize Terraform, which will facilitate the download of the New Relic provider. To run the initialization, run terraform init from the console. You should see a message that shows Terraform has been initialized successfully. Still, in your working folder, create a file called variables.tf. Include the newrelic_api_key variable definition to allow the Terraform CLI to prompt for your New Relic Admin’s API key for your user and account, then run the plan: variable \"newrelic_api_key\" { description = \"The New Relic API key\" type = string } Tip: If you want to suppress user prompts, you can also provide the API key via the NEWRELIC_API_KEY environment variable. You can combine this with a secret manager like Hashicorp's Vault to automate your Terraform runs while keeping secret values out of source control. See Terraform’s provider documentation for details. Your working folder is now initialized, and you’re ready to begin defining your New Relic resources with Terraform. Step 2: Provision an alert policy resource Now we’ll define an alerting strategy for a sample app—called “Web Portal”—already reporting to our New Relic account. We want to apply the principles of golden signal monitoring and alerting to this application. To do so, we’ll first need some details about the application we’re targeting and an alert policy in which we can define the appropriate alert conditions. In the main.tf file, define these resources in HCL: data \"newrelic_application\" \"web_portal\" { name = \"Web Portal\" } resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_application.web_portal.name}\" } These two blocks define a data source to retrieve application context for a New Relic application named “Web Portal” and a resource for provisioning a simple alert policy with the name “Golden Signals - Web Portal.” Take note that we’ve included two strings at the start of each block: The first represents the data source we are provisioning, as defined by the provider. Here we are using the newrelic_application data source and the newrelic_alert_policy (See the provider documentation for a full list of the available New Relic resource types.) The second is an identifier used for referencing this element from within the plan. In this case, we interpolate the application’s name, stored in its name attribute, into the alert policy name to avoid duplication in our configuration. The policy name defined here will be the one that shows in the New Relic UI, but the golden_signal_policy identifier is for use inside our Terraform configuration only.   Run terraform plan. You’ll be prompted for your admin API key. Once you enter it, you will see a diff-style representation of the execution plan Terraform is about to carry out on your behalf: ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + created_at          = (known after apply) + id                  = (known after apply) + incident_preference = \"PER_POLICY\" + name                = \"Golden Signals - WebPortal\" + updated_at          = (known after apply) } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ After verifying the details of the execution plan, run terraform apply to execute the plan and provision the resource: newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=643964]Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log into New Relic and navigate to the Alert Policies page for your account. You should see your alert policy has been created. When you created the alert policy in step 1.3, Terraform began tracking the state of your resource. If you ran terraform apply again, Terraform would compare the configuration in your main.tf file to the internally tracked state of the resource and determine that no action is necessary—this is the power of observability as code. You can delete the policy, with terraform destroy. Step 3: Provision alert conditions based on the four golden signals Next, we’ll want to add alert conditions for our application based on the four golden signals: latency, traffic, errors, and saturation. 1. Latency As described earlier, latency is a measure of the time it takes to service a request. Use the newrelic_alert_condition resource to create a basic alert condition resource for the response time of our sample application: resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name            = \"High Response Time (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"response_time_web\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above 5 seconds per request. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } Here, we defined a condition named High Response Time (web) that will trigger if the overall response time of our application rises above five seconds for five minutes. Note that for the value of the policy_id attribute, we can link the alert policy we defined earlier with a reference to its identifier and its id attribute. We’re also using the ID of the application by referencing the application’s data source we defined in the previous section and by using its id attribute. Run terraform apply and verify that your alert condition has been created and linked to your alert policy. After Terraform runs, you can review the latency condition in New Relic. 2. Traffic The traffic signal represents how much demand is being placed on your system at any given moment. Use the application’s throughput as a metric for measuring the application’s traffic: resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id   name            = \"Low Throughput (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"throughput_web\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes below 1 request per minute. term { duration      = 5 operator      = \"below\" priority      = \"critical\" threshold     = \"1\" time_function = \"all\" } } Here, we define a condition named Low Throughput (web) that will trigger if the overall response time of our application falls below five requests per minute for five minutes. This type of alert is useful if we expect a constant baseline of traffic at all times throughout the day—a drop-off in traffic indicates a problem. Run terraform apply to create this condition. After Terraform runs, you can review the throughput condition in New Relic. 3. Errors Define a condition based on the error rate generated by our application: resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type  = \"apm_app_metric\" entities = [data.newrelic_application.web_portal.id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } This condition, error percentage, will trigger if the overall error rate for our application rises above 5% for five minutes. Run terraform apply to create the condition. After Terraform runs, you can review the error condition in New Relic. 4. Saturation Saturation represents how “full” your service is and can take many forms, such as CPU time, memory allocation, or queue depth. Let’s assume that in this case, we have a New Relic Infrastructure agent on the hosts serving our sample application, and we’d like to measure their overall CPU utilization. Use the newrelic_infra_alert_condition resource to create an alert condition based on this metric: resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name        = \"High CPU usage\" type        = \"infra_metric\" event       = \"SystemSample\" select      = \"cpuPercent\" comparison  = \"above\" runbook_url = \"https://www.example.com\" where       = \"(`applicationId` = '${data.newrelic_application.web_portal.id}')\"   # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration      = 5 value         = 90 time_function = \"all\" } } This alert will trigger if the aggregate CPU usage on these hosts rises above 90% for five minutes. Note that the definition for this resource is slightly different from the definition of newrelic_alert_condition—the New Relic provider documentation is the best source of information about the required or optional attributes on the resource. Run terraform apply to create the condition. After Terraform runs, you can review the saturation condition in New Relic. Your resources are now fully defined in code, and you can run terraform destroy or terraform apply at any time to remove or re-provision these resources in your New Relic account in a matter of seconds. Linking a notification channel We’ve created alert conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those alerts. Our team uses PagerDuty, so let’s create a notification channel to integrate with that service. (For a full list of the supported notification channels, see the newrelic_alert_channel documentation.) Create a variable to store the PagerDuty service key to avoid storing sensitive values in your codebase. In variables.tf, create a new variable: variable \"pagerduty_service_key\" { description = \"The Pagerduty service key\" type = string } Define the channel with the newrelic_alert_channel resource, and link it to your policy defined earlier with the newrelic_alert_policy_channel resource: resource \"newrelic_alert_channel\" \"pagerduty_channel\" { name = \"Page Developer Toolkit Team\" type = \"pagerduty\" config { service_key = var.pagerduty_service_key } # The following block prevents configuration drift for channels that use sensitive data. # See the Getting Started guide for more info: # https://www.terraform.io/docs/providers/newrelic/guides/getting_started.html lifecycle { ignore_changes = [config] } } resource \"newrelic_alert_policy_channel\" \"golden_signal_policy_pagerduty\" { policy_id  = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.pagerduty_channel.id] } Run terraform apply to apply your configuration. A PagerDuty notification channel set up in New Relic Alerts. Observability as code in practice Congratulations, you’re now a practitioner of observability as code. Now it’s time to create a repository—perhaps in GitHub—for your observability configuration and place it under version control. As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. You can do this with a pull request to your alerting repository. Since you’re practicing observability as code, your team can review these changes right alongside the rest of your code contributions. You may also want to consider automating this process in your CI/CD pipeline, taking your observability as code practice to the next level. Don’t miss our latest video quick tip: Terraform Provider for New Relic—Getting Started Guide [embed]https://www.youtube.com/watch?v=UwJ-7BLylJo[/embed]   By Chris Trombley Chris Trombley is a Software Engineer at New Relic Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.99991,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Practicing Observability as Code: Defining New Relic <em>Alert</em> Policies with <em>Terraform</em>",
        "sections": "Linking a <em>notification</em> <em>channel</em>",
        "body": "-provision these resources in your New Relic account in a matter of seconds. Linking a <em>notification</em> <em>channel</em> We’ve created <em>alert</em> conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those <em>alerts</em>. Our team uses PagerDuty, so let’s"
      },
      "id": "60763298196a679eea64a7a3"
    },
    {
      "sections": [
        "Test alert notification channels",
        "Request the test",
        "Troubleshoot the test results",
        "Tip"
      ],
      "title": "Test alert notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "c001fca5128a2fb8128ff655c44f9d51b6d5fa2a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/test-alert-notification-channels/",
      "published_at": "2021-04-16T14:39:15Z",
      "updated_at": "2021-03-16T06:45:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must save a new notification channel or any changes to an existing notification channel before testing it. Alerts will then send a test message to your chosen destination. Request the test To test a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Follow standard procedures to add a new notification channel or to update an existing notification channel, and save it. Select a notification channel, and then click Send a test notification. Review the test confirmation message, and then click Got it. Troubleshoot the test results A confirmation message will automatically show up in the user interface that indicates where the test was sent (for example, email) and whether it was successful. Also, the test notification message itself includes detailed information, including: The person who requested the test Links to policies for the channel Links to all notification channels and policies for the account Tip When troubleshooting problems, review the test notification message, and verify the setup requirements for the type of notification channel you selected. If necessary, make additional changes to your notification channel, and test it again as needed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.60461,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Test <em>alert</em> <em>notification</em> <em>channels</em>",
        "sections": "Test <em>alert</em> <em>notification</em> <em>channels</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": "You must save a new <em>notification</em> <em>channel</em> or any changes to an existing <em>notification</em> <em>channel</em> before testing it. <em>Alerts</em> will then send a test message to your chosen destination. Request the test To test a <em>notification</em> <em>channel</em>: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click"
      },
      "id": "603ec9ffe7b9d25b3d2a07a7"
    },
    {
      "sections": [
        "Update alert notification channels",
        "Reference for updating channels",
        "Add or remove policies assigned to a channel",
        "Assign a channel to policies",
        "Change a channel's name",
        "Check for policies assigned to a user",
        "Check how many policies are assigned to a channel",
        "Create more channels",
        "Delete a channel",
        "Test a saved channelView assigned alert policies",
        "Basic process"
      ],
      "title": "Update alert notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "521bed5aa6fdcea5c1cffd11d01e6dad19bc7c40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/update-alert-notification-channels/",
      "published_at": "2021-04-16T14:39:15Z",
      "updated_at": "2021-03-16T08:08:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Depending on the selected channel type, different values appear. Reference for updating channels Here's a quick reference for updating channels which also includes links to more detailed information and procedures. Add or remove policies assigned to a channel To add or remove policies assigned to a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Choose a channel, and then click Alert policies. From the selected policy, use the windows to select, remove, or clear all notification channels. Assign a channel to policies To add a notification channel to one or more policies: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies. Choose a policy, click Notification channels, and then click Add notification channels. Choose a channel, and then click Update policy. Change a channel's name To rename an existing notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, then choose a channel. From the Channel details, change the name (maximum 64 characters) based on the channel type if applicable, and then save. Check for policies assigned to a user To check whether an account user has any policies assigned: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Optional: Search by \"user\" to browse users or a specific username or email. Choose the user, then click Alert policies. Check how many policies are assigned to a channel To check whether a notification channel has any policies assigned: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create more channels To create a new notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Click New notification channel. Delete a channel To delete a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. In the list, click the Delete icon. Test a saved channelView assigned alert policies To view the policies assigned to a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, choose a channel, and then click Alert policies. OR To view the notification channels assigned to a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, choose a policy, then click Notification channels. Basic process Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, then choose a channel. From the Channel details page, make any necessary changes, and then save. The user interface shows a Last modified time stamp for any changes to policies, including their conditions and notification channels.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.89485,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update <em>alert</em> <em>notification</em> <em>channels</em>",
        "sections": "Update <em>alert</em> <em>notification</em> <em>channels</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to a <em>notification</em> <em>channel</em>: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, click <em>Notification</em> channels. Choose a <em>channel</em>, and then click <em>Alert</em> policies. From the selected policy, use the windows to select, remove, or clear all <em>notification</em> channels. Assign a <em>channel</em> to policies To add"
      },
      "id": "603eca45e7b9d2d1d82a0806"
    },
    {
      "sections": [
        "Delete alert notification channels",
        "Caution",
        "Delete a channel"
      ],
      "title": "Delete alert notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "4462298a5f026be9672d24ea2b452eb4c00a51c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/delete-alert-notification-channels/",
      "published_at": "2021-04-16T14:35:43Z",
      "updated_at": "2021-03-16T08:07:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Caution If you delete a channel, you cannot restore it. If you want to keep the notification channel, you can remove it from any associated policy. Delete a channel To delete a channel permanently: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Optional: To find the notification channel easily, search the Notification channels index. From the Notification channels index, select the channel's delete icon, and then select the confirmation prompt to cancel or continue. When you delete (or remove) a channel, any policies associated with it will still remain. You must delete policies separately.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.38046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Delete <em>alert</em> <em>notification</em> <em>channels</em>",
        "sections": "Delete <em>alert</em> <em>notification</em> <em>channels</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": "Caution If you delete a <em>channel</em>, you cannot restore it. If you want to keep the <em>notification</em> <em>channel</em>, you can remove it from any associated policy. Delete a <em>channel</em> To delete a <em>channel</em> permanently: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. Optional"
      },
      "id": "603ec9ff64441fd0e84e885b"
    }
  ],
  "/build-apps/howto-use-nrone-table-components": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/EKAJAC-nr-css-table-cell.jpg",
      "url": "https://newrelic.com/blog/best-practices/css-versioning-conflicts",
      "sections": [
        "Solution development",
        "Fixing CSS double-class collisions",
        "Fine-tuning overrides",
        "Our solution to CSS versioning issues"
      ],
      "published_at": "2021-04-16T02:35:47Z",
      "title": "How We Solve CSS Versioning Conflicts Here at New Relic",
      "updated_at": "2021-04-14T03:08:27Z",
      "type": "",
      "external_id": "85abd3f625626982297ab1845c490504a18f43c7",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Best Practices How We Solve CSS Versioning Conflicts Here at New Relic Jul 27, 2017 • 8 min read By Javier Sánchez-Marín At New Relic, the user-interface infrastructure team delivers components for the rest of the company to use. These components are shipped as a single NPM package, providing both the JavaScript and Syntactically Awesome Style Sheets (SASS) that New Relic teams can reference via their package.json file. Because our products are built of multiple pieces, we could occasionally end up with a single page built using different internal NPM packages, and these packages may depend on different versions of the New Relic UI. The styles of the latest included version would then override styles of any other versions in the page. Conflicts that can arise in JavaScript are often easily solved, thanks to the availability of tooling like NPM; but CSS (Cascading Style Sheets) has a single global context and lacks the ability to contextualize. We had to come up with a way of fixing this for the New Relic teams that use the components. There is no perfect solution for CSS versioning issues—basically, double-class collisions in CSS—and the industry approaches vary widely, from a single, global CSS that prevents double inclusions to approaches that involve writing all CSS in JavaScript. Each approach has benefits and drawbacks, but we wanted to share how we solve the problem in hopes that our solutions can inform your own efforts to deal with CSS conflicts. We had three key requirements for our solution: Standard-following: The accepted standard for CSS company-wide is to use SASS, so our versioning solution should also follow it. In addition, we wanted to take advantage of the robust tooling around CSS/SASS. Extensibility and override-ability: Although the goal of our UI component package is to standardize behavior and look-and-feel across all our products, the transition must be made in small bits. Therefore, teams may need the ability to override individual styles if a component does not fit their needs. Zero overhead in production code: We wanted to minimize the impact on runtime, so solutions that involved calling several JavaScript functions for each node to be styled didn’t please us. Solution development With these requirements in mind, we iterated different solutions. Let’s walk through some code samples to illustrate our approach. This is what our CSS looks like: .nr-table { overflow-y: scroll;   &--dark { background: #333; }   &-cell { display: flex; height: 2em; }   // More rules... } The first solution consisted in wrapping all root classes in SASS with an extra class. Then, the root element of each component will include these classes. For the example above, it would look like this: .v5-0-1 { // Note that rules applied to the root element are // wrapped in a different selector (\"&.#{$root}\"). &.nr-table { overflow-y: scroll;   &--dark { background: #333; } }   // Rules applied to child elements are kept as-is. .nr-table { &-cell { display: flex; height: 2em; } } } This will output selectors like: .v5-0-1.nr-table { ... } .v5-0-1.nr-table--dark { ... } .v5-0-1 .nr-table-cell { ... } With these selectors you can use—together with the main class of your root element (nr-table in the example)—the version class (v5-0-1): <div class=\"v5-0-1 nr-table\"> <div class=\"nr-table-cell\"> <!-- Content... --> </div> </div> We had planned to add the root class in SASS via a helper and in JavaScript through a common base class in all our components. This would have implied minimal code changes. However, we soon found problems with this approach. Many of our components can accept other subcomponents, such as a link or button, as children. In the example we use, a link could be inserted in one table cell. But this creates the possibility of a collision between the table version and the link version: <div class=\"v5-0-1 nr-table\"> <div class=\"nr-table-cell\"> <a href=\"/path/to/page\" class=\"v4-3-1 nr-link\"> <span class=\"nr-link-content\">Fancy external page</span> </a> </div> </div> In the HTML above, the nr-link-content matches with version 4.3.1 as expected, but also with 5.0.1 (i.e., selector .v5-0-1) because of the table version. This collision breaks the version sandboxing we wanted to achieve, thus making the solution unusable. Fixing CSS double-class collisions To fix this issue, we decided to prefix each class with the version. This approach doesn’t impact the specificity of the selector. However, the process of adding the version to each class becomes too complex to be done manually, so we decided to automate it. First, we picked a unique prefix. All classes already start with nr-, but we thought that was too generic, so we changed it. In our case we chose nr-css-. Then, we looked through all the UI infrastructure codebase to make sure this combination was not used anywhere else. Finally, we clearly stated that nr-css- implicitly meant a class: All classes must start with nr-css, and you can use nr-css only if you are talking about CSS classes. Next, we developed two Webpack loaders that do AST (Abstract Syntax Tree) traversing (using Gonzales-Pe for SASS, and Babylon + Recast for JavaScript) to find all Literals and TemplateLiterals containing nr-css and modify them by prepending the version (e.g., nr-css-link-content becomes v4-3-1-nr-css-link-selector). Webpack loaders are transformations applied on a resource file of your app. They are functions (running in Node.js) that take the source of a resource file as the parameter and return the new source. Although it might seem complex, both loaders have less than 60 lines each and were written in approximately one day. Fine-tuning overrides As stated above, sometimes temporary overrides are necessary while adopting components on older UIs because of look-and-feel incompatibilities. So our end solution slightly modifies how the version is prepended to each class. We extract version numbers, reverse them, and transform them into a two-digit letter code (the number in base 26, using only letters). For example, version 2.9.114 gets transformed into EKAJAC (AC for 2, AJ for 9 and EK for 114). This allows fine-tuning selection for overrides. In theory, no user of the library should override styles. However, the adoption process is not instantaneous, and some inconsistencies may arise, so we give the possibility of overriding while introducing some intentional friction in the process. The version “hash” plays an important role on how to define your override: Let’s imagine we want to override something in nr-css-table-cell. Its full CSS selector for version 2.9.114 is then EKAJAC-nr-css-table-cell. Depending on how much you select from it (via CSS attribute selectors), you can decide version overriding: The UI Infrastructure team also provides a SASS helper that can combine the desired override into a combined attribute selector. For example, for overriding all patches in version 2.9 (i.e., ~2.9), the consumer would write: @include nr-css-override(\"table-cell\", 2, 9) { background: red; } Which would then compile into CSS as: [class*=\"AJAC-nr-css-table-cell \"], [class$=\"AJAC-nr-css-table-cell\"] { background: red; } Our solution to CSS versioning issues We decided to use the solution that had minimal impact in the current codebase, as well as a negligible impact in performance. In the final approach, zero additional lines of JavaScript are executed on each render. We also provide a fine-grained way of overriding custom rules to ease the transition while adopting the library. This also lets us decide to disable these rules in the future, instantly making all UIs consistent. Again, we hope that this look into our solution can help address any CSS versioning issues you may face. Former New Relic Lead Software Engineer Miguel Jiménez Esún contributed to this post.   By Javier Sánchez-Marín Javier Sánchez-Marín is a lead software engineer for New Relic in Barcelona, Spain. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 235.09436,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How We Solve CSS Versioning Conflicts Here at New <em>Relic</em>",
        "body": " solutions. Let’s walk through some code samples to illustrate our approach. This is what our CSS looks like: .nr-<em>table</em> { overflow-y: scroll;   &amp;--dark { background: #333; }   &amp;-<em>cell</em> { display: flex; height: 2em; }   &#x2F;&#x2F; More rules... } The first solution consisted in wrapping all root classes in SASS"
      },
      "id": "60765cab28ccbc09f451c193"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/article-templates/landing-page-template/",
      "sections": [
        "Landing page template",
        "Important",
        "Front matter",
        "Tip",
        "Introduction section",
        "Tiles",
        "Button for viewing all docs in the category",
        "Code sample"
      ],
      "published_at": "2021-04-16T01:35:17Z",
      "title": "Landing page template",
      "updated_at": "2021-04-12T11:25:05Z",
      "type": "docs",
      "external_id": "c40093f49b3daaa82483e1f82228c53a3b12ad6c",
      "document_type": "page",
      "popularity": 1,
      "body": "Landing pages are a specialized type of page that serve as the starting pages for various New Relic products. For example, you'll see landing pages for Application monitoring (APM) and Browser monitoring. Important This landing page information does not apply to the docs home page. If you need to create a new landing page, you can either copy an existing landing page, or you can modify the sample landing page shown at the bottom. The next sections look at what you need to include for each landing page. Front matter When you insert the front matter, be sure to designate the type as landingPage. Here's an example: --- title: New Relic APM type: landingPage --- Copy Tip In the front matter, the following are optional: tags, translate, and redirects. So, you can leave them out if they don't have any values. Introduction section Following the front matter, the first content section is a two-column introduction (also called the hero section). This includes the following: A <LandingPageHero> component wrapping all the introductory content. A <HeroContent> component wrapping the text portion of the introduction (the content in the left column). An image or video (appears in the right column). A caption (optional), which is wrapped by the <figcaption> component. Here's an example of the hero section that shows you where to insert your content: <LandingPageHero> <HeroContent> INSERT_PARAGRAPHS_FOR_YOUR_INTRODUCTION </HeroContent> ![INSERT_ALT-TEXT_HERE](./images/INSERT_IMAGE_FILE_NAME.png \"INSERT_THE_IMAGE_TITLE_HERE\") <figcaption> INSERT_OPTIONAL_CAPTION_USING_SAME_INDENTATION_AS_IMAGE </figcaption> </LandingPageHero> Copy Tiles Tiles are a series of boxes after the introduction. They contain the main subject areas for your product. You should just list these in order you want them to appear, and the cascading style sheet will render them across the page. Here's an example of a tile: <LandingPageTileGrid> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE.\" href=\"/docs/INSERT_THE_DIRECTORY_PATH_TO_THE_TARGET_LANDING_PAGE_INDEX.HTML\" icon=\"fe-INSERT_THE_ICON_NAME\" > INSERT_TILE_CONTENT_HERE... </LandingPageTile> ... Copy For each tile, do the following: Insert a value for title that explains the purpose of the category. Insert a value for href that links to the target landing page. If the target landing page is index.html, you can just include the directory path with no filename since index.html is the default (it doesn't cause any problems if you include index.html). Insert a value for icon by prefixing the icon name with fe- (Feather icons), logo- (third-party logos), or nr- (New Relic logos). For example, here is the format for a feather icon: fe-alert-triangle). Tip For more details about icons, see Embed images. Between the LandingPageTile tags, insert text, such as a bullet list with links to product documentation. Button for viewing all docs in the category After your tiles, you should have a single button that offers to take users to all the documentation for that category. The table of contents page that gets linked here is always at the same path as the landing page, but with /table-of-contents appended to it. These table of contents pages get built automatically for every landing page. For example, if this landing page was located at /docs/apm, this link should be /docs/apm/table-of-contents. Here's an example: <ButtonLink role=\"button\" to=\"INSERT_LINK_TO_DIRECTORY_WITH_ALL_THESE_DOCS/table-of-contents\" variant=\"normal\" > View all INSERT_YOUR_CATEGORY_HERE docs </ButtonLink> Copy Code sample Here's a sample landing page you could modify to suit your needs: --- title: INSERT_YOUR_TITLE_HERE type: landingPage --- <LandingPageHero> <HeroContent> INSERT_PARAGRAPHS_FOR_YOUR_INTRODUCTION </HeroContent> ![INSERT_ALT-TEXT_HERE](./images/INSERT_IMAGE_FILE_NAME.png \"INSERT_THE_IMAGE_TITLE_HERE\") <figcaption> INSERT_OPTIONAL_CAPTION_USING_SAME_INDENTATION_AS_IMAGE </figcaption> </LandingPageHero> <LandingPageTileGrid> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * [INSERT_LINK_NAME](INSERT_LINK_URL) Aliquam auctor mattis nisl ut iaculis. * [INSERT_LINK_NAME](INSERT_LINK_URL) Suspendisse pharetra elit sit amet risus euismod, a consectetur tortor vulputate. </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) to lectus diam, ornare vitae dui suscipit, laoreet ultrices lacus. * Mauris tempor massa ac augue mattis, nec pharetra quam mollis [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) rhoncus tortor vitae libero laoreet feugiat. * Donec dui elit, fermentum vel faucibus sed, rhoncus in felis [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) uspendisse pharetra elit sit amet risus euismod. * Pellentesque finibus magna vitae hendrerit gravida [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) Etiam imperdiet felis eu ipsum consequat tristique. * Etiam imperdiet felis eu ipsum consequat tristique [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) Quisque hendrerit, dolor sed sodales aliquet. * Vestibulum varius lectus ac velit euismod [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> </LandingPageTileGrid> <ButtonLink role=\"button\" to=\"INSERT_LINK_TO_DIRECTORY_WITH_ALL_THESE_DOCS/table-of-contents\" variant=\"normal\" > View all INSERT_YOUR_CATEGORY_HERE docs </ButtonLink> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 211.93027,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Introduction</em> section",
        "body": "-column introduction (also called the hero section). This includes the following: A &lt;LandingPageHero&gt; <em>component</em> wrapping all the introductory content. A &lt;HeroContent&gt; <em>component</em> wrapping the text portion of the introduction (the content in the left column). An image or video (appears in the right"
      },
      "id": "6042212a28ccbc283feba79d"
    },
    {
      "sections": [
        "Use a Plugin Central plugin",
        "Important",
        "Limited access to legacy plugins",
        "View plugin dashboard details",
        "Plugin summary",
        "Plugin dashboards",
        "Plugin alerts",
        "Delete a plugin",
        "Remove plugin components (instances)",
        "Delete the plugin"
      ],
      "title": "Use a Plugin Central plugin",
      "type": "docs",
      "tags": [
        "Plugins",
        "Plugins New Relic",
        "Install plugins"
      ],
      "external_id": "feae68c2e9d870f7c02fff5ffb69f2c262a0cd6c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/plugins/plugins-new-relic/install-plugins/use-plugin-central-plugin/",
      "published_at": "2021-04-16T10:20:00Z",
      "updated_at": "2021-03-16T11:03:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important For an even better experience than plugins, go to: newrelic.com/integrations: Integrate the on-host and cloud systems you already use with New Relic, so you can filter and analyze data, create dashboards, and set alerts within a single platform. developer.newrelic.com: Use developer tools to collect data from any source, automate workflows, build apps, and use our APIs. Limited access to legacy plugins As of December 2, 2020, plugin access has been limited to accounts that have accessed a legacy plugin in the past 30 days. The legacy plugin experience will reach end of life (EoL) as of June 16, 2021. For more information, see our Explorers Hub post. View plugin dashboard details Each plugin in Plugin Central includes procedures for how to install, use, troubleshoot, and uninstall it. Plugins in Plugin Central are not supported with accounts that host data in the EU region data center. After you install a plugin, it starts to receive data, usually within five minutes. The plugin automatically appears with a short name and icon on your Plugins menu in New Relic One. You do not need to select it from Plugin Central. The amount and types of information on the plugin's summary page and dashboards depend on the specific plugin. For example, a plugin may have one or more components (instances) and one or more dashboards. To view summary and dashboard details about the plugin: Go to one.newrelic.com > More > Plugins, and select your plugin. From the plugin's summary page, review the list of components or instances, summary metrics, and list of Recent Events. To view dashboard details about any component or instance, select its name. Plugin summary Depending on the plugin, the summary includes: One or more components or instances (what the plugin agent is monitoring, typically a host/port pair) Zero to five summary metrics for the past three minutes (values such as average, total, minimum, maximum, standard deviation, rate, or count) with optional alerts Recent events list, including deployments, notifications, and alerts Other information about alert violations, events, and activity If your plugin has 100 or more components or instances, you can search for a specific component instance. Here is a summary of additional standard features. If you want to... Do this... View version information for a component's or instance's agent Mouse over the component's name. Change the sort order On the title row of the plugin's summary page, select the up or down arrow for a component (instance) or a summary metric's label. Show or hide items on the events and activity list Select an event icon, or select All. View details about an event On the events and activity list, select the link. View page details for a component or instance Select the name or a summary metric for the component (instance). Plugin dashboards Depending on the plugin, it may have one or more dashboards, and each dashboard may present data as a chart or a table. You can use any of New Relic's standard dashboard features to drill down into detailed information. The customized dashboards that show plugin data are part of the plugin. Users cannot add or remove these dashboards. This must be done by the author or publisher as part of a plugin update. Plugin alerts If the plugin publisher set Critical (red) or Caution (yellow) alert conditions for your plugin's components or instances, you can view details direct in the user interface. For example, you can: Select and view alert details. Change the existing thresholds. Set your alert notification options; for example, to receive email notifications for Critical events. Delete a plugin Each plugin in Plugin Central includes procedures for how to uninstall it. When you select the plugin's Download or Continue button, the plugin should include a README file or refer to other documentation resources. Remove plugin components (instances) At a minimum, your plugin must stop reporting data before you start uninstalling it. Make sure the health status for your plugin's components (instances) are gray. Depending on the plugin, there may be other dependencies before disabling or uninstalling it. For example, plugins from SaaS providers may have different requirements. Be sure to review the instructions that the plugin's publisher provides. Then, to remove individual components from your plugin, click the settings icon for each component (instance). Delete the plugin After you remove each component (instance) for the plugin, the plugin icon will automatically disappear from your Plugins menu in the New Relic UI. You do not need to do anything else to delete the plugin. If you are the plugin's publisher and need to delete the plugin from Plugin Central, go to support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 206.27515,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Remove</em> plugin <em>components</em> (<em>instances</em>)",
        "tags": "Plugins New <em>Relic</em>",
        "body": "&#x27;s name. Change the sort order On the title <em>row</em> of the plugin&#x27;s summary page, select the up or down arrow for a <em>component</em> (instance) or a summary metric&#x27;s label. Show or hide items on the events and activity list Select an event icon, or select All. View details about an event On the events and activity"
      },
      "id": "603ebf0928ccbcf8d0eba762"
    },
    {
      "sections": [
        "Create application baselines",
        "1. Identify components",
        "Tip",
        "Example: List of components",
        "2. Determine compatibility",
        "Example: Components matched to New Relic products",
        "3. Deploy monitoring",
        "Deploy New Relic APM",
        "Deploy New Relic Infrastructure",
        "Deploy Infrastructure on-host integrations",
        "Create New Relic Synthetics monitors",
        "4. Gather metrics",
        "5. Set up Dashboards",
        "Example: Component performance compared against baselines",
        "Expert tips"
      ],
      "title": "Create application baselines",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "878baea2ae1087d64186b1f08b3b4e7c0326fb70",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/create-application-baselines/",
      "published_at": "2021-04-17T03:09:04Z",
      "updated_at": "2021-03-13T03:34:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Cloud migrations can take many forms. Some companies choose to port their applications directly from their data center to the cloud (a “Lift and Shift” migration) while others focus on completely re-architecting their applications to take advantage of benefits available only in the cloud. No matter your approach, there are three primary questions you want to answer after your migration: Has my application gotten slower? Is my application less stable than before? Am I losing customers due to either of the previous questions? To answer these questions, start by performing some basic testing to establish a baseline for the performance and availability of your systems. A baseline is a measurement of the current performance and availability of your application, which you then use as a comparison after your migration to validate your business case. In some cases, you may change a baseline when you perform migration acceptance testing. You can also use a baseline as a comparison point during your migration to make sure that you are on track. 1. Identify components Before you begin a cloud migration, identify all the tiers of your entire application stack. List all of the components (applications, services, etc.) that you want to migrate. Segment the application stack as follows: Application (backend/microservices/cron jobs) Dependency services, such as the message queue Database Website Underlying server and infrastructure Tip Make sure that you have access to applications and instances before you start creating application baselines. Engage your application owners, DevOps engineers, and product managers for access. Example: List of components Here is an example of the list of components in an application stack: Component Name Owner Language Stack Accessibility (Internet, Intranet) Operating System Service 1 John Doe Java Internet RHEL 6 Service 2 Maya Wiz .NET Intranet Win2003 R2 RabbitMQ John Doe Java Intranet AIX Website Maya Wiz Classic ASP Internet Win2000 MS SQL Dave Z NA Intranet Win2003 R2 2. Determine compatibility Once you identify the applications that you want to migrate, it is time to verify which application tiers to monitor with the New Relic platform. Work with stakeholders in your organization to determine the amount of instrumentation that is possible–or allowed–within your organization. This is an important step and one that will pay off, as the more you can instrument, the better your baselines. Here are the New Relic products to use for baselining, depending on the components that you identified: New Relic APM: Monitor your web apps with New Relic APM. See Compatibility and requirements for New Relic agents and products to learn precise compatibility details for each supported language. New Relic Infrastructure: Monitor your hosts with New Relic Infrastructure. See Compatibility and requirements for New Relic Infrastructure for supported operating systems and environments. You can also instrument other products and services with on-host integrations. New Relic Synthetics: Monitor web frontends and APIs with New Relic Synthetics. Sometimes, you may not be able to instrument your on-premise environment with APM or Infrastructure. For example, maybe your organization's policy forbids installing an agent behind a firewall. In these cases, if the application has a web frontend, use Synthetics, as it offers non-agent monitoring while still providing the ability to establish a baseline. Example: Components matched to New Relic products Match the components that you identified with their corresponding products: Component Name Tier Owner Language Stack Accessibility (Internet/ Intranet) Operating System New Relic Products Service 1 John Doe Java Internet RHEL 6 APM, Infrastructure, Synthetics Service 2 Maya Wiz .NET Intranet Win2003 R2 APM, Infrastructure ActiveMQ John Doe Java Intranet AIX APM, Plugin Website Maya Wiz Classic ASP Internet Win2000 Synthetics MS SQL Dave Z n/a Intranet Win2003 R2 Infrastructure, On-host Integration 3. Deploy monitoring Based on the component-product matches you made, deploy agents or monitors across your architecture: Deploy New Relic APM Install the APM agent on your application stack. The steps to install the APM agent are different based on language. Deploy New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, follow the instructions to install the Infrastructure agent on your hosts: Install for Linux Install for Windows Server Install on AWS Elastic Beanstalk Install with a configuration management tool Deploy Infrastructure on-host integrations To gain extended visibility into applications that your code depends on, deploy on-host integrations. Available integrations include Apache, MySQL, NGINX, and others. Create New Relic Synthetics monitors New Relic Synthetics is a suite of automated, scriptable tools to monitor your websites, critical business transactions, and API endpoints. To get started add a monitor. Tip Make sure to verify that your website URL is accessible from the public network. You may also need to add New Relic IPs to your allow list. 4. Gather metrics After you deploy the agents and monitors, identify which metrics are the most important to your business and use these metrics to define your KPIs. Some recommendations include: Response time: Time taken to respond to a request. Throughput: Number of requests that came in through the application. Requesting queuing (Apache, IIS, NGINX): Duration of time taken for a request to reach your application. Database call duration: Duration of time taken to complete a database call. DB call counts: Number of calls made by application code to the database. Error rate: Percent of errors reported. Apdex score: An industry standard to measure user satisfaction with the response time of web applications and services. DNS setup timing: The time it takes to connect and receive data from DNS. SSL setup timing: The time it takes to establish an SSL connection. You can find some of these metrics in service maps, as well as on APM, and [Browser] ( /docs/ /new-relic-browser/getting-started/browser-overview-page-website-performance-summary) overview pages. For more detailed information about navigating, interpreting, and using New Relic APM, check out these New Relic University’s tutorials: Overview dashboard tour Transactions dashboard Understanding Apdex 5. Set up Dashboards After you define your KPIs, it is easy to visualize them in New Relic Dashboards. Dashboards provide a single location to view all the data that New Relic products gather. Dashboards data consists of events, and each event has an event type, a timestamp, and key-value attributes. For more information about events, see Data collection and Default events for New Relic products. You can locate your KPIs and business metrics data in New Relic using the data explorer and the NRQL query language. You can also build Dashboards to track the performance of those KPIs: Example: Component performance compared against baselines Continuing the examples in this document, the following table illustrates the maturity of your application performance over a period of time based on deployment milestones. Each milestone will serve as a new baseline for your applications: Component Milestone 1 Milestone 2 Milestone N Environment Component Name Response Time SLA Apdex Response Time SLA Apdex Response On-Prem Service 1 1.5 secs 80% 70% 1.5 secs 68% 0.65 1.4 secs Cloud Service 1 0.9 secs 96.8% 95% 0.9 secs 98% 0.99 0.7 secs On-Prem Service 2 0.7 secs 73% 68% 0.7 secs 80% 0.78 0.85 secs Cloud Service 2 0.6 secs 90% 92% 0.6 secs 89% 0.90 0.5 secs After your migration, compare these baselines against your migration acceptance testing baselines. Expert tips If you find that you need data that is not captured by default instrumentation, New Relic makes it easy to capture custom data: APM custom instrumentation Browser custom data Infrastructure custom attributes Custom event data Mobile custom data Synthetics custom attributes You can also learn more about APM custom instrumentation with the New Relic University Custom data tutorial series.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.65227,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>application</em> baselines",
        "sections": "Example: <em>Components</em> matched to New <em>Relic</em> products",
        "tags": "New <em>Relic</em> solutions",
        "body": " Classic ASP Internet Win2000 Synthetics MS SQL Dave Z n&#x2F;a Intranet Win2003 <em>R</em>2 Infrastructure, On-host Integration 3. Deploy monitoring Based on the <em>component</em>-product matches you made, deploy agents or monitors across your architecture: Deploy New Relic APM Install the APM agent on your application"
      },
      "id": "6044605c64441f1d15378edf"
    },
    {
      "sections": [
        "Plugin summary metrics and dashboards",
        "Important",
        "Limited access to legacy plugins",
        "Plugin summary metrics",
        "Add summary metrics",
        "Optional: Add alert summary metrics",
        "Time periods for metrics",
        "Plugin dashboards",
        "View the default dashboard",
        "Add dashboards",
        "Avoid metric grouping problems",
        "Change or delete dashboards",
        "Plugin settings",
        "Initial settings",
        "Additional updates"
      ],
      "title": "Plugin summary metrics and dashboards",
      "type": "docs",
      "tags": [
        "Plugins",
        "Plugin developer resources",
        "Develop plugins"
      ],
      "external_id": "a0163b9f1efd59d8c50c60a3b8b5b5419f336824",
      "image": "",
      "url": "https://docs.newrelic.com/docs/plugins/plugin-developer-resources/develop-plugins/plugin-summary-metrics-dashboards/",
      "published_at": "2021-04-16T15:11:44Z",
      "updated_at": "2021-03-16T11:00:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important For an even better experience than plugins, go to: newrelic.com/integrations: Integrate the on-host and cloud systems you already use with New Relic, so you can filter and analyze data, create dashboards, and set alerts within a single platform. developer.newrelic.com: Use developer tools to collect data from any source, automate workflows, build apps, and use our APIs. Limited access to legacy plugins As of December 2, 2020, plugin access has been limited to accounts that have accessed a legacy plugin in the past 30 days. The legacy plugin experience will reach end of life (EoL) as of June 16, 2021. For more information, see our Explorers Hub post. Plugin summary metrics Each component or instance for your plugin in Plugin Central can have summary metrics, such as average, total, minimum, maximum, standard deviation, rate, or count. The summary metrics appear on your plugin's Summary page in the Plugins user interface. The summary metric dashboards are also useful as a debugging tool to review all of the metrics sent by your plugin agent to New Relic. To view dashboard details about any component or instance, select any summary metric value for it. You can also change various plugin settings in the UI. When you first create a summary metric for your plugin, this triggers a change to New Relic's collectors. This may cause your running components (instances) to stop showing summary metrics for a short period of time. For example, if you add a new summary metric to your plugin, any components (instances) you are monitoring that use that plugin may have all summary metrics temporarily cleared. This will also close any outstanding related events and alerts. Depending on the components and other factors, you may need to wait fifteen minutes or more before summary metrics appear again. Add summary metrics To add a summary metric: Go to one.newrelic.com > More > Plugins, and select your plugin. From the plugin's Summary page, select Edit. From the Summary metrics section of the plugin's editing page, select Add. If your plugin contains only one summary metric, you can identify the metric in the chart's title and then hide the legend (colored bars that label the metrics) that normally appears below the chart. Also, if you define negative metric values, the charts on your plugin's dashboards will not show them. However, the summary metrics for your plugin will show negative values. Optional: Add alert summary metrics Plugin publishers and users can define alert conditions from the plugin's Summary page by selecting the component's or instance's settings icon. The alerts will be activated when the summary metric's specified values fall above the thresholds. The Recent events list for the plugin's components (instances) appears on the plugin's Summary page. To view additional details about an alert, select its name. Sometimes there may be a delay between the time that a summary metric event is triggered and the time that New Relic creates the corresponding incident and sends the alert notification. There are several timing mechanisms at work, such as collector caching, summary metric event timing, delayed job queues, email delivery, etc. Depending on the situation, this delay could be up to ten or fifteen minutes before the alert notification is sent. Time periods for metrics Metrics that appear in dashboards are reported with a duration. The end time is implied by the time New Relic receives the metrics. This is why you cannot define metric values that both start and end in the future, or start and end in the past. The Plugin API is designed for live metrics only, not historical metric collection. Metrics may only be reported for a period starting in the past (no more than a few hours) and ending upon reporting. The charts on your plugin's dashboards can show various time periods. You can also deliver data at one-hour intervals. New Relic does not extrapolate data values between the data points delivered. For example, New Relic aggregates when there is too much data, but it does not extrapolate if there is not enough data. In order for data to appear on a 30-minute chart, make sure at least one data point is within the range, or no data will appear. Recommendation: Use a 60-second polling interval. Default dashboards show 30 minutes of data, which gives 30 data points for the chart. Or, if you want to show 3 days of data, use a 1-hour polling interval, which provides 24 * 3=72 data points for your chart. Plugin dashboards You can create dashboards to visualize the data generated by your plugins in New Relic. You must be a plugin author or publisher to add, edit, and delete dashboards. Plugin users cannot customize the plugin dashboards they acquire from Plugin Central. View the default dashboard New plugins automatically include a default dashboard. Once your plugin agent starts sending data to New Relic's Plugin API, you can view the default dashboard in New Relic's UI and change it as needed. To view the default dashboard for your plugin: Go to one.newrelic.com > More > Plugins, and select your plugin. From the plugin's Summary page, select a component (instance). Add dashboards In addition to the default dashboard, you can create as many additional dashboards for your plugin as you want. After you publish your plugin, all of these dashboards and summary metrics are available to plugin users. The customized dashboards that display plugin data are part of the plugin. Plugin users cannot add their own dashboards. This needs to be done by the author or publisher as part of a plugin fork or update. To create additional dashboards: Go to one.newrelic.com > More > Plugins, and select your plugin. From the plugin's summary page, select Edit. From the Dashboards section of the plugin's editing page, select Add. Specify a title for your dashboard, select a page layout, then select Create. From the new dashboard page, type a label for the new chart or table, and then select Add chart or table. Edit the chart, including the case-sensitive metrics (for example, a metric name you see in the agent output, such as Component/SIN[Value]) and value (for example, Total value). To use additional options (for example, number format), select Advanced options. Optional: Use a wildcard (*) to show multiple metrics on a chart. For example, to include the metric component/foo/bar and the metric component/foo/xyz, use the metric name component/foo/*.f Select Save and Preview to preview the chart or table. Or, select Save and finish when you are satisfied with the appearance of the chart or table. Review the new chart that appears on the customized dashboard, and continue adding, editing, or rearranging charts and tables on your dashboard as needed. When finished, select I'm done editing. Avoid metric grouping problems Wildcards provide flexibility for how your metric names appear. When creating a chart, consider whether you want the metric names to appear with identical namespace segments, or include a wildcard to strip the namespace segments. For example: Component/Database/Metric1 Component/Database/Metric2 Component/Database/Metric3 Copy OR Metric1 Metric2 Metric3 Copy To prevent problems with metric grouping issues, avoid defining values that result in excessively large numbers. For example, if a plugin's chart value is 1 widget and New Relic collects 3 million widgets, change the value to 1 million widgets so that the chart can show millions of widgets more efficiently. Also, avoid creating high-precision values containing many digits after a decimal point. Change or delete dashboards To update or remove any plugin dashboard, including the default: Go to one.newrelic.com > More > Plugins, and select your plugin. From the plugin's summary page, select Edit. Keep a stable production version of your plugin that users can acquire from Plugin Central, and create a development version that you are actively improving, testing, browsing the presentation of metrics on your custom dashboard, or otherwise have in a non-production state. Plugin settings You can change several plugin settings before you publish the plugin. You can also make changes at any time to published plugins. Initial settings Before you publish your plugin, you can: Select a generic plugin icon for the Plugins UI. This is not the same as the URL for your customized branding image you may choose as part of the publishing process. Change your plugin's label for the Plugins UI. By default, this is the first 11 characters of the plugin's Title field. Change your plugin's title. The default title is your plugin's GUID. Add, change, or delete your plugin's summary metrics and their alert conditions. Add, change, or delete your plugin's dashboards. Exception: You can edit but you cannnot delete your plugin's default dashboard. To add, change, or delete plugin settings: Go to one.newrelic.com > More > Plugins, and select your plugin. From the plugin's Summary page, select Edit. When finished, be sure to save your changes. Additional updates After you publish your plugin, you can continue making changes. Recommendation: To avoid development and testing impacts on your users, maintain development and production versions. To make additional updates to your plugin: Go to one.newrelic.com > More > Plugins, and select your plugin. From your plugin's Summary page, select Edit, Publish, or your component's (instance's) settings icon as applicable. Update the settings as needed, and then save your changes. When you are ready to release this version: Go to one.newrelic.com > More > Plugins, select your plugin, and then select Publish. Here is a summary of where to view or make changes to your plugin. Type of change Edit Publish Settings Agent: Change the plugin's version (n/a in UI). Alert conditions, customized for components (instances) Alert conditions, defaults for summary metrics Branding image (URL) that appears in Plugin Central Components (instances): Remove from your plugin Dashboards: Add, edit, delete Description Developer Terms of Service Icon that appears in the Plugins UI Name for plugin (label) in the Plugins UI Name for plugin (title) in Plugin Central NPI Compatible designation Publisher's name Summary metrics: Add, edit, delete URL for installation and setup instructions URL for your support site URL for your website (\"About us\")",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.58443,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Initial</em> settings",
        "tags": "Plugin developer <em>resources</em>",
        "body": " multiple metrics on a chart. For example, to include the metric <em>component</em>&#x2F;foo&#x2F;bar and the metric <em>component</em>&#x2F;foo&#x2F;xyz, use the metric name <em>component</em>&#x2F;foo&#x2F;*.f Select Save and Preview to preview the chart or <em>table</em>. Or, select Save and finish when you are satisfied with the appearance of the chart or <em>table</em>"
      },
      "id": "603ea2bc196a6740f7a83de2"
    }
  ],
  "/automate-workflows/kubernetes-helm-deployment": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/SynthKub1.png",
      "url": "https://newrelic.com/blog/how-to-relic/deploy-synthetics-from-kubernetes-environments",
      "sections": [
        "Benefits of connecting New Relic Synthetics and Kubernetes",
        "How to get started with New Relic Synthetics and Kubernetes",
        "To monitor the CPM using the Kubernetes cluster explorer",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:24:33Z",
      "title": "Deploy Synthetics from Kubernetes Environments to Monitor Employee-Facing Applications",
      "updated_at": "2021-04-13T23:54:47Z",
      "type": "",
      "external_id": "fe7c715c1417af64bd4c5ffc1871739a673484f8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Kubernetes Monitoring Deploy Synthetics from Kubernetes Environments to Monitor Employee-Facing Applications May 13, 2020 • 7 min read By Mat Ball Kubernetes helps increase the velocity of deployments, improve infrastructure durability, and automate the building, running, and maintaining of applications throughout your production environments. To optimize performance, New Relic released the Kubernetes cluster explorer so you can quickly understand the health of your rapidly-scaling environments of pods, containers, and applications. Synthetic testing and monitoring allows you to proactively test the availability and performance of your critical endpoints.  We launched containerized private minions to help you easily incorporate uptime monitoring into the build process as you tested employee facing applications behind the firewall. For these reasons, we’re excited to announce that New Relic users can now add private minions into their Kubernetes environments. This new feature offers our customers the ability to automatically deploy synthetic private locations and run monitors alongside them as part of a Kubernetes deployment. In short, New Relic Synthetics is meeting you where you are—within the systems you’re using—to automate and manage your build and deployment processes. You now have an easier way to automate and ensure that your critical endpoints are available and performant as you rapidly change and scale your systems. Benefits of connecting New Relic Synthetics and Kubernetes We’ve made Synthetics compatible with your Kubernetes orchestration software, enabling you to use Kubernetes to monitor availability and performance from Synthetic’s private locations, such as those behind a firewall or not exposed to the public. Leveraging Kubernetes to automate and manage these private locations helps developers save time and reduce manual efforts. Use the private minion Helm charts to easily include a private location in your next Kubernetes deployment. Once the location is created, add it to your existing Synthetics monitors, and you’ll be up and running in minutes. Leave the scaling and reliability concerns to Kubernetes. We have designed our private minion so that Kubernetes has full control over the resources and containers. The Helm charts allow you to use our recommended default resources or provide you with the ability to define the resource allocation per synthetics check. This helps you focus more on remediating latency and improving reliability, and less on configuration and instrumentation. Even more, we offer additional visibility of the Kubernetes host itself. Using the New Relic Kubernetes cluster explorer you can quickly see the health and status of your private location, alongside the other containers running in your Kubernetes environment. You can also easily view stats and errors about your private location, and understand how widespread issues might be across other applications running on the same cluster. This way, New Relic customers leveraging Kubernetes can simultaneously deploy a new version of their application alongside APM and Synthetics. The feature makes it easy by leveraging Helm charts on Kubernetes, which automatically provide reference configurations, steps for deployment, and resource requirements. If an application experiences issues and is re-deployed per the Kubernetes automated deployment process, Synthetics is also redeployed with no additional configuration needed. How to get started with New Relic Synthetics and Kubernetes Confirm you meet the Kubernetes container orchestration system environment requirements. Locate your private location key.  Go to synthetics.newrelic.com > Private locations.In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Set up a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com/charts If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Install the CPM using the Helm charts: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY To update an existing CPM installation: helm update YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YO Next, connect into New Relic’s Kubernetes cluster explorer. To monitor the CPM using the Kubernetes cluster explorer Locate your license key. Find your cluster name: kubectl config current-context Confirm you have kube-state-metrics installed: kubectl get deployment --all-namespaces | grep kube-state-metrics Select the cluster for the agent installation: kubectl config set-cluster DESIRED_CLUSTER Add the Helm charts: helm repo add stable https://kubernetes-charts.storage.googleapis.com/ Install the Kubernetes integration using the Helm charts, depending on whether you're using Helm 2 or Helm 3 Look up the Synthetics minion in your Kubernetes cluster explorer. For employee-facing applications, or any application not exposed to the public or behind the firewall, availability, and performance is critical to efficiency. Kubernetes orchestration software allows teams to quickly automate change and more easily manage the build and deploy process. Incorporating synthetic monitoring into Kubernetes software gives software engineers the ability to easily detect, isolate, and communicate problems of availability and performance for critical application endpoints. To learn more about how you can enable teams to proactively detect and resolve incidents faster by finding problems before they impact customers, check out New Relic Synthetics. Related Topics Kubernetes Monitoring By Mat Ball Mat Ball is a product marketing manager at New Relic focused on the impact of frontend web applications to business and customer experience outcomes. Previously, Mat worked for SOASTA, where he marketed their data science product. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 213.26712,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Benefits of connecting <em>New</em> <em>Relic</em> Synthetics and Kubernetes",
        "body": " the key associated with the private location with the key icon. <em>Set</em> <em>up</em> a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy the <em>Helm</em> <em>charts</em> from the <em>New</em> <em>Relic</em> <em>Helm</em> repo. If you are copying the <em>charts</em> for the first time: <em>helm</em> repo add YOUR_REPO_NAME https:&#x2F;&#x2F;<em>helm</em>"
      },
      "id": "60762f4864441f45329d854f"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/openshift5.png",
      "url": "https://newrelic.com/blog/how-to-relic/what-is-kubernetes",
      "sections": [
        "OK, but why all the buzz? Why is Kubernetes so popular?",
        "So, how does Kubernetes work?",
        "The Kubernetes master",
        "Nodes",
        "Deployments and replicas",
        "Namespaces",
        "Labels",
        "Stateful sets and persistent storage volumes",
        "Other useful components",
        "Kubernetes DNS",
        "Cluster-level logs",
        "Helm: managing Kubernetes applications",
        "Kubernetes and Istio: a popular pairing",
        "Challenges to Kubernetes adoption",
        "New Relic can support your Kubernetes journey",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:38:48Z",
      "title": "What Is Kubernetes? An Introduction to the Wildly Popular Container Orchestration Platform",
      "updated_at": "2021-04-14T00:02:30Z",
      "type": "",
      "external_id": "1e800a620cd7bce03e30dd9a74ee244fc2e5ad6a",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Kubernetes Monitoring What Is Kubernetes? An Introduction to the Wildly Popular Container Orchestration Platform Aug 15, 2019 • 14 min read By Ali Gerrard This is an update of a post originally published in July, 2018. Container-based microservices architectures have profoundly changed the way development and operations teams test and deploy modern software. Containers help companies modernize by making it easier to scale and deploy applications, but containers have also introduced new challenges and more complexity by creating an entirely new infrastructure ecosystem. Large and small software companies alike are now deploying thousands of container instances daily, and that’s a complexity of scale they have to manage. So how do they do it? Enter the age of Kubernetes. Originally developed by Google, Kubernetes is an open-source container orchestration platform designed to automate the deployment, scaling, and management of containerized applications. In fact, Kubernetes has established itself as the defacto standard for container orchestration and is the flagship project of the Cloud Native Computing Foundation (CNCF), backed by key players like Google, AWS, Microsoft, IBM, Intel, Cisco, and Red Hat. Kubernetes makes it easy to deploy and operate applications in a microservice architecture. It does so by creating an abstraction layer on top of a group of hosts, so that development teams can deploy their applications and let Kubernetes manage: Controlling resource consumption by application or team Evenly spreading application load across a host infrastructure Automatically load balancing requests across the different instances of an application Monitoring resource consumption and resource limits to automatically stop applications from consuming too many resources and restarting the applications again Moving an application instance from one host to another if there is a shortage of resources in a host, or if the host dies Automatically leveraging additional resources made available when a new host is added to the cluster Easily performing canary deployments and rollbacks See also: Docker vs. Kubernetes: It’s Not About One or the Other OK, but why all the buzz? Why is Kubernetes so popular? As more and more organizations move to microservice and cloud native architectures that make use of containers, they’re looking for strong, proven platforms. Practitioners are moving to Kubernetes for four main reasons: 1. Kubernetes helps you move faster. Indeed, Kubernetes allows you to deliver a self-service Platform-as-a-Service (PaaS) that creates a hardware layer abstraction for development teams. Your development teams can quickly and efficiently request the resources they need. If they need more resources to handle additional load, they can get those just as quickly, since resources all come from an infrastructure shared across all your teams. No more filling out forms to request new machines to run your application. Just provision and go, and take advantage of the tooling developed around Kubernetes for automating packaging, deployment, and testing, such as Helm (more below). 2. Kubernetes is cost efficient. Kubernetes and containers allow for much better resource utilization than hypervisors and VMs do; because containers are so light weight, they require less CPU and memory resources to run. 3. Kubernetes is cloud agnostic. Kubernetes runs on Amazon Web Services (AWS), Microsoft Azure, and the Google Cloud Platform (GCP), and you can also run it on-premise. You can move workloads without having to redesign your applications or completely rethink your infrastructure—which lets you to standardize on a platform and avoid vendor lock-in. In fact, companies like Kublr, Cloud Foundry, and Rancher provide tooling to help you deploy and manage your Kubernetes cluster on-premise or on whatever cloud provider you want. 4. Cloud providers will manage Kubernetes for you. As noted earlier, Kubernetes is currently the clear standard for container orchestration tools. It should come as no surprise, then, that major cloud providers are offering plenty of Kubernetes-as-a-Service-offerings. Amazon EKS, Google Cloud Kubernetes Engine, Azure Kubernetes Service (AKS), Red Hat Openshift, and IBM Cloud Kubernetes Service all provide a full Kubernetes platform management, so you can focus on what matters most to you—shipping applications that delight your users. So, how does Kubernetes work? The central component of Kubernetes is the cluster. A cluster is made up of many virtual or physical machines that each serve a specialized function either as a master or as a node. Each node hosts groups of one or more containers (which contain your applications), and the master communicates with nodes about when to create or destroy containers. At the same time, it tells nodes how to re-route traffic based on new container alignments. The following diagram depicts a general outline of a Kubernetes cluster: The Kubernetes master The Kubernetes master is the access point (or the control plane) from which administrators and other users interact with the cluster to manage the scheduling and deployment of containers. A cluster will always have at least one master, but may have more depending on the cluster’s replication pattern. The master stores the state and configuration data for the entire cluster in ectd, a persistent and distributed key-value data store. Each node has access to ectd and through it, nodes learn how to maintain the configurations of the containers they’re running. You can run etcd on the Kubernetes master, or in standalone configurations. Masters communicate with the rest of the cluster through the kube-apiserver, the main access point to the control plane. For example, the kube-apiserver makes sure that configurations in etcd match with configurations of containers deployed in the cluster. The kube-controller-manager handles control loops that manage the state of the cluster via the Kubernetes API server. Deployments, replicas, and nodes have controls handled by this service. For example, the node controller is responsible for registering a node and monitoring its health throughout its lifecycle. Node workloads in the cluster are tracked and managed by the kube-scheduler. This service keeps track of the capacity and resources of nodes and assigns work to nodes based on their availability. The cloud-controller-manager is a service running in Kubernetes that helps keep it “cloud-agnostic.” The cloud-controller-manager serves as an abstraction layer between the APIs and tools of a cloud provider (for example, storage volumes or load balancers) and their representational counterparts in Kubernetes. Nodes All nodes in a Kubernetes cluster must be configured with a container runtime, which is typically Docker. The container runtime starts and manages the containers as they’re deployed to nodes in the cluster by Kubernetes. Your applications (web servers, databases, API servers, etc.) run inside the containers. Each Kubernetes node runs an agent process called a kubelet that is responsible for managing the state of the node: starting, stopping, and maintaining application containers based on instructions from the control plane. The kubelet collects performance and health information from the node, pods and containers it runs and shares that information with the control plane to help it make scheduling decisions. The kube-proxy is a network proxy that runs on nodes in the cluster. It also works as a load balancer for services running on a node. The basic scheduling unit is a pod, which consists of one or more containers guaranteed to be co-located on the host machine and can share resources. Each pod is assigned a unique IP address within the cluster, allowing the application to use ports without conflict. You describe the desired state of the containers in a pod through a YAML or JSON object called a Pod Spec. These objects are passed to the kubelet through the API server. A pod can define one or more volumes, such as a local disk or network disk, and expose them to the containers in the pod, which allows different containers to share storage space. For example, volumes can be used when one container downloads content and another container uploads that content somewhere else. Since containers inside pods are often ephemeral, Kubernetes offers a type of load balancer, called a service, to simplify sending requests to a group of pods. A service targets a logical set of pods selected based on labels (explained below). By default, services can be accessed only from within the cluster, but you can enable public access to them as well if you want them to receive requests from outside the cluster. Deployments and replicas A deployment is a YAML object that defines the pods and the number of container instances, called replicas, for each pod. You define the number of replicas you want to have running in the cluster via a ReplicaSet, which is part of the deployment object. So, for example, if a node running a pod dies, the replica set will ensure that another pod is scheduled on another available node. A DaemonSet deploys and runs a specific daemon (in a pod) on nodes you specify. They’re most often used to provide services or maintenance to pods. A daemon set, for example, is how New Relic Infrastructure gets the Infrastructure agent deployed across all nodes in a cluster. Namespaces Namespaces allow you to create virtual clusters on top of a physical cluster. Namespaces are intended for use in environments with many users spread across multiple teams or projects. They assign resource quotas and logically isolate cluster resources. Labels Labels are key/value pairs that you can assign to pods and other objects in Kubernetes. Labels allow Kubernetes operators to organize and select subset of objects. For example, when monitoring Kubernetes objects, labels let you quickly drill down to the information you’re most interested in. Stateful sets and persistent storage volumes StatefulSets give you the ability to assign unique IDs to pods in case you need to move pods to other nodes, maintain networking between pods, or persist data between them. Similarly, persistent storage volumes provide storage resources for a cluster to which pods can request access as they’re deployed. Other useful components These Kubernetes components are useful but not required for regular Kubernetes functionality: Kubernetes DNS Kubernetes provides this mechanism for DNS-based service discovery between pods. This DNS server works in addition to any other DNS servers you may use in your infrastructure. Cluster-level logs If you have a logging tool, you can integrate it with Kubernetes to extract and store application and system logs from within a cluster, written to standard output and standard error. If you want to use cluster-level logs, it’s important to note that Kubernetes does not provide native log storing; you must provide your own log storage solution. Helm: managing Kubernetes applications Helm is an application package management registry for Kubernetes, maintained by the CNCF. Helm “charts” are pre-configured software application resources you can download and deploy and in your Kubernetes environment. According to a 2018 CNCF survey, 68% of respondents said Helm was the preferred package management tool for Kubernetes applications. Helm charts can help DevOps teams come up to speed more quickly with managing applications in Kubernetes; it allows them leverage existing charts that they can share, version, and deploy into their dev and production environments. Kubernetes and Istio: a popular pairing In a microservices architecture like those that run in Kubernetes, a service mesh is an infrastructure layer that allows your service instances to communicate with one another. The service mesh also lets you configure how your service instances perform critical actions such as service discovery, load balancing, data encryption, and authentication and authorization. Istio is one such service mesh, and current thinking from tech leaders, like Google and IBM, suggests they’re increasingly becoming inseparable. The IBM Cloud team, for example, uses Istio to address the control, visibility, and security issues it has encountered while deploying Kubernetes at massive scale. More specifically, Istio helps IBM: Connect services together and control the flow of traffic Secure interactions between microservices with flexible authorization and authentication policies Provide a control point so IBM can manage services in production Observe what’s happening in their services, via an adapter that sends Istio data to New Relic—allowing it to monitor microservice performance data from Kubernetes alongside the application data it's already gathering. Challenges to Kubernetes adoption Kubernetes clearly has come a long way in the first five years of life. That kind of rapid growth, though, also involves occasional growing pains. Here are a few challenges with Kubernetes adoption: 1. The Kubernetes technology landscape can be confusing. One thing developers love about open-source technologies, like Kubernetes is the potential for fast-paced innovation. But sometimes too much innovation creates confusion, especially when the central Kubernetes code base moves faster than users can keep up with it. Add a plethora of platform and managed service providers, and it can be hard for new adopters to make sense of the landscape. 2. Forward-thinking dev and IT teams don’t always align with business priorities. When budgets are only allocated to maintain the status quo, it can be hard for teams to get funding to experiment with Kubernetes adoption initiatives, as such experiments often absorb a significant amount of time and team resources. Additionally, enterprise IT teams are often adverse to risk and slow to change. 3. Teams are still acquiring the skills required to leverage Kubernetes. It wasn’t until a few years ago that developers and IT operations folks had to readjust their practices to adopt containers—and now, they have to adopt container orchestration, as well. Enterprises hoping to adopt Kubernetes need to hire professionals who can code, as well as knowing how to manage operations and understand application architecture, storage, and data workflows. 4. Kubernetes can be difficult to manage. In fact, you can read any number of Kubernetes horror stories—everything from DNS outages to “a cascading failure of distributed systems”— in the Kubernetes Failure Stories GitHub repo. New Relic can support your Kubernetes journey To fully understand what’s going on in your environment, you need to see into all its layers, including inside your containers. That means holistic, application-centric and infrastructure-centric monitoring. Monitoring application performance in Kubernetes is important, but you also need visibility into your Docker and Kubernetes infrastructure. New Relic's Kubernetes cluster explorer, which is part of New Relic Infrastructure , addresses this need. It leverages an on-host integration for Kubernetes that provides deep monitoring for backend and frontend applications and for hosts running in your clusters. The rollout of New Relic's Kubernetes cluster explorer was one highlight among many during a year packed with innovative upgrades to the New Relic Platform Using Kubernetes cluster explorer, teams can expect total visibility, alerting, and dashboards for all Kubernetes entities—metadata for nodes, namespaces, neployments, ReplicaSets, pods, and containers—that host your applications. This integration can be used with provider offerings as well. For example, teams using Red Hat OpenShift can link New Relic APM data with OpenShift data. This step provides deep application performance monitoring (with code instrumentation and distributed tracing) for the applications running in a cluster. After linking your applications, click any of the hexagons in the cluster explorer—each of which represents a pod in a cluster—to open a detailed view of that pod. From there, you can analyze the performance of applications running in that pod. Examine New Relic APM data about the applications running in your OpenShift clusters. You can even dive into New Relic distributed tracing to inspect the distributed traces captured for the application running in that pod. If you click on an individual span in a distributed trace, you can quickly see the relevant Kubernetes attributes for that application; for example you can find out which pod, cluster, and deployment an individual span belongs to. Get distributing tracing data from the applications running in your OpenShift cluster. Using New Relic to take advantage of the power of Kubernetes is essential for modern software companies looking to move faster with confidence. Learn how to get started monitoring containers yin our Kubernetes environment in the New Relic documentation. Related Topics Kubernetes Monitoring By Ali Gerrard Ali Gerrard is a product marketing manager at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.007385,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> can support your Kubernetes journey",
        "body": "Skip to main content We&#x27;re leveling <em>up</em> FutureStack registration with swag, only until 4&#x2F;30. Terms &amp; conditions apply. Register Now Dismiss alert <em>New</em> <em>Relic</em> logo Search Submit Products Products <em>New</em> <em>Relic</em> One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence"
      },
      "id": "6076311628ccbc612e51c156"
    },
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "Tip",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-ed6795cfdb010c5eabb1cfe9c83a82a9.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-04-16T23:03:27Z",
      "updated_at": "2021-03-16T17:42:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. Tip To use CPMs and synthetic monitoring, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Memory 2.5 GB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a Scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a Simple Browser or Scripted Browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a Runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and Memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com/charts Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.34383,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install and <em>update</em> CPM versions",
        "body": " environment. The CPM will auto-detect its environment to select the appropriate operating mode. Tip To <em>use</em> CPMs and synthetic monitoring, as well as the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign <em>up</em> to create your free account in only a few seconds. Then ingest <em>up</em> to 100GB of data"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/istio_adapter_trace.png",
      "url": "https://newrelic.com/blog/how-to-relic/how-to-monitor-istio-service-mesh",
      "sections": [
        "How the newrelic-istio-adapter works",
        "Istio metrics data",
        "Istio trace data",
        "Getting started with the newrelic-istio-adapter",
        "Contributing to the newrelic-istio-adapter",
        "Related Topics"
      ],
      "published_at": "2021-04-16T00:15:37Z",
      "title": "How To Monitor Istio With New Relic",
      "updated_at": "2021-04-14T00:55:13Z",
      "type": "",
      "external_id": "0b1e64e8faf5a47499cffe287aeac4cf869ce727",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Observability How To Monitor Istio With New Relic Nov 6, 2019 • 7 min read By Tyler Yahn A central component of the New Relic One observability platform is an adherence to open instrumentation. Many open systems and frameworks for software development have built-in metrics, events, logs, and traces that they emit in common formats. For observability, you need to collect telemetry data from both open and proprietary sources, and combine it in one place. Istio is a popular service mesh that lets you connect, monitor, and secure microservices deployed on-premise, in the cloud, or with orchestration platforms like Kubernetes. Istio is an excellent example of a system that emits useful telemetry data about its health and function. In fact, this was one of the primary reasons the New Relic Service Mesh team chose to build New Relic’s next-generation service mesh on the Istio platform. To run our mesh on Istio, we had to build an adapter to directly integrate with Istio's telemetry engine, Mixer. Our adapter leverages Mixer’s extensible architecture to send curated and customizable telemetry for any service-to-service communication within the service mesh to New Relic, all without the need of an agent. Once we built the adapter, though, we knew we couldn’t keep it to ourselves. So, as part of our open instrumentation initiative, we open sourced the newrelic-istio-adapter, available now on GitHub. Read on to learn more about how it works. How the newrelic-istio-adapter works We built the newrelic-istio-adapter using the new go-telemetry-sdk, an open source set of API client libraries that send your metric and trace data to the New Relic platform. Using the SDK we were able to integrate with Mixer to gather two types of telemetry data: Istio's metric telemetry to send that open source metric data to New Relic Istio's trace telemetry to send spans of distributed traces traversing the service mesh to New Relic The newrelic-istio-adapter sits alongside Istio in an isolated environment to ensure no interference with the core service mesh functionality of Istio. Once the adapter is up and running, you configure Mixer to send telemetry about events within the service mesh to the adapter. The adapter transforms and delivers this telemetry data as curated open source (multi-dimensional) metrics—essentially, metrics with multiple key-value pairs—to New Relic. The newrelic-istio-adapter gathers telemetry data from the Istio service mesh in a Kubernetes environment. Istio metrics data The ability to send open source dimensional metrics data to New Relic is a real game changer for any New Relic user. With a high volume of information-rich data, you can query and visualize that data with a high degree of resolution and filter it in meaningful ways through actionable dashboards, alerts, and New Relic One programmable applications. For example, the newrelic-istio-adapter has a default configuration that sends metrics representing the \"four golden signals\" for all services within the service mesh: error rates, latency, request volume, and throughput. The “four golden signals” from the Istio service mesh captured in a New Relic dashboard. Any service running in the service mesh is monitored for these critical, customer-centric signals. You won’t need to reconfigure any service or install a New Relic agent. Istio trace data The good news doesn’t stop there: Any service within the service mesh that supports Zipkin (b3-propagation) traces can have spans sent to New Relic using the newrelic-istio-adapter. Even services you haven’t instrumented with New Relic agents (i.e., open source components of a system) can be included in New Relic’s distributed tracing simply by operating within the service mesh. Traces from services running in the Istio service mesh can tracked in New Relic’s distributed tracing. Getting started with the newrelic-istio-adapter The newrelic-istio-adapter GitHub repository has all the information you need to start gathering metrics and traces from Istio. For more information on how Istio Mixer telemetry is created and collected, refer to this overview on the Mixer configuration model. Key requirements include: A Kubernetes cluster A working kubectl installation A working Helm installation An Istio deployment, including an installed and configured Istio Mixer server A New Relic Insert API Key An APM Pro account Note: Metrics and traces exported from this adapter to New Relic are rate limited. See the New Relic documentation for Trace API general requirements and limits and Metric API limits and restricted attributes for more information. Instructions for deploying the adapter with Helm, as well as for enabling distributed tracing to send trace spans from services within the Istio service mesh to New Relic, are available in the GitHub repo. We’ve also provided a dashboard template that charts Istio metrics from our default configuration. The template is designed to be imported with the Insights Dashboard API. The dashboards are available in New Relic Insights and as New Relic One dashboards. Contributing to the newrelic-istio-adapter We welcome contributions to the newrelic-istio-adapter or any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our contributor licensing agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Related Topics Observability By Tyler Yahn Tyler Yahn is a Senior Software Engineer at New Relic. He is currently based in Portland, Oregon. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.2233,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How To Monitor Istio With <em>New</em> <em>Relic</em>",
        "sections": "How the <em>newrelic</em>-istio-adapter works",
        "body": " on GitHub. Read on to learn more about how it works. How the newrelic-istio-adapter works We built the newrelic-istio-adapter <em>using</em> the <em>new</em> go-telemetry-sdk, an open source <em>set</em> of API client libraries that send your metric and trace data to the <em>New</em> <em>Relic</em> platform. <em>Using</em> the SDK we were able to integrate"
      },
      "id": "60763d7164441fc4a69d8578"
    },
    {
      "sections": [
        "Install the Kubernetes integration for Windows",
        "Compatibility and requirements",
        "Important",
        "Example: Get Kubernetes for Windows from a BusyBox container.",
        "Install",
        "Limitations",
        "Known issues with the Windows Kubelet"
      ],
      "title": "Install the Kubernetes integration for Windows",
      "type": "docs",
      "tags": [
        "Integrations",
        "Kubernetes integration",
        "Installation"
      ],
      "external_id": "8b179894cbfc76f448c158f36d7ce1843f108dc0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/install-kubernetes-integration-windows/",
      "published_at": "2021-04-16T17:08:02Z",
      "updated_at": "2021-03-16T06:07:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To run our Kubernetes installation for Windows, follow the steps below to: Check the compatibility and requirements. Update the manifest file. Learn about the limitations of the integration. Compatibility and requirements Before you install New Relic's Kubernetes integration, review the compatibility and requirements. Important When using containers in Windows, the container host version and the container image version must be the same. Our Kubernetes integration supports Windows versions 1809 and 1909. To check your Windows version: Open a command window. Run the following command: Reg Query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\" /v ReleaseIdcmd.exe Copy Example: Get Kubernetes for Windows from a BusyBox container. $ kubectl exec -it busybox1-766bb4d6cc-rmsnj -- Reg Query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\" /v ReleaseId Copy HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion ReleaseId REG_SZ 1809 Copy Install You can install the Kubernetes integration for Windows using Helm. See an example on how to install the integration in a cluster with nodes having different build versions of Windows (1809 and 2004): Install kube-state-metrics and run it in your cluster using this snippet: curl -L -o kube-state-metrics-1.9.5.zip https://github.com/kubernetes/kube-state-metrics/archive/v1.9.5.zip && unzip kube-state-metrics-1.9.5.zip && kubectl apply -f kube-state-metrics-1.9.5/examples/standard Copy Create a values.yml file with the follow data to be used by Helm: global: licenseKey: <YOUR_LICENSE_KEY> cluster: <YOUR_CLUSTER_NAME> enableLinux: false enableWindows: true windowsOsList: - version: 1809 imageTag: 2.2.0-windows-1809-alpha buildNumber: 10.0.17763 - version: 2004 imageTag: 2.2.0-windows-2004-alpha buildNumber: 10.0.19041 Copy Install the integration with: helm install <YOUR_INSTALL_NAME> newrelic/newrelic-infrastructure -f values.yml Copy Confirm that the DaemonSet has been created successfully by looking for newrelic-infra in the results generated by this command: kubectl get daemonsets Copy The Helm chart will create one DeamonSet per each version of Windows that is in the list and use NodeSelector to deploy the corresponding Pod per Node. Limitations The following limitations apply to the Kubernetes integration for Windows: The Windows agent only sends the Kubernetes samples (K8sNodeSample, K8sPodSample, etc.) SystemSample, StorageSample, NetworkSample, and ProcessSample are not generated. Some Kubernetes metrics are missing because the Windows kubelet doesn’t have them: Node: fsInodes: not sent fsInodesFree: not sent fsInodesUsed: not sent memoryMajorPageFaultsPerSecond: always returns zero as a value memoryPageFaults: always returns zero as a value memoryRssBytes: always returns zero as a value runtimeInodes: not sent runtimeInodesFree: not sent runtimeInodesUsed: not sent Pod: net.errorsPerSecond: not sent net.rxBytesPerSecond: not sent net.txBytesPerSecond: not sent Container: containerID: not sent containerImageID: not sent memoryUsedBytes: in the UI, this is displayed in the pod card that appears when you click on a pod, and will show no data. We will soon fix this by updating our charts to use memoryWorkingSetBytes instead. Volume: fsUsedBytes: zero, so fsUsedPercent is zero Known issues with the Windows Kubelet There are a couple of issues with the Windows version of Kubelet that can prevent the integration from fetching data: Issue 90554: This issue makes the Kubelet return 500 errors when the integration makes a request to the /stats/summary endpoint. It will be included in the Kubernetes 1.19 release and has been backported to the releases 1.16.11, 1.17.7, and 1.18.4. There is no solution on the integration side for this problem, we advise you to update to one of the patch versions as soon as possible. You can see if you're being affected by this problem by enabling verbose logs and looking for messages of the type: error querying Kubelet. Get \"https://<KUBELET_IP>/stats/summary\": error calling kubelet endpoint. Got status code: 500 Copy Issue 87730: This issue makes the Kubelet metrics very slow when running minimal load. It makes the integration fail with a timeout error. A patch for this issue has been added for Kubernetes 1.18 and backported to 1.15.12, 1.16.9, and 1.17.5. We advise you to update to one of the patch versions as soon as possible. To mitigate this issue you can increase the integration timeout with the TIMEOUT config option. You can see if you're being affected by this problem by enabling verbose logs and looking for messages of the type: error querying Kubelet. Get \"https://<KUBELET_IP>/stats/summary\": context deadline exceeded (Client.Timeout exceeded while awaiting headers) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.610825,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Install the integration with: <em>helm</em> install &lt;YOUR_INSTALL_NAME&gt; newrelic&#x2F;newrelic-infrastructure -f values.yml Copy Confirm that the Daemon<em>Set</em> has been created successfully by looking for newrelic-infra in the results generated by this command: kubectl get daemonsets Copy The <em>Helm</em> <em>chart</em> will create one"
      },
      "id": "603e814028ccbc1ce0eba780"
    }
  ],
  "/terraform/get-started-terraform": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/07-saturation-condition-1024x558.png",
      "url": "https://newrelic.com/blog/how-to-relic/observability-as-code-new-relic-terraform-provider",
      "sections": [
        "About the Terraform New Relic provider",
        "Before you begin",
        "Step1: Initialize your working folder",
        "Step 2: Provision an alert policy resource",
        "Step 3: Provision alert conditions based on the four golden signals",
        "1. Latency",
        "2. Traffic",
        "3. Errors",
        "4. Saturation",
        "Linking a notification channel",
        "Observability as code in practice"
      ],
      "published_at": "2021-04-16T04:24:42Z",
      "title": "Practicing Observability as Code: Defining New Relic Alert Policies with Terraform",
      "updated_at": "2021-04-14T00:08:56Z",
      "type": "",
      "external_id": "f6ed141e784fb49eb7e1a31fe5752bf78186209c",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Practicing Observability as Code: Defining New Relic Alert Policies with Terraform Apr 6, 2020 • 11 min read By Chris Trombley Observability is an essential part of operating modern, complex architectures. But building an observability system that consumes a wide breadth of data from numerous data sources to drive alerts with a high signal-to-noise ratio can be overwhelming. Furthermore, maintaining such configurations manually across a large organization with distributed teams creates the potential for human error and configuration drift. A ThoughtWorks Technology Radar report suggested software teams treat “observability ecosystem configurations” as code—making observability as code an important practice for any teams adopting infrastructure as code (IaC) for their monitoring and alerting infrastructure. At New Relic, we believe that observability as code through automation is a best practice, and recommend a single source of truth for observability configurations. In this blog post, we’ll use the IaC tool Terraform and the New Relic Terraform provider to practice observability as code. We’ll use the provider to create a monitoring and alerting configuration for a sample application based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: Measures the amount of time it takes your application to service a request. In other words, how responsive is your application? Traffic: Measures how much demand is being placed on your system. How many requests or sessions are aimed at your application? Errors: Measures the rate of requests that fail. How much traffic is unable to fulfill its requests or sessions? Saturation: Measures how “full” your service is. How are resources being stressed to meet the demands of your application? You can combine these four signals to create a fairly thorough depiction of the health of your system. We’ll build the alerting strategy for our sample application based on these signals. About the Terraform New Relic provider Terraform is an open-source infrastructure as code tool teams use to define and provision their infrastructure (physical machines, VMs, network switches, containers, SaaS services, and more) through repeatable automation. In Terraform, any infrastructure type can be represented as a resource, and providers expose how developers can interact with their APIs. The Terraform New Relic provider, officially supported by New Relic, integrates with core Terraform to allow for provisioning and managing resources in your New Relic account. Note: We wrote this post using version 0.12.21 of the Terraform CLI and version 1.14.0 of the Terraform New Relic provider. Future releases may impact the correctness of the examples included below. Before you begin To complete this walkthrough, you’ll need to install the Terraform CLI. Homebrew users can run brew install terraform. If you’re not a Homebrew user, check the Terraform download page for install instructions. Step1: Initialize your working folder Terraform configuration is based on a declarative language called HCL, which defines resources in terms of blocks, arguments, and identifiers. We’ll represent our New Relic resources in HCL to allow Terraform to provision and manage them. In your working folder, create a file called main.tf. Include the provider block to signal to Terraform that the New Relic provider will be used for the plan we are about to create: provider \"newrelic\" { api_key = var.newrelic_api_key } You can now initialize Terraform, which will facilitate the download of the New Relic provider. To run the initialization, run terraform init from the console. You should see a message that shows Terraform has been initialized successfully. Still, in your working folder, create a file called variables.tf. Include the newrelic_api_key variable definition to allow the Terraform CLI to prompt for your New Relic Admin’s API key for your user and account, then run the plan: variable \"newrelic_api_key\" { description = \"The New Relic API key\" type = string } Tip: If you want to suppress user prompts, you can also provide the API key via the NEWRELIC_API_KEY environment variable. You can combine this with a secret manager like Hashicorp's Vault to automate your Terraform runs while keeping secret values out of source control. See Terraform’s provider documentation for details. Your working folder is now initialized, and you’re ready to begin defining your New Relic resources with Terraform. Step 2: Provision an alert policy resource Now we’ll define an alerting strategy for a sample app—called “Web Portal”—already reporting to our New Relic account. We want to apply the principles of golden signal monitoring and alerting to this application. To do so, we’ll first need some details about the application we’re targeting and an alert policy in which we can define the appropriate alert conditions. In the main.tf file, define these resources in HCL: data \"newrelic_application\" \"web_portal\" { name = \"Web Portal\" } resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_application.web_portal.name}\" } These two blocks define a data source to retrieve application context for a New Relic application named “Web Portal” and a resource for provisioning a simple alert policy with the name “Golden Signals - Web Portal.” Take note that we’ve included two strings at the start of each block: The first represents the data source we are provisioning, as defined by the provider. Here we are using the newrelic_application data source and the newrelic_alert_policy (See the provider documentation for a full list of the available New Relic resource types.) The second is an identifier used for referencing this element from within the plan. In this case, we interpolate the application’s name, stored in its name attribute, into the alert policy name to avoid duplication in our configuration. The policy name defined here will be the one that shows in the New Relic UI, but the golden_signal_policy identifier is for use inside our Terraform configuration only.   Run terraform plan. You’ll be prompted for your admin API key. Once you enter it, you will see a diff-style representation of the execution plan Terraform is about to carry out on your behalf: ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + created_at          = (known after apply) + id                  = (known after apply) + incident_preference = \"PER_POLICY\" + name                = \"Golden Signals - WebPortal\" + updated_at          = (known after apply) } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ After verifying the details of the execution plan, run terraform apply to execute the plan and provision the resource: newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=643964]Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log into New Relic and navigate to the Alert Policies page for your account. You should see your alert policy has been created. When you created the alert policy in step 1.3, Terraform began tracking the state of your resource. If you ran terraform apply again, Terraform would compare the configuration in your main.tf file to the internally tracked state of the resource and determine that no action is necessary—this is the power of observability as code. You can delete the policy, with terraform destroy. Step 3: Provision alert conditions based on the four golden signals Next, we’ll want to add alert conditions for our application based on the four golden signals: latency, traffic, errors, and saturation. 1. Latency As described earlier, latency is a measure of the time it takes to service a request. Use the newrelic_alert_condition resource to create a basic alert condition resource for the response time of our sample application: resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name            = \"High Response Time (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"response_time_web\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above 5 seconds per request. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } Here, we defined a condition named High Response Time (web) that will trigger if the overall response time of our application rises above five seconds for five minutes. Note that for the value of the policy_id attribute, we can link the alert policy we defined earlier with a reference to its identifier and its id attribute. We’re also using the ID of the application by referencing the application’s data source we defined in the previous section and by using its id attribute. Run terraform apply and verify that your alert condition has been created and linked to your alert policy. After Terraform runs, you can review the latency condition in New Relic. 2. Traffic The traffic signal represents how much demand is being placed on your system at any given moment. Use the application’s throughput as a metric for measuring the application’s traffic: resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id   name            = \"Low Throughput (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"throughput_web\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes below 1 request per minute. term { duration      = 5 operator      = \"below\" priority      = \"critical\" threshold     = \"1\" time_function = \"all\" } } Here, we define a condition named Low Throughput (web) that will trigger if the overall response time of our application falls below five requests per minute for five minutes. This type of alert is useful if we expect a constant baseline of traffic at all times throughout the day—a drop-off in traffic indicates a problem. Run terraform apply to create this condition. After Terraform runs, you can review the throughput condition in New Relic. 3. Errors Define a condition based on the error rate generated by our application: resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type  = \"apm_app_metric\" entities = [data.newrelic_application.web_portal.id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } This condition, error percentage, will trigger if the overall error rate for our application rises above 5% for five minutes. Run terraform apply to create the condition. After Terraform runs, you can review the error condition in New Relic. 4. Saturation Saturation represents how “full” your service is and can take many forms, such as CPU time, memory allocation, or queue depth. Let’s assume that in this case, we have a New Relic Infrastructure agent on the hosts serving our sample application, and we’d like to measure their overall CPU utilization. Use the newrelic_infra_alert_condition resource to create an alert condition based on this metric: resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name        = \"High CPU usage\" type        = \"infra_metric\" event       = \"SystemSample\" select      = \"cpuPercent\" comparison  = \"above\" runbook_url = \"https://www.example.com\" where       = \"(`applicationId` = '${data.newrelic_application.web_portal.id}')\"   # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration      = 5 value         = 90 time_function = \"all\" } } This alert will trigger if the aggregate CPU usage on these hosts rises above 90% for five minutes. Note that the definition for this resource is slightly different from the definition of newrelic_alert_condition—the New Relic provider documentation is the best source of information about the required or optional attributes on the resource. Run terraform apply to create the condition. After Terraform runs, you can review the saturation condition in New Relic. Your resources are now fully defined in code, and you can run terraform destroy or terraform apply at any time to remove or re-provision these resources in your New Relic account in a matter of seconds. Linking a notification channel We’ve created alert conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those alerts. Our team uses PagerDuty, so let’s create a notification channel to integrate with that service. (For a full list of the supported notification channels, see the newrelic_alert_channel documentation.) Create a variable to store the PagerDuty service key to avoid storing sensitive values in your codebase. In variables.tf, create a new variable: variable \"pagerduty_service_key\" { description = \"The Pagerduty service key\" type = string } Define the channel with the newrelic_alert_channel resource, and link it to your policy defined earlier with the newrelic_alert_policy_channel resource: resource \"newrelic_alert_channel\" \"pagerduty_channel\" { name = \"Page Developer Toolkit Team\" type = \"pagerduty\" config { service_key = var.pagerduty_service_key } # The following block prevents configuration drift for channels that use sensitive data. # See the Getting Started guide for more info: # https://www.terraform.io/docs/providers/newrelic/guides/getting_started.html lifecycle { ignore_changes = [config] } } resource \"newrelic_alert_policy_channel\" \"golden_signal_policy_pagerduty\" { policy_id  = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.pagerduty_channel.id] } Run terraform apply to apply your configuration. A PagerDuty notification channel set up in New Relic Alerts. Observability as code in practice Congratulations, you’re now a practitioner of observability as code. Now it’s time to create a repository—perhaps in GitHub—for your observability configuration and place it under version control. As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. You can do this with a pull request to your alerting repository. Since you’re practicing observability as code, your team can review these changes right alongside the rest of your code contributions. You may also want to consider automating this process in your CI/CD pipeline, taking your observability as code practice to the next level. Don’t miss our latest video quick tip: Terraform Provider for New Relic—Getting Started Guide [embed]https://www.youtube.com/watch?v=UwJ-7BLylJo[/embed]   By Chris Trombley Chris Trombley is a Software Engineer at New Relic Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 294.4516,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Practicing Observability as Code: Defining New Relic <em>Alert</em> Policies with <em>Terraform</em>",
        "sections": "Step 3: Provision <em>alert</em> conditions based on the four <em>golden</em> <em>signals</em>",
        "body": "-provision these resources in your New Relic account in a matter of seconds. Linking a <em>notification</em> <em>channel</em> We’ve created <em>alert</em> conditions for the four <em>golden</em> <em>signals</em> of our application in our New Relic account. Now we’ll want to set up notifications on those <em>alerts</em>. Our team uses PagerDuty, so let’s"
      },
      "id": "60763298196a679eea64a7a3"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-04-16T14:38:31Z",
      "updated_at": "2021-04-06T07:43:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirements: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more sub-accounts, the notification channel includes only users for the currently selected master or sub-account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.13406,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to select existing account team members and admins. To view the Users list or to add users to <em>alert</em> policies: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. If a user has configured the New Relic mobile app, the user <em>notification</em> <em>channel</em> also sends push"
      },
      "id": "603ecfbf64441f4ee54e885f"
    },
    {
      "sections": [
        "Test alert notification channels",
        "Request the test",
        "Troubleshoot the test results",
        "Tip"
      ],
      "title": "Test alert notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "c001fca5128a2fb8128ff655c44f9d51b6d5fa2a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/test-alert-notification-channels/",
      "published_at": "2021-04-16T14:39:15Z",
      "updated_at": "2021-03-16T06:45:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must save a new notification channel or any changes to an existing notification channel before testing it. Alerts will then send a test message to your chosen destination. Request the test To test a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Follow standard procedures to add a new notification channel or to update an existing notification channel, and save it. Select a notification channel, and then click Send a test notification. Review the test confirmation message, and then click Got it. Troubleshoot the test results A confirmation message will automatically show up in the user interface that indicates where the test was sent (for example, email) and whether it was successful. Also, the test notification message itself includes detailed information, including: The person who requested the test Links to policies for the channel Links to all notification channels and policies for the account Tip When troubleshooting problems, review the test notification message, and verify the setup requirements for the type of notification channel you selected. If necessary, make additional changes to your notification channel, and test it again as needed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.60461,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Test <em>alert</em> <em>notification</em> <em>channels</em>",
        "sections": "Test <em>alert</em> <em>notification</em> <em>channels</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": "You must save a new <em>notification</em> <em>channel</em> or any changes to an existing <em>notification</em> <em>channel</em> before testing it. <em>Alerts</em> will then send a test message to your chosen destination. Request the test To test a <em>notification</em> <em>channel</em>: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click"
      },
      "id": "603ec9ffe7b9d25b3d2a07a7"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/proactive_detection6-1024x765.png",
      "url": "https://newrelic.com/blog/nerdlog/new-capabilities-proactive-detection",
      "sections": [
        "Automatic analysis of every anomaly",
        "See all anomalies in a single view",
        "Alert, query, and leverage the power of anomalies in NRDB",
        "The full power of New Relic AI: anomalies integrated into Incident Intelligence",
        "Related Topics"
      ],
      "published_at": "2021-04-16T00:19:16Z",
      "title": "Enhancing New Relic AI With New Capabilities For Proactive Detection",
      "updated_at": "2021-04-13T23:31:44Z",
      "type": "",
      "external_id": "47801e8f396395e32a3da28b34d08b92af08bacb",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit AIOps Enhancing New Relic AI With New Capabilities For Proactive Detection May 4, 2020 • 6 min read By Annette Sheppard The rate of change within your software is faster than ever, and with this pace comes the risk that your team may miss issues, or lose critical time trying to diagnose the causes of errors. Proactive Detection, an essential part of our recently released AIOps solution, New Relic AI, helps DevOps teams avoid such problems and drive faster mean time to resolution (MTTR) by proactively detecting and analyzing anomalies using data from New Relic APM. Whether it’s alerts you didn’t know you needed to set up or dependent systems you may not even own, New Relic AI Proactive Detection surfaces and analyzes anomalies, bringing attention to potential problems before they become bigger issues—all within your team’s existing incident response workflows. Easy to set up, Proactive Detection simply needs a configuration name and a list of the applications to be monitored to begin discovering and analyzing anomalies in your system. Today we’re announcing four key enhancements to Proactive Detection: An in-depth analysis of each anomaly via the Analysis page A complete list of all anomalies in your environment with the Anomaly overview Integration with the New Relic Database (NRDB), so you can create dashboards and alerts based on anomaly data Integration with New Relic AI Incident Intelligence—via NRQL alerts—for deeper context into incidents Automatic analysis of every anomaly Not only does Proactive Detection flag and notify you of anomalies in your system, it also analyzes each anomaly to help you speed troubleshooting. The Analyze page automatically surfaces queries and context to help explain the cause of an anomaly. Each Proactive Detection notification delivered in Slack provides a link to the Analyze page, allowing you to easily investigate an anomaly or switch between anomalies as you dive deeper into issues. Anomalies delivered to your team via Slack quickly link to the Analyze page for deeper analysis The Analyze page provides an overview of the anomaly itself, as well as details and recent activity for an entity. When available, Proactive Detection automatically suggests attributes that help explain the cause of the anomaly and provide paths for further troubleshooting, as shown in the Key Attributes section: The three key attributes surrounding an error spike are visualized to provide you with multiple paths for troubleshooting. Proactive Detection uses APM event data to suggest queries that explain the anomaly, based either on statistical differences in the data or on historical usage. Finally, the Analyze page provides a table with sparklines that include anomalies related to the SRE “golden signals” (error rate, throughput, and response time) for the affected entity, and lists additional anomalies in related applications that are upstream or downstream of the initial anomaly. Sparklines include anomalies related to the SRE “golden signals” and additional anomalies in related upstream or downstream applications All of this gives your team a holistic view of the events leading up to the anomaly, helping you better identify what is happening in your application and environment. See all anomalies in a single view The Analyze page provides the context surrounding one anomaly, but the Anomaly overview page gives you a broader view of what's happening in your environment. You’ll have a full view of all detected anomalies, with the ability to instantly view more details for each one. If you want to dive in and learn even more about a specific anomaly, simply use the Analyze link. The Anomaly overview page gives you an overview of all anomalies detected in your environment. Alert, query, and leverage the power of anomalies in NRDB Since all anomalies are automatically written to the NRDB, you can use anomaly data to build dashboards, or create alerts. Query any Proactive Detection event from any configured application. For example, use Proactive Detection data in NRQL alerts to notify you when clusters of anomalies occur. Any anomaly can be plotted in a dashboard to discover trends and patterns. You can even build your dashboards to show anomalous events that are relevant to the specific applications you’re monitoring for anomalies in Proactive Detection. Be notified when clusters of anomalies occur. The full power of New Relic AI: anomalies integrated into Incident Intelligence Proactive Detection and Incident Intelligence are New Relic AI’s critical set of capabilities that help teams detect issues early, eliminate alert noise, and drive toward even faster MTTR. Incident Intelligence uses AI and machine learning (ML) to suppress alerts you don’t care about and correlate related incidents and events into single issues, without excessive configuration, training, or onboarding. Stronger together, you can now link anomalies detected with Proactive Detection to Incident Intelligence—via NRQL alerts—to receive enhanced context inside of your Incident Intelligence to gain the full power of New Relic AI. New Relic AI Proactive Detection has a free tier that you can start using today: If you’re new to New Relic, sign up for your free account. Already using New Relic? Get started with Proactive Detection in under 10 minutes by visiting http://one.newrelic.com > New Relic AI > Proactive Detection. Interested in learning more about New Relic AI, check out these resources: Accelerate Incident Response with AIOps: An introduction to AIOps best practices with New Relic AI (eBook) Accelerate Incident Response with AIOps (Webinar) New Relic AI documentation Request a demo   Related Topics AIOps By Annette Sheppard Annette Sheppard is a Senior Product Marketing Manager at New Relic. She is focused on AIOps and is always looking to learn something new. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.38377,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Alert</em>, query, and leverage the power of anomalies in NRDB",
        "body": " differences in the data or on historical usage. Finally, the Analyze page provides a table with sparklines that include anomalies related to the SRE “<em>golden</em> <em>signals</em>” (error rate, throughput, and response time) for the affected entity, and lists additional anomalies in related applications that are upstream"
      },
      "id": "607629e028ccbc02d751c161"
    },
    {
      "sections": [
        "Update alert notification channels",
        "Reference for updating channels",
        "Add or remove policies assigned to a channel",
        "Assign a channel to policies",
        "Change a channel's name",
        "Check for policies assigned to a user",
        "Check how many policies are assigned to a channel",
        "Create more channels",
        "Delete a channel",
        "Test a saved channelView assigned alert policies",
        "Basic process"
      ],
      "title": "Update alert notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "521bed5aa6fdcea5c1cffd11d01e6dad19bc7c40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/update-alert-notification-channels/",
      "published_at": "2021-04-16T14:39:15Z",
      "updated_at": "2021-03-16T08:08:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Depending on the selected channel type, different values appear. Reference for updating channels Here's a quick reference for updating channels which also includes links to more detailed information and procedures. Add or remove policies assigned to a channel To add or remove policies assigned to a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Choose a channel, and then click Alert policies. From the selected policy, use the windows to select, remove, or clear all notification channels. Assign a channel to policies To add a notification channel to one or more policies: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies. Choose a policy, click Notification channels, and then click Add notification channels. Choose a channel, and then click Update policy. Change a channel's name To rename an existing notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, then choose a channel. From the Channel details, change the name (maximum 64 characters) based on the channel type if applicable, and then save. Check for policies assigned to a user To check whether an account user has any policies assigned: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Optional: Search by \"user\" to browse users or a specific username or email. Choose the user, then click Alert policies. Check how many policies are assigned to a channel To check whether a notification channel has any policies assigned: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create more channels To create a new notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Click New notification channel. Delete a channel To delete a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. In the list, click the Delete icon. Test a saved channelView assigned alert policies To view the policies assigned to a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, choose a channel, and then click Alert policies. OR To view the notification channels assigned to a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, choose a policy, then click Notification channels. Basic process Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, then choose a channel. From the Channel details page, make any necessary changes, and then save. The user interface shows a Last modified time stamp for any changes to policies, including their conditions and notification channels.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.89485,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update <em>alert</em> <em>notification</em> <em>channels</em>",
        "sections": "Update <em>alert</em> <em>notification</em> <em>channels</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to a <em>notification</em> <em>channel</em>: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, click <em>Notification</em> channels. Choose a <em>channel</em>, and then click <em>Alert</em> policies. From the selected policy, use the windows to select, remove, or clear all <em>notification</em> channels. Assign a <em>channel</em> to policies To add"
      },
      "id": "603eca45e7b9d2d1d82a0806"
    }
  ],
  "/explore-docs/nr1-catalog": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 294.37485,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-16T22:12:16Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.07364,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.06238,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.05777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.05777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/build-apps/add-query-mutate-data-nerdstorage": [
    {
      "sections": [
        "ダッシュボードの管理",
        "ダッシュボードのカスタマイズ",
        "ヒント",
        "ダッシュボードを編集する",
        "設定メニュー",
        "TVモード",
        "ダークモード",
        "ダッシュボードをエクスポートする",
        "新規コンテンツをダッシュボードに追加する",
        "マークダウンエディタを使用して、カスタムコンテンツを追加する。",
        "ページのあるダッシュボードを整理する",
        "ページをダッシュボードに追加し編集する",
        "チャートとマークダウンコンテンツを管理する",
        "重要",
        "チャートにフィルターを適用して絞り込む",
        "チャート凡例を使用してフィルターを適用する",
        "ファセットを使用してダッシュボードにフィルターを適用する",
        "タイムピッカーを使用して時間設定を変更する",
        "データをエクスポートし共有する",
        "その他のヘルプ"
      ],
      "title": "ダッシュボードの管理",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d5e5a7705eda167da4867960df29bd237535a8e5",
      "image": "https://docs.newrelic.com/static/129e7a553450c47847a969c79a2f7f89/c1b63/Dashboards_conf.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-04-17T02:37:22Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneダッシュボードにアクセスし、チャートメニューから直接チャートを作成または管理し、ダッシュボードのレイアウトをカスタマイズし、表示モードを調整し、データのエクスポートを行います。 ダッシュボードをカスタマイズし、チャートを構築したら、データを詳しく知るための高度な視覚化機能とツールを使用して、データを関連付け分析します。 ダッシュボードのカスタマイズ ダッシュボードは非常に柔軟な設定となっています。ダッシュボードのレイアウトをカスタマイズし、チャートのサイズを調整してデータの表示方法を最適化できます。 ヒント をクリックして、メタデータを表示しタグを管理モーダルにアクセスします。ここで、ダッシュボードのガイドやアカウントID、アプリIDを表示し、ダッシュボードに追加されたすべてのタグを管理できます。 ダッシュボードには、次の機能が含まれます： ダッシュボードを編集する 編集 ボタンを使用して次のことを行う: ダッシュボードの名前を変更する。名前は検索可能なため、意味のある名前を付けることを推奨します。 ウィジェットを追加ボタンをクリックして、新規コンテンツを作成する。クエリビルダーを使用して新規チャートを追加する、またはマークダウンエディタを使用してテキストや画像、リンクを追加する。 新規ページを追加する。ページを使用して、ダッシュボードをより整理できます。 チャートのサイズと範囲を変更する。チャートを移動し、ダッシュボードのどこにも置くことができるため、お好みに合わせてレイアウトを設定します：関連性の高いチャートを上部に置いたり、あまり使用しないチャートを角に配置します。最大で12列のチャートを設定できます。 設定メニュー 右上にある設定メニューを使用します。 ダッシュボードの名前を変更する。名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前を付けることを推奨します。 ダッシュボードの許可を変更する。 設定メニューで、ダッシュボードの作成時期とダッシュボードに属するアカウントも表示できます。この値は変更できません。 TVモード テレビ画面での表示向けにダッシュボードを最適化する、全画面のTVモードを有効にできます。 TVモードを有効にするには、次の2つの方法があります。 New Relic Oneでダッシュボードを表示している際に、右上の アイコンを選択します。 このパラメーターをダッシュボードのページのURLに追加します：&platform[tvMode]=true TVモードを設定するには、ダッシュボードから アイコンを選択します。オプションに含まれるもの： ダッシュボード名が表示されます。 ダッシュボード名をオフにすると、画面上でダッシュボードのチャートのスペースが増えます。 ページの切り替え。 複数のページのあるダッシュボードでは、これによりページが自動的に切り替わります。 ダークモード 高コントラストモードを、ダッシュボードで使用できます。 アイコンを、右上のメニューバーから選択します。 ダッシュボードをエクスポートする アイコンをクリックして、PDFファイルとしてダッシュボードをエクスポートできます。 ヒント いつでも検索機能を使用して、New Relic One全体でデータを検索できます。 新規コンテンツをダッシュボードに追加する 複数の方法で、ダッシュボードに新規コンテンツを追加できます： データエクスプローラーおよびクエリビルダー機能から。 + ダッシュボードに追加ボタン（メインのダッシュボードのページから、または編集モードでアクセス可能）を使用して、クエリビルダーにアクセスするか、マークダウンエディタを使用してコンテンツ（テキストやリンク、画像など）を追加する。 ダッシュボードから既存のチャートをコピーする。 マークダウンエディタを使用して、カスタムコンテンツを追加する。 マークダウンエディタには、コンテンツを入力するマークダウンペインや、表示するプレビューペインが含まれます。マークダウン構文オプションの詳細については、Commonmarkのウェブサイトをご覧ください。 マークダウンウィジェットの楕円 アイコンをクリックし、編集をクリックして、既存のコンテンツを編集することもできます。 ページのあるダッシュボードを整理する 複数のページを使用して、さまざまな表示でダッシュボードを整理できます。ページをそのダッシュボードに追加すると、ダッシュボードUIの上部にあるタブを使用して、そのページにアクセスできます。 one.newrelic.com > Dashboards: ダッシュボードの上部にあるタブで表示された、複数のページのあるNew Relic Oneのダッシュボードの例は次のとおりです。ページをダッシュボードに追加し、既存のページをコピーし、ページタブを新たな位置にドラッグしてドロップできます。 この機能を使用して、関連するダッシュボード表示をグループ化できます。これは、特定のプロジェクトやチーム、主題に関連する多くのデータとチャートを集計する際に有用です。 たとえば、モバイルアプリチームは、国ごとにアプリのパフォーマンスに重点を置いたダッシュボードを構築できます。最初のダッシュボードのページを、すべての国のパフォーマンスの概要とし、その他のページで特定の国を取り上げることができます。 当社では、ダッシュボードをつなぐその他の機能を提供しています。 マークダウンテキストを含むウィジェットを作成して、特定のUIページやダッシュボードへのダイレクトリンクを追加します。 ファセットによるフィルタリングを使用して、自動的にその他のダッシュボードにリンクしフィルタリングを行うリンクを作成します。 ダッシュボード検索を使用して、似た名前のダッシュボードを検索します。この機能を活用して、チームやプロジェクトに固有の語句をダッシュボード名に追加できます。 New Relic Insightsでは、この機能はデータアプリと呼ばれていました。InsightsからNew Relic Oneの切り替えの詳細については、移行ガイドをご覧ください。 ページをダッシュボードに追加し編集する ページをダッシュボードに追加、またはページを編集するには： 新規または既存のダッシュボードで、 アイコンを選択して編集モードで入力します。 新規ページを追加する： ページを追加を選択して空白のページを追加します。 ダッシュボード名の隣にあるドロップダウンをクリックし、複製を選択して、既存のページのクローンを作成します。 編集モードの間、新規ページにウィジェットを追加し、ページタブを新たな場所にドラッグしてドロップしたり、その他のダッシュボード編集タスクを行えます。 終了したら、編集を完了を選択します。 チャートとマークダウンコンテンツを管理する マークダウン要素から、右上隅にあるアクセスメニューにアクセスし、編集または削除を行います。チャートから、右上角のチャートアクションメニューにアクセスし、次のことを行います。 チャートを全画面に拡張する。 画像として、またはリンクを付けてチャートを共有する。 チャートをダッシュボードにコピーする。 クエリビルダーにアクセスし、チャートに関連したクエリを表示または編集する。 チャートを削除する。 重要 ダッシュボードに対する許可が読み取り専用の場合、チャートのクエリは編集できません。 詳細については、チャートの使い方をご覧ください。 チャートにフィルターを適用して絞り込む フィルタリング機能を使用して、ディスプレイで情報を絞り込むことができます。この機能は、クエリ条件を視覚的に表すものです。 フィルターバーを使用して、表示する値や属性を選択し、チャートから残りの要素を削除する。 高度なフィルターバーを開いてboolean演算子（=、!=、CONTAINS、EXCLUDESなど）にアクセスし、データのフィルタリングのための複雑で組み合わされた条件を追加する。 フィルターを適用後、ダッシュボードには、選択した要素に関連するデータのみが表示されます。小さなカウンターは、1回にいくつのフィルターが適用されているかを表します。 デフォルト表示に戻るには、フィルターの横にある小さなXをクリックして削除します。 チャート凡例を使用してフィルターを適用する 凡例のついたチャートで凡例をクリックして、その系列のみを表示し、チャートから残りのものを削除します。これにより、分析するデータを隔離できます。 反対の動作では、CMD（Macの場合）またはCTRL（Windowsの場合）を使用します。選択した系列を削除し、残りを保存します。 ファセットを使用してダッシュボードにフィルターを適用する チャートのNRQLクエリにFACET句が含まれる場合、ファセットのついた属性を使用して、現在のダッシュボードまたは別の関連するダッシュボードにフィルターを適用できます。詳細については、ファセットによりフィルターを適用するをご覧ください。 タイムピッカーを使用して時間設定を変更する デフォルトでは、ダッシュボードの各チャートには、クエリビルダーで作成時に指定された期間のデータが表示されますが、タイムピッカーを使用して表示されるデータの時間範囲を変更し、すべてのチャートに同じ範囲を設定できます。これは、データを絞り込み特定の期間に何が発生したかを観察する必要がある場合、インシデントのトラブルシューティングの間に特に有用です。 更新率は、表示中の期間の長さにより異なります。将来と例については、チャートの更新間隔をご覧ください。 時間範囲を変更するには： ドロップダウンメニューから、利用可能なオプション（直近30分から直近7日まで）を1つ選択します。 カスタムメニューを使用して、特定の開始および終了タイムスタンプで時間範囲をカスタマイズします。 重要 ダッシュボードでは、Insightsとは異なり、タイムゾーンはお使いのノートパソコンの時間とは関連していません。タイムピッカーのカスタムメニューから簡単にアクセスできるユーザー設定で、使用するタイムゾーンを設定できます。 データをエクスポートし共有する 社内外でダッシュボードとチャートデータをエクスポートし共有することは、非常に簡単です。 右上のメニューバーにあるPDFとしてダッシュボードをエクスポートボタンを使用して、PDFファイルとしてダッシュボードをエクスポートできます。 チャートをPNG画像またはリンクとして共有することもできます。チャートメニューに移動し、画像として取得またはチャートリンクを取得オプションのいずれかを選択します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.88313,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Query</em> your <em>data</em>"
      },
      "id": "6053437b196a67a8322d1626"
    },
    {
      "sections": [
        "ダッシュボード入門",
        "ヒント",
        "重要な理由",
        "New Relic全体にまたがるダッシュボードを表示する",
        "ダッシュボードの使用を開始",
        "ダッシュボードの作成",
        "ダッシュボードのクローンを作成",
        "ダッシュボードの削除",
        "ダッシュボードにお気に入りの印を付ける",
        "ダッシュボードの検索と並び替え",
        "ダッシュボードのアクセス許可",
        "タグを使用してダッシュボードを整理する",
        "主要な視覚化ツール",
        "一貫したチャートの色",
        "関連するニードル",
        "データスクラバー",
        "拡大ブラシ",
        "カスタムの可視化",
        "その他のヘルプ"
      ],
      "title": "ダッシュボード入門",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "36da9a58bf388d15522c769ef3ad709550eee043",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-04-17T03:24:45Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データを道路の複雑なシステムとして捉える：道路の標識や信号に従い運転し、収集する情報の意味を迅速に把握し実行する必要があります。New Relic Oneダッシュボードは、New Relicプラットフォームのあらゆる場所から、表示したい特定のデータを収集して、お望みの方法でチャートを作成します。 ヒント ダッシュボードとその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 New Relic Oneダッシュボードを使用して、収集するデータをカスタマイズして理解できます。カスタマイズされたユーザーフレンドリーなチャートでデータを詳しく調べ、つながりのあるソースの相関性を導き、システムとアプリケーションの状態を素早く理解することで、より迅速かつ効率的なトラブルシューティングを行います。 ダッシュボードを利用して、次のことを行います： 一貫したUIによるカスタムの高密のインタラクティブな可視化により、知見を深める。 プラットフォームのどこからでも、すべてのイベントと属性のチャートを作成する。詳細については、デフォルトのデータ収集に関する弊社のドキュメンテーションを参照してください。 カスタム属性の追加またはカスタムイベントタイプの送信を大半のイベントに対して行います。これにより、貴社のビジネスへの理解力を高め、ページビュー数やホストトランザクションなど、顧客とプラットフォームのインタラクションに関する具体的なポイントを確認できます。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度な補足説明機能とズームイン機能でデータの探索とコンテキスト化を行い、貴社システムのリアルタイムのアクティビティをモニターできます。 ダッシュボードで属性とメトリックスを検索します。 APIを使用してダッシュボードにデータを送信します。 New Relic全体にまたがるダッシュボードを表示する New Relic Oneのダッシュボードには、元々のNew Relicプラットフォームとの完全な下位互換性が備わっているため、Insightsで作成した全てのダッシュボードがダッシュボードで自動的に利用できるようになります。つまり、新たにダッシュボードを追加すると、Insightsでも作成されます。追加の設定は必要ありません。New Relic Oneでは、クロスアカウント検索を利用することで、組織全体にまたがるダッシュボードを表示できます。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 ダッシュボードの使用を開始 ダッシュボードにアクセスするには、one.newrelic.comに移動し、ナビゲーションメニューの上部にあるダッシュボードをクリックします。 ダッシュボードの索引で、New Relicアカウントに関連するすべてのダッシュボードとデータアプリを表示できます。これには、New Relic Oneプラットフォーム内で作成したダッシュボードと、Insightsで構築したダッシュボードが含まれます。 上部のバーから、エンティティエクスプローラーや、APMやBrowser、Infrastructure monitoring、Logs、インテリジェンスの応用などすべてのNew Relic機能に迅速にアクセスします。また、プラットフォーム全体で使用できるデータの検索やクエリなどのNew Relic Oneの中心的な機能も使用できます。 各ダッシュボードで、索引に次の情報が表示されます： 星で表される、お気に入りのステータス 名前：ダッシュボードの名前 アカウント：ダッシュボードが属するアカウント 作成者：ダッシュボードを作成したユーザー 最終編集日時：直近のダッシュボード変更の日時 作成日時：ダッシュボードの作成日時： 次のアクションを行えます： ダッシュボードの作成 ダッシュボードの索引の右上隅にある+ダッシュボードを作成ボタンを選択して、ダッシュボードからNew Relic Oneでダッシュボードを作成できます。 ダッシュボードに名前を付ける名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前（例として、サービスやアプリケーション）を付けることを推奨します。 ダッシュボードが属するアカウントを選択します。このアクションは変更できないため、慎重に選択してください。 作成を押して続けるか、キャンセルを押して索引に戻ります。 ヒント デフォルトでは、ダッシュボードはパブリック - 読み取りと書き込み許可で作成されます。ダッシュボードにアクセスした後、設定メニューから編集できます。 または、次のように新規のダッシュボードを作成することもできます： 既存のダッシュボードのクローンを作成して。 チャートから：チャートを任意のダッシュボードから新規または既存のダッシュボードにコピーします。 データエクスプローラーまたはクエリビルダーから: クエリ機能から作成したチャートを、新規または既存のダッシュボードに追加します。 エンティティエクスプローラーから：エンティティマネージャからダッシュボードにカスタムで表示を行います。 複数のページでダッシュボードを整理するには、ダッシュボードにページを追加します。 ダッシュボードのクローンを作成 索引のダッシュボード行の上にカーソルを移動すると表示されるダッシュボードのクローンを作成ボタンをクリックして、ダッシュボードのクローンを作成します。許可のレベルにかかわらず、あらゆるダッシュボードのクローンを作成できます。 ダッシュボードは自動的にコピーされ、クローンが索引に追加されます。画面にポップアップ表示されるメッセージをクリックして、新規ダッシュボードにアクセスします。 クローン版のダッシュボードには、元のダッシュボードの名前の後に「copy」が付けられます。たとえば、this is my dashboardという名前のダッシュボードのクローンを作成すると、クローンはthis is my dashboard copyとして作成されます。クローンの許可は、パブリック - 読み取りと書き込みとなります。 ダッシュボードの名前や許可などのその他のプロパティは、いつでも編集できます。 ヒント 索引には、並べ替えに従いダッシュボードが表示されます。クローン版のダッシュボードを迅速に検索するには、作成日でダッシュボードを並び替えます。新規のダッシュボードが先頭に表示されます。 ダッシュボードの削除 ダッシュボードを削除するには、削除ボタンが表示されるまで、索引のダッシュボード行の上にカーソルを移動します。自身で作成した場合、または許可がパブリック - 読み取りと書き込みの場合しか、ダッシュボードは削除できません。詳しくは、許可についての情報を参照してください。 ダッシュボードの設定パネルから、ダッシュボードを削除することもできます。 ダッシュボードにお気に入りの印を付ける ダッシュボードの隣にある星のアイコンをクリックすると、お気に入りがオンとオフで切り替わります。ダッシュボードをお気に入りにすると、リストの先頭にあるその他のお気に入りのダッシュボードと同じグループに入り、New Relic Oneのホームページで表示されます。 お気に入りからダッシュボードを削除するには、星のアイコンをもう一度選択します。 New Relic Oneは、Insightsからお気に入りのダッシュボードを取得しません。InsightsからNew Relic Oneへの移行の方法をご覧ください。 ダッシュボードの検索と並び替え 索引の上にある検索ボックスを使用して、ダッシュボード名と作成者別に、ダッシュボードの検索を行えます。 索引でダッシュボードの並べ替えも行えます。デフォルトでは、直近に編集したダッシュボードが、お気に入りとお気に入り以外のセクションの両方で、索引の先頭に表示されます。この順序を変更するには、索引の任意の列で両方のセクションを並べ替えると、直近の並べ替えの結果が、次回New Relic Oneにアクセスした際に表示されます。 ダッシュボードのアクセス許可 ダッシュボードには、次の3種類の権限があります。 パブリック - 読み取りと書き込み: すべてのユーザーが、ダッシュボードに対し完全な権利を有します。 パブリック - 読み取りのみ: すべてのユーザーはダッシュボードを表示できますが、ダッシュボードで作業を行う完全な権利を有するのはあなただけです。他のユーザーはダッシュボードにアクセスし、クローンを作成できますが、編集や削除はできません。 プライベート: ダッシュボードを表示できるのはあなただけです。 ダッシュボードを作成ボタンを使用して、または別のダッシュボードのクローンを作成してダッシュボードを作成すると、デフォルトでパブリック - 読み取りと書き込みの権利が付与されます。新規ダッシュボードにアクセスして、この設定を変更します。 タグを使用してダッシュボードを整理する タグ作成APIであるNerdGraphを使用して、タグを追加できます。 タグ別にダッシュボードをフィルターすることもできます。これによってユーザーアカウントやロケーションなどを特定できます。タグフィルターをクリックして使用可能なタグを表示すると、リストから1つ以上のタグを簡単に選択して、索引でダッシュボードを絞り込むことができます。 主要な視覚化ツール ダッシュボードには、詳細なデータ検索や迅速なトラブルシューティングのための、分かりやすい視覚化機能とツールが備わっています。 一貫したチャートの色 データやファセットをすぐに表示し関連付け、ダッシュボードで1つ以上のチャートに適用し、すべてのチャートでファセットの色を一貫したものにできます。 関連するニードル マウスをチャートの上に移動すると、関連するニードルが、同時にダッシュボードのすべてのチャートやデータポイントに重なって表示されます。ツールチップには、線チャートの最大値や最小値など、選択したファセットからの関連データポイントが記載されています。また、パイチャートで選択した属性をハイライト表示します。 データスクラバー チャートスクラバーを使用して、チャートが密集しており、ファセット間の距離が非常に近い場合に、チャートでデータポイントやファセットを選択できます。 マウスをニードルの側に移動し、隣にあるファセットをスムーズに選択し、関連するデータポイントを表示します。また、UIに表示される1つ以上の属性の選択を解除して、投入データの多いチャートのデータ投入を減らすこともできます。 拡大ブラシ ドラッグしてチャート上の時間セグメントを選択すると、ダッシュボードのすべてのチャートでその期間が自動的に拡大されます。 タイムピッカーは、ダッシュボードに表示される新規の期間を反映します。いつでもデフォルトやその他の時間設定に戻ることができます。 カスタムの可視化 ダッシュボードにカスタムの可視化を行うこともできます。これにより、データソースからの情報を含めることができるようになります。カスタムの可視化の詳細については、ダッシュボードのカスタムの可視化とダッシュボードにカスタムの可視化を追加をご覧ください。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.88313,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Query</em> your <em>data</em>"
      },
      "id": "6053433228ccbcdc10c2fd60"
    },
    {
      "sections": [
        "データエクスプローラーの概要",
        "ヒント",
        "重要な理由",
        "データのクエリ",
        "データエクスプローラーを使用する",
        "イベントを詳しく調べる",
        "メトリックスを詳しく調べる",
        "重要",
        "調査を可視化し絞り込む",
        "クエリエリア",
        "NRQLクエリ表示",
        "チャートエリア",
        "共有してエクスポート",
        "使用事例",
        "新規データを確認",
        "データを検証",
        "データの問題のトラブルシューティング",
        "その他のヘルプ"
      ],
      "title": "データエクスプローラーの概要",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "94545f74e5fd5ab0b18f47342f7a8f2a2fa82558",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-16T15:16:11Z",
      "updated_at": "2021-04-12T03:13:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データエクスプローラーを使用すれば、NRQLの知識がなくても、すべてのデータを視覚的に操作できます。データエクスプローラーを使用してデータにアクセスしクエリやカスタマイズ、視覚化を行い、サービスとサービスをつなぎ、一貫したキュレート済みの体験を実現します。 ヒント データエクスプローラー、およびその他のオブザーバビリティ プラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 システムの状態を調査しますか？リソースの計画を作成し、インシデントを特定しそれに対応し、動作不良のトラブルシューティングを行う必要がありますか？データエクスプローラーにより、NRQLを使用したりクエリを構築せずに、視覚的なメニューを通じて、探しているデータを簡単に特定、取得し、視覚化できます。 データエクスプローラーを使用して、次のことを行えます。 イベントやメトリックスデータに、迅速で直感的な方法でアクセスする。 視覚化し簡単に実行できるようにして、データのディメンションを詳しく調べる。 さまざまな観点からデータを把握する：生データや、進歩や配信などについての知見を提供するさまざまな視覚化。 フィルターによりデータを掘り下げる。 1回のクリックで検索をダッシュボードに追加する。 NRQLのしくみについて理解する: データエクスプローラーは、利用可能なデータを検索している間にクエリがどのように構築されるかを示します。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 データのクエリ データエクスプローラーにアクセスするには、one.newrelic.comに移動し ページの上部にあるデータをクエリアイコンをクリックします。 データのブラウズドロップダウンで、イベントまたはメトリクスを選択します。 データエクスプローラーは、New Relicにあるすべてのデータを詳しく調べるためのポータルです。データエクスプローラーUIにあるイベントやメトリックスを詳しく調べたり、LogsやTracesアプリを選択して詳しく調べることができます。また、タブをクリックして、いつでもクエリビルダーにアクセスすることもできます。 データエクスプローラーを使用する データエクスプローラーは、上部にある範囲絞り込みセクション（a）、左側のデータブラウジングエリア（b）、ワークスペース（c）で構成されます。 データエクスプローラーを使用するには： 調べる範囲を定義する：ブラウズするアカウントとデータタイプ（メトリックまたはイベント）を選択します。 タイムピッカーを使用して時間範囲を選択します。 左側のブロックを使用して、イベントかメトリックスのいずれかについて使用可能なデータをブラウズし、検索を作成します。1ブロックにつき1つの要素しか選択できません。ブロックは検索可能です。 イベントを詳しく調べる イベントタイプ 選択したアカウントで使用できるすべてのイベントを表示します。 デフォルトでは、イベントは名前で並び替えられます。 プロット 以前選択したイベントのすべての数字属性を表示します。 リストの最初の項目はcount( * )で、これは属性ではありません。選択したイベントの数を計算します。 デフォルトでは、属性は名前で並び替えられます。 プロットする関数を選択します。デフォルトでは、各属性は関数Averageに設定されます。 ディメンション 以前選択したイベントとプロットのすべてのディメンションを表示します。 ディメンションは、イベントについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 メトリックスを詳しく調べる APM 時間区切りデータを調べるには、AppID、AppName、またはEntityGuidをステップとして選択します（またはそれらのステップでグループ化します）。それ以外の場合は、すべてのエンティティの集計データを取得します。 メトリック 選択したアカウントで使用できるすべてのメトリックスを表示します。 デフォルトでは、メトリックスは名前で並べ替えられます。 ディメンション 以前選択したメトリックのすべてのディメンションを表示します。 ディメンションは、メトリックについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 重要 ユニットの表示には、メトリックシステム（メトリックSIプレフィックスを含む）が使用されています。 調査を可視化し絞り込む 調査の結果は、右側のワーキングスペースに表示されます。 調査を絞り込むか、チャートを共有する ワーキングスペースには、次のものが表示されます。 クエリエリア クエリエリアでは、クエリを異なる構成要素に分解します。ここで、NRQLクエリとして調査の結果を簡単に読み、プロットしている正確なデータをチェックできます。 NRQLに習熟していない場合、このエリアをチェックしクエリの作成方法について学習します。 クエリの別の部分は次のとおりです。 [ イベントのみ]FROM: 最初のブロックで選択したイベント。 SELECT: 選択したプロットまたはメトリック。この入力では、1つの値と1つの関数のみをプロットします。 GROUP BY: FACET句を表し、選択したディメンションごとにデータをグループ化します。 LIMIT: 表示する値の量を入力します。 WHERE: このフィールドを使用して、結果にさらにフィルターを適用します。この入力では、n値をプロットします。 各項目は、xをクリックしてクエリから削除できます。 NRQLクエリ表示 上記のフィールドと、タイムピッカーで選択した時間範囲で構成される、完全なクエリを表示できます。 ヒント より詳細な検索を行う、またはチャートをカスタマイズする必要がある場合データエクスプローラーから、クエリビルダーにアクセスしてクエリを編集できます。 チャートエリア デフォルトでは、データは線チャートで表示されます。チャートピッカーを使用して、面グラフ、円グラフ、およびバーチャートに簡単に切り替えることができます。結果の生データをテーブルまたはJSON形式として表示することもできます。 ディメンションを選択している場合、チャートは異なるファセットで更新されます。チャートの下に、ファセットのリストとそれぞれの値があるファセットの表が表示されます。 ファセットテーブルを使用して、データをドリルダウンします。クリックしたファセットはフィルターとして適用されます。表は表示されたままなので、別のファセットを簡単に選択して調査を続けることができます。 共有してエクスポート 右上にあるオプションメニューを使用して、チャートを画像として取得、またはリンクとして共有、ダッシュボードに追加できます。 また、URLをコピーし、その他のNew Relicユーザーと調査全体を共有することもできます。 使用事例 次の例で、データエクスプローラーをいつどのように使用するかについて学習してください。 新規データを確認 新規インストゥルメンテーションに接続したばかりで、新規データを利用できるかどうか確認したいと思っています。 アカウントとイベント、または新規データを生成しているメトリックを選択します。 データエクスプローラーで別のツールを使用して、利用できるようになった新規データを使ってみる：そのイベントまたはメトリックの生データを表として見る、またはリストとする、またはクリックしてチャートとしてプロットされることを確認します。 イベントやメトリックを選択した後、ディメンションでデータの形状を確認します。濃度を使用して、あらゆるデータの異なる視点を確認できます。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 データを検証 カスタムイベント/メトリックを変更したので、この変更が正常に行われたかどうかをチェックする必要がある。 データエクスプローラータブで、変更したアカウントとデータタイプ、イベント/メトリックを選択します。 エンティティがデータをレポートしていることと、すべての属性がプロットされていることを確認します。 変更した属性を検索し、更新が正常に行われたことをチェックします。 データの問題のトラブルシューティング アラートやダッシュボードからのイベント/メトリックで何か問題があることが分かっている。イベント/メトリック属性の動作について、根本原因を知る必要がある。 データエクスプローラーで、メニューを使用して、想定どおりに動作していないイベントやメトリックを選択し、データエクスプローラーでそのチャートをプロットします。 そこから、そのデータのディメンションを掘り下げて、関連する属性によりフィルターを適用できます。 また、次のような異なる観点からそのデータを把握することもできます：分布や値の順位、経時進化。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.85411,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Query</em> your <em>data</em>"
      },
      "id": "605343b4196a6754132d166e"
    },
    {
      "sections": [
        "Explore the Public API Performance dashboard",
        "Important",
        "Add the dashboard in New Relic",
        "Explore the dashboard",
        "More about dashboards and data"
      ],
      "title": "Explore the Public API Performance dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "71646dd30d63a0c7e343f4d81061bbb27eceeb86",
      "image": "https://docs.newrelic.com/static/2c9a2621107e0114a2c345fcbb22356f/8c557/Public-API-Performance-Dash-for-GPD.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/explore-public-api-performance-dashboard/",
      "published_at": "2021-04-16T15:12:55Z",
      "updated_at": "2021-03-16T04:14:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Public API Performance dashboard is a dashboard supported by New Relic’s Global Performance data sets. It’s an out-of-the-box dashboard included as part of your New Relic account. It provides both actionable general insights about the performance of public APIs and an opportunity for new customers to test-drive New Relic’s dashboarding capabilities before adding their own data. The dashboard works by showing real latencies experienced by an anonymized sampling of New Relic customers when accessing popular public APIs. Important Global Performance data sets are presented as-is. Global Performance data sets represent an aggregate of samples across a range of sources, and New Relic makes no effort to attempt to confirm the correctness, completeness, or veracity of the data. This data should not be relied on as the sole source of information for any purpose you may use it, and New Relic is not responsible for decisions made in reliance on this data. Global Performance data sets should not be viewed as either an endorsement or a recommendation by New Relic of the technologies represented in the data sets. Add the dashboard in New Relic If the Public API Performance dashboard isn't already visible in your UI, you can add it easily. Enable the dashboard from https://one.newrelic.com/: New customers: The dashboard is enabled by default and added to the favorites list for all new accounts. Existing customers: If the dashboard hasn't already been enabled, you can add it by clicking your avatar and selecting Add your data. Click the Public API Performance tile to open the account selector, then click Add and view pre-built dashboard On the Public API Performance dashboard page, start exploring! Click the ... at the corner of any pane to expand charts, view queries, and more. Public API Performance dashboard Explore the dashboard Below are some suggestions for how to explore the Public API Performance dashboard. Click … in the corner of any of the charts and select View query to view the NRQL query used to create the chart. Click … in the corner of any of the charts and select Get as image to view or download any chart as an image. Select specific domains from the bar chart or add a filter by clicking the text field along the at the top of the page. If you’ve already added your own data, experiment with copying queries and modifying them for your own use. Important The Public API Performance dashboard is not currently available to EU customers. Important The Public API Performance dashboard does not currently support alerts. More about dashboards and data For more information about the Global Performance data sets that power the Public Performance API dashboard, see New Relic Global Performance data sets. For more information about New Relic dashboards, see our dashboards introduction. Customers can also dive into this data set in greater depth using our new data explorer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.12421,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> the dashboard in New Relic",
        "tags": "<em>Query</em> your <em>data</em>",
        "body": " is not responsible for decisions made in reliance on this <em>data</em>. Global Performance <em>data</em> sets should not be viewed as either an endorsement or a recommendation by New Relic of the technologies represented in the <em>data</em> sets. <em>Add</em> the dashboard in New Relic If the Public API Performance dashboard isn&#x27;t"
      },
      "id": "603e97fa28ccbc013ceba7c1"
    },
    {
      "sections": [
        "Introduction to dashboards",
        "Tip",
        "Why it matters",
        "See your dashboards across all New Relic",
        "Get started with dashboards",
        "Create a dashboard",
        "Import a dashboard",
        "Clone a dashboard",
        "Delete a dashboard",
        "Mark a dashboard as favorite",
        "Search and sort dashboards",
        "Dashboard permissions",
        "Organize your dashboards with tags",
        "Key visual tools",
        "Consistent chart coloring",
        "Correlated needle",
        "Data scrubber",
        "Brush to zoom",
        "Custom visualizations"
      ],
      "title": "Introduction to dashboards",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "caf20070eae1529315d1e0642bd2f853e2872b77",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-04-17T03:22:26Z",
      "updated_at": "2021-03-30T02:06:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Envision your data as a complex system of roads: you need to navigate the signs and signals along the way to quickly see and make meaning of the information you collect. New Relic One dashboards gather and chart the specific data you want to see, the way you want to see it, from anywhere in the New Relic platform. Tip To use dashboards and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters With New Relic One dashboards you can customize and understand the data you collect. Explore your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient troubleshooting. Use dashboards to: Drive insight with custom, high-density interactive visualizations with a consistent UI. Chart all the events and attributes from everywhere across our platform. For more information, see our documentation on default data collection. Add custom attributes or send custom event types to most events in order to better understand your business, and see specific details about how your customers interact with your platform, such as page views, host transactions, etc. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom-in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our APIs. See your dashboards across all New Relic New Relic One dashboards have full backwards compatibility with the original New Relic platform, so any dashboard you have created in Insights will be automatically available in dashboards from day one. Reciprocally, when you add a new dashboard, it is also created in Insights. No further action is needed. With New Relic One you can also view dashboards across your organization using cross-account search. Tip Switching to New Relic One from Insights? See our transition guide. Get started with dashboards To access dashboards, go to one.newrelic.com and click on Dashboards on the top navigation menu. In the dashboards index, you can view all the dashboards and data apps associated with your New Relic account. This includes the dashboards you've created within the New Relic One platform as well as the dashboards built in Insights. From the top bar, quickly access our explorer as well as all New Relic capabilities, such as APM, Browser and Infrastructure monitoring, Logs, or Applied Intelligence. You can also use the core New Relic One features such as Search or Query your data that are available across the platform. For each dashboard, the index displays the following information: Favorite status, indicated by a star Name: The name of the dashboard Account: The account the dashboard belongs to Created by: The user who created the dashboard Last edited: When the dashboard was last modified Created on: When the dashboard was created Here you can carry out the following actions: Create a dashboard You can easily create a dashboard in New Relic One from the dashboards index by selecting the + Create a dashboard button located at the top-right corner of the dashboards index. Name your dashboard. Names are searchable, so we recommend giving it a meaningful name (your service or application, for instance) using words that will help you locate your dashboard easily. Select the account the dashboard belongs to. Choose carefully because this action cannot be modified. Press Create to continue, or Cancel to return to the index. Tip By default a dashboard is created with Public - Read and write permissions. You can edit them from the settings menu once you access the dashboard. Alternatively, you can also create a new dashboard: By cloning an existing dashboard. From any chart: Copy any chart from any dashboard to a new or an existing dashboard. From the data explorer or the query builder: Add any chart you create from our querying features to a new or an existing dashboard. From the explorer: Take any custom view from the entity manager over to dashboards. To organize dashboards with multiple pages, see Add pages to a dashboard. Import a dashboard You can import a dashboard as JSON by selecting the Import a dashboard button located at the top-right corner of the dashboards index: Paste the JSON code. By default, the dashboard belongs to the same account as the original dashboard you’re importing. Select a different account if you want to change it. By default, the new dashboard has the same rights as the original dashboard you’re importing. Select different rights if you want to change them. Tip See how to obtain a dashboard’s JSON. Clone a dashboard Clone any dashboard by clicking the Clone dashboard button that appears when you hover over any dashboard row in the index. You can clone any dashboard regardless of your permission levels. The dashboard is automatically copied and the clone is added to the index. Access the new dashboard by clicking on the message that pops up on your screen. The cloned dashboard is named like the original dashboard followed by the word \"copy\". For example, if you clone a dashboard named this is my dashboard, the clone will be created as this is my dashboard copy. The clone has Public - Read and write permissions. You can edit the name and other properties of the dashboard, like the permissions, at any time. Tip The index displays dashboards according to sorting. To quickly find your cloned dashboard, sort the dashboards by creation date. The new dashboard appears on top. Delete a dashboard To delete a dashboard, hover over the dashboard row at the index until the Delete button appears. You can only delete a dashboard if you created it, or if it has Public - Read and write permissions. For more information, see the permissions information. You can also delete a dashboard from the settings panel of the dashboard. Mark a dashboard as favorite Clicking the star icon next to a dashboard toggles on or off the favorites. When you favorite a dashboard, it’s grouped with other favorite dashboards at the top of the list, and appears on the New Relic One home page. To remove a dashboard from your favorites, select the star icon again. New Relic One doesn’t retrieve favorited dashboards from Insights. Learn how to make the transition from Insights to New Relic One. Search and sort dashboards You can search dashboards by dashboard name and author using the search box above the index. You can also sort the dashboards in the index. By default, dashboards you edited recently are at the top of the index in both the favorited and non-favorited sections. To change this order, you can sort both sections by any of the columns in the index, your most recent sort is displayed next time you access New Relic One. Dashboard permissions Dashboards have three types of permissions: Public - Read and write: All users have full rights to the dashboard. Public - Read only: All users are able to see the dashboard, but only you have full rights to work with the dashboard. Other users can access the dashboard but are not able to edit or delete it, although they can clone it. Private: Only you can see the dashboard. When you create a dashboard using the Create a dashboard button or by cloning another dashboard, it will have Public - Read and write rights by default. Access the new dashboard to change this setting. Organize your dashboards with tags You can add tags using our NerdGraph, our tagging API. You can also filter your dashboards by tags, which you can use to identify users, accounts, locations, etc. Click on the tag filter to see the available tags, you can easily select one or more tags from the list to narrow down the dashboards in the index. Key visual tools Dashboards offer intuitive visualization features and tools for advanced data exploration and fast troubleshooting. Consistent chart coloring So that you can quickly see and correlate your data, facets that you apply to more than one chart in a dashboard have a consistent facet color across all the charts. Correlated needle When you mouse over one chart, the correlated needle overlays across all charts or data points in the dashboard at the same time. The tooltip provides the relevant data points from the selected facet, such as maximum and minimum values in a line chart. It also highlights the selected attribute in a pie chart. Data scrubber The chart scrubber helps you select a data point or facet in a chart when the chart is too crowded and facets are too close to each other. Mouse along the needle to smoothly select the adjacent facets and view their associated data points. You can also lighten a heavily populated chart by unselecting one or more of the attributes that appear in the UI. Brush to zoom Drag to select a time segment on any chart and you automatically zoom to that time period on all the charts in the dashboard. The time picker reflects the new period on display in the dashboard. You can return to the default or any other time settings at any time. Custom visualizations You can also make custom visualizations for your dashboards. These enable you to include information from any data source. To learn more about working with custom visualizations, see Build a custom visualization for dashboards and Add custom visualizations to your dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 72.04696,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Data</em> scrubber",
        "tags": "<em>Query</em> your <em>data</em>",
        "body": " create a new dashboard: By cloning an existing dashboard. From any chart: Copy any chart from any dashboard to a new or an existing dashboard. From the <em>data</em> explorer or the <em>query</em> builder: <em>Add</em> any chart you create from our querying features to a new or an existing dashboard. From the explorer: Take"
      },
      "id": "603ec16028ccbc8d07eba78d"
    }
  ],
  "/explore-docs/nerdstorage": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.2268,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " a <em>New</em> <em>Relic</em>-monitored entity or <em>data</em> from another service or API. Get started Keep reading to learn more about what you can do with <em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>. If you want to get started building quickly, first read the requirements. Tip To use our developer site and <em>New</em> <em>Relic</em> <em>One</em>, as well as the rest of our"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-16T22:12:16Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.2434,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "Workloads: Isolate and resolve incidents faster",
        "Tip",
        "What is a workload in New Relic?",
        "Why it matters",
        "Requirements",
        "Impact of accounts on the workload permissions and content",
        "Workload account",
        "Scope accounts"
      ],
      "title": "Workloads: Isolate and resolve incidents faster",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "858e74779a209ac0eb948405c311e59a71eb8d9b",
      "image": "https://docs.newrelic.com/static/bb2929677005af573675e7eceead70de/c1b63/1_workload_health_tab.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster/",
      "published_at": "2021-04-15T21:23:24Z",
      "updated_at": "2021-04-09T01:54:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our workloads feature gives you the ability to group and monitor entities based on a team or a set of responsibilities, providing aggregated health and activity data from frontend to backend services across your entire stack. Workloads help you understand the status of complex systems, detect issues, understand the cause and impact of an incident, and resolve those issues quickly. Tip To use workloads and the rest of our observability platform, join the New Relic family! Sign up to create your account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What is a workload in New Relic? New Relic monitors a wide range of entities and data, from client-side applications and backend APIs, to the underlying infrastructure. To make sense of this large data set, we give you the ability to create and monitor workloads. Workloads give you the ability to group and monitor entities based on a team or a set of responsibilities, and provide an aggregated view of the health and activity of the entities in the workload. Thus, you can understand better how your business logic is working, from frontend to backend services, across your entire stack. Here are some workload examples: A serverless application that includes an API gateway, a few serverless functions, and a managed database and storage. A browser application and the backend APIs that support it. A collection of Java microservices and the infrastructure they run on. Here's a workload: one.newrelic.com > Explorer > Workloads > (selected workload): The workloads UI provides a curated view of how the entities in your workload are performing. The charts you see will depend on the types of entities you've included to the workload. Tip Learn how to use workloads. Why it matters Workloads give you visibility into the end-to-end availability and consumption of resources across an entire service, and provide you a way to define what’s relevant to you. You can use workloads to group together entities that are important to a specific team or project, so you can better browse and isolate the most relevant data for that service. Because our UI gives you cross-account access, you can add entities to your workload from any of the accounts you have access to. A workload can include: Any New Relic-monitored entity, including services, browser apps, mobile apps, databases, and hosts. Dashboards. Other workloads: this is useful for complex teams who need to divide and overlap workloads. Requirements Requirements for creating and managing workloads: All users for an account can view that account's workloads. To create, edit, and delete workloads, you must have a user role with that permission. Impact of accounts on the workload permissions and content Workloads can group and display entities from multiple accounts to provide complete observability of complex systems. When creating a workload, you must set: The workload account Scope accounts Learn how to find a New Relic account ID. Workload account The workload account is where any workload-specific data is stored. For example, a workload might generate NrAuditEvent data, and you would find that data by querying the workload account. The workload account determines the user permissions that govern which users can see and manage the workload, through the account roles. Once created, the workload account can’t be changed. Scope accounts Scope accounts are the accounts from which a workload fetches entity data. In other words, the scope accounts provide the content for a workload. Users who don’t have access to all of a workload's scope accounts may not be able to see complete workload data. Scope accounts can be updated at any point in time by any user with workload management capabilities on the workload account. By default, all accounts that the workload creator has access to at the moment of the workload creation are set as scope accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.82123,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is a workload in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " relevant <em>data</em> for that service. Because our UI gives you cross-account <em>access</em>, you can add entities to your workload from any of the accounts you have <em>access</em> to. A workload can include: Any <em>New</em> <em>Relic</em>-monitored entity, including services, browser <em>apps</em>, mobile <em>apps</em>, databases, and hosts. Dashboards"
      },
      "id": "6043cb93196a67f988960f76"
    },
    {
      "sections": [
        "New Relic One user model: Understand the user structure",
        "Important",
        "Overview",
        "User type: basic and full",
        "Compare full vs basic capabilities",
        "Tips on choosing user type",
        "Understand user-related billing",
        "Default groups: Admin and User",
        "Relationship between user type, roles, and groups",
        "Roles and capabilities",
        "Standard (default) roles",
        "Capabilities",
        "Manage users",
        "2020 user model changes"
      ],
      "title": "New Relic One user model: Understand the user structure ",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "New Relic One user management"
      ],
      "external_id": "169383c2678ce973404db07195b2dee6eda9163d",
      "image": "https://docs.newrelic.com/static/565d4ebddf52a4592c594032696516b9/c1b63/New-Relic-capabilities-UI-screenshot.png",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-user-management/new-relic-one-user-model-understand-user-structure/",
      "published_at": "2021-04-15T22:24:23Z",
      "updated_at": "2021-04-12T11:28:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In mid-2020, New Relic released a newer user model, referred to as the New Relic One user model. Important If you had a New Relic organization created before July 30 2020 and you haven't gone through a user migration process, your users are likely on our original user model. For more on this, see Pricing and user model changes. Overview This doc will explain the structure of the New Relic One user model, including: User type (basic user vs full user) Default user groups User roles and capabilities For how to add and manage users in the UI, see User management. User type: basic and full Important This section is for users on our New Relic One user model. If you're on our original user model, see Original users. The user type (basic user or full user) determines whether a user has access to our Full Stack Observability features. A user's type is something you set long-term based on that user's expected New Relic responsibilities. Below are details on the two user types. Note that billing-related aspects only apply if you're on New Relic One pricing. Basic user. Details: These users are free and have access to a wide range of features, including running queries of data, making custom charts and dashboards, and setting up alerts. Unlike full users, they do not have access to our Full-Stack Observability features and some advanced Applied Intelligence features (for a comparison of abilities, see Capabilities). No matter what custom group a basic user is assigned to, they always have the capabilities of a basic user: no more and no less. Basic users will see prompts for upgrading to a full user when they attempt to access unavailable features. For details, see Upgrade. Full user. Details: Unlike basic users, full users have access to our Full-Stack Observability features, which include curated UI experiences like APM, infrastructure monitoring, browser monitoring, mobile monitoring, synthetic monitors, access to New Relic One apps, and more. For details, see Capabilities. The Standard pricing tier includes one free full user and up to five total full users. A full user can downgrade to a basic user twice in a 12-month period. Learn more about basic user versus full user differences: Compare full vs basic capabilities Below is a table comparing what basic users and full users can do. In short: basic users have access to our Telemetry Data Platform and some Applied Intelligence features, while full users have theoretical access to all features (dependent on any group-related restrictions). Features Full user Basic user Full-Stack Observability (Curated UI experiences) Application performance monitoring (APM) UI Infrastructure monitoring UI Digital Experience Monitoring UI (browser, mobile, synthetics) Serverless monitoring UI Logs in context with other UI experiences Synthetics checks Assorted curated UI experiences (distributed tracing, Kubernetes cluster explorer, workloads, etc.) Infinite Tracing (Pro and Enterprise) Access to New Relic One apps Can build apps but can't access other apps Applied Intelligence Automatic anomaly detection Correlated alerts and events Anomaly/alert analysis Root cause details in issues Telemetry Data Platform Data ingest from any source (our agents, integrations, and APIs) Query your data Create custom charts and dashboards (not New Relic-built) Alerts and notifications Our APIs, including NerdGraph (GraphQL) (with some restrictions) Logs UI Build New Relic One apps (but cannot access other apps) Encryption at rest Standard data retention Security and compliance Data management Note that your pricing tier will also affect what features you have access to. For accounts on New Relic One pricing, learn more about user-related billing calculations. Tips on choosing user type A user's type (basic user vs full user) is meant to be a long-term assignment, based on the New Relic responsibilities that user is expected to perform. A full user can be downgraded to a basic user only twice in one year. Below are tips for why you'd choose full user versus basic user. Reasons to make someone a full user: They play a key role in the development, testing, deployment, and maintenance phases of the application development lifecycle. They break/fix code regularly; they are responsible for triaging workflows, troubleshooting, or managing users and roles for their team. They have DevOps practices (i.e. version control systems and implement CI/CD). They need to use New Relic's curated dashboards and experiences (not just the ability to create their own custom queries and charts); in other words, they need full access to our platform. They need to be able to manage users and/or billing. Reasons to make someone a basic user: They play a key role in the planning phase of the application development lifecycle. They use and configure New Relic agents, APIs, and integrations to send us data, and access, configure, and use alerts on such data (not necessarily responsible for triaging workflows, troubleshooting, or managing users and roles for their team). They want to see high-level analytics and business metrics for future planning (such as C-Suite executives). They do not need to use our curated experiences and dashboards, but would benefit from the ability to create their own custom queries and charts of data; in other words, they don't need full access to the platform. They don't manage users. For accounts on New Relic One pricing, learn more about user-related billing calculations. Understand user-related billing If you're on the New Relic One pricing plan, full users are billable, and there are restrictions around how often a full user can downgrade to a basic user. For details, see Calculations. For how to query and alert on usage data, see Query usage data. Default groups: Admin and User Important This applies to users on our New Relic One user model. For users on our original user model, see Original user docs. A user group allows managing multiple users at the same time. Your New Relic users are assigned to a group and that group is granted access to specific roles and specific accounts. Full users can be added to one of two default groups: User: This group allows a user to use and configure monitoring/analysis features but not perform account-related tasks like managing billing or users. Admin: This group has all standard roles. Pro and Enterprise tier organizations can create custom groups, and control access to roles and accounts using access grants. To change the group a user is in, use the User management UI. Relationship between user type, roles, and groups Important This applies to users on our New Relic One user model. For users on our original user model, see Original user docs. Here's a table explaining how user type (basic vs full user), roles, and groups relate to each other: Full user Basic user Group Full users can be assigned to default groups (User and Admin) or custom groups. Basic users, no matter what group they're assigned to, always have basic user abilities, no more and no less. Role Here are the roles our default groups have: User group: has the All product admin standard role, which includes some feature-related administrative abilities but not more advanced organization-level or user management admin abilities. Admin group: has complete admin capabilities, which is the equivalent of all our standard roles, including the more advanced organization-level and user management roles. Custom groups can have either our default standard roles, or custom roles. A basic user's abilities aren't directly related to roles. A basic user can best be described as having the All product admin role but without access to most of our curated UI experiences (learn more about user type). Roles and capabilities Important This applies to users on our New Relic One user model. For users on our original user model, see Original user docs. Roles are a set of capabilities. A capability is defined as the ability to do a specific New Relic task, like 'Delete alert conditions' (learn more about capabilities). We provide some default standard roles (below). Pro and Enterprise tier accounts can also create custom roles. Standard (default) roles Our standard roles are default sets of capabilities that satisfy some commonly needed use cases. Important Note that some of our standard roles have hidden capabilities that aren't available for selection when creating a custom role. The only standard roles that can be replicated with a custom role are Standard user and Read only; all others have special hidden abilities. Our standard roles include: Standard roles Scope Description All product admin Account Provides admin-level access to the platform. This includes all New Relic capabilities with the exception of managing users (Authentication domain manager role) and managing account-structure settings (Organization manager role). Standard user Account Provides access to use most of the platform, but lacks configuration and administration-level abilities (like account-level configuration or synthetic monitor secure credentials). Billing user Account Provides ability to manage subscriptions and billing, and read-only access to the rest of the platform. Organization manager Organization Provides the ability to manage organization settings, including organization structure, name, and preferences. Due to our recent switch to the New Relic One account/user model, this role currently has few abilities but more will be added over time. For how to grant this role, see Add user management capability. Organization read only Organization Provides the ability to view organization-level settings. For how to grant this role, see Add user management capability. Authentication domain manager Organization Provides ability to add and manage users, and configure authentication domains for users on the New Relic One user model. For how to grant this role, see Add user management capability. Authentication domain read only Organization Provides the ability to view users in your organization and view the configuration of authentication domains. For how to grant this role, see Add user management capability. Read only Account Provides read-only access to the New Relic platform (except for synthetic monitor secure credentials). Manage v1 users Account For New Relic organizations that existed before July 30 2020 and have users on our original user model, this role lets you manage those \"v1\" users. Capabilities A role, whether one of our standard roles or a custom one, is defined as a set of capabilities. In the Organization and access UI, when you choose a role or create a custom role, you can see the available capabilities. Important Some of our standard roles have hidden capabilities that aren't available for selection when creating a custom role. For details, see Standard roles. Here's a view of the capabilities associated with the All product admin role. When creating a custom role, you can select a custom set of capabilities. Note that our list of capabilities changes over time: this screenshot was taken April 2021. For how to set up roles with custom capabilities, see the user management tutorial. Manage users To learn how to add users, assign them to groups, and create custom groups and roles, see Manage users. 2020 user model changes If you'd like to understand how our user model changed in 2020 and what the impacts of that change were, see User model changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.87387,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> user model: Understand the user structure ",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> user model: Understand the user structure",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> user management",
        "body": " and dashboards (not <em>New</em> <em>Relic</em>-built) Alerts and notifications Our APIs, including NerdGraph (GraphQL) (with some restrictions) Logs UI Build <em>New</em> <em>Relic</em> <em>One</em> <em>apps</em> (but cannot <em>access</em> other <em>apps</em>) Encryption at rest Standard <em>data</em> retention Security and compliance <em>Data</em> management Note that your pricing tier"
      },
      "id": "603e88e328ccbcfcbaeba7a8"
    },
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Steps for a successful transition",
        "Get started with New Relic One",
        "Query anything",
        "Visualize more data"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "https://docs.newrelic.com/static/37a6b5e8b87c365c4b1bf9ea778696a7/c1b63/new-relic-one-dashboard-example_1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-04-16T22:09:48Z",
      "updated_at": "2021-04-05T03:35:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries, charts, and dashboards. With New Relic One, we have modernized the experience for you to access, analyze, and visualize your data. New Relic One offers an improved charts and dashboards experience, and it provides a platform where we can more rapidly bring new innovations to you. This transition guide can help you understand: What are some of the new and improved features you get with New Relic One charts, dashboards, and queries Why it's easy to transition to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Steps for a successful transition The transition to New Relic One has two parts: the UI and mobile app experience (April 12, 2021) and the Dashboard API (July 2021). Insights functionality Transition to New Relic One UI We have already taken care of your transition from Insights to New Relic One for you! As of April 12, 2021, your old Insights web URLs redirect automatically to New Relic One. We recommend that you familiarize yourself with the new UI features available to you, as described in this transition guide. If you need to view any Insights charts embedded in other websites, go to one.newrelic.com > More > Manage Data. (These older embedded charts will continue to function as expected.) Mobile apps Your Insights mobile app is deprecated as of April 11, 2021. Go to the Google Play Store 2 or Apple App store. Delete your old Insights mobile app, and download the New Relic One mobile app. tvOS apps and large displays New Relic's tvOS app is still available. No action is needed by you at this time. Some New Relic customers with the original pricing model may have set up dashboards on wall screens for restricted users with kiosk mode. No action is required for you to continue to view these dashboards. APIs The Insights API to create dashboards will be deprecated and replaced with the new Dashboards API as of July 2021. We encourage you to start exploring the capabilities of the Dashboards API in NerdGraph now! You can continue to use your Insights insert API key with the Dashboards API, or you can create a new user API key. Every user who wants to query with the NerdGraph API will need their own user API key. The REST API for Insights queries is not affected by this change and will not be deprecated. For more information about which key to use with our APIs, see our documentation about API keys. Easily access your insert and query API keys by going to one.newrelic.com > More > Manage Insights Data> API Keys Partnership accounts This applies only if your account is one of the few using our partnership account structure to deliver New Relic services to your direct customers. In this situation, the Insights EOL will not affect your customers’ pricing. This is simply an EOL for the UI, not an EOL for the account type. Questions If you have questions about the transition, please comment in our Explorers Hub post. Or, if you work with an account team, they will be happy to help you. Get started with New Relic One New Relic One dashboards are an improvement to the Insights experience. New Relic One has all the dashboard and charting features that Insights has, and more! one.newrelic.com > Dashboards: New Relic One offers a better querying and charting experience than Insights. Switching to New Relic One is easy and seamless. All of the dashboards you previously created in Insights are automatically available in New Relic One. Query anything With New Relic One, you get: Better querying and charting experiences: Query access is available globally, no matter where you are in New Relic One. This includes a \"basic\" query mode that doesn't require knowledge of NRQL. Improved query experience: You can query both the Metric data type and metric timeslice data. Easy customization: Every visualization now has the query accessible. You can augment any curated chart just by changing the NRQL. Visualize more data Not only can you select a wide range of visualization options, you can also add more to your dashboards: Better display options: Make your data easier to understand by using visualizations other than dense, line-heavy charts. New Relic One also offers a better TV mode. More charts or widgets across dashboards: Insights restricted you to a 3-across limit. Now you can display up to 12 across your dashboard, providing increased data density along with improved tooltips and tracking across charts. Easier creation of multi-page dashboards: Insights referred to these as data apps. Your Insights data apps are preserved as multi-page dashboards in New Relic One. Chart consistency and flexibility: Dashboards include facet color consistency across widgets and faster loading times for more performant dashboards. Also, you can add any chart type to a dashboard in New Relic One! The New Relic Insights UI has served our users well for many years, but it's time to give you an even better experience. Join us and make the switch to New Relic One!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.3957,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "sections": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " our Explorers Hub post. Released in 2014, <em>New</em> <em>Relic</em> Insights was our original way to create custom queries, charts, and dashboards. With <em>New</em> <em>Relic</em> <em>One</em>, we have modernized the experience for you to <em>access</em>, analyze, and visualize your <em>data</em>. <em>New</em> <em>Relic</em> <em>One</em> offers an improved charts and dashboards"
      },
      "id": "6044171164441f454a378ee2"
    }
  ],
  "/explore-docs/nr1-plugins": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 296.45654,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-16T22:12:16Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.133,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.12167,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.11703,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.11703,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/explore-docs/nr1-nerdpack": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 294.37485,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-16T22:12:16Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.07364,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.06238,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.05777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.05777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/explore-docs/intro-to-sdk": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programability_browser_analyze_1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-developers-guide-roundup",
      "sections": [
        "Intro to New Relic One SDK",
        "New Relic One CLI",
        "Intro to NerdStorageVault - New Feature!",
        "Create a \"Hello, World\" app",
        "Practice diagnosing common issues using New Relic",
        "Get coding and get inspired",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:23:24Z",
      "title": "New Relic Developers Guide Roundup",
      "updated_at": "2021-04-13T23:23:31Z",
      "type": "",
      "external_id": "9322d4fbb3dbbeb84cc7c3f26c9cc2c275e3a11d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Relic Developers Guide Roundup Jan 5, 2021 • 7 min read By Vi Tran When we first launched our programmable platform, one of our executives envisioned a simple way to visualize customer experience and satisfaction scores. He sent the following sketch to an engineer: Two days later, he had a production-ready application, built on New Relic One, that showed not just what the customer experience scores were, but what they should be. The browser analyzer application This New Relic One application is called the browser analyzer—it’s open source and available for you to use today. But now it’s your turn to go from sketch to app. We’ve given you the same tools our own engineers use, so you can build and deploy applications in New Relic One that connect your observability data, gathered from myriad sources—including third-party open source data—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK The New Relic One SDK provides the necessary components you need to build New Relic One applications. Components of the SDK include: React UI components for controlling text and layout in a New Relic One application Chart components for representing different types of charts Query and storage components for fetching and storing New Relic data Platform APIs that enable your application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build your applications, create visualizations, and fetch New Relic or third-party data. New Relic One CLI In addition to the SDK, you’ll need the New Relic One CLI to build apps on the platform. You’ll use the CLI to build, publish, and manage your app. More specifically, you’ll use the CLI to do the following: Generate Nerdpack/Nerdlet templates—(a Nerdpack is a package containing all the files needed by an application; a Nerdlet is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Intro to NerdStorageVault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store your data. NerdStorageVault lets you store and retrieve sensitive data secrets such as: Personal access tokens License keys API keys Other third-party secrets You can explore NerdStorageVault fields and response types with the NerdGraph API explorer. NerdStorageVault is encrypted with AES-256 encryption. In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes. Check out the guide for more information. Create a \"Hello, World\" app In this guide, you’ll build a \"Hello, World!\" application in New Relic One in nine quick steps. You’ll create a local version of the New Relic One site where you can prototype your application, and when you're ready to share the application with others, you can publish it to New Relic One. [embed]https://www.youtube.com/watch?v=7omo0qHxku8&feature=youtu.be[/embed] To get started, make sure you have accounts in GitHub and New Relic. You’ll also need to install Node.js and familiarize yourself with the New Relic One CLI. Tip: Check out Set up your development environment to make sure you have everything in order before you jump in. Practice diagnosing common issues using New Relic Every time you deploy an application, you hope that it's efficient and free of errors. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled demo environment. Acme Telco Lite is a telecom business that maintains an e-commerce website for its customers. The site's architecture has eight interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. Check out the full guide for more on prerequisites and deployment details. Get coding and get inspired Explore more guides and tutorials on New Relic Developers, because we’re constantly adding content. Best of all? The site is built completely in open source—feel free to submit a pull request while you’re there. Related Topics Extend New Relic By Vi Tran Vi Tran is a Senior Product Marketing Manager for Developer Ecosystem at New Relic. Her focus is on growing and enabling the developer ecosystem to extend New Relic One. Before New Relic, she was on the global strategic alliances team at Splunk and was a management consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 699.677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers Guide Roundup",
        "sections": "Intro to <em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em>",
        "body": " The <em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em> provides the necessary <em>components</em> you need to build <em>New</em> <em>Relic</em> <em>One</em> applications. <em>Components</em> of the <em>SDK</em> include: React <em>UI</em> <em>components</em> for controlling text and layout in a <em>New</em> <em>Relic</em> <em>One</em> application <em>Chart</em> <em>components</em> for representing different types of charts <em>Query</em> and <em>storage</em>"
      },
      "id": "607627f464441f7e2b9d8537"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/mobile_ui_react_folder_structure-546x1024.png",
      "url": "https://newrelic.com/blog/best-practices/mobile-ui-react",
      "sections": [
        "The new and improved New Relic Mobile UI architecture",
        "Managing state",
        "Running async services",
        "Plugged in NRQL models",
        "Bonus content: project folder structure",
        "Building more than just a UI"
      ],
      "published_at": "2021-04-16T04:23:43Z",
      "title": "How We Architected the New Relic Mobile Web UI in React",
      "updated_at": "2021-04-14T06:37:40Z",
      "type": "",
      "external_id": "e3d67df0a38b9980728a89cac2fb64cddc1708b1",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Best Practices How We Architected the New Relic Mobile Web UI in React Jan 3, 2018 • 7 min read By Frank Linehan An ongoing curiosity in JavaScript development communities is the question of how to build complex UI applications in React. This open source JavaScript library, maintained by Facebook, makes it easier than ever to write efficient, component-based projects in JavaScript. React has been around for about four years now, but the JavaScript community is still learning how to take full advantage of its powers. The web UI for New Relic Mobile has several points of integration with components, services, and container objects built by different UI engineers across New Relic. Historically it’s been a challenge to cleanly integrate all the pieces. Additionally, we now have more non-frontend engineers than ever contributing to the UI, so it’s become very important for us to have a clean architecture that everyone can easily navigate and contribute to. To make it easier for engineers who contribute code to the UI, we’ve created a flexible system, written in React. And since we’ve built this layered architecture from modules, we’ve been able to decouple the different domains of the UI application from each other, thus easing the burdens of contributors. We wanted to share some of the design behind this complex React project because it’s led us to some seriously great outcomes. The new and improved New Relic Mobile UI architecture Consider this diagram of the new architecture: The top three layers are made up of our framework-specific UI views, containers, and components (which I’ll give a bit more detail for when I discuss the folder structure of our project). Where possible we favor composition over inheritance since React classes are great for this design pattern. For example, we use this pattern in the Handled exceptions sidebar container that has three child UI components: a search input, an occurrence count, and a bar chart component. The sidebar composes these child UI components by passing needed properties to its children (for example, data to render the bar chart). This allows us to reuse these smaller components throughout the application and to handle layout and configuration through the larger container components. We like to think of these UI components as “Lego pieces:” they can be used in multiple ways to build dozens of combinations. The UI views and containers, on the other hand, are much less modular and are more like jigsaw puzzle pieces in that they fit together only one specific way. The bottom layer is composed of three collections of modules in which a significant portion of the Mobile UI application code base lives. These collections handle state management, asynchronous services, and store NRQL models (the latter of which powers the New Relic Query Language functionality in the UI). Managing state In React, state is an object that can change over time; for example, UI text changing to red in the case of an emergency is controlled by state. State can be managed—or held—in stores. In New Relic Mobile, some UI components manage their own internal state (dropdown components keep track of when they are open or closed), but other components, such as the filter list, filter picker, and time picker, use state containers (or bundles of state) that allow state to be easily shared across components. To store the state React renders, we use the MobX library. In the New Relic Mobile UI, the top-level stores that manage application state use singleton patterns. These singletons use object composition to reference the other store singletons in the project. For example, as shown in diagram below, the App store, which handles the UI’s high-level application state, has references to our Router store, Nav store, Time store, Filters store, and Account store. So, for example, when a user clicks and “brushes” a graph (i.e., selects a data point in a graph that is then highlighted in another graph), we need to update our time window and route for the change. When the “brush” action is called, the App store mutates our router state and timestore state, which then triggers updates to all the components that observe those states. The API interface between our State store and the graph component is lightweight and simple, and this part of the UI is flexible if we ever require changes. Running async services This set of core modules are for a few asynchronous services that retrieve data from different places in the New Relic Mobile application. These store objects use the fetch API to make HTTP requests, and they manage the state of data as it loads. These async store objects inherit from our HTTP request store (which is one of the few places where we use inheritance). The HTTP request store is a finite state machine that has some helper methods for handling loading, errors, and data. We chose inheritance for these objects because they all have the same HTTP request pattern (for example, fetch, is loading, has data, has error). By moving that shared behavior to the HTTP request object and inheriting off of it, we removed hundreds of lines of redundant code from our project. Plugged in NRQL models The New Relic Query Language models are modules of code that generate NRQL queries used by the UI components, containers, and views. These models are pretty specific to the structure of the New Relic UI, so a close examination of them isn’t necessary here. Bonus content: project folder structure Finally, no discussion of a JavaScript project is complete without a look at the project’s folder structure. Obviously, there is no “perfect folder structure,” but this is what has worked well for our team in this project. Application code lives in the src folder and styling lives in our scss folder. Both of these folders are bundled up by webpack and turned into UI assets. Our src folder has the following structure: The component folder holds React components that are given sets of properties and render widgets on the screen. These are our “Lego pieces” that can be composed into different combinations in the UI. The containers folder is for components that compose other components. The containers are our puzzle pieces that fit only one way when used in the UI. Then we have our views folder that holds our views components. The views components compose our containers. This folder combines all of our smaller pieces into one big picture, and since most of the team is experienced with some form of the model, view, controller (MVC) architecture, having a views folder gives us all a familiar entry point into the application. The models folder contains the aforementioned NRQL models used to build queries consumed by our graph components and other containers. The configs folder is where we store static variables that are used to configure views and containers. The libs, services, utils, andtransforms folders are where we keep smaller reusable pieces of code that format data or talk to APIs; these can even be used by our other components. Last but not least we have our stores folder, which holds our state containers. As noted, we’re using MobX to store our state and actions. Our end goal was to have as flat a folder structure as possible, since flat is always better than nested. We also made sure the folder names were easily readable since team members need to be able to identify what lives where and what it does. Building more than just a UI In addition to being a successful experiment in architecting a complex JavaScript project in React, we’ve found that this architecture has led to some critical outcomes: Predictable state management: By breaking state into discrete objects, it’s easier for us to see which actions are mutating state in our components. Easy for non-UI-focused team members to contribute: Building our UI architecture with object-oriented programming allows our less experienced UI devs to quickly contribute to the project. Explicitness: Because we’ve decoupled state, UI components, and the underlying service models, new contributors can quickly figure out exactly what parts of the project to contribute to. Ease of use: Thanks to this decoupled and organized architecture, our agent and service engineers were able to complete a significant chunk of UI work in a single sprint while the UI engineer was on a weeklong vacation.   By Frank Linehan Frank Linehan is a Senior Software Engineer on the Mobile APM team at New Relic. He's passionate about front-end engineering, emergent JavaScript frameworks, and maintainable and flexible JavaScript projects. He's also very passionate about mountaineering. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 643.5204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How We Architected the <em>New</em> <em>Relic</em> Mobile Web <em>UI</em> in React",
        "sections": "The <em>new</em> <em>and</em> improved <em>New</em> <em>Relic</em> Mobile <em>UI</em> architecture",
        "body": " error). By moving that shared behavior to the HTTP request object and inheriting off of it, we removed hundreds of lines of redundant code from our project. Plugged in NRQL models The <em>New</em> <em>Relic</em> <em>Query</em> Language models are modules of code that generate NRQL queries used by the <em>UI</em> <em>components</em>"
      },
      "id": "60768db464441f7ce19d854c"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/service-map-graph-1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/service-maps-ga",
      "sections": [
        "Auto-generated dynamic magic maps",
        "Service Maps to support multiple perspectives",
        "Now, go out and play!",
        "Related Topics"
      ],
      "published_at": "2021-04-16T00:00:59Z",
      "title": "Introducing General Availability of Service Maps in New Relic APM",
      "updated_at": "2021-04-13T23:50:38Z",
      "type": "",
      "external_id": "8e669e48d0f2577a07dace9c57cb27f75b8dfb2b",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit APM Introducing General Availability of Service Maps in New Relic APM May 6, 2015 • 9 min read By Stevan Arychuk Regardless of the industry, every company is now a software business. The modern architectures enabling these businesses are becoming increasingly complex and difficult to manage. Increased complexity means increased risk, further exacerbated by a lack of understanding of the system as a whole. One response to this increasing complexity is the rise of microservices, which let organizations build software in which specific functions can evolve independently from the rest of the system. This usually allows those functions to scale and move faster. Microservice architectures also help teams isolate complexity, making it easier to solve for a particular problem. But microservices bring their own challenges: how do you give teams visibility into particular service behaviors and how do you manage the ways each microservice interacts with all the other services in a dynamic environment. These trends and fundamental challenges led us to create a tool specifically designed to help our customers view and understand their complex microservices architectures. Once understood, architectures can be better managed. So that’s why today we are happy to announce a new feature in New Relic APM that's designed to do exactly that: Here come Service Maps! Service Maps are a new map visualization feature in New Relic APM specifically designed for microservice and modern architectures that have many decoupled apps, services, and components. Service developers who build these services, ops and site engineering teams that support them, and DevOps teams that do all the above—you can now rejoice! Service Maps will help you better understand your complex software architectures by creating a visual, real-time map that represents your specific view of the world. Auto-generated dynamic magic maps Using visual aids to represent complex architectures is not a new concept. Large-format network or architecture diagrams built in Visio or Omnigraffle have a long history in software businesses. Although useful, these diagrams can be time consuming to create, often require input from numerous people or teams to provide a complete picture, and may become out of date almost immediately due to constant architecture changes. Service Maps will not only show a representation of your architecture as seen by New Relic APM auto-magically, but any changes to the architecture will be reflected in the map. Real-time health status for components shown on the map are made visible for troubleshooting purposes, including evaluating the health of incoming or outgoing connections for each specific app. We worked hard to make creating Service Maps fun and easy, including special assistance getting started: A welcome screen is presented if you have no previously viewed maps, which will suggest interesting applications to start from based on throughput, visits, and connectedness. If you have previously viewed a map, the last map viewed will be automatically loaded on your next visit. Clicking on the “Service Maps” link in the left nav bar while viewing an application in New Relic APM will automatically create a map starting with that application. Service Maps to support multiple perspectives Every individual and team supporting a service or collection of services as part of a platform that provides a business capability will have a unique view of what is most important. We believe this customized perspective is a core concept of microservices architectures, which holds that autonomous and independent services enable teams to move faster while still participating in a larger ecosystem. From our perspective, the impact of change, from the perspectives of the service and the system as a whole, is critical to understand these types of architectures. To illustrate the core concepts and feature itself, let us use an internal example of the New Relic Alerts, which is also made generally available today, and look at some Service Maps representing the view of the world from the New Relic Alerting team. The first perspective we will look at is the view of the alerting system from the developers of the UI components. Their primary focus and interest are the Alerts' UI-related services and components that they designed, developed, and will support both independently and as part of the larger New Relic Software Analytics Platform architecture. This narrow view is represented in a custom Service Map that shows just those core UI components that are important to that team: service map graph 1 This map was created and customized to show only the relevant components for the Alerting UI since that is what is the most important to the team. This includes the following: Incoming browser connections from end users A Postgres database used by the Alert Service - Production Dependencies on other apps/services as they relate to the Alerting UI, including both Alerting and core platform services 3rd-party external services Less interesting services are shown as a group to minimize clutter on the map but remain important as context The UI team can reference this Service Map to see how changes to the architecture and dependent services impact their own services in real time. Now let’s take a broader view, from the ops and site engineering teams involved in keeping the New Relic Platform and products humming. The alerts components are small pieces of a much larger microservices architecture that support all New Relic products; understanding the boundaries of the alerting system and the connections and dependencies among internal New Relic and external services is important for support, scaling, and performance optimizations. This larger custom Service Map has been created to show this broader perspective: service map graph 2 This map is significantly more complex, as it represents the entire alerting system and other New Relic Platform services consumed by the alerting system. Discovering inter-service connections and dependencies and seeing the real-time health of both core and dependent services is helpful in reducing complexity through visual understanding. We can see from this map that there are a number of services in poor health, which could be causing upstream or downstream issues. When things go bad, the ability to quickly identify both impact and causality can ease troubleshooting this complex architecture. Sharing this understanding is particularly important for large teams supporting complex software architectures. Situational awareness can help everyone make better decisions. So we made it easy to save and share maps with others in your account. Shared maps can help drive a shared understanding of different perspectives for complex architectures between teams. The permalink function in the footer generates a unique URL specific to your map, which can be sent to others to quickly see that specific map. Now, go out and play! The Service Maps feature is released for general availability, and is currently being rolled out to all New Relic APM customers with a paid account. If you don’t see the Service map tab in your APM navigation bar, please be patient—we promise it will show up soon! General availability of Service Maps is just the beginning of ongoing work in both spatial and temporal visualizations in APM and across the New Relic Software Analytics Platform. We aim to continue active development on these and similar features will continue over the coming weeks and months. Getting to this point and releasing the feature has been incredibly challenging yet rewarding for the awesome team who worked on it. We would also like to extend our heartfelt thanks to the many customers who provided invaluable feedback during the beta MVP. That input helped shape our philosophy around solving for the explosion in services and complex environments, leading to a map-based visualization tool in APM. We hope you all have as much fun using it as we have had building it. For more information on Service Maps, see: Service Maps documentation Service Maps configuration documentation New Relic's Modern Software Architectures press release   Background image courtesy of Shutterstock.com. Related Topics APM By Stevan Arychuk Stevan Arychuk is a senior product manager at New Relic. He's based in our Portland office. Follow the author Stevan Arychuk on Twitter Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 484.90588,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introducing General Availability of Service Maps in <em>New</em> <em>Relic</em> APM",
        "sections": "Now, go out <em>and</em> play!",
        "body": " of the larger <em>New</em> <em>Relic</em> Software Analytics <em>Platform</em> architecture. This narrow view is represented in a custom Service Map that shows just those core <em>UI</em> <em>components</em> that are important to that team: service map graph 1 This map was created and customized to show only the relevant <em>components</em> for the Alerting <em>UI</em>"
      },
      "id": "60762e4e28ccbcc0fc51c198"
    },
    {
      "sections": [
        "What is an entity in New Relic?",
        "What is an entity?",
        "Find and explore entities",
        "Tip",
        "Entity relationships",
        "Important",
        "Group and organize entities"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-16T22:09:48Z",
      "updated_at": "2021-03-16T10:03:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of the entity. This document explains: What entities are How to find entity data How entities are related to one another How to organize them into groups for easier analysis What is an entity? From a New Relic product perspective, entity is a broad concept. An entity is anything we can identify that has data you can monitor. \"Entity\" can refer to fundamental data-reporting components like applications, hosts, and database services, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. This conceptual definition of \"entity\" is important because New Relic's goal is to give you practical information about the status of your business-important entities (and not just give you an unhelpfully large stream of assorted metrics and data). Our focus on entities, and the relationships between them, helps us optimize monitoring and troubleshooting of complex, modern systems. Find and explore entities An entity is anything that reports data to New Relic, so you'll find your entities wherever you see your data reporting in New Relic. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's unique global identifier (GUID): from any list of monitored entities in the New Relic Explorer, hover over a specific entity and click the icon to see the GUID and other metadata. An entity's GUID is reported as the attribute entityGuid. You can query for an entity using this attribute in the query builder. Use the Related Entities view in the New Relic Explorer, service maps, distributed tracing, and our relationships API in GraphQL to see connections between entities. Explore entity data using our NerdGraph GraphiQL explorer (api.newrelic.com/graphiql). Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a single entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related Entities in the entity's mini overview. Related Entities is a visualization of the various entities connected directly to the current entity in focus. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip You can learn more about how entities are related using our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related Entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. These are granted to user roles by default. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: How to tag entities Create workloads (groups of related entities)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 460.917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> monitoring is built around the concept of the entity. This document explains: What entities are How to find entity data How entities are related to <em>one</em> another How to organize them into groups for easier analysis What is an entity? From a <em>New</em> <em>Relic</em> product perspective, entity is a broad"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "Understand the Lambda monitoring UI",
        "View your data",
        "Important",
        "UI pages",
        "Understand chart data",
        "For more help"
      ],
      "title": "Understand the Lambda monitoring UI",
      "type": "docs",
      "tags": [
        "Serverless function monitoring",
        "AWS Lambda monitoring",
        "UI and data"
      ],
      "external_id": "45a6a881de05bcb4814f7f25f2bfa1632257a7f1",
      "image": "https://docs.newrelic.com/static/17e88e0171bc6b4358292daf4ddf7cf4/c1b63/new-relic-lambda-entities-screenshot_0.png",
      "url": "https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/ui-data/understand-lambda-monitoring-ui/",
      "published_at": "2021-04-17T01:51:08Z",
      "updated_at": "2021-03-30T19:47:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Serverless monitoring for AWS Lambda offers in-depth performance monitoring for your Lambda functions. This document explains how to: Find your Lambda data in the UI Understand the UI components Understand your chart data How to create custom charts View your data one.newrelic.com> Explorer > Amazon Web Services > Lambda functions: Click Lambda functions to see charts and details. To view your Lambda data in New Relic: Go to one.newrelic.com, click Explorer. In the left nav under Amazon Web Services, click Lambda functions. For more about our UI, see Intro to New Relic One. Important If you can't find your Lambda data: Ensure you've followed the instructions for enabling Lambda monitoring. Note that this feature is different from our infrastructure monitoring Lambda integration. UI pages Here are descriptions of the UI pages available for our Lambda monitoring: UI page Functionality Summary The Summary page displays charts that give you a quick view into the most important performance data. If available, this will feature data gathered from APM agent instrumentation. CloudWatch metrics The CloudWatch metrics page displays Lambda data that comes from AWS CloudWatch. Charts include: invocation counts, duration, throttles, and error counts. Distributed tracing The Distributed tracing page shows distributed traces that include the monitored Lambda function. For details about this feature, see Distributed tracing. Errors The Errors page displays errors (AwsLambdaInvocationError events). You can filter by error rate, error percentage, or error class. You can drill down into errors and see attributes and, if available, stack traces. Invocations The Invocations page lets you filter your invocations by attribute, and view duration, throughput, external calls, and invocation breakdowns. About invocation breakdowns: Some invocations will generate a breakdown if distributed tracing is enabled during instrumentation. Breakdowns are sampled; approximately 10% of invocations generate a breakdown. This sampling rate may be higher, depending on upstream sampling decisions. Logs The Logs page displays recent log messages from your Lambda function. For details about this feature, see Logs. Understand chart data Lambda data charts are generated by running NRQL queries of Lambda-related event data. Reasons to view a chart's NRQL query include: To better understand what a chart is displaying To get ideas on how to create a custom NRQL query and chart Related documentation: Learn how to view a chart's query. Learn about Lambda data storage and structure. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 458.85828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Understand the Lambda monitoring <em>UI</em>",
        "sections": "Understand the Lambda monitoring <em>UI</em>",
        "tags": "<em>UI</em> <em>and</em> data",
        "body": "Serverless monitoring for AWS Lambda offers in-depth performance monitoring for your Lambda functions. This document explains how to: Find your Lambda data in the <em>UI</em> Understand the <em>UI</em> <em>components</em> Understand your <em>chart</em> data How to create custom charts View your data <em>one</em>.newrelic.com&gt; Explorer"
      },
      "id": "603eb10f196a67c65da83da2"
    }
  ],
  "/explore-docs/nr1-subscription": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 294.37476,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-16T22:12:16Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.07355,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.06232,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.05768,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.05768,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/build-apps/build-visualization": [
    {
      "sections": [
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "Tip",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs"
      ],
      "title": "Automate instrumentation",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "65d82617672b47497b59dcf7c55eaba535714676",
      "image": "https://docs.newrelic.com/static/82b9b43751f8e8c8dbf4be1242cc6cb3/c1b63/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation/",
      "published_at": "2021-04-16T10:15:36Z",
      "updated_at": "2021-03-16T10:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Tip Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.25957,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ". For example, the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "603ea2f7196a672323a83def"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.77335,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom New Relic <em>One</em> application ",
        "sections": "Build a custom New Relic <em>One</em> application",
        "tags": "New Relic <em>One</em>",
        "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic <em>One</em> platform, alongside your other dashboards and data. Feature <em>visualizations</em> that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-16T22:12:16Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.003876,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic <em>One</em>",
        "body": "To view workloads, go to <em>one</em>.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.00101,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic <em>One</em>",
        "body": "New Relic <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.99984,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "New Relic <em>One</em>で構築",
        "tags": "New Relic <em>One</em>",
        "body": "New Relic <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント New Relic <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    }
  ],
  "/explore-docs/nr1-common": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 296.45654,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-16T22:12:16Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.133,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.12167,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.11703,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.11703,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/explore-docs/nr1-config": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 296.45645,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-16T22:12:16Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.1329,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.12158,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.11694,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.11694,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/build-apps/permission-manage-apps": [
    {
      "sections": [
        "Add custom visualizations to your dashboards",
        "Add a visualization to a dashboard",
        "Manage your dashboard visualizations"
      ],
      "title": "Add custom visualizations to your dashboards",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d6c9973ef2c2547a99539d1da027b54db23af42c",
      "image": "https://docs.newrelic.com/static/5f7bd9c6a2a163d1f19c5c8b0d844d2f/c1b63/dashboard_viz.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/add-custom-visualizations-your-dashboards/",
      "published_at": "2021-04-17T03:06:30Z",
      "updated_at": "2021-03-16T11:03:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can build your own visualizations and add them to a dashboard. This gives you great flexibility around what you display on dashboards, from a company logo to custom queries from any data source. This visualization shows the number of people in each city who are viewing New Relic within an organization. The visualization was created using the New Relic One CLI and Treemap from the Recharts library. If you have full user permissions, which include the Nerdpack manager role, you can add a visualization to a dashboard as described in the following section. The process for creating a visualization is covered in the guide, Build a custom visualization for dashboards. Add a visualization to a dashboard You can add a visualization to a new or existing dashboard. From New Relic, in the top right, click the Apps button, and then on the Apps page, click Custom Visualizations. Hint: if you don't see the Custom Visualizations tile, use the search to locate it. In Custom Visualizations, select the visualization you want to add to a dashboard and then enable it. If there are configuration options, fill those in. The visualization will update with your changes. Click Add to dashboard and then select a dashboard from the list of available dashboards, or select New dashboard. If you decide to create a new dashboard, select the account where you want to run the dashboard, and give the dashboard a name. Click Add to dashboard, then click the link to your dashboard to see the custom visualization. Manage your dashboard visualizations Deleting: To remove a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click delete. Editing: If your visualization needs some tweaking, delete the visualization, then follow the steps above to re-add the visualization, making any updates in Custom Visualizations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.36367,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Manage</em> your dashboard visualizations",
        "body": " an organization. The visualization was created using the New Relic One CLI and Treemap from the Recharts library. If you have full user <em>permissions</em>, which include the <em>Nerdpack</em> <em>manager</em> role, you can add a visualization to a dashboard as described in the following section. The process for creating"
      },
      "id": "603ec4e628ccbc9409eba7ab"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/2g790g7la1iot/promo-image.1573253956.png",
      "url": "https://learn.newrelic.com/live-learncast-new-relic-one-programmability",
      "sections": [
        "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications.",
        "About this Learncast",
        "Prerequisites",
        "Virtual Training Session List"
      ],
      "published_at": "2021-04-20T01:39:15Z",
      "title": "Live Learncast: New Relic One Programmability",
      "updated_at": "2021-01-02T01:38:56Z",
      "type": "",
      "external_id": "053510b559767dbde34e3f1ee9a73bbf813a5a83",
      "popularity": 1,
      "body": "Sign In Live Learncast: New Relic One Programmability Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. Not currently available Available until July 10, 2020, 3:30 p.m. PDT. Already registered? Sign In About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably.   During this session we will review the following topics:   1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites   This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications.   Must have:   Permissions to install  Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy   Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably.   During this session we will review the following topics:   1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites   This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications.   Must have:   Permissions to install  Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy   Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) © 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 85.8408,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic <em>Applications</em>.",
        "body": " A text editor or IDE of your choice (we will be using VS Code) <em>Nerdpack</em> <em>manager</em> roll to deploy   Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials"
      },
      "id": "5dc618cbe7b9d2a0a8e4649c"
    },
    {
      "sections": [
        "Integrations and custom roles",
        "Recommended role",
        "Optional role",
        "Important",
        "List of permissions",
        "Common permissions",
        "Service-specific permissions",
        "Permissions to link projects through the UI"
      ],
      "title": "Integrations and custom roles",
      "type": "docs",
      "tags": [
        "Integrations",
        "Google Cloud Platform integrations",
        "Get started"
      ],
      "external_id": "d4f60e2d8413ddde9a342980d75a0e216af9baa4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/google-cloud-platform-integrations/get-started/integrations-custom-roles/",
      "published_at": "2021-04-16T16:37:10Z",
      "updated_at": "2021-04-16T16:37:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To read the relevant data from your Google Cloud Platform (GCP) account, New Relic uses the Google Stackdriver API and also other specific services APIs. To access these APIs in your Google Cloud project, the New Relic authorized account needs to be granted a certain set of permissions; GCP uses roles to grant these permissions. Recommended role By default we highly recommend using the GCP primitive role Project Viewer, which grants \"permissions for read-only actions that do not affect your cloud infrastructure state, such as viewing (but not modifying) existing resources or data.\" This role is automatically managed by Google and updated when new Google Cloud services are released or modified. Optional role Alternatively, you can create your own custom role based on the list of permissions, which specifies the minimum set of permissions required to fetch data from each GCP integration. This will allow you to have more control over the permissions set for the New Relic authorized account. Important New Relic has no way of identifying problems related to custom permissions. If you choose to create a custom role, it is your responsibility to maintain it and ensure proper data is being collected. To customize your role you need to: Create a Google Cloud IAM Custom Role in each one of the GCP projects you want to monitor with New Relic. In each custom role, add the permissions that are specifically required for the cloud services you want to monitor according to the following list. Assign the custom role(s) to the New Relic authorized account. List of permissions Common permissions All integrations need the following permission: monitoring.timeSeries.list service.usage.use Service-specific permissions For some GCP integrations, New Relic will also need the following permissions, mainly to collect labels and inventory attributes. Integration Permissions Google AppEngine n/a; Google App Engine does not require additional permissions. Google BigQuery bigquery.datasets.get bigquery.tables.get bigquery.tables.list Google Cloud Functions cloudfunctions.locations.list Google Cloud Load Balancing n/a; Google Cloud Load Balancing does not require additional permissions. Google Cloud Pub/Sub pubsub.subscriptions.get pubsub.subscriptions.list pubsub.topics.get pubsub.topics.list Google Cloud Spanner spanner.instances.list spanner.databases.list spanner.databases.getDdl Google Cloud SQL cloudsql.instances.list Google Cloud Storage storage.buckets.list Google Compute Engine compute.instances.list compute.disks.get compute.disks.list Google Kubernetes Engine container.clusters.list Permissions to link projects through the UI To be able to see the list of projects that you can link to New Relic through the UI, your New Relic authorized service account needs the following permissions: resourcemanager.projects.get monitoring.monitoredResourceDescriptors.list If you do not want to grant New Relic authorized account the permissions that are needed for the linking process through the UI, you have the following options: Assign the Project Viewer or Monitoring Viewer role initially to the authorized account to link Google Cloud projects to New Relic through the UI. After the projects are linked, assign a Google Cloud custom role to the authorized account. Use New Relic NerdGraph to link Google Cloud projects to New Relic. This does not involve listing the viewable projects. However, you must know the id of the project you want to monitor. For more information, see the NerdGraph GraphiQL cloud integrations API tutorial.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.99452,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "List of <em>permissions</em>",
        "body": " <em>permissions</em>, mainly to collect labels and inventory attributes. Integration <em>Permissions</em> Google <em>App</em>Engine n&#x2F;a; Google <em>App</em> Engine does not require additional <em>permissions</em>. Google BigQuery bigquery.datasets.get bigquery.tables.get bigquery.tables.list Google Cloud Functions cloudfunctions.locations.list Google"
      },
      "id": "603ebb3564441f34b64e8874"
    },
    {
      "sections": [
        "Users and roles (original user model)",
        "Requirements",
        "View and manage users in UI",
        "Tip",
        "View pending SAML SSO users",
        "Add a new user",
        "Important",
        "Update user type (basic vs full)",
        "Update account roles",
        "Delete a user",
        "Update the account Owner",
        "User types: basic user and full user",
        "Account roles",
        "Add-on roles",
        "View roles",
        "Assign a managed role",
        "Create a custom role",
        "Assign a custom role",
        "Edit or delete a custom role",
        "Account permissions",
        "Alert permissions",
        "APM permissions",
        "Browser permissions",
        "Infrastructure permissions",
        "Insights permissions",
        "Mobile permissions",
        "Synthetics permissions",
        "Workloads permissions"
      ],
      "title": "Users and roles (original user model)",
      "type": "docs",
      "tags": [
        "Accounts",
        "Original accounts and billing",
        "Original users and roles"
      ],
      "external_id": "95ae42f3474b43dec394245cfc3e23628449a1ed",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/original-accounts-billing/original-users-roles/users-roles-original-user-model/",
      "published_at": "2021-04-16T04:43:30Z",
      "updated_at": "2021-03-30T15:18:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For users on our original user model, an introduction to how the user model works, including user roles and permissions, and how to add and manage users. Requirements This doc and the surrounding section of docs shows you how to manage users who are on our original user model. If you were a New Relic customer before July 30 2020, you likely have users on our original user model (and not the New Relic One user model). One way to quickly check your users' user model: if you can see users in the Users and roles UI, those users are on our original user model. Want to learn more about user model changes? See Overview of user models. View and manage users in UI If your New Relic account has users on our original user model, you can use the Users and roles UI. To access this UI: select the account dropdown, select Account settings, and select Users and roles. Some features in the UI are visible only to account Owners and Admins. Tip You can also use the New Relic REST API to obtain a list of everyone and their roles in your New Relic account. Here are some instructions and tips for adding and managing users via the UI: View pending SAML SSO users New Relic accounts with SAML Single Sign On (SSO) may have a list of Pending users. These are individuals who have been added to the SAML-enabled account but have not yet confirmed. Add a new user Tip Owner or Admins To add a new user to your New Relic account: Go to: account dropdown > Account settings > Users and roles > Users. In the upper right corner, click New user. Enter the appropriate name and email address. Select their base role as either Admin, User, or Restricted. Select Add user. The new user will receive an email notification automatically from New Relic. Important New Relic recommends a maximum of 1,000 accounts per user. Additional accounts may result in limited access to some New Relic features. Update user type (basic vs full) To update a user's type (basic user versus full user): Go to: account dropdown > Account settings > Users and roles > Users. Either select a user and edit their type or bulk update the type for multiple useres. For more about this, see User type. Update account roles Tip Owner or Admins To update a person's role and capabilities: Go to: account dropdown > Account settings > Users and roles > Users. Select the person's name. Under Roles and capabilities, select their base role as Admin, User, or Restricted. The account Owner must update the Owner role. Delete a user Tip Owner or Admins To remove a user from your New Relic account: Go to: account dropdown > Account settings > Users and roles > Users. Click on the name of the person you would like to update. Click Delete User. Tip You can also add, update, or delete users in bulk via CSV file. Update the account Owner A New Relic account can have only one Owner role at any time. You must be the current account Owner to change your role to someone who currently has an Admin role for the account. If the current Owner is unavailable, contact your account representative at New Relic, or get support at support.newrelic.com. You cannot delete or remove your assigned Owner role. However, if the account has one or more Admin role, you can change an Owner to an Admin. Go to: account dropdown > Account settings > Account > Users and roles. Above the Active users list, select Change owner. If an account has no Admins, this button won't be available. Select someone who currently has an Admin role for the account. Refresh the page for changes to take effect. Your previous Owner role automatically changes to an Admin role. To find out who is the current assigned Owner: Go to: account dropdown > Account settings > Account > Users and roles. View the Base role column to locate your account Owner. The Change owner button is only visible to the current account Owner. If the current Owner is unable to change the role (for example, that person no longer is with your organization), contact your account representative at New Relic, or get support at support.newrelic.com. User types: basic user and full user Important This section is for users on our original user model. If you're on our New Relic One user model, see our New Relic One user docs. Starting March 2021, we ended the preview period for these basic users. The preview period gave basic users the same permissions as full users. For more on this, see our Explorer's Hub post on user type changes. The user type (basic user or full user) determines what features a user has access to. Below are details on the two user types. Note that billing-related aspects only apply if you're on New Relic One pricing. If you're on our original pricing plan, billing impacts do not apply. Basic user. Details: These users have access to basic features like setting up reporting of data, running queries of data, making custom charts and dashboards, and setting up alerts. They do not have access to Full-Stack Observability features (for more details on feature access, see Capabilities). Basic users can upgrade to become full users in the UI. They will see prompts when attempting to access unavailable features. They cannot self-upgrade; they must request an upgrade. No matter what custom group a basic user is assigned to, they always have the capabilities of a basic user: no more and no less. Full user. Details: Full users have access to our Full-Stack Observability features, which include our curated UI experiences like APM, infrastructure monitoring, browser monitoring, mobile monitoring, and synthetic monitors. For details on what's available, see Capabilities. For organizations on New Relic One pricing: these users are billable. The Standard pricing tier includes one free full user and up to five total. If a user in your organization is set as a basic user in one account and a full user in another, the user has full user access for all accounts. For how to edit user type, see Manage users. Account roles A New Relic account can have only one Owner. To share an account with other users in your organization, create Admins, Users, or Restricted Users. Account role Description Owner The person who initially creates the New Relic account and receives all billing queries. The Owner has complete access to all of the account information. Admin Can add, edit, and delete users, and can enable or set up features. User Can use (and optionally set up) New Relic features. In general, Admins take responsibility for setting up features, and Users and Restricted Users can use them. Restricted User One or more individuals who can view (but not set up or change) any New Relic features. The Restricted User role is useful, for example, for demos. You can change your New Relic session settings so that Restricted User logins do not time out, and then set the user interface to Kiosk mode. Add-on roles With add-on roles, you can grant variable levels of access to all users in your account, across the entire platform of New Relic products. This allows you to tailor your account permissions levels to suit the needs of Users and Restricted Users within your account. Giving a User or Restricted User add-on manager access to a product grants them the equivalent of Admin capabilities within the product. They will continue to have User or Restricted User capabilities for all other New Relic products. For example, you could make a software engineer in your company a User in most products, but assign Admin-level access to APM. For another example, you might assign the Nerdpack manager role to a user, and that gives them the ability to subscribe and unsubscribe New Relic One applications to an account. There are two types of add-on roles: Add-on Manager roles are available to grant permissions on a per-product basis. Giving a User or Restricted User managed add-on access to a product grants them the equivalent of Admin capabilities within the product. Custom add-on roles can grant feature-specific permissions across different New Relic products. For example, a group of Users could have the ability to acknowledge incidents and close violations in New Relic Alerts, but not have the ability to modify your existing alert preferences. Individuals on a master account that has sub-accounts automatically have the same level of access for all sub-accounts. Below are options for managing both managed add-on roles and custom add-on roles: View roles To view the list of individuals assigned to your account and their current roles: Go to account dropdown > Account settings > Users and roles. Assign a managed role Tip Owner and Admins Managed add-on roles are available by default for each New Relic product. Adding a managed role for a user grants them Admin-level permissions for the assigned product. They cannot be edited or deleted. To assign a managed add-on role for a User or Restricted User in your account: Go to account dropdown > Account settings > Users and roles. From the list of users associated with your account, select their name. Under Add-on roles, select the type of manager role for the user. To understand which capabilities may be added, use the Capabilities preview chart. Features in the Capabilities preview chart may not exactly match what features are available for your subscription level. Tip You can also add, update, or delete users in bulk by using a CSV file. Create a custom role To create a custom add-on role for your account: Go to account dropdown > Account settings > Users and roles > Roles. Select New custom add-on role. Select the capabilities necessary for the new custom role, then Create role. Assign a custom role Tip Owners and Admins You must create a custom role before assigning it to a user. To assign a custom add-on role for a User or Restricted User in your account: Go to account dropdown > Account settings > Users and roles > Users. From the list of users associated with your account, select their name ]. Under Add-on roles, select a custom role for the user. Click Update user. Edit or delete a custom role Tip Owners and Admins You cannot edit or delete New Relic's default roles. However, you can edit or delete custom add-on roles for your account: Go to account dropdown > Account settings > Users and roles > Roles. From the Add-on roles list, select the custom add-on role, then select Edit role or Delete role as appropriate. Account permissions Here is a summary of basic user rights for your New Relic account. Individuals on a master account with sub-accounts automatically have the same level of access for all sub-accounts. However, they will not receive email notifications for alerts or weekly reports for sub-accounts unless they are explicitly granted permission on these sub-accounts. Function Owner Admin User Restricted Maintain billing information. Change the account Owner. Add, update, and delete account Admins, Users, and Restricted Users. When the account Owner and Admins add individuals to the account, New Relic automatically sends them an email message. Update users' job titles and roles from Account settings in the New Relic UI. Create, modify and delete sub-accounts from Account settings in the New Relic UI. Update your own account information (name, password change or password reset request, default account, email preferences, etc.) from User preferences in the New Relic UI. Change someone else's password. You cannot reset passwords for anyone else on the account, even if you are an Owner or Admin. Instead, follow standard procedures to request a password reset from New Relic. View the list of individuals on the account from (account dropdown) > Account settings > Account > Summary in the New Relic UI. Manage flexible data retention. Subscribe and unsubscribe applications to New Relic One Alert permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Alerts. To allow a User or Restricted User to execute any of these functions in New Relic Alerts, assign an Alerts add-on manager role. Admin and manager capabilities for Alerts include: Create or name alert policies. Specify incident preferences. Disable or define alert conditions. Provide runbook instructions. Select product targets. Alter alert condition thresholds. Create, modify, or delete notification channels. APM permissions Here is a summary of Admin and Add-on manager capabilities with New Relic APM. To allow a User or Restricted User to execute any of these functions in New Relic APM, assign an APM add-on manager role. Admin and manager capabilities for APM include: Remove applications from the New Relic UI. Delete app traces and error traces. Browser permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Browser. To allow a User or Restricted User to execute any of these functions in New Relic Browser, assign a Browser add-on manager role. Admin and manager capabilities for Browser include: Add, rename, or delete applications. Manage whitelists. Manage domain conditions. Infrastructure permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Infrastructure. To allow a User or Restricted User to execute any of these functions in New Relic Infrastructure, assign an Infrastructure manager role. Admin and manager capabilities for Infrastructure include: Create alert conditions in New Relic Infrastructure, including conditions for host not reporting. Add or modify integrations. Insights permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Insights. To allow a User or Restricted User to execute any of these functions in New Relic Insights, assign an Insights manager role. These functions include: Create, view, modify, or delete Query API keys or Insert API keys. Tip New Relic Insights includes permission levels to share your Insights dashboards with others. Mobile permissions To give permission to delete a mobile app from New Relic, you can assign an Admin or Mobile manager role. Synthetics permissions Here's a summary of Admin and Add-on manager capabilities with New Relic Synthetics. To allow a User or Restricted User to execute any of these functions in New Relic Synthetics, assign a Synthetics add-on manager role. Admin and manager capabilities for Synthetics include: Create, edit, or delete monitors. Edit monitor scripts. Create, edit, or delete private locations. Create, edit, or delete monitor downtimes. Create, view, edit, or delete secure credentials. For more information, see User roles in Synthetics. Workloads permissions Here's a summary of Admin and Add-on manager capabilities with New Relic One workloads: Create, duplicate, modify, or delete workloads. Link dashboards to workloads and save filters. To allow a User or Restricted User to execute these functions, assign the workloads manager add-on role.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.153564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Account <em>permissions</em>",
        "body": " might assign the <em>Nerdpack</em> <em>manager</em> role to a user, and that gives them the ability to subscribe and unsubscribe New Relic One applications to an account. There are two types of add-on roles: Add-on <em>Manager</em> roles are available to grant <em>permissions</em> on a per-product basis. Giving a User or Restricted"
      },
      "id": "603e88b2e7b9d2a3f12a07d5"
    },
    {
      "image": "https://newrelic.com/dam/new-relic/opengraph/newrelic_og_image.png",
      "url": "https://newrelic.com/resources/webinars/NR-One-Programmability-191126",
      "sections": [
        "During this session we will review the following topics:",
        "Related Links",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-04-15T23:03:40Z",
      "title": "New Relic One Programmability Online Training",
      "updated_at": "2021-03-16T04:37:48Z",
      "type": "storefront",
      "external_id": "f583edb88ca2d2430ca297364eac839705311616",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Video New Relic One Programmability Online Training 46:59   Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. Prerequisites This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications.  Must have: Permissions to install  Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager role to deploy Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests JavaScript layouts   During this session we will review the following topics: Installation of New Relic CLI and Environment setup Familiarisation with New Relic One Application component model and lifecycle Advanced UI construction and data processing Individual self paced experimentation and Open Source example deployment Request a Demo Related Links Case Study La plus grande brasserie au monde se tourne vers New Relic pour que la bière continue de couler à flots dans l’ère numérique Webinar Introduction to Custom Apps on New Relic One eBook Understanding the 3 Phases of DevOps Maturity Article Black Friday Is Coming: Are Your Sites and Apps Ready? eBook DevOps – so geht es richtig : Best Practices zur Überwindung von Erfolgshindernissen eBook DevOps Done Right: Best Practices to Knock Down Barriers to Success eBook Creating a Framework for Digital Media Success Article 7 Requirements for Monitoring Cloud Apps and Infrastructure COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.02928,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications.  Must have: <em>Permissions</em> to install  Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) <em>Nerdpack</em> <em>manager</em> role"
      },
      "id": "5ece92cb28ccbc3012c1356a"
    }
  ],
  "/collect-data/query-data-nrql": [
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/1qf2g217c4q7m/promo-image.1608575584.png",
      "url": "https://learn.newrelic.com/getting-started-with-dashboards-nrql",
      "sections": [
        "Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations.",
        "About this workshop",
        "Getting started with Dashboards & NRQL"
      ],
      "published_at": "2021-04-20T01:39:15Z",
      "title": "[Webinar] Getting started with Dashboards & NRQL",
      "updated_at": "2021-04-20T01:39:15Z",
      "type": "",
      "external_id": "20be8b6c5a3882e951f9dfd70354ea7ceaa38c7c",
      "popularity": 1,
      "body": "Sign In [Webinar] Getting started with Dashboards & NRQL Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations. Register | FREE Already registered? Sign In About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.  These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.  Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.   In this hands-on session, you’ll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.  Using a sandbox account you’ll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.  Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL April 20, 2021, 1 p.m. - April 20, 2021, 3 p.m. BST 104 Getting started with Dashboards & NRQL May 6, 2021, noon - May 6, 2021, 2 p.m. PDT 148 Getting started with Dashboards & NRQL May 11, 2021, 1 p.m. - May 11, 2021, 3 p.m. BST 148 Getting started with Dashboards & NRQL June 8, 2021, 1 p.m. - June 8, 2021, 3 p.m. BST 150 Getting started with Dashboards & NRQL June 8, 2021, noon - June 8, 2021, 2 p.m. PDT 150 About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.  These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.  Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.   In this hands-on session, you’ll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.  Using a sandbox account you’ll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.  Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Live events Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL April 20, 2021, 1 p.m. - April 20, 2021, 3 p.m. BST 104 Getting started with Dashboards & NRQL May 6, 2021, noon - May 6, 2021, 2 p.m. PDT 148 Getting started with Dashboards & NRQL May 11, 2021, 1 p.m. - May 11, 2021, 3 p.m. BST 148 Getting started with Dashboards & NRQL June 8, 2021, 1 p.m. - June 8, 2021, 3 p.m. BST 150 Getting started with Dashboards & NRQL June 8, 2021, noon - June 8, 2021, 2 p.m. PDT 150 © 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.56952,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "[Webinar] Getting started with Dashboards &amp; <em>NRQL</em>",
        "sections": "Learn to use the <em>Data</em> Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of <em>NRQL</em>. Progress to working directly with <em>NRQL</em> to create a wider range of charts and visualizations.",
        "body": " a sandbox account you’ll get familiar with <em>NRQL</em> <em>syntax</em>, work with the Query Builder to build your own queries and charts, and create <em>data</em> rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting"
      },
      "id": "5fe29f8528ccbcf532f15668"
    },
    {
      "sections": [
        "Create smoother charts with sliding windows",
        "When to use sliding windows",
        "Valid NRQL syntax for SLIDE BY",
        "Translation from PromQL-style queries",
        "Use SLIDE BY with MAX and AUTO",
        "Tip"
      ],
      "title": "Create smoother charts with sliding windows",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "97fe07b51e5f2c6a2868c924d1c829d82fd8f585",
      "image": "https://docs.newrelic.com/static/9d882293c1b7b04e65b4bcf6f3ae4bbf/e5166/SlidingWindow2.jpg",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows/",
      "published_at": "2021-04-17T02:36:14Z",
      "updated_at": "2021-03-16T13:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Sliding windows are a technique for generating charts using the SLIDE BY clause in conjunction with the TIMESERIES clause. With sliding windows, data is gathered in time \"windows\" that overlap with each other. For example, in the image below, a query gathers data with 5 minute windows. The windows \"slide\" by 1 minute. Each window overlaps with the previous window by 4 minutes. 5-minute windows with 1-minute \"slide\" In contrast, with \"tumbling\" or \"cascading\" windows, the windows do not overlap. For example, in this TIMESERIES 3 minutes NRQL query, the windows are 3 minutes in length, with each beginning when the other ends. There is no overlap in the measurement interval. 3-minute windows with no overlap or \"slide\". When to use sliding windows Sliding windows are helpful when you need to smooth out \"spiky\" charts. One common use case is to use sliding windows to smooth line graphs that have a lot of variation over short periods of time in cases where the rolling aggregate (for example a rolling mean) is more important than aggregates from narrow windows of time. In the example below, data varies greatly from one minute to another, so the 1-minute tumbling window chart shows many high peaks and low valleys. TIMESERIES query without SLIDE BY clause However, in this example, 5-minute wide TIMESERIES windows are smoothed with the help of 1-minute SLIDE BY intervals. The query returns similar data but creates a much smoother chart. TIMESERIES query with SLIDE BY clause Valid NRQL syntax for SLIDE BY Valid NRQL syntax for the SLIDE BY clause will follow the format below. SELECT ... TIMESERIES integer1 units SLIDE BY integer2 units Copy integer1 specifies the sliding window width and integer2 specifies the SLIDE BY interval. units is a time unit, such as second, minute, hour, or day. All standard NRQL time units are accepted. Here’s a real-life example. It shows 5-minute TIMESERIES windows with a 1-minute SLIDE BY interval. SELECT average(duration) from Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy Translation from PromQL-style queries When applicable, a PromQL-style query is translated into a NRQL sliding window query. For example, if your PromQL style query uses rate(request_count[5m]) for the past 60 minutes with a 1-minute window overlap, the NRQL translation would be the query below. SELECT rate(sum(request_count), 1 SECONDS) FROM Metric SINCE 3600 SECONDS AGO UNTIL NOW FACET dimensions() LIMIT 100 TIMESERIES 300000 SLIDE BY 60000 Copy In the translation output, the default unit of millisecond is used for TIMESERIES and SLIDE BY clauses. For TIMESERIES, 300000 ms is 300 seconds, or 5 minutes, specifying a window size of 5 minutes. For SLIDE BY, 60000 ms is 60 seconds, specifying a slide interval of 1 minute. Use SLIDE BY with MAX and AUTO You can combine SLIDE BY with MAX and AUTO arguments to further tailor query results, as shown in the examples below. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy Tip When paired with SLIDE BY, TIMESERIES does not support AUTO or MAX. The TIMESERIES value must be an integer time unit value. In other words, SLIDE BY AUTO or SLIDE BY MAX will work, but TIMESERIES AUTO or TIMESERIES MAX followed by SLIDE BY and MAX, AUTO, or a specific integer time unit is not supported. Tip The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which will show up as gaps and unexpected results. If you experience these issues with query results, consider checking for instances of SLIDE BY where the step interval exceeds the window size.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.41669,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Valid <em>NRQL</em> <em>syntax</em> for SLIDE BY",
        "tags": "Query your <em>data</em>",
        "body": " high peaks and low valleys. TIMESERIES query without SLIDE BY clause However, in this example, 5-minute wide TIMESERIES windows are smoothed with the help of 1-minute SLIDE BY intervals. The query returns similar <em>data</em> but creates a much smoother chart. TIMESERIES query with SLIDE BY clause Valid <em>NRQL</em>"
      },
      "id": "603e8a2528ccbc56e5eba774"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/NRQL-Alerting2.png",
      "url": "https://newrelic.com/blog/nerdlog/nrql-alerts-generally-available",
      "sections": [
        "What are NRQL Alerts?",
        "Why use NRQL alerts?",
        "How can you use NRQL alerts?",
        "Where can I get more information?"
      ],
      "published_at": "2021-04-16T04:26:20Z",
      "title": "NRQL Alerts Goes GA: Easily Convert NRQL Queries to Alert Conditions",
      "updated_at": "2021-04-13T23:50:38Z",
      "type": "",
      "external_id": "4e0e8343f3c4f7592a29c28f30f3c437d6e6f8a3",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Nerdlog NRQL Alerts Goes GA: Easily Convert NRQL Queries to Alert Conditions May 17, 2017 • 4 min read By Chhavi Nijhawan New Relic Query Language (NRQL), pronounced “nerkel,” is the SQL-like language we have been developing since 2014 specifically for analytics. Our customers use NRQL extensively to write custom queries and analyze the data (both metric and events data) they send to New Relic. Along the way we’ve received many requests to add alerting and notifications using data from NRQL queries. Following up on those requests, we announced NRQL alerts at our FutureStack16 user conference in San Francisco last year. Since then, hundreds of customers have participated in the limited-release beta program. They have not only given us great feedback but also demonstrated a plethora of game-changing use cases for NRQL alerting. That’s why I am so happy to announce that NRQL alerting capability is now generally available. What are NRQL Alerts? NRQL alerts are designed to offer the ability to create highly customized alerts using NRQL queries on the data you store in New Relic Insights and the New Relic database (NRDB). Now NRQL queries can be easily converted to alert conditions using the New Relic Alerts UI. The screenshots below show just how easy it is to use: Why use NRQL alerts? New Relic Alerts are designed to provide an easy-to-use, centralized UI to create alert conditions with full-stack visibility. Alert conditions can be easily created on a wide range of metric data collected from almost all New Relic products (including New Relic APM, New Relic Browser, New Relic Synthetics, New Relic Mobile, and New Relic Infrastructure) using the New Relic Alerts UI. Now, in addition to operationalizing on metric data, NRQL alerts extend that capability to your event data stored in NRDB. This data can contain many dimensions, and NRQL lets you instantly slice and dice it to receive notifications when thresholds are met for the nuanced performance indicators that best represent system or business health. One common use case for NRQL alerts is to alert off a group of things based on some shared criteria; for instance, if you want to trigger an alert any time checkout-related transactions have a duration longer than a particular threshold. The following NRQL query shows how easy it is: Customers familiar with New Relic’s Key Transactions capability may be asking, “Isn’t that the same as a Key Transaction response time condition?” Yes, but with NRQL and the addition of a simple custom attribute like “username,” you can modify the query to notify you when a particular VIP customer had a bad experience with checkout: The ability to arbitrarily filter and aggregate with a flexible analytics-focused query language (NRQL) opens the door to endless possibilities for ops and DevOps teams. How can you use NRQL alerts? Since NRQL alerts has been in limited-release beta, early users have been busy coming up with innovative ways to use it. Nate Heinrich recently wrote a description of how NRQL alerts works, and shared his “giant list of things you can do with this that might inspire you.” Read his post NRQL Alerts Will Change How You Think About Using New Relic Data to find more than a dozen examples of useful queries, including creating percentile-based queries on transaction data, so you don’t get swayed by misleading averages. Where can I get more information? For more information on NRQL alerts, refer to the create alert conditions for NRQL queries section of the New Relic documentation. And lots of great information on how to write NRQL queries can be found in the NRQL syntax, components, functions section of our documentation. Or, now that NRQL alerts is generally available, just go ahead and give it a try yourself!   By Chhavi Nijhawan Chhavi Nijhawan is a senior product marketing manager at New Relic. She is passionate about new technologies. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.44299,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> Alerts Goes GA: Easily Convert <em>NRQL</em> Queries to Alert Conditions",
        "sections": "What are <em>NRQL</em> Alerts?",
        "body": " been developing since 2014 specifically for analytics. Our customers use <em>NRQL</em> extensively to write custom queries and analyze the <em>data</em> (both metric and events <em>data</em>) they send to New Relic. Along the way we’ve received many requests to add alerting and notifications using <em>data</em> from <em>NRQL</em> queries"
      },
      "id": "60762e4e64441fd0499d8569"
    },
    {
      "sections": [
        "Introduction to NRQL, New Relic's query language",
        "What is NRQL?",
        "Where can you use NRQL?",
        "What data can you query with NRQL?",
        "Tip",
        "Start using NRQL",
        "Important",
        "NRQL query examples",
        "Basic NRQL query of Browser data",
        "Attribute name with a space in it",
        "Querying multiple data sources",
        "Query returning multiple columns",
        "NRQL syntax"
      ],
      "title": "Introduction to NRQL, New Relic's query language",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "51e361ee5ec2a2379486d6686677e0383eb49163",
      "image": "https://docs.newrelic.com/static/04052353f8dbe132cd384d7472778b3f/c1b63/new-relic-view-chart-nrql-query_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language/",
      "published_at": "2021-04-16T10:30:55Z",
      "updated_at": "2021-03-11T03:19:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "One way to query your New Relic data is with the New Relic Query Language (NRQL). This resource explains what NRQL is, when and how you can use it, and basic syntax rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see NRQL syntax, clauses, and functions. What is NRQL? NRQL is New Relic's SQL-like query language. You can use NRQL to retrieve detailed New Relic data and get insight into your applications, hosts, and business-important activity. Reasons to use NRQL include: To answer a question for the purpose of troubleshooting or business analysis To create a new chart To make API queries of New Relic data (for example, using our NerdGraph API) NRQL is used behind the scenes to generate some New Relic charts: Some New Relic charts are built using NRQL. One way to start using NRQL is to view a chart's query and then edit it to make your own custom chart. Where can you use NRQL? You can use NRQL in these places: New Relic One query builder: Advanced mode is a NRQL query interface Basic mode provides a simplified query experience that doesn't require knowledge of NRQL but that uses NRQL to generate results New Relic Insights NerdGraph: our GraphQL-format API, which includes options for making NRQL queries one.newrelic.com > Query your data: You can run a NRQL query in both New Relic One and New Relic Insights. This NRQL query shows a count of distributed tracing spans faceted by their entity names. NRQL is one of several ways to query New Relic data. For more on all query options, see Query your data. What data can you query with NRQL? NRQL allows you to query these New Relic data types: Event data from all New Relic products, including: APM events, like Transaction Browser monitoring events, like PageView Mobile monitoring events, like Mobile Infrastructure events, like ProcessSample Synthetics events, like SyntheticCheck Custom events, like those reported by the Event API Metric timeslice data (metrics reported by New Relic APM, Browser, and Mobile) The Metric data type (metrics reported by the Metric API and data sources that use that API) The Span data type (distributed tracing data) The Log data type (data from New Relic Logs) Tip Some data, like relationships between monitored entities, is not available via NRQL but is available using our NerdGraph API. Start using NRQL One way to start using NRQL and to understand what data you have available is to go to a NRQL interface (for example, the New Relic One query builder), type FROM, and press space. The interface will suggest available types of data: To see the attributes available for a specific data type, type FROM DATA_TYPE SELECT and press space. The interface will suggest available attributes. For example: To see the complete JSON associated with a data type, including all of its attributes, use the keyset() attribute. For example: FROM Transaction SELECT keyset() Copy NRQL is used behind the scenes to build some New Relic charts and dashboards. One way to learn NRQL is to find one of these NRQL-generated charts and start playing with the NRQL to create new, customized queries and charts: Charts built with NRQL will have View query as an option. You can then edit and customize that query to see how your changes affect the resulting visualization. Important To explore your data without having to use NRQL, use the basic mode of New Relic One query builder. NRQL query examples Here's an example NRQL query of Transaction data, which is reported by New Relic APM. FROM Transaction SELECT average(duration) FACET appName TIMESERIES auto Copy This would generate a chart that looks like: Here are some more query examples: Basic NRQL query of Browser data Here's a NRQL query of PageView data, which is reported by New Relic Browser. SELECT uniqueCount(user) FROM PageView WHERE userAgentOS = 'Mac' FACET countryCode SINCE 1 day ago LIMIT 20 Copy Attribute name with a space in it If a custom attribute name has a space in it, use backticks around the attribute name: SELECT count(*) FROM Transaction FACET `Logged-in user` Copy Querying multiple data sources To return data from two data sources, separate their data types with a comma. For example, this query returns a count of all APM transactions and Browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Query returning multiple columns To return multiple columns from a dataset, separate the aggregator arguments with a comma: SELECT function(attribute), function(attribute) ... FROM ... Copy This query returns the minimum, average, and maximum duration for New Relic Browser PageView events over the last week: SELECT min(duration), max(duration), average(duration) FROM PageView SINCE 1 week ago Copy See more NRQL query examples. NRQL syntax The syntax of a NRQL query is similar to standard SQL queries. Here is a breakdown of the structure of a NRQL query: SELECT function(attribute) [AS 'label'][, ...] FROM data type [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Copy Basic rules include: NRQL condition Details Required values The SELECT statement and FROM clause are required. All other clauses are optional. You can start your query with either SELECT or FROM. Query string size The query string must be less than 4 KB. Case sensitivity The data type names and attribute names are case sensitive. NRQL clauses and functions are not case sensitive. Syntax for strings NRQL uses single quotes to designate strings. For example: ... where traceId = '030a573f0df02c57' Copy Attribute names with spaces Use backticks `` to quote a custom attribute name that has a space in it. For example: ... FACET `Logged-in user` Copy Data type coercion Insights does not support data type \"coercion.\" For more information, see Data type conversion. Use of math functions Basic and advanced math functions are supported in the SELECT statement. JOIN functions NRQL does not have the equivalent of the SQL JOIN function, but you can simulate a JOIN with custom attributes. Read more about NRQL syntax and functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.889435,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>NRQL</em>, New Relic&#x27;s query language",
        "sections": "What <em>data</em> can you query with <em>NRQL</em>?",
        "tags": "Query your <em>data</em>",
        "body": "One way to query your New Relic <em>data</em> is with the New Relic Query Language (<em>NRQL</em>). This resource explains what <em>NRQL</em> is, when and how you can use it, and basic <em>syntax</em> rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see <em>NRQL</em> <em>syntax</em>"
      },
      "id": "60445a0e196a67cb09960f6e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/whats-new/2020/10/build-high-resolution-charts-using-sliding-windows/",
      "sections": [
        "Build high-resolution charts using sliding windows"
      ],
      "published_at": "2021-04-16T19:08:25Z",
      "title": "Build high-resolution charts using sliding windows",
      "updated_at": "2021-03-11T00:17:31Z",
      "type": "docs",
      "external_id": "e50c25be8e8f4cc4b1ee455ba7443bcdd4c33178",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "Sliding windows enable you to increase chart resolution without losing the intent of the result by reducing the timeseries aggregate size, as shown below. Highly variable results can also be smoothed out by increasing the aggregate size, without losing resolution. Sliding windows generate charts using the SLIDE BY clause in conjunction with the TIMESERIES clause. With sliding windows, data is gathered in time \"windows\" that overlap with each other. The first duration associated with TIMESERIES defines the size of the aggregation windows, which defines how many results are captured per window. The second duration associated with SLIDE BY, defines the step size between each aggregation, which then defines the charts resolution. NRQL syntax follows the following format: SELECT ... TIMESERIES integer1 units SLIDE BY integer2 units PromQL-style queries are translated into NRQL sliding window queries. For example, rate(request_count[5m]) over the past 60 minutes with a 1-minute window overlap would be translated into the NRQL query below: SELECT rate(sum(request_count), 1 SECONDS) FROM Metric SINCE 3600 SECONDS AGO UNTIL NOW FACET dimensions() LIMIT 100 TIMESERIES 300000 SLIDE BY 60000",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.7811,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". The second duration associated with SLIDE BY, defines the step size between each aggregation, which then defines the charts resolution. <em>NRQL</em> <em>syntax</em> follows the following format: SELECT ... TIMESERIES integer1 units SLIDE BY integer2 units PromQL-style queries are translated into <em>NRQL</em> sliding window"
      },
      "id": "604cb72964441fdbdc93746c"
    }
  ],
  "/automate-workflows/diagnose-problems/error-alerts": [
    {
      "sections": [
        "データエクスプローラーの概要",
        "ヒント",
        "重要な理由",
        "データのクエリ",
        "データエクスプローラーを使用する",
        "イベントを詳しく調べる",
        "メトリックスを詳しく調べる",
        "重要",
        "調査を可視化し絞り込む",
        "クエリエリア",
        "NRQLクエリ表示",
        "チャートエリア",
        "共有してエクスポート",
        "使用事例",
        "新規データを確認",
        "データを検証",
        "データの問題のトラブルシューティング",
        "その他のヘルプ"
      ],
      "title": "データエクスプローラーの概要",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "94545f74e5fd5ab0b18f47342f7a8f2a2fa82558",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-16T15:16:11Z",
      "updated_at": "2021-04-12T03:13:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データエクスプローラーを使用すれば、NRQLの知識がなくても、すべてのデータを視覚的に操作できます。データエクスプローラーを使用してデータにアクセスしクエリやカスタマイズ、視覚化を行い、サービスとサービスをつなぎ、一貫したキュレート済みの体験を実現します。 ヒント データエクスプローラー、およびその他のオブザーバビリティ プラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 システムの状態を調査しますか？リソースの計画を作成し、インシデントを特定しそれに対応し、動作不良のトラブルシューティングを行う必要がありますか？データエクスプローラーにより、NRQLを使用したりクエリを構築せずに、視覚的なメニューを通じて、探しているデータを簡単に特定、取得し、視覚化できます。 データエクスプローラーを使用して、次のことを行えます。 イベントやメトリックスデータに、迅速で直感的な方法でアクセスする。 視覚化し簡単に実行できるようにして、データのディメンションを詳しく調べる。 さまざまな観点からデータを把握する：生データや、進歩や配信などについての知見を提供するさまざまな視覚化。 フィルターによりデータを掘り下げる。 1回のクリックで検索をダッシュボードに追加する。 NRQLのしくみについて理解する: データエクスプローラーは、利用可能なデータを検索している間にクエリがどのように構築されるかを示します。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 データのクエリ データエクスプローラーにアクセスするには、one.newrelic.comに移動し ページの上部にあるデータをクエリアイコンをクリックします。 データのブラウズドロップダウンで、イベントまたはメトリクスを選択します。 データエクスプローラーは、New Relicにあるすべてのデータを詳しく調べるためのポータルです。データエクスプローラーUIにあるイベントやメトリックスを詳しく調べたり、LogsやTracesアプリを選択して詳しく調べることができます。また、タブをクリックして、いつでもクエリビルダーにアクセスすることもできます。 データエクスプローラーを使用する データエクスプローラーは、上部にある範囲絞り込みセクション（a）、左側のデータブラウジングエリア（b）、ワークスペース（c）で構成されます。 データエクスプローラーを使用するには： 調べる範囲を定義する：ブラウズするアカウントとデータタイプ（メトリックまたはイベント）を選択します。 タイムピッカーを使用して時間範囲を選択します。 左側のブロックを使用して、イベントかメトリックスのいずれかについて使用可能なデータをブラウズし、検索を作成します。1ブロックにつき1つの要素しか選択できません。ブロックは検索可能です。 イベントを詳しく調べる イベントタイプ 選択したアカウントで使用できるすべてのイベントを表示します。 デフォルトでは、イベントは名前で並び替えられます。 プロット 以前選択したイベントのすべての数字属性を表示します。 リストの最初の項目はcount( * )で、これは属性ではありません。選択したイベントの数を計算します。 デフォルトでは、属性は名前で並び替えられます。 プロットする関数を選択します。デフォルトでは、各属性は関数Averageに設定されます。 ディメンション 以前選択したイベントとプロットのすべてのディメンションを表示します。 ディメンションは、イベントについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 メトリックスを詳しく調べる APM 時間区切りデータを調べるには、AppID、AppName、またはEntityGuidをステップとして選択します（またはそれらのステップでグループ化します）。それ以外の場合は、すべてのエンティティの集計データを取得します。 メトリック 選択したアカウントで使用できるすべてのメトリックスを表示します。 デフォルトでは、メトリックスは名前で並べ替えられます。 ディメンション 以前選択したメトリックのすべてのディメンションを表示します。 ディメンションは、メトリックについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 重要 ユニットの表示には、メトリックシステム（メトリックSIプレフィックスを含む）が使用されています。 調査を可視化し絞り込む 調査の結果は、右側のワーキングスペースに表示されます。 調査を絞り込むか、チャートを共有する ワーキングスペースには、次のものが表示されます。 クエリエリア クエリエリアでは、クエリを異なる構成要素に分解します。ここで、NRQLクエリとして調査の結果を簡単に読み、プロットしている正確なデータをチェックできます。 NRQLに習熟していない場合、このエリアをチェックしクエリの作成方法について学習します。 クエリの別の部分は次のとおりです。 [ イベントのみ]FROM: 最初のブロックで選択したイベント。 SELECT: 選択したプロットまたはメトリック。この入力では、1つの値と1つの関数のみをプロットします。 GROUP BY: FACET句を表し、選択したディメンションごとにデータをグループ化します。 LIMIT: 表示する値の量を入力します。 WHERE: このフィールドを使用して、結果にさらにフィルターを適用します。この入力では、n値をプロットします。 各項目は、xをクリックしてクエリから削除できます。 NRQLクエリ表示 上記のフィールドと、タイムピッカーで選択した時間範囲で構成される、完全なクエリを表示できます。 ヒント より詳細な検索を行う、またはチャートをカスタマイズする必要がある場合データエクスプローラーから、クエリビルダーにアクセスしてクエリを編集できます。 チャートエリア デフォルトでは、データは線チャートで表示されます。チャートピッカーを使用して、面グラフ、円グラフ、およびバーチャートに簡単に切り替えることができます。結果の生データをテーブルまたはJSON形式として表示することもできます。 ディメンションを選択している場合、チャートは異なるファセットで更新されます。チャートの下に、ファセットのリストとそれぞれの値があるファセットの表が表示されます。 ファセットテーブルを使用して、データをドリルダウンします。クリックしたファセットはフィルターとして適用されます。表は表示されたままなので、別のファセットを簡単に選択して調査を続けることができます。 共有してエクスポート 右上にあるオプションメニューを使用して、チャートを画像として取得、またはリンクとして共有、ダッシュボードに追加できます。 また、URLをコピーし、その他のNew Relicユーザーと調査全体を共有することもできます。 使用事例 次の例で、データエクスプローラーをいつどのように使用するかについて学習してください。 新規データを確認 新規インストゥルメンテーションに接続したばかりで、新規データを利用できるかどうか確認したいと思っています。 アカウントとイベント、または新規データを生成しているメトリックを選択します。 データエクスプローラーで別のツールを使用して、利用できるようになった新規データを使ってみる：そのイベントまたはメトリックの生データを表として見る、またはリストとする、またはクリックしてチャートとしてプロットされることを確認します。 イベントやメトリックを選択した後、ディメンションでデータの形状を確認します。濃度を使用して、あらゆるデータの異なる視点を確認できます。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 データを検証 カスタムイベント/メトリックを変更したので、この変更が正常に行われたかどうかをチェックする必要がある。 データエクスプローラータブで、変更したアカウントとデータタイプ、イベント/メトリックを選択します。 エンティティがデータをレポートしていることと、すべての属性がプロットされていることを確認します。 変更した属性を検索し、更新が正常に行われたことをチェックします。 データの問題のトラブルシューティング アラートやダッシュボードからのイベント/メトリックで何か問題があることが分かっている。イベント/メトリック属性の動作について、根本原因を知る必要がある。 データエクスプローラーで、メニューを使用して、想定どおりに動作していないイベントやメトリックを選択し、データエクスプローラーでそのチャートをプロットします。 そこから、そのデータのディメンションを掘り下げて、関連する属性によりフィルターを適用できます。 また、次のような異なる観点からそのデータを把握することもできます：分布や値の順位、経時進化。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 59.27971,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "605343b4196a6754132d166e"
    },
    {
      "sections": [
        "ダッシュボード入門",
        "ヒント",
        "重要な理由",
        "New Relic全体にまたがるダッシュボードを表示する",
        "ダッシュボードの使用を開始",
        "ダッシュボードの作成",
        "ダッシュボードのクローンを作成",
        "ダッシュボードの削除",
        "ダッシュボードにお気に入りの印を付ける",
        "ダッシュボードの検索と並び替え",
        "ダッシュボードのアクセス許可",
        "タグを使用してダッシュボードを整理する",
        "主要な視覚化ツール",
        "一貫したチャートの色",
        "関連するニードル",
        "データスクラバー",
        "拡大ブラシ",
        "カスタムの可視化",
        "その他のヘルプ"
      ],
      "title": "ダッシュボード入門",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "36da9a58bf388d15522c769ef3ad709550eee043",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-04-17T03:24:45Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データを道路の複雑なシステムとして捉える：道路の標識や信号に従い運転し、収集する情報の意味を迅速に把握し実行する必要があります。New Relic Oneダッシュボードは、New Relicプラットフォームのあらゆる場所から、表示したい特定のデータを収集して、お望みの方法でチャートを作成します。 ヒント ダッシュボードとその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 New Relic Oneダッシュボードを使用して、収集するデータをカスタマイズして理解できます。カスタマイズされたユーザーフレンドリーなチャートでデータを詳しく調べ、つながりのあるソースの相関性を導き、システムとアプリケーションの状態を素早く理解することで、より迅速かつ効率的なトラブルシューティングを行います。 ダッシュボードを利用して、次のことを行います： 一貫したUIによるカスタムの高密のインタラクティブな可視化により、知見を深める。 プラットフォームのどこからでも、すべてのイベントと属性のチャートを作成する。詳細については、デフォルトのデータ収集に関する弊社のドキュメンテーションを参照してください。 カスタム属性の追加またはカスタムイベントタイプの送信を大半のイベントに対して行います。これにより、貴社のビジネスへの理解力を高め、ページビュー数やホストトランザクションなど、顧客とプラットフォームのインタラクションに関する具体的なポイントを確認できます。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度な補足説明機能とズームイン機能でデータの探索とコンテキスト化を行い、貴社システムのリアルタイムのアクティビティをモニターできます。 ダッシュボードで属性とメトリックスを検索します。 APIを使用してダッシュボードにデータを送信します。 New Relic全体にまたがるダッシュボードを表示する New Relic Oneのダッシュボードには、元々のNew Relicプラットフォームとの完全な下位互換性が備わっているため、Insightsで作成した全てのダッシュボードがダッシュボードで自動的に利用できるようになります。つまり、新たにダッシュボードを追加すると、Insightsでも作成されます。追加の設定は必要ありません。New Relic Oneでは、クロスアカウント検索を利用することで、組織全体にまたがるダッシュボードを表示できます。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 ダッシュボードの使用を開始 ダッシュボードにアクセスするには、one.newrelic.comに移動し、ナビゲーションメニューの上部にあるダッシュボードをクリックします。 ダッシュボードの索引で、New Relicアカウントに関連するすべてのダッシュボードとデータアプリを表示できます。これには、New Relic Oneプラットフォーム内で作成したダッシュボードと、Insightsで構築したダッシュボードが含まれます。 上部のバーから、エンティティエクスプローラーや、APMやBrowser、Infrastructure monitoring、Logs、インテリジェンスの応用などすべてのNew Relic機能に迅速にアクセスします。また、プラットフォーム全体で使用できるデータの検索やクエリなどのNew Relic Oneの中心的な機能も使用できます。 各ダッシュボードで、索引に次の情報が表示されます： 星で表される、お気に入りのステータス 名前：ダッシュボードの名前 アカウント：ダッシュボードが属するアカウント 作成者：ダッシュボードを作成したユーザー 最終編集日時：直近のダッシュボード変更の日時 作成日時：ダッシュボードの作成日時： 次のアクションを行えます： ダッシュボードの作成 ダッシュボードの索引の右上隅にある+ダッシュボードを作成ボタンを選択して、ダッシュボードからNew Relic Oneでダッシュボードを作成できます。 ダッシュボードに名前を付ける名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前（例として、サービスやアプリケーション）を付けることを推奨します。 ダッシュボードが属するアカウントを選択します。このアクションは変更できないため、慎重に選択してください。 作成を押して続けるか、キャンセルを押して索引に戻ります。 ヒント デフォルトでは、ダッシュボードはパブリック - 読み取りと書き込み許可で作成されます。ダッシュボードにアクセスした後、設定メニューから編集できます。 または、次のように新規のダッシュボードを作成することもできます： 既存のダッシュボードのクローンを作成して。 チャートから：チャートを任意のダッシュボードから新規または既存のダッシュボードにコピーします。 データエクスプローラーまたはクエリビルダーから: クエリ機能から作成したチャートを、新規または既存のダッシュボードに追加します。 エンティティエクスプローラーから：エンティティマネージャからダッシュボードにカスタムで表示を行います。 複数のページでダッシュボードを整理するには、ダッシュボードにページを追加します。 ダッシュボードのクローンを作成 索引のダッシュボード行の上にカーソルを移動すると表示されるダッシュボードのクローンを作成ボタンをクリックして、ダッシュボードのクローンを作成します。許可のレベルにかかわらず、あらゆるダッシュボードのクローンを作成できます。 ダッシュボードは自動的にコピーされ、クローンが索引に追加されます。画面にポップアップ表示されるメッセージをクリックして、新規ダッシュボードにアクセスします。 クローン版のダッシュボードには、元のダッシュボードの名前の後に「copy」が付けられます。たとえば、this is my dashboardという名前のダッシュボードのクローンを作成すると、クローンはthis is my dashboard copyとして作成されます。クローンの許可は、パブリック - 読み取りと書き込みとなります。 ダッシュボードの名前や許可などのその他のプロパティは、いつでも編集できます。 ヒント 索引には、並べ替えに従いダッシュボードが表示されます。クローン版のダッシュボードを迅速に検索するには、作成日でダッシュボードを並び替えます。新規のダッシュボードが先頭に表示されます。 ダッシュボードの削除 ダッシュボードを削除するには、削除ボタンが表示されるまで、索引のダッシュボード行の上にカーソルを移動します。自身で作成した場合、または許可がパブリック - 読み取りと書き込みの場合しか、ダッシュボードは削除できません。詳しくは、許可についての情報を参照してください。 ダッシュボードの設定パネルから、ダッシュボードを削除することもできます。 ダッシュボードにお気に入りの印を付ける ダッシュボードの隣にある星のアイコンをクリックすると、お気に入りがオンとオフで切り替わります。ダッシュボードをお気に入りにすると、リストの先頭にあるその他のお気に入りのダッシュボードと同じグループに入り、New Relic Oneのホームページで表示されます。 お気に入りからダッシュボードを削除するには、星のアイコンをもう一度選択します。 New Relic Oneは、Insightsからお気に入りのダッシュボードを取得しません。InsightsからNew Relic Oneへの移行の方法をご覧ください。 ダッシュボードの検索と並び替え 索引の上にある検索ボックスを使用して、ダッシュボード名と作成者別に、ダッシュボードの検索を行えます。 索引でダッシュボードの並べ替えも行えます。デフォルトでは、直近に編集したダッシュボードが、お気に入りとお気に入り以外のセクションの両方で、索引の先頭に表示されます。この順序を変更するには、索引の任意の列で両方のセクションを並べ替えると、直近の並べ替えの結果が、次回New Relic Oneにアクセスした際に表示されます。 ダッシュボードのアクセス許可 ダッシュボードには、次の3種類の権限があります。 パブリック - 読み取りと書き込み: すべてのユーザーが、ダッシュボードに対し完全な権利を有します。 パブリック - 読み取りのみ: すべてのユーザーはダッシュボードを表示できますが、ダッシュボードで作業を行う完全な権利を有するのはあなただけです。他のユーザーはダッシュボードにアクセスし、クローンを作成できますが、編集や削除はできません。 プライベート: ダッシュボードを表示できるのはあなただけです。 ダッシュボードを作成ボタンを使用して、または別のダッシュボードのクローンを作成してダッシュボードを作成すると、デフォルトでパブリック - 読み取りと書き込みの権利が付与されます。新規ダッシュボードにアクセスして、この設定を変更します。 タグを使用してダッシュボードを整理する タグ作成APIであるNerdGraphを使用して、タグを追加できます。 タグ別にダッシュボードをフィルターすることもできます。これによってユーザーアカウントやロケーションなどを特定できます。タグフィルターをクリックして使用可能なタグを表示すると、リストから1つ以上のタグを簡単に選択して、索引でダッシュボードを絞り込むことができます。 主要な視覚化ツール ダッシュボードには、詳細なデータ検索や迅速なトラブルシューティングのための、分かりやすい視覚化機能とツールが備わっています。 一貫したチャートの色 データやファセットをすぐに表示し関連付け、ダッシュボードで1つ以上のチャートに適用し、すべてのチャートでファセットの色を一貫したものにできます。 関連するニードル マウスをチャートの上に移動すると、関連するニードルが、同時にダッシュボードのすべてのチャートやデータポイントに重なって表示されます。ツールチップには、線チャートの最大値や最小値など、選択したファセットからの関連データポイントが記載されています。また、パイチャートで選択した属性をハイライト表示します。 データスクラバー チャートスクラバーを使用して、チャートが密集しており、ファセット間の距離が非常に近い場合に、チャートでデータポイントやファセットを選択できます。 マウスをニードルの側に移動し、隣にあるファセットをスムーズに選択し、関連するデータポイントを表示します。また、UIに表示される1つ以上の属性の選択を解除して、投入データの多いチャートのデータ投入を減らすこともできます。 拡大ブラシ ドラッグしてチャート上の時間セグメントを選択すると、ダッシュボードのすべてのチャートでその期間が自動的に拡大されます。 タイムピッカーは、ダッシュボードに表示される新規の期間を反映します。いつでもデフォルトやその他の時間設定に戻ることができます。 カスタムの可視化 ダッシュボードにカスタムの可視化を行うこともできます。これにより、データソースからの情報を含めることができるようになります。カスタムの可視化の詳細については、ダッシュボードのカスタムの可視化とダッシュボードにカスタムの可視化を追加をご覧ください。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 48.163956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053433228ccbcdc10c2fd60"
    },
    {
      "sections": [
        "ダッシュボードの管理",
        "ダッシュボードのカスタマイズ",
        "ヒント",
        "ダッシュボードを編集する",
        "設定メニュー",
        "TVモード",
        "ダークモード",
        "ダッシュボードをエクスポートする",
        "新規コンテンツをダッシュボードに追加する",
        "マークダウンエディタを使用して、カスタムコンテンツを追加する。",
        "ページのあるダッシュボードを整理する",
        "ページをダッシュボードに追加し編集する",
        "チャートとマークダウンコンテンツを管理する",
        "重要",
        "チャートにフィルターを適用して絞り込む",
        "チャート凡例を使用してフィルターを適用する",
        "ファセットを使用してダッシュボードにフィルターを適用する",
        "タイムピッカーを使用して時間設定を変更する",
        "データをエクスポートし共有する",
        "その他のヘルプ"
      ],
      "title": "ダッシュボードの管理",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d5e5a7705eda167da4867960df29bd237535a8e5",
      "image": "https://docs.newrelic.com/static/129e7a553450c47847a969c79a2f7f89/c1b63/Dashboards_conf.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-04-17T02:37:22Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneダッシュボードにアクセスし、チャートメニューから直接チャートを作成または管理し、ダッシュボードのレイアウトをカスタマイズし、表示モードを調整し、データのエクスポートを行います。 ダッシュボードをカスタマイズし、チャートを構築したら、データを詳しく知るための高度な視覚化機能とツールを使用して、データを関連付け分析します。 ダッシュボードのカスタマイズ ダッシュボードは非常に柔軟な設定となっています。ダッシュボードのレイアウトをカスタマイズし、チャートのサイズを調整してデータの表示方法を最適化できます。 ヒント をクリックして、メタデータを表示しタグを管理モーダルにアクセスします。ここで、ダッシュボードのガイドやアカウントID、アプリIDを表示し、ダッシュボードに追加されたすべてのタグを管理できます。 ダッシュボードには、次の機能が含まれます： ダッシュボードを編集する 編集 ボタンを使用して次のことを行う: ダッシュボードの名前を変更する。名前は検索可能なため、意味のある名前を付けることを推奨します。 ウィジェットを追加ボタンをクリックして、新規コンテンツを作成する。クエリビルダーを使用して新規チャートを追加する、またはマークダウンエディタを使用してテキストや画像、リンクを追加する。 新規ページを追加する。ページを使用して、ダッシュボードをより整理できます。 チャートのサイズと範囲を変更する。チャートを移動し、ダッシュボードのどこにも置くことができるため、お好みに合わせてレイアウトを設定します：関連性の高いチャートを上部に置いたり、あまり使用しないチャートを角に配置します。最大で12列のチャートを設定できます。 設定メニュー 右上にある設定メニューを使用します。 ダッシュボードの名前を変更する。名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前を付けることを推奨します。 ダッシュボードの許可を変更する。 設定メニューで、ダッシュボードの作成時期とダッシュボードに属するアカウントも表示できます。この値は変更できません。 TVモード テレビ画面での表示向けにダッシュボードを最適化する、全画面のTVモードを有効にできます。 TVモードを有効にするには、次の2つの方法があります。 New Relic Oneでダッシュボードを表示している際に、右上の アイコンを選択します。 このパラメーターをダッシュボードのページのURLに追加します：&platform[tvMode]=true TVモードを設定するには、ダッシュボードから アイコンを選択します。オプションに含まれるもの： ダッシュボード名が表示されます。 ダッシュボード名をオフにすると、画面上でダッシュボードのチャートのスペースが増えます。 ページの切り替え。 複数のページのあるダッシュボードでは、これによりページが自動的に切り替わります。 ダークモード 高コントラストモードを、ダッシュボードで使用できます。 アイコンを、右上のメニューバーから選択します。 ダッシュボードをエクスポートする アイコンをクリックして、PDFファイルとしてダッシュボードをエクスポートできます。 ヒント いつでも検索機能を使用して、New Relic One全体でデータを検索できます。 新規コンテンツをダッシュボードに追加する 複数の方法で、ダッシュボードに新規コンテンツを追加できます： データエクスプローラーおよびクエリビルダー機能から。 + ダッシュボードに追加ボタン（メインのダッシュボードのページから、または編集モードでアクセス可能）を使用して、クエリビルダーにアクセスするか、マークダウンエディタを使用してコンテンツ（テキストやリンク、画像など）を追加する。 ダッシュボードから既存のチャートをコピーする。 マークダウンエディタを使用して、カスタムコンテンツを追加する。 マークダウンエディタには、コンテンツを入力するマークダウンペインや、表示するプレビューペインが含まれます。マークダウン構文オプションの詳細については、Commonmarkのウェブサイトをご覧ください。 マークダウンウィジェットの楕円 アイコンをクリックし、編集をクリックして、既存のコンテンツを編集することもできます。 ページのあるダッシュボードを整理する 複数のページを使用して、さまざまな表示でダッシュボードを整理できます。ページをそのダッシュボードに追加すると、ダッシュボードUIの上部にあるタブを使用して、そのページにアクセスできます。 one.newrelic.com > Dashboards: ダッシュボードの上部にあるタブで表示された、複数のページのあるNew Relic Oneのダッシュボードの例は次のとおりです。ページをダッシュボードに追加し、既存のページをコピーし、ページタブを新たな位置にドラッグしてドロップできます。 この機能を使用して、関連するダッシュボード表示をグループ化できます。これは、特定のプロジェクトやチーム、主題に関連する多くのデータとチャートを集計する際に有用です。 たとえば、モバイルアプリチームは、国ごとにアプリのパフォーマンスに重点を置いたダッシュボードを構築できます。最初のダッシュボードのページを、すべての国のパフォーマンスの概要とし、その他のページで特定の国を取り上げることができます。 当社では、ダッシュボードをつなぐその他の機能を提供しています。 マークダウンテキストを含むウィジェットを作成して、特定のUIページやダッシュボードへのダイレクトリンクを追加します。 ファセットによるフィルタリングを使用して、自動的にその他のダッシュボードにリンクしフィルタリングを行うリンクを作成します。 ダッシュボード検索を使用して、似た名前のダッシュボードを検索します。この機能を活用して、チームやプロジェクトに固有の語句をダッシュボード名に追加できます。 New Relic Insightsでは、この機能はデータアプリと呼ばれていました。InsightsからNew Relic Oneの切り替えの詳細については、移行ガイドをご覧ください。 ページをダッシュボードに追加し編集する ページをダッシュボードに追加、またはページを編集するには： 新規または既存のダッシュボードで、 アイコンを選択して編集モードで入力します。 新規ページを追加する： ページを追加を選択して空白のページを追加します。 ダッシュボード名の隣にあるドロップダウンをクリックし、複製を選択して、既存のページのクローンを作成します。 編集モードの間、新規ページにウィジェットを追加し、ページタブを新たな場所にドラッグしてドロップしたり、その他のダッシュボード編集タスクを行えます。 終了したら、編集を完了を選択します。 チャートとマークダウンコンテンツを管理する マークダウン要素から、右上隅にあるアクセスメニューにアクセスし、編集または削除を行います。チャートから、右上角のチャートアクションメニューにアクセスし、次のことを行います。 チャートを全画面に拡張する。 画像として、またはリンクを付けてチャートを共有する。 チャートをダッシュボードにコピーする。 クエリビルダーにアクセスし、チャートに関連したクエリを表示または編集する。 チャートを削除する。 重要 ダッシュボードに対する許可が読み取り専用の場合、チャートのクエリは編集できません。 詳細については、チャートの使い方をご覧ください。 チャートにフィルターを適用して絞り込む フィルタリング機能を使用して、ディスプレイで情報を絞り込むことができます。この機能は、クエリ条件を視覚的に表すものです。 フィルターバーを使用して、表示する値や属性を選択し、チャートから残りの要素を削除する。 高度なフィルターバーを開いてboolean演算子（=、!=、CONTAINS、EXCLUDESなど）にアクセスし、データのフィルタリングのための複雑で組み合わされた条件を追加する。 フィルターを適用後、ダッシュボードには、選択した要素に関連するデータのみが表示されます。小さなカウンターは、1回にいくつのフィルターが適用されているかを表します。 デフォルト表示に戻るには、フィルターの横にある小さなXをクリックして削除します。 チャート凡例を使用してフィルターを適用する 凡例のついたチャートで凡例をクリックして、その系列のみを表示し、チャートから残りのものを削除します。これにより、分析するデータを隔離できます。 反対の動作では、CMD（Macの場合）またはCTRL（Windowsの場合）を使用します。選択した系列を削除し、残りを保存します。 ファセットを使用してダッシュボードにフィルターを適用する チャートのNRQLクエリにFACET句が含まれる場合、ファセットのついた属性を使用して、現在のダッシュボードまたは別の関連するダッシュボードにフィルターを適用できます。詳細については、ファセットによりフィルターを適用するをご覧ください。 タイムピッカーを使用して時間設定を変更する デフォルトでは、ダッシュボードの各チャートには、クエリビルダーで作成時に指定された期間のデータが表示されますが、タイムピッカーを使用して表示されるデータの時間範囲を変更し、すべてのチャートに同じ範囲を設定できます。これは、データを絞り込み特定の期間に何が発生したかを観察する必要がある場合、インシデントのトラブルシューティングの間に特に有用です。 更新率は、表示中の期間の長さにより異なります。将来と例については、チャートの更新間隔をご覧ください。 時間範囲を変更するには： ドロップダウンメニューから、利用可能なオプション（直近30分から直近7日まで）を1つ選択します。 カスタムメニューを使用して、特定の開始および終了タイムスタンプで時間範囲をカスタマイズします。 重要 ダッシュボードでは、Insightsとは異なり、タイムゾーンはお使いのノートパソコンの時間とは関連していません。タイムピッカーのカスタムメニューから簡単にアクセスできるユーザー設定で、使用するタイムゾーンを設定できます。 データをエクスポートし共有する 社内外でダッシュボードとチャートデータをエクスポートし共有することは、非常に簡単です。 右上のメニューバーにあるPDFとしてダッシュボードをエクスポートボタンを使用して、PDFファイルとしてダッシュボードをエクスポートできます。 チャートをPNG画像またはリンクとして共有することもできます。チャートメニューに移動し、画像として取得またはチャートリンクを取得オプションのいずれかを選択します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 48.163956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053437b196a67a8322d1626"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Tip",
        "Why it matters",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "8f390d6aa6f57d215b3c23f8cf08c02ef310bddc",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-17T02:08:27Z",
      "updated_at": "2021-03-16T11:03:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Tip To use the data explorer and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces apps to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From data explorer you can access query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 44.379883,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the data <em>explorer</em>",
        "sections": "Introduction to the data <em>explorer</em>",
        "tags": "<em>Explore</em> and query data",
        "body": " icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to <em>explore</em> all the data you have in New Relic. You can <em>explore</em> events and metrics on the data explorer UI, or select the Logs and Traces apps to <em>explore</em> those. You can also access the query builder any time"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    },
    {
      "sections": [
        "Data explorer: Query and chart event data",
        "Important",
        "Events vs metrics",
        "UI components",
        "Data samples",
        "Caution"
      ],
      "title": "Data explorer: Query and chart event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Use Insights UI",
        "Explore data"
      ],
      "external_id": "72a23b59b41a3cb521c184c24603d50c28cffdb1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/explore-data/data-explorer-query-chart-event-data/",
      "published_at": "2021-04-16T03:05:44Z",
      "updated_at": "2021-03-30T08:43:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you explore the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs metrics In New Relic Insights, the Data explorer page has two tabs: Events: In the context of the Insights UI, this refers to any data that can be queried via NRQL. This includes all our major data types, including events and the Metric, Log, and Span data types. Metrics: In the context of the Insights UI, this refers to metric timeslice data. (Note that metric timeslice data is available for querying with NRQL in New Relic One.) For an improved querying and charting experience, we recommend using New Relic One chart builder and dashboards. UI components Use the Events data explorer to view and explore the data available to you. The UI includes: A dropdown that lets you select a data type, like PageView or Transaction. A time-based chart for that data. A sample of that data type, showing its attached attributes, and the ability to see other samples. Ability to search by group by and search for specific attributes. Data samples The most recent sample for the chosen data type is listed at the bottom of the page. Default attributes are underlined. To see more samples, select See more samples. You may need to scroll left and right to see the full table of data. Caution The amount of data stored for a given event type can run into the hundreds of thousands, or even millions, of records. This report only shows a small sample. Use this UI to review the structure of the data, not the contents of a specific record. For example, you can use it to make sure an attribute is populating properly.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 39.58773,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data <em>explorer</em>: Query and chart event data",
        "sections": "Data <em>explorer</em>: Query and chart event data",
        "tags": "<em>Explore</em> data",
        "body": " our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you <em>explore</em> the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs"
      },
      "id": "6043efa0e7b9d2b78d5799d2"
    }
  ],
  "/explore-docs/query-and-store-data": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/java-release-notes/java-agent-3360/",
      "sections": [
        "Java agent v3.36.0",
        "Improvements",
        "Fixes"
      ],
      "published_at": "2021-04-17T00:44:37Z",
      "title": "Java agent v3.36.0",
      "updated_at": "2021-03-11T03:30:39Z",
      "type": "docs",
      "external_id": "620b9aa4068c44bd29515f153020db735791cd39",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "Improvements APIs This release adds a number of APIs that will allow you to instrument and get expanded visibility into frameworks, libraries, and any custom code that New Relic does not automatically instrument. In addition to instrumenting your web frameworks, you can also instrument calls to and from messaging systems, database calls, and external calls! By passing context about your code to the APIs, you will get the same reporting, including cross application tracing, that you get with New Relic’s built-in instrumentation. Solr This release adds support for Solr versions 5 and 6 (up to and including version 6.3.0). Fixes Fixes a bug that prevents an application from starting up when a JAX-RS annotated method contains more than 8 parameters. Fixes an issue that affected Spring and JAX-RS applications compiled with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using static methods. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page for customers injecting the X-Queue-Start or X-Request-Start HTTP headers. This fix brings the Java Agent into compliance with the behavior of other New Relic Agents. Fixes an issue in which custom Hystrix Commands that are subclassed multiple times in Groovy cause an application to throw an exception on startup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 60.087418,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using <em>static</em> <em>methods</em>. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page"
      },
      "id": "60445ebc196a676dd6960f5e"
    },
    {
      "sections": [
        "newrelic_add_custom_tracer (PHP agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples",
        "Instrument a function",
        "Instrument a method within a class",
        "Instrument a method within a namespaced class",
        "For more help"
      ],
      "title": "newrelic_add_custom_tracer (PHP agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "PHP agent API"
      ],
      "external_id": "c3a4f57bd2b02aa46f896e6e54ef818bac7d66b6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_add_custom_tracer/",
      "published_at": "2021-04-16T06:04:54Z",
      "updated_at": "2021-04-16T06:04:54Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic_add_custom_tracer(string $function_name) Copy Specify functions or methods for the agent to instrument with custom instrumentation. Requirements Compatible with all agent versions. Description Specify functions or methods for the agent to target for custom instrumentation. This is the API equivalent of the newrelic.transaction_tracer.custom setting. You cannot apply custom tracing to internal PHP functions. Parameters Parameter Description $function_name string Required. The name can be formatted either as function_name for procedural functions, or as \"ClassName::method\" for methods. Both static and instance methods will be instrumented if the method syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return values Returns true if the tracer was added successfully. Examples Instrument a function function example_function() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"example_function\"); } } Copy Instrument a method within a class class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"ExampleClass::example_method\"); } } } Copy Instrument a method within a namespaced class namespace Foo\\Bar; class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"Foo\\\\Bar\\\\ExampleClass::example_method\"); } } } Copy Alternatively, on PHP 5.5 or later, the ::class syntax can be used instead: namespace Foo\\Bar { class ExampleClass { function example_method() { // ... } } } namespace { use Foo\\Bar; if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(Bar::class . \"::example_method\"); } } } Copy For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 44.330635,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Instrument a <em>method</em> within a class",
        "body": "&quot; for <em>methods</em>. Both <em>static</em> and instance <em>methods</em> will be instrumented if the <em>method</em> syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return values Returns true if the tracer was added successfully. Examples Instrument"
      },
      "id": "6043c950196a67e23d960f2d"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-04-16T02:07:11Z",
      "updated_at": "2021-03-11T02:31:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events to Insights. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the first call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 28.470215,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: <em>Static</em> <em>methods</em> on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/introduction-new-relic-mobile-unity/",
      "sections": [
        "Introduction to New Relic Mobile (Unity)",
        "Caution",
        "Contents",
        "Monitor mobile app performance",
        "Features",
        "Known limitations",
        "Install and configure",
        "Install the Unity plugin",
        "Configure the Unity plugin",
        "Configure crash reporting",
        "Optional: Change the logging level",
        "Use Unity SDK API",
        "Create and complete interactions",
        "Set a custom build identifier",
        "Execute a demo crash",
        "Record custom metrics",
        "Send custom events and attributes to Insights",
        "RecordEvent (name, attributes)",
        "SetAttribute (name, value)",
        "IncrementAttribute (name [, value])",
        "RemoveAttribute (name)",
        "removeAllAttributes",
        "Track custom network requests",
        "NoticeNetworkRequest",
        "NoticeNetworkFailure",
        "Uninstall plugin",
        "Unity release notes",
        "Unity plugin 1.2.0",
        "Unity plugin 1.1.0",
        "Unity plugin 1.0.1",
        "Unity plugin 1.0.0"
      ],
      "published_at": "2021-04-16T01:21:03Z",
      "title": "Introduction to New Relic Mobile (Unity)",
      "updated_at": "2021-03-13T01:08:55Z",
      "type": "docs",
      "external_id": "21224415c30ee2bedbd3e15ec5afae0f830e5305",
      "document_type": "page",
      "popularity": 1,
      "body": "Caution This document is for historical reference. Unity is no longer supported for new customers. Contents Monitor mobile app performance The New Relic Unity plugin allows Unity developers to embed a New Relic Mobile agent (iOS or Android) in a Unity app build for mobile devices to monitor your app's performance. The plugin is written in C#, but it includes the native iOS and Android agents that embed the appropriate files for your build. Features New Relic Mobile Features Comprehensive performance data View your mobile app's performance Overview page for summary information about active sessions, or drill down to detailed information, including (note limitations below): Interaction times and trace details Crash reporting Devices Operating systems Detailed network views Available by using the API to track custom network requests For iOS apps, receive automatic instrumentation for networking for any parts of the app that are native and non-Unity (using standard Apple networking components such as NSURLConnection) Examine HTTP errors and network failures (such as DNS lookups, timeouts, SSL errors, etc.) and server error traces. Usage details at a glance Compare performance between versions of your app with detailed information for memory, CPU (iOS only), interaction speed, network requests per minute, and network failures. View a monthly report with a bar chart tracking the number of devices running your app for each month over the last year. Mobile SDK API options Use the Unity API to: Create and complete interactions Record custom metrics Send custom events to Insights Track custom network requests Known limitations The New Relic Unity plugin does not automatically instrument interactions. You must use the Unity API to track specific interactions. The New Relic Unity plugin does not automatically instrument network requests. You must use the Unity API to track network calls. Android builds: Unity still generates an Eclipse project, but Android Studio can import the Eclipse project. Install and configure The Unity plugin includes iOS and Android agent files that will embed the appropriate files for your build. To instrument interactions and network requests, you must use the Unity API to manually instrument your code. Install the Unity plugin As part of the installation process, New Relic Mobile automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile project you monitor in New Relic Mobile. For Admins with existing New Relic accounts, follow these steps to install and configure your Unity application. (If you do not have a New Relic account, see New Relic Mobile.) Go to rpm.newrelic.com/mobile. From the mobile apps index, select Add a new app. From the Get started page, select Unity as the platform for mobile monitoring. Type a name for your mobile project, then select Continue. Continue with the procedures to configure the Unity plugin. Configure the Unity plugin These procedures to configure your app also appear on the Get started page in the New Relic UI. Install NewRelic-Unity-Plugin.unitypackage into your project by going to Assets > Import package > Custom package... and selecting NewRelic-Unity-Plugin.unitypackage. Create a new GameObject in your project's initial scene by going to GameObject > Create empty and naming it NewRelicAgent. Add NewRelicAgent.cs script (located in Assets/Plugins) to the NewRelicAgent GameObject: Drag it on top of NewRelicAgent in the Hierarchy tab. OR Click Add Component button, then select New Relic Agent from the Scripts option. In the Inspector tab, set the iOS or Android application token from your New Relic Mobile apps. (Recommendation: Keep New Relic Mobile apps on separate platforms.) Build for your platform (iOS or Android), then open the resulting project (Xcode or Eclipse). For Eclipse, import the generated project into Android Studio. Android only: Ensure that your app requests the INTERNET permission through the Player Settings inspector window. In Other Settings, Configuration, ensure the Internet access dropdown is set to Required. This will result in the following permission added to the app's manifest: <uses-permission android:name=\"android.permission.INTERNET\" /> Run your app in an emulator or device to generate data. Check New Relic Mobile to ensure the data is reporting to your account. Configure crash reporting The New Relic Unity plugin cannot automatically upload dSYMs for iOS crash reporting. You must manually upload dSYMs once your iOS unity app is built for release. If the application is bitcode enabled, follow the procedures for bitcode enabled apps once the your iOS app is submitted to Apple. If you are building an Android app with ProGuard enabled, you must follow similar steps. The ProGuard mapping must be uploaded to New Relic so crash reports can be de-obfuscated. For more information, see Android agent crash reporting. Optional: Change the logging level Six logging levels are available for mobile apps monitoring: NONE ERROR WARNING INFO VERBOSE DEBUG Recommendation: Set the logging level from the Unity Inspector tab. Use Unity SDK API Use the New Relic Unity SDK API to further configure and extend the plugin's instrumentation. Create and complete interactions To start an interaction: string interactionIdentifier = NewRelicAgent.StartInteractionWithName(\"new interaction\"); Copy To stop the current interaction: NewRelicAgent.StopCurrentInteraction(interactionIdentifier); Copy Interactions work in conjuction with method tracing. To trace a method insert startTracingMethod, insert at the start of the method to trace, and insert endTracingMethodWithTimer at each exit point of the method. To start tracing a method: Timer methodTimer = new Timer(); NewRelicAgent.StartTracingMethod(\"MethodName\",\"ClassName\",methodTimer,NewRelicAgent.NRTraceType.None); Copy To end tracing a method, use the same timer as the startTracingMethod:> NewRelicAgent.EndTracingMethodWithTimer(methodTimer); Copy Set a custom build identifier Custom build identifiers are set as the Application Build property in the inspector pane for the NewRelicAgent game object, under the New Relic Agent (Script) settings. Execute a demo crash If you have trouble getting your project to crash, use the New Relic Unity plugin API to execute a demo crash. Recommendation: Add this line of code to a button click event handler as applicable: NewRelicAgent.CrashNow(\"message\")> Copy Record custom metrics With the custom metric API, you can record arbitrary numerical data and named events. Custom metrics can help to track high level events specific to your application. You can use several API calls to record custom metrics that provide different levels of detail. To create a custom metric, use this method: NewRelicAgent.RecordMetricWithName(String name, String category) Copy The name parameter is the textual name of the metric that will appear in the user interface for New Relic Mobile. Using clear, concise metric names will help you get the most out of the metrics. The guidelines for naming a custom metric include: Use case and white space characters appropriate for display in the user interface. Metric names are rendered as-is. Capitalize the metric name. Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. If you want to specify more details about a custom metric, three other API methods are available: NewRelicAgent.RecordMetricWithName(String name, String category, double value) NewRelicAgent.RecordMetricWithName(string name, string category, double value, string valueUnits) NewRelicAgent.RecordMetricWithName(string name, string category, double value, string valueUnits, string countUnits) Copy With these methods, you can record additional details: Parameter Description count The number of times the event has happened totalValue The total value of the recording exclusiveValue The exclusive value of the recording; for example, if the total value contains measurements accounted for elsewhere countUnit Unit of measurement for the metric count, including PERCENT, BYTES, SECONDS, BYTES_PER_SECOND, or OPERATIONS valueUnit Unit of measurement for the metric value, including PERCENT, BYTES, SECONDS, BYTES_PER_SECOND, or OPERATIONS To view the custom metrics you collect, follow standard procedures to create custom dashboards. Send custom events and attributes to Insights Caution The SDK can store up to 64 user-defined attributes at a time. If you attempt to store more than 64 attributes, the SDK returns false. Use the following static methods in the NewRelicAgent namespace to send custom attributes and events to New Relic Insights. Methods that return boolean results return true if they succeed, or false if the operation did not complete. The following methods are available for custom attributes and events: RecordEvent (name, attributes) NewRelicAgent.RecordEvent (string name, string dictionary attributes) Copy Records a custom Insights event. Includes a list of attributes specified as a map. SetAttribute (name, value) NewRelicAgent.SetAttribute (string name, string value) Copy NewRelicAgent.SetAttribute (string name, double value) Copy Creates an attribute with the specified text name and text/float value. SetAttribute overwrites its previous value and type each time it is called. Examples boolean attributeSet = NewRelicAgent.SetAttribute(\"username\", \"SampleUserName\"); Copy boolean attributeSet = NewRelicAgent.SetAttribute(\"rate\", 9999.99); Copy IncrementAttribute (name [, value]) public static boolean IncrementAttribute(String name); Copy public static boolean incrementAttribute(String name, double value) Copy If value is not specified, this method increments the count for the specified attribute by 1. If the attribute does not exist, it creates the attribute with a value of 1. If value is specified, the method will increment the attribute by the specified amount. Examples boolean incremented = NewRelicAgent.IncrementAttribute(\"rate\"); Copy boolean incremented = NewRelicAgent.IncrementAttribute(\"rate\", 9999.99, false); Copy RemoveAttribute (name) NewRelicAgent.RemoveAttribute(String name) Copy Removes the specified attribute. Example boolean attributeRemoved = NewRelicAgent.RemoveAttribute(\"rate\"); Copy removeAllAttributes NewRelicAgent.removeAllAttributes() Copy Removes all attributes from the session. Example boolean attributesRemoved = NewRelicAgent.RemoveAllAttributes(); Copy Track custom network requests New Relic Mobile's API provides several methods to track network requests and network failures. For example, use the noticeHttpTransaction family of methods to record HTTP transactions with several available levels of detail. If a network request fails, you can record details about the failure with noticeNetworkFailure. NoticeNetworkRequest NewRelicAgent.NoticeNetworkRequest (\"http://newrelic.com\", \"GET\", timer, null, 200, 1024, 8192, bytes, httpParameters); Copy Parameter Description url The URL of the request httpMethod The HTTP method used, such as GET or POST statusCode The statusCode of the HTTP response, such as 200 for OK timer A timer created when the network request was started bytesSent The number of bytes sent in the request bytesReceived The number of bytes received in the response responseBody The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. params Additional parameters included in an HTTP Error metric if the HTTP transaction is an error. NoticeNetworkFailure NewRelicAgent.NoticeNetworkFailure(String url, String httpMethod, Timer timer, NewRelicAgent.NetworkFailureCode failureCode, String message) Copy Parameter Description url The URL of the request httpMethod The HTTP method used, such as GET or POST timer A timer created when the network request was started exception The exception that occurred. New Relic Mobile can automatically translate many common exceptions into network failure types. failure The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Uninstall plugin To uninstall the Unity plugin, use the project console to remove all related files and resources that were installed with the Unity package: Delete NewRelicAgent object from the Hierarchy pane of the Unity project console. From All Scripts, delete all the scripts that start with newrelic. Then do the following as applicable: From Assets > Plugin > iOS, delete the NewRelicIos, NewRelicUnityPlugin, post-build, and restore-framework files. Then remove the mod_pbxproj and NewRelicAgent.framework directories. From Assets > Plugin > Android, delete the newrelic.android and NewRelicAndroid files. Then remove the LICENSE and README directories. Unity release notes Caution These release notes are for historical reference. Unity is no longer supported for new customers. Unity plugin 1.2.0 Released on: Monday, March 13, 2017 - 13:00 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.2.0.zip Notes: Updated Unity plugin to iOS agent 5.9.0 and Android agent 5.9.0 Unity plugin 1.1.0 Released on: Tuesday, September 6, 2016 - 14:53 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.1.0.zip Notes: Updated Unity plugin to iOS agent 5.8.0 and Android agent 5.7.1 Unity plugin 1.0.1 Released on: Monday, August 8, 2016 - 14:00 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.0.1.zip Notes: Bundle Android class rewriter JAR file (version 5.6.1) into the Unity package. Unity plugin 1.0.0 Released on: Wednesday, May 25, 2016 - 14:00 Download URL: http://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.0.0.zip Notes: This plugin provides New Relic Mobile agent support for iOS and Android applications built with Unity. It also gives Unity developers access to New Relic crash reporting. It provides information about app performance, sessions, devices, operating systems, and more. It also includes APIs for custom instrumentation to gain deeper insights into specific areas of your app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 17.660643,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " and attributes to Insights Caution The SDK can store up to 64 user-defined attributes at a time. If you attempt to store more than 64 attributes, the SDK returns false. Use the following <em>static</em> <em>methods</em> in the NewRelicAgent namespace to send custom attributes and events to New Relic Insights. <em>Methods</em>"
      },
      "id": "6043daf4e7b9d24bf75799fd"
    },
    {
      "sections": [
        "function_trace (Python agent API)",
        "Syntax",
        "Description",
        "Important",
        "Alternate call forms",
        "The context manager",
        "The wrapper",
        "Path-based wrapping",
        "Parameters",
        "Parameters for decorator",
        "Parameters for context manager",
        "Wrapper parameters",
        "Path-based wrapping parameters",
        "Examples",
        "function_trace example",
        "Context manager example",
        "Wrapper example"
      ],
      "title": "function_trace (Python agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "Python agent API"
      ],
      "external_id": "8c0c11c34a9d98922a56321682f20c2bfd63c3e4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/python-agent-api/functiontrace-python-agent-api/",
      "published_at": "2021-04-16T10:09:23Z",
      "updated_at": "2021-03-11T07:06:56Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.agent.function_trace(name=None, group=None, label=None, params=None, terminal=False) Copy Used to instrument functions, methods, generators, and coroutines that aren't instrumented by default. Description function_trace is a decorator for adding to functions, methods, generators, and coroutines. Adding this decorator lets you collect additional transaction information (including transaction trace information). (An alternate way to instrument functions without having to touch your app code is to list them in the config file.) function_trace does not give you a full profile of all the functions that happen in a decorated function. What it does is add the decorated function as a node in the New Relic UI and capture the time spent in that function. If you need more detail about what is going on in that function, you would need to also apply the function trace to the function's child functions. The function_trace decorator can be used on generators and coroutines with agent version 2.102.0.85 or higher. Timing of these objects begins when consumption starts, and ends when the object is exhausted or goes out of scope. This is a change from earlier versions where the metric represented the time taken to create the generator or coroutine object itself. You can use the decorator in conjunction with existing decorators, including those for static and class methods. When nesting multiple decorators, have the function_trace decorator as the outermost decorator. Important For any decorators that are being wrapped, use functools.wraps() from the Python standard library in their implementation. (Or, otherwise ensure that the decorator propagates the correct name attributes of the innermost wrapped object required to allow correct name introspection.) If this is not done, then when the metric is reported, the name of the nested decorator function (not the innermost wrapped function) will be used. Alternate call forms For setups where you cannot use the decorator, these alternate call forms are available: The context manager The FunctionTrace context manager is used when the parameters to be passed cannot be determined before runtime. (For example, you may not know the name of a function at import time.) When using the context manager to name a metric, you must always supply the name and the metric path prefix. The FunctionTrace class implements the context manager and is used in conjunction with the with statement. The FunctionTrace class is the lowest level primitive available for tracing time against a transaction. The with statement defines the bounds of what is timed and not a single function. Thus, the context manager could be applied to an arbitrary block of code. The block of code could therefore contain calls to multiple functions, or it could be a self-contained block of code implementing a time-oriented algorithm that you want to track. Important Avoid tracing blocks of code that are called an excessive number of times. For example, do not use it within the context of a loop that executes many times. The data generated will incur a performance overhead. A better solution is to enclose the loop. The wrapper If you know in advance where the specific functions you want to trace are, you could use the function_trace decorator. However, if you don't know all the functions that need to be traced (for example, if they're being looked up dynamically as part of a routing system), then you must use the FunctionTraceWrapper to wrap the function at the time of registration or at the time of calling. Path-based wrapping wrap_function_trace is used for wrapping functions outside of the code they're declared in. For example: you might use this to instrument library code that you don't want to modify. For more about the differences between these call formats, see Different call formats. Parameters Parameters for decorator newrelic.agent.function_trace(name=None, group=None, label=None, params=None, terminal=False) Copy This call includes these parameters: Parameter Description name string Optional. The function name. If not set, defaults to the captured name of the function. group string Optional. The group represents the naming structure for the name parameter. This is used in the UI for segregating the transaction types. If not supplied, the group will default to Function in expectation that the name is of the form module:class.function or module:function and represents the name of the function being executed. If you are creating a custom group, it's recommended you prefix it with Python/. label string Optional. Adds a callout-style flag to the segment in a transaction trace. Default is None. params dict Optional. Custom parameters to add to the segment in transaction traces. terminal boolean Optional. If true, no children segments will be recorded. Default is False. Parameters for context manager newrelic.agent.FunctionTrace(name, group=None, label=None, params=None, terminal=False) Copy Parameters for the context manager includes all of the parameters from function_trace. The name parameter is required and not optional. Parameter Description name string Required. The function name. Wrapper parameters newrelic.agent.FunctionTraceWrapper(wrapped, name=None, group=None, label=None, params=None, terminal=False) Copy Parameters for the wrapper include all parameters for function_trace and a wrapped parameter: Parameter Description wrapped function Required. The function being wrapped. Path-based wrapping parameters newrelic.agent.wrap_function_trace(module, object_path, name=None, group=None, label=None, params=None, terminal=False) Copy Parameters include all parameters for function_trace and these parameters: Parameter Description module object Required. The module containing the function to be instrumented. object_path string The path to the location of the function. Examples function_trace example An example of using the function_trace decorator: import newrelic.agent class _Database(UserDict.DictMixin): ... @newrelic.agent.function_trace() def _commit(self): ... @newrelic.agent.function_trace() def open(file, flag=None, mode=0666): ... Copy An example of using the function_trace decorator with native coroutines: import newrelic.agent class _Database(UserDict.DictMixin): ... @newrelic.agent.function_trace() async def _commit(self): ... @newrelic.agent.function_trace() async def open(file, flag=None, mode=0666): ... Copy Context manager example An example of using the FunctionTrace context manager: import newrelic.agent def dispatch_request(self, request): adapter = self.url_map.bind_to_environ(request.environ) try: endpoint, values = adapter.match() function = getattr(self, 'on_' + endpoint) with newrelic.agent.FunctionTrace( endpoint, 'Python/EndPoint'): return function(request, **values) except HTTPException as e: return e Copy Wrapper example An example of using the FunctionTraceWrapper: URL routing with Werkzeug yields a name that is used first to dynamically look up a method of a class using getattr() and the result then invoked: def dispatch_request(self, request): adapter = self.url_map.bind_to_environ(request.environ) try: endpoint, values = adapter.match() return getattr(self, 'on_' + endpoint)(request, **values) except HTTPException as e: return e Copy If you want to trace the endpoint function, you can rewrite this as: import newrelic.agent def dispatch_request(self, request): adapter = self.url_map.bind_to_environ(request.environ) try: endpoint, values = adapter.match() function = getattr(self, 'on_' + endpoint) function = newrelic.agent.FunctionTraceWrapper(function) return function(request, **values) except HTTPException as e: return e Copy If you want to name the metric after the endpoint name (rather than naming the metric based on the identifier for the function being called), you can supply the name to use plus an alternate metric path prefix when the FunctionTraceWrapper object is created. import newrelic.agent def dispatch_request(self, request): adapter = self.url_map.bind_to_environ(request.environ) try: endpoint, values = adapter.match() function = getattr(self, 'on_' + endpoint) function = newrelic.agent.FunctionTraceWrapper( function, name=endpoint, group='Python/EndPoint') return function(request, **values) except HTTPException as e: return e Copy For this example, if the endpoint were called help, the final metric would be: Python/EndPoint/help Copy In the performance breakdown for a transaction, the category would be Python and the segment name EndPoint/help. That segment name would also appear in slow transaction traces as the node name.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 14.209753,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " the metric represented the time taken to create the generator or coroutine object itself. You can use the decorator in conjunction with existing decorators, including those for <em>static</em> and class <em>methods</em>. When nesting multiple decorators, have the function_trace decorator as the outermost decorator. Important"
      },
      "id": "6044019928ccbc62462c6081"
    }
  ],
  "/collect-data/get-started-nerdgraph-api-explorer": [
    {
      "sections": [
        "NerdGraph cloud integrations API tutorial",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph cloud integrations API tutorial",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-04-16T14:50:03Z",
      "updated_at": "2021-04-12T04:27:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to https://api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } }</integration_slug></provider_slug> Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } }</integration_slug></provider_slug> Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.39615,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> cloud integrations API tutorial",
        "sections": "<em>NerdGraph</em> cloud integrations API tutorial",
        "tags": "<em>NerdGraph</em>",
        "body": "This document provides examples of how to use New Relic <em>NerdGraph</em> to <em>query</em> and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the <em>NerdGraph</em> GraphiQL explorer, you can also <em>query</em> NRQL data. These examples for querying"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "sections": [
        "NerdGraph API: Examples",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Tip",
        "Queries",
        "Mutations"
      ],
      "title": "NerdGraph API: Examples ",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "62c3f9bdca2acc3e9257b07970a717ee2ab0548f",
      "image": "https://docs.newrelic.com/static/6551638ff382e1ef38324cd82dca1214/e2c15/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples/",
      "published_at": "2021-04-16T14:43:10Z",
      "updated_at": "2021-03-13T02:52:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. Tip For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.26526,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> API: Examples ",
        "sections": "<em>Mutations</em>",
        "tags": "Alerts and <em>Nerdgraph</em>",
        "body": " Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and <em>mutations</em> is through the <em>NerdGraph</em> API explorer. <em>NerdGraph</em> API explorer Our <em>NerdGraph</em> API explorer is a GraphiQL editor where you can prototype queries and <em>mutations</em>. Here are some examples showing"
      },
      "id": "6043fe3864441f2dd2378ee8"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/graphql_aws_services-1024x593.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/graphql-api",
      "sections": [
        "Using GraphQL in New Relic",
        "Example 1: Querying Infrastructure cloud integrations with NerdGraph",
        "Example 2: Modifying integration configurations with NerdGraph",
        "Transfering NerdGraph data to the terminal",
        "New Relic and GraphQL—easing the path for developers"
      ],
      "published_at": "2021-04-16T04:24:43Z",
      "title": "Getting Started With NerdGraph—The New Relic GraphQL API Explorer",
      "updated_at": "2021-04-14T00:03:23Z",
      "type": "",
      "external_id": "381e6b1a3bca81ebc8b6efc8199d2b75983befca",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Getting Started With NerdGraph—The New Relic GraphQL API Explorer Jun 11, 2020 • 12 min read By Mark Weitzel As you build observability into your workflows and processes, you need the ability to quickly retrieve, sort, and process all kinds of telemetry through APIs. With New Relic, you can gather a lot of data, but when you’re building dashboards and applications for working with your data, you want to minimize superfluous API operations. With the NerdGraph API explorer—built on GraphQL—you can more easily query the data you need, without over-or under-fetching, and reduce manual toil in your data analysis workflows. More specifically, in New Relic you can use NerdGraph to: Query all the entities associated with your account Query, create, and update the workloads associated with your account Create, manage, and add tags to entities Query distributed tracing data Fetch data when building a New Relic One application Understand upstream and downstream relationships with your services Configure your New Relic Infrastructure cloud integrations Query event data and custom event data with NRQL In this post, I’ll walk through two examples using NerdGraph to query information about New Relic Infrastructure cloud integrations and update their configuration values. But first a bit of history. Using GraphQL in New Relic Unlike typical REST APIs that often require loading from multiple endpoints, GraphQL provides a single endpoint that can manage complex queries so developers can get all the data their app needs from many services in one request. GraphQL is strongly typed, which allows developers to explicitly declare what information is available via queries to the GraphQL service. This declaration is done via a GraphQL schema. Schemas give developers the flexibility they need to express information about the data they return. For example, each field has a description, which developers can use to indicate the proper usage of the data. Schemas also provide the API blueprint developers need to build tools for properly constructing queries and guiding proper usage of any returned data. For example, developers can use the schema to indicate if a field has been deprecated so tools like IDEs can surface this fact and discourage use of that data. And “schema stitching”—creating a single schema from several underlying GraphQL APIs—allows developers to deliver a unified access experience across all of their APIs, as we’ve done at New Relic: The New Relic GraphQL implementation includes several underlying GraphQL APIs—including accounts, Infrastructure, and the New Relic database (for constructing NRQL queries). For more information on GraphQL, the following examples of querying cloud integration configuration data use GraphQL queries and mutations: Queries: GraphQL requests that only fetch data Mutations: GraphQL requests that modify and fetch data NerdGraph has a single endpoint: https://api.newrelic.com/graphiql. This launches (after authenticating the user) the NerdGraph API interface—an interactive, browser-based IDE for running GraphQL requests. In the NerdGraph API explorer, you build and run your query on the left, and the result is returned on the right. You can click into fields to drill into their definitions. For example, if you drill into actor, you’ll see it contains fields for user and accounts: { actor { user { name email } accounts { id name } } } The fields under actor expose data from different downstream services that are unified in the GrahQL schema delivered by the GraphQL server. When you issue a query, the GraphQL server pulls apart the query and invokes a resolver for each of the services. When the queries complete (or time out or encounter errors), the GraphQL server assembles the result and returns it to you. In the example above, we get information about the user and all the accounts that they have access to. Let’s walk through our examples to show the full power of GraphQL’s data collection capabilities. Example 1: Querying Infrastructure cloud integrations with NerdGraph In my first example, I’ll use NerdGraph to query for various data about the AWS integrations that are running in my New Relic account. I’ll use the data I gather in this example to update some specific settings in the next section. Tip: If you’re planning on following along, make sure you generate an API key that you can use with New Relic’s GraphQL API. In fact, you can generate one directly from NerdGraph. Let's start with a list of the AWS integrations I have available in New Relic Infrastructure: AWS integrations installed in New Relic Infrastructure. Next, let's retrieve some information about these AWS services via a GraphQL query. I’m going to query for the cloud provider (in this case, AWS) that’s linked to my account and the set of integrations from AWS that I’ve installed. To do this, I need to pass the ID of the account I want to query—this is the account(id: MY ACCOUNT ID) part of the query. Notice that I’m “nesting” requests to get information about the cloud provider and the integrations I’m using. If I were using a REST API, this would require multiple calls, but with the GraphQL API, I can gather this information with just one query.   { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { id name slug } integrations { id name service { id slug name createdAt updatedAt provider { name id } } } } } } } } When the query completes, the GraphQL server assembles the results about the AWS integrations I’ve installed, as shown below (note that I’ve truncated the example): { \"data\": { \"actor\": { \"account\": { \"cloud\": { \"linkedAccounts\": [ { \"authLabel\": \"arn:aws:iam::8xxxxxxx7:role/NewRelicInfrastructure-Integrations-Origami\", \"externalId\": \"8xxxxxxx7\", \"id\": 3542, \"integrations\": [ { \"id\": 75540, \"name\": \"RDS\", \"service\": { \"createdAt\": 1470991744, \"id\": 3, \"name\": \"RDS\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"rds\", \"updatedAt\": 1534242454 } }, { \"id\": 14233, \"name\": \"S3\", \"service\": { \"createdAt\": 1470991745, \"id\": 4, \"name\": \"S3\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"s3\", \"updatedAt\": 1534242454 } }, { \"id\": 12223, \"name\": \"Lambda\", \"service\": { \"createdAt\": 1477910055, \"id\": 14, \"name\": \"Lambda\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"lambda\", \"updatedAt\": 1534242454 } }, { \"id\": 172534, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 } }, } } ] } } } } } But what if I want more specific information about one of the integrations? Specifically, I want to see what tags (user-defined metadata) I’ve applied to a particular integration as well as its metrics polling interval (how often New Relic polls the integration for data), and when these settings were last updated. To do this, I’ll need to use one of the more nuanced features of GraphQL—interfaces, an abstract type that represents a collection of common fields that other object types can implement. So in my original query, I’ll add two new clauses: ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } Now, if my query hits a result that is of type CloudDynamodbIntegration or CloudReshiftIntegration, it also return the fields metricsPollingInterval, tagKey, tagValue, and updatedAt. Here's what my (truncated) query will like now: { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { ... } integrations { id name service { ... } } ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } } } } } } In the result, notice that the DynamoDb and Redshift configuration information contain the extra fields that I specified in the query using their interfaces. { \"id\": 173397, \"metricsPollingInterval\": 900, \"name\": \"Redshift\", \"service\": { \"createdAt\": 1497364366, \"id\": 21, \"name\": \"Redshift\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"redshift\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1544435410 }, { \"id\": 112183, \"metricsPollingInterval\": 900, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1549499902 }, OK! I’ve successfully queried information about my AWS integrations in New Relic Infrastructure, and I’ve used an interface to get additional information about a specific integration. Now, I’ll use the GraphQL API to update the metrics data polling intervals in one of these integrations. Example 2: Modifying integration configurations with NerdGraph In GraphQL, when you modify data with a write operation, it’s called a mutation. In this example, I’ll build a mutation to update the polling intervals of an AWS integration. First, though, I’ll set a polling interval so that we'll notice when I change it with NerdGraph. Here are the configuration options for my AWS DynamoDB integration: DynamoDB integration configuration options in New Relic Infrastructure. As you can see, I’ve set the metrics data and inventory data polling intervals to every 5 minutes, and I’ve also toggled Collect tags to ON. Now I’ll build the mutation query. First, I'll start with the keyword mutation, and like any GraphQL API request, enclose it in a pair of curly braces,{ }. Next, I want to specify that I’m configuring a cloud integration; so I’ll add cloudConfigureIntegration, which takes two arguments: accountId and integrations. For accountId, I’ll use the same account id from the first example to get information about the Infrastructure-linked accounts. The second argument is the integrations that I want to update. Again, integrations are specified by cloud provider, so here I want to include aws. So far my mutation looks like this: mutation{ cloudConfigureIntegration( accountId:MY ACCOUNT ID integrations:{aws I want to specify that I’m updating the configuration for DynamoDB, so I’ll pass in an object with dynamodb as the key and an array that contains objects with the values I want to to set. Remember, for our mutation, we want to update the metricsPollingInterval (valid values are 300, 900, 1800, and 3600 seconds) and add a tagKey (metadata about the function of the integration). The final part of the mutation adds a set of fields to return if my request is successful and a set of fields to return if there are any errors. Here's the full query: mutation{ cloudConfigureIntegration( accountId:630060 integrations:{aws:{ dynamodb:[ { linkedAccountId:4912 metricsPollingInterval:1800 tagKey:\"mdw-test\" }] } } ) { integrations{ id name updatedAt ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } errors{ linkedAccountId message integrationSlug } } } And here’s the result, which shows no errors and indicates DynamoDB’s configuration was successfully updated: { \"data\": { \"cloudConfigureIntegration\": { \"errors\": [], \"integrations\": [ { \"id\": 177184, \"metricsPollingInterval\": 1800, \"name\": \"DynamoDB\", \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1551139957 } ] } } } I can now return to New Relic Infrastructure and refresh the DynamoDB configuration page: Refreshing the DynamoDB configuration in New Relic Infrastructure. Our mutation changed the metric polling interval from 300 seconds (5 minutes) to 1800 seconds (30 minutes), and entered tag key value of mdw-test. That's it! I've successfully updated the configuration of a New Relic Infrastructure integration using NerdGraph. Transfering NerdGraph data to the terminal So, now you know how to explore the New Relic data available to you in NerdGraph, and you know how to create queries and mutations, but how do you transfer this data to your code? To capture code-ready queries and mutations, select the Tools drop down in the NerdGraph explorer. To copy a curl statement with the in-scope query to your clipboard, select Copy as CURL. Paste this code snippet into your terminal, or use it to populate an HTTP request in your code. If you’re working with the New Relic CLI, select Copy as New Relic CLI from the drop down to generate a command-line ready query or mutation. New Relic and GraphQL—easing the path for developers As these examples show, GraphQL is extremely flexible and lightweight, and dramatically reduces the overhead of working with your New Relic data. If you want to challenge yourself even more, create some more complex queries in the Query Builder. For example, can you create a query to grab the count of all of your reporting entities? Hint: check out NerdGraph’s entity search field. We’re passionate about making life for developers as easy as possible. Check out the resources available at developer.newrelic.com, and engage in the discussion with fellow developers on the Explorer’s Hub. By Mark Weitzel Mark Weitzel is General Manager, New Relic One at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.20328,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Started With <em>NerdGraph</em>—The New Relic GraphQL API Explorer",
        "sections": "Transfering <em>NerdGraph</em> data to the <em>terminal</em>",
        "body": " Infrastructure integration using <em>NerdGraph</em>. Transfering <em>NerdGraph</em> data to the <em>terminal</em> So, now you know how to explore the New Relic data available to you in <em>NerdGraph</em>, and you know how to create queries and <em>mutations</em>, but how do you transfer this data to your code? To capture code-ready queries and <em>mutations</em>"
      },
      "id": "6076314c64441f483e9d8576"
    },
    {
      "sections": [
        "Use NerdGraph to manage license keys and user keys",
        "Overview of feature description",
        "Before using examples",
        "Create keys",
        "Create a user key",
        "Update keys",
        "Delete keys",
        "Query keys"
      ],
      "title": "Use NerdGraph to manage license keys and user keys",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "5610c77ebfcd92d59c1d0a1b15343f499c8e310e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-user-keys/",
      "published_at": "2021-04-16T14:50:59Z",
      "updated_at": "2021-03-16T08:11:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc contains tutorials on how to use NerdGraph to programmatically manage some New Relic API keys. For general information about New Relic keys, see API keys. Overview of feature description You can use the API keys UI to create and manage keys. Alternatively, you can use NerdGraph's ApiAccess field to programmatically create and manage the following types of keys: User keys License keys, including: General license key (used for APM, infrastructure monitoring, more) Browser key (for browser monitoring) One common use case for this feature is the ability to create and manage license keys to let you rotate keys for security purposes. Note that you can't use this NerdGraph functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you've created. Notes about this functionality: All mutations can accept multiple keys as arguments, and will return details about successful changes and errors. See examples below for details. All mutations (create, update and delete) will result in an NrAuditEvent that can be queried for auditing purposes. For details, see Audit events. Regarding license keys: License keys are categorized by NerdGraph as ingest keys. This is because their main use is to allow data ingest. You can create up to 1,000 keys of each license key type, which allows for key rotation. You can't manage or delete original license keys; you can only create additional license keys and manage keys you've created. Before using examples Things to note before using these example queries: The examples below use license keys (aka ingest keys), but you can query user keys in similar ways, replacing the ingest-key-specific fields with user-key-specific fields. To understand the data structure, we recommend experimenting with queries using the GraphiQL explorer. You can also create, view, and delete user keys using the UI. Create keys You can create multiple keys in a single mutation, for multiple accounts and key types. Note that the mutation can return successfully created keys as well as any errors encountered trying to create keys. Example of creating a key: mutation { apiAccessCreateKeys(keys: {ingest: {accountId: YOUR_ACCOUNT_ID, ingestType: BROWSER, name: \"Browser Key\", notes: \"A note.\"}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Here's an example of using this query to create a user key: Create a user key To create a user key, you'd change the above query slightly, in the keys section: mutation { apiAccessCreateKeys(keys: {user: {accountId: YOUR_ACCOUNT_ID, userId: YOUR_USER_ID}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Copy Update keys The update mutation takes the key ID, not the key string, to identify keys. mutation { apiAccessUpdateKeys(keys: {ingest: {keyId: KEY_ID, name: \"Updated name\", notes: \"A new note!\"}}) { updatedKeys { id key type name notes } errors { message } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Delete keys The delete mutation takes the key ID, not the key string, to identify keys. Deleted keys will no longer grant access to New Relic systems and will no longer be returned by queries to the API access GraphQL API. mutation { apiAccessDeleteKeys(keys: {ingestKeyIds: INGEST_KEY_ID}) { deletedKeys { id } errors { message } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Query keys You can access ingest and user keys by querying a single key or all keys, scoped to the actor. If querying for a single key, you must provide the key ID and type (INGEST or USER). Querying for multiple keys is done via a key search, which uses a mandatory types list and an optional scope to filter results. User keys belonging to other users will be obfuscated in the results. Single key example query: query { actor { apiAccess { key(id: INGEST_KEY_ID, keyType: INGEST) { key name type ... on ApiAccessIngestKey { ingestType } } } } } Copy Key search example query: query { actor { apiAccess { keySearch(query: {types: INGEST, scope: {ingestTypes: BROWSER}}) { keys { name key type ... on ApiAccessIngestKey { ingestType } } } } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.84021,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>NerdGraph</em> to manage license keys and user keys",
        "sections": "Use <em>NerdGraph</em> to manage license keys and user keys",
        "tags": "<em>NerdGraph</em>",
        "body": " to let you rotate keys for security purposes. Note that you can&#x27;t use this <em>NerdGraph</em> functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you&#x27;ve created. Notes about this functionality: All <em>mutations</em> can accept multiple keys"
      },
      "id": "603e96bf28ccbc326aeba75c"
    },
    {
      "sections": [
        "Dashboards API migration: from Insights API to Nerdgraph",
        "Why a new dashboards API?",
        "From REST endpoints to GraphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "Show (GET) -> entity query",
        "Create (POST) -> dashboardCreate mutation",
        "Update (PUT) -> dashboardUpdate mutation",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Errors as first class citizens"
      ],
      "title": "Dashboards API migration: from Insights API to Nerdgraph",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "7a1a086f45b7aefccb5d2cd5f42b3a0f0dd526c2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph/",
      "published_at": "2021-04-16T04:41:13Z",
      "updated_at": "2021-03-11T03:15:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In case you haven’t heard, NerdGraph is New Relic’s unified API in a GraphQL flavor. The new dashboards API follows this unified approach and is exposed through NerdGraph for user consumption. Why a new dashboards API? Dashboards in New Relic embrace the entity concept and are now an entity in New Relic’s entity ecosystem. Dashboards can now connect with any other type of entity for better observability solutions, which opens the door to endless opportunities we would like you to benefit from. At the same time, we have built new features for dashboards: All New Relic One dashboards are structured in pages, known as Data Apps in Insights Multiple queries from different accounts within the same widget Facet linking Facet linking with support for cases From REST endpoints to GraphQL queries/mutations One of the main benefits from a GraphQL API is that it provides a complete and understandable description of the APIs' data. By using NerdGraph GraphiQL explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new GraphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic’s entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by name: { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s email: { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy You can list all the dashboards by the creator’s userId: { actor { entitySearch(query: \"type = 'DASHBOARD' and ownerId = \"2357322\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity GUID. Then you can access all the dashboard properties that you are interested in by adding them in the GraphQL query. In the example below we are only interested in the entity GUID and the name of our dashboard. { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid name } } } } Copy Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in GraphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although GraphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields, like the doc about how to build dashboard widgets. The example below is not complete but can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardCreate( accountId: 1, dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard GUID and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory, but you can look up the doc about how to build dashboard widgets. The example is not complete but it can give you an understanding of how the mutation looks like. Try it out using the NerdGraph GraphiQL explorer. mutation { dashboardUpdate( guid: \"MY_EXISTING_DASHBOARD_GUID\", dashboard: { name: \"My dashboard\", pages: [ { name: \"Errors page\", widgets: {} } { name: \"Logs page\", widgets: {} } ], permissions: PUBLIC_READ_ONLY }) { entityResult { name guid updatedAt createdAt } errors { description type } } } Copy Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity GUID. mutation { dashboardDelete { status errors { type description } } } Copy Errors as first class citizens As you might have noticed, all dashboard mutations offer you a way to ask for errors when being executed. This means that you can perform your dashboard mutations and check the response in order to detect potential issues. Every error has a type and a description to help you identify what’s the source of the problem. mutation { dashboardMutation(guid: \"MY_EXISTING_DASHBOARD_GUID\") { mutationResult { result } errors { description type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.60204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Dashboards API migration: from Insights API to <em>Nerdgraph</em>",
        "sections": "From REST endpoints to GraphQL <em>queries</em>&#x2F;<em>mutations</em>",
        "body": " REST endpoints map to the new GraphQL queries or <em>mutations</em>. List (GET) -&gt; entitySearch <em>query</em> Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic’s entity ecosystem. You can list all the dashboard entities you have access to: { actor { entitySearch"
      },
      "id": "60441442e7b9d2020b5799b9"
    }
  ],
  "/automate-workflows/get-started-kubernetes": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/K8s2.png",
      "url": "https://newrelic.com/blog/how-to-relic/kubernetes-operators-for-parallel-deployment",
      "sections": [
        "What is a Kubernetes Operator?",
        "About the New Relic Kubernetes Operator",
        "Before you begin",
        "Installing the operator on your Kubernetes cluster",
        "Using the Kubernetes operator",
        "Workflow overview",
        "Creating your first alert policy",
        "Add NRQL alert conditions to your alert policy",
        "What’s next?",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:25:05Z",
      "title": "How to Use the New Relic Kubernetes Operators for Parallel Deployment",
      "updated_at": "2021-04-14T00:01:39Z",
      "type": "",
      "external_id": "4b06941f074b16cd874c3c525c2153dfc224613d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Kubernetes Monitoring How to Use the New Relic Kubernetes Operators for Parallel Deployment Jul 1, 2020 • 6 min read By Sander Blue The New Relic Developer Toolkit offers a suite of tools expressly built to reduce toil for developers. In Practicing Observability as Code: Defining New Relic Alert Policies with Terraform, we explained how to use the New Relic Terraform provider to deploy monitoring and alerting configurations alongside your infrastructure and application code. Now we're doing the same for Kubernetes. In this post, we'll briefly go over Kubernetes Operators, why they're useful, and show how the New Relic Kubernetes Operator provides a seamless way to deploy New Relic resources alongside your Kubernetes deployment. What is a Kubernetes Operator? Operators are software extensions to Kubernetes that make use of custom resources to manage applications and their components. Operators follow Kubernetes principles, notably the control loop. Kubernetes is becoming the de-facto standard for orchestrating containerized services in the cloud. Kubernetes introduced the Operator pattern in version 1.7, giving you the ability to extend Kubernetes by defining custom Kubernetes objects that can perform domain-specific operations, such as configuring and provisioning third-party services. About the New Relic Kubernetes Operator The New Relic Kubernetes Operator provides the ability to configure your New Relic monitoring resources the same way you manage the rest of your Kubernetes configuration. For example, once you've installed the operator in your cluster, you can create a New Relic alert policy via kubectl apply using New Relic's custom Kubernetes AlertsPolicy object. You can also configure the AlertsPolicy object using NRQL alert conditions. To configure a standalone New Relic NRQL alert condition and apply it to a pre-existing alert policy, you can use New Relic's custom AlertsNrqlCondition object. Note: This post was written with the New Relic Kubernetes Operator version v0.0.2 and Kubernetes version 1.18.2. Before you begin This walkthrough assumes you’ve already deployed a Kubernetes cluster. You could even create a local cluster on your machine with kind. To complete the full exercise, you’ll need to: Install kubectl, and point it at the correct cluster, as this will determine the cluster where you’ll install the New Relic operator. Install kustomize. Installing the operator on your Kubernetes cluster Installing the New Relic operator is a two-step process. First, install cert-manager, which automatically provisions and manages TLS certificates in Kubernetes: kubectl apply --validate=false -f https://github.com/jetstack/cert-manager/releases/download/v0.15.0/cert-manager.yaml Next, install the Kubernetes operator: kustomize build https://github.com/newrelic/newrelic-kubernetes-operator/configs/default | kubectl apply -f - To confirm the installation was successful, run a few kubectl commands to check the status of the Kubernetes operator. Ensure the Kubernetes operator's namespace, newrelic-kubernetes-operator-system, has been applied: kubectl get namespaces The output should be similar to the example below, which includes the Kubernetes operator's namespace, newrelic-kubernetes-operator-system: NAME                                     STATUS   AGE cert-manager                          Active   4m35s default                               Active   20m kube-node-lease                       Active   20m kube-public                           Active   20m kube-system                           Active   20m newrelic-kubernetes-operator-system   Active   3m48s Now, make sure the Kubernetes operator's controller manager is running: kubectl get pods --namespace newrelic-kubernetes-operator-system Note: Don't forget to include the --namespace (shorthand -n) option when running kubectl get pods to ensure you're inspecting resources within the correct namespace. You should see output similar to the following: NAME                                                               READY   STATUS    RESTARTS   AGE newrelic-kubernetes-operator-controller-manager-7b9c64f58crwg9j   2/2     Running   0          157m If you see output similar to the above, you’re ready for the next step. If you don’t see a pod named newrelic-kubernetes-operator-controller-manager-<hash>, double check your Kubernetes configuration to ensure you’re within the correct context and pointing to the correct cluster. Using the Kubernetes operator Now that Kubernetes operator is deployed to your cluster, you can put it to work. You’ll write the alert policy and NRQL alert condition configuration the same way you write your other Kubernetes configurations. Workflow overview Generally, it’s a three-step process to create your first alert policy using kubectl apply. Using a declarative approach, you’ll write an alert policy configuration file. You’ll add your New Relic personal API key to the configuration. You’ll run kubectl apply when your configuration is ready to go. Creating your first alert policy To kick things off, start small. First, create an alert policy with the minimum required configuration, then add a NRQL alert condition to the policy, which will add the condition to the policy in New Relic. A minimal alert policy configuration is represented in the code below. For the sake of this walkthrough, name this file new_relic_alert_policy.yaml. new_relic_alert_policy.yaml apiVersion: nr.k8s.newrelic.com/v1 kind: AlertsPolicy metadata: name: my-policy spec: account_id: <your New Relic account ID> api_key: <your New Relic personal API key> name: \"Alert Policy Created With k8s\" # Feel free to rename region: \"us\" Note: For help locating your personal API key, check out New Relic's personal API key documentation. Now run the kubectl apply command to create your alert policy: kubectl apply -f ./new_relic_alert_policy.yaml You'll see output that reads similar to the following: alertspolicy.nr.k8s.newrelic.com/my-policy created\\ Confirm that your alert policy was created by viewing your policies at alerts.newrelic.com/accounts/{your account ID}/policies. You can search for your new policy by its name. In this case , you’d search for \"Alert Policy Created With k8s.\" You should see your new alert policy. Now it’s time to add a NRQL alert condition to the policy using the same configuration file. Add NRQL alert conditions to your alert policy Now that you’ve created an alert policy, you’ll want to add some alert conditions to the policy so you can trigger alerts when certain metrics are out of line. In your new_relic_alert_policy.yaml file, add a NRQL alert condition to the policy that will alert you when an application's average overall response time is above five seconds for a three minute period. new_relic_alert_policy.yaml # The policy from the previous steps apiVersion: nr.k8s.newrelic.com/v1 kind: AlertsPolicy metadata: name: my-policy spec: account_id: <your New Relic account ID> api_key: <your New Relic personal API key> name: \"Alert Policy Created With k8s\" # Feel free to rename region: \"us\" # Add a NRQL alert condition to the policy conditions: - spec: type: \"NRQL\" name: \"NRQL Alert Condition Created With k8s\" nrql: query: \"SELECT average(duration) FROM Transaction WHERE appName = 'YOUR APP NAME'\" evaluationOffset: 3 enabled: true terms: - threshold: \"5\" threshold_occurrences: \"ALL\" threshold_duration: 180 priority: \"CRITICAL\" operator: \"ABOVE\" violationTimeLimit: \"ONE_HOUR\" valueFunction: \"SINGLE_VALUE\" Note: To receive notifications when an alert is triggered, you'll want to add notification channels to your alert policy. With the alert condition added to the configuration,  you can apply the update, which will create a NRQL alert condition and add it to your policy. kubectl apply -f ./new_relic_alert_policy.yaml To confirm the successful creation of the NRQL alert condition, refresh your alert policy. If you see a new alert condition added to the alert policy, it was a success. To finish things off,  create and add an alert channel to your alert policy. For example, maybe you want to send an email out to your team when your alert condition is triggered. What’s next? Nice work—now you can manage your New Relic alert policies and NRQL alert conditions with code that integrates seamlessly within your Kubernetes workflow. This allows you to configure and manage your alerts with a domain-specific pattern, providing consistency and maintainability. You also gain the benefits of code reviews for any potential changes moving forward. As you and your team progress, you may need to adjust some of the configuration values to better fit your needs. The New Relic Kubernetes Operator is just one of several tools in the New Relic Developer Toolkit aimed at facilitating observability as code. Check out the New Relic Kubernetes Operator and other tools to help automate your workflows at New Relic Open Source. Related Topics Kubernetes Monitoring By Sander Blue Sander is a Senior Software Engineer at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.51239,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How to Use the New Relic <em>Kubernetes</em> <em>Operators</em> for Parallel Deployment",
        "sections": "Add <em>NRQL</em> <em>alert</em> <em>conditions</em> to your <em>alert</em> policy",
        "body": " also configure the AlertsPolicy object using <em>NRQL</em> <em>alert</em> <em>conditions</em>. To configure a standalone New Relic <em>NRQL</em> <em>alert</em> condition and apply it to a pre-existing <em>alert</em> policy, you can use New Relic&#x27;s custom Alerts<em>Nrql</em>Condition object. Note: This post was written with the New Relic <em>Kubernetes</em> <em>Operator</em>"
      },
      "id": "607630e3e7b9d2705da5c672"
    },
    {
      "sections": [
        "Recommended ECS alert conditions",
        "Recommended alert conditions"
      ],
      "title": "Recommended ECS alert conditions",
      "type": "docs",
      "tags": [
        "Integrations",
        "Elastic Container Service integration",
        "Understand use data"
      ],
      "external_id": "334d80a75b3ef0a7b6125bf2a15f643ea46d7282",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/elastic-container-service-integration/understand-use-data/ecs-integration-recommended-alert-conditions/",
      "published_at": "2021-04-16T03:43:17Z",
      "updated_at": "2021-03-16T05:41:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's ECS integration reports and displays performance data from your Amazon ECS environment. This document provides some recommended alert conditions for monitoring ECS performance. Recommended alert conditions Here are some recommended ECS alert conditions. To add these alerts, go to the Alerts UI and add the following NRQL alert conditions to an existing or new alert policy: High CPU usage NRQL: FROM ContainerSample SELECT cpuUsed / cpuLimitCores Critical: > 90% for 5 minutes High memory usage NRQL: FROM ContainerSample SELECT memoryUsageBytes / memorySizeLimitBytes Critical: > 80% for 5 minutes Restart count NRQL: FROM ContainerSample SELECT max(restartCount) - min(restartCount) Critical: > 5 for 5 minutes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.58221,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Recommended ECS <em>alert</em> <em>conditions</em>",
        "sections": "Recommended ECS <em>alert</em> <em>conditions</em>",
        "body": " to the Alerts UI and add the following <em>NRQL</em> <em>alert</em> <em>conditions</em> to an existing or new <em>alert</em> policy: High CPU usage <em>NRQL</em>: FROM ContainerSample SELECT cpuUsed &#x2F; cpuLimitCores Critical: &gt; 90% for 5 minutes High memory usage <em>NRQL</em>: FROM ContainerSample SELECT memoryUsageBytes &#x2F; memorySizeLimitBytes Critical: &gt; 80% for 5 minutes Restart count <em>NRQL</em>: FROM ContainerSample SELECT max(restartCount) - min(restartCount) Critical: &gt; 5 for 5 minutes"
      },
      "id": "603e7eee64441f0f674e889f"
    },
    {
      "sections": [
        "Create NRQL alert conditions",
        "Tip",
        "Create a NRQL alert condition",
        "NRQL alert syntax",
        "Important",
        "Reformatting incompatible NRQL",
        "NRQL alert threshold examples",
        "Alert on specific segments of your data",
        "Alert on Nth percentile of your data",
        "Alert on max, min, avg of your data",
        "Alert on a percentage of your data",
        "Alert on Apdex with any T-value",
        "Alert conditions and query order of operations",
        "Example: null value returned",
        "Example: zero value returned",
        "Nested aggregation NRQL alerts",
        "Nested queries with a non-faceted innermost query are not currently supported",
        "Queries at all levels must have the same aggregation window size",
        "Signal loss is not yet supported for nested queries",
        "NRQL condition creation tips",
        "Alert threshold types",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Advanced signal settings",
        "Aggregation window",
        "Evaluation offset",
        "Fill data gaps"
      ],
      "title": "Create NRQL alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "2872f770a5fc8a802f99b9f848906f7e351ad761",
      "image": "https://docs.newrelic.com/static/eb8e1b2d826f9fd9cf46fe3dd5455217/c1b63/nr1_nrql_alert_conditions.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions/",
      "published_at": "2021-04-16T14:31:15Z",
      "updated_at": "2021-04-06T05:25:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use NRQL queries to create alert conditions. Once you've defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Click NRQL, and then Next, define thresholds. Tip For more information on key concepts relating to NRQL alert conditions and streaming alerts, see Streaming alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition for a policy: On one.newrelic.com, in the header click Alerts & AI, then in the left sidebar click Policies. Select an existing policy or click New alert policy to create a new policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define thresholds. NRQL alert syntax Here's the basic syntax for creating all NRQL alert conditions. The FACET clause is required for Outlier threshold types, optional for Static, and not allowed for Baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Copy Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount Tip If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Required for outlier conditions, but not baseline or static Include an optional FACET clause in your NRQL syntax depending on the threshold type: static, baseline, or outlier. Use the FACET clause to separate your results by attribute and alert on each attribute independently. No LIMIT clause is allowed, but all queries will receive the maximum number of facets possible. Faceted queries can return a maximum of 5000 values for static conditions and a maximum of 500 values for outlier conditions. Important If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values. Reformatting incompatible NRQL Some elements of NRQL used in charts don’t make sense in the streaming context of alerts. Here’s a list of the most common incompatible elements and suggestions for reformatting a NRQL alert query to achieve the same effect. Element Notes SINCE and UNTIL Example: SELECT percentile(largestContentfulPaint, 75) FROM PageViewTiming WHERE (appId = 837807) SINCE yesterday Copy NRQL Alerting produces a never-ending stream of windowed query results, so the SINCE and UNTIL keywords to scope the query to a point in time are not compatible. As a convenience, we automatically strip SINCE and UNTIL from a query when creating a NRQL Alert Condition from the context of a chart. TIMESERIES In NRQL queries, the TIMESERIES clause is used to return data as a time series broken out by a specified period of time. For NRQL alerts, the equivalent property of a signal is the aggregation window. histogram() The histogram() aggregation function is used to generate histograms. histogram() is not compatible with NRQL alerting: histogram aggregations can not be formatted as a time series. To create an alert from a portion of a histogram (e.g. 95th percentile), use the percentile() aggregation function. Multiple Aggregation Functions Each alert condition can only target a single aggregated stream of data. To alert on multiple streams simultaneously, you’ll need to decompose them into individual conditions within the same policy. Original Query: SELECT count(foo), average(bar), max(baz) from Transaction Copy Decomposed: SELECT count(foo) from Transaction SELECT average(bar) from Transaction SELECT max(baz) from Transaction Copy COMPARE WITH The COMPARE WITH clause is used to compare the values for two different time ranges. This type of query is incompatible with NRQL alerting. We recommend using a Baseline Alert Condition to dynamically detect deviations for a particular signal. SLIDE BY The SLIDE BY clause supports a feature known as sliding windows. With sliding windows, SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. Sliding windows are not currently supported in NRQL alerts. LIMIT In NRQL queries, the LIMIT clause is used to control the amount of data a query returns, either the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. LIMIT is not compatible with NRQL alerting: evaluation is always performed on the full result set. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) Copy SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Copy Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction Copy SELECT percentile(databaseDuration, 75) FROM Transaction Copy Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction Copy SELECT average(duration) FROM Transaction Copy Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction Copy SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Copy Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Copy Alert conditions and query order of operations By default, the aggregation window is 1 minute, but you can change the window to suit your needs. Whatever the aggregation window, New Relic will collect data for that window using the function in the NRQL alert condition’s query. The query is parsed and executed by our systems in the following order: FROM clause – which event type needs to be grabbed? WHERE clause – what can be filtered out? SELECT clause – what information needs to be returned from the now-filtered data set? Example: null value returned Let's say this is your alert condition query: SELECT count(*) FROM SyntheticCheck WHERE monitorName = 'My Cool Monitor' AND result = 'FAILURE' Copy If there are no failures for the aggregation window: The system will execute the FROM clause by grabbing all SyntheticCheck events on your account. Then it will execute the WHERE clause to filter through those events by looking only for the ones that match the monitor name and result specified. If there are still events left to scan through after completing the FROM and WHERE operations, the SELECT clause will be executed. If there are no remainig events, the SELECT clause will not be executed. This means that aggregators like count() and uniqueCount() will never return a zero value. When there is a count of 0, the SELECT clause is ignored and no data is returned, resulting in a value of NULL. Example: zero value returned If you have a data source delivering legitimate numeric zeroes, the query will return zero values and not null values. Let's say this is your alert condition query, and that MyCoolEvent is an attribute that can sometimes return a zero value. SELECT average(MyCoolAttribute) FROM MyCoolEvent Copy If, in the aggregation window being evaluated, there's at least one instance of MyCoolEvent and if the average value of all MyCoolAttribute attributes from that window is equal to zero, then a 0 value will be returned. If there are no MyCoolEvent events during that minute, then a NULL will be returned due to the order of operations. Tip For more information about this topic, you can check out our blog post on troubleshooting for zero versus null values. Tip You can determine how null values will be handled by adjusting loss of signal and gap filling settings in the Alert Conditions UI. Nested aggregation NRQL alerts Nested aggregation queries are a powerful way to query your data. However, they have a few restrictions that are important to note. Nested queries with a non-faceted innermost query are not currently supported Without a FACET, the inner query produces a single result, giving the outer query nothing to aggregate. If you're using a nested query, make sure your inner query is faceted. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu) ​​​​​ Copy Queries at all levels must have the same aggregation window size With an alert aggregation window of 1 minute, the inner query would produce two smaller windows of 30 seconds. In theory, these two windows could be aggregated by the outer query. However, this is not currently supported. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)​​ Copy Signal loss is not yet supported for nested queries For more information on signal loss, see NerdGraph API: Loss of signal and gap filling. NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. For details, see Description Query results Queries must return a number. The condition evaluates the returned number against the thresholds you've set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that violations for sporadic data, such as error counts, are closed when no signal is coming in. Tip To learn more about signal loss and how to request access to it, see this announcement. Advanced signal settings These settings give you options for better handling continuous, streaming data signals that may sometimes be missing. These settings include the aggregation window, the evaluation offset, and an option for filling data gaps. For more on using these, see Advanced signal settings. Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions don't affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type, except you can't use a FACET clause. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. Sum of query results (limited or intermittent data) Important Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. You can use loss of signal, aggregation duration, and gap filling settings to minimize these false notifications. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum and the preview chart will update accordingly. Set the loss of signal threshold Loss of signal occurs when no data matches the NRQL condition over a specific period of time. You can set your loss of signal threshold duration and and also what happens when the threshold is crossed. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Loss of signal is only available for NRQL conditions. You may also manage these settings using the GraphQL API (recommended), or the REST API. Go here for specific GraphQL API examples. Loss of signal settings: Loss of signal settings include a time duration and two possible actions. Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration Expiration duration is a timer that starts and resets when we receive a data point in the streaming alerts pipeline. If we don't receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. The loss of signal expiration time is independent of the threshold duration and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we recommend using at least 3-5 minutes. Loss of signal actions Once a signal is considered lost, you can close open violations, open new violations, or both. Close all current open violations: This closes all open violations that are related to a specific signal. It won't necessarily close all violations for a condition. If you're alerting on an ephemeral service, or on a sporadic signal, you'll want to choose this action to ensure that violations are closed properly. The GraphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to a loss of signal. Based on your incident preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we'll close all open violations first, and then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: For a policy, when you create a condition, under Select a product, click NRQL, then click Next, define thresholds. Write a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in minutes or seconds in the Signal is lost after field. Choose what you want to happen when the signal is lost. You can check one or both of Close all current open violations and Open new \"lost signal\" violation . These control how loss of signal violations will be handled for the condition. Make sure you name your condition before you save it. Tip Loss of signal detection doesn't work on NRQL queries that use nested aggregation or sub-queries. Advanced signal settings When creating a NRQL alert condition, the advanced signal settings gives you better control over streaming alert data and helps you avoid false alarms. When creating a NRQL condition, there are several advanced signal settings: Aggregation window Evaluation offset Fill data gaps To read an explanation of what these settings are and how they relate to each other, see Streaming alerts concepts. Below are instructions and tips on how to configure them. Aggregation window You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. You can set it to anything between one second and 15 minutes. The default is one minute. Tip Baseline alert condition thresholds don't support editing the aggregation window. They use the 1 minute default. Evaluation offset You can adjust the evaluation offset to coordinate our streaming alerting algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. The total supported latency is the product of the aggregation window duration multiplied by the evaluation offset. In the example screenshot above, the supported latency is 3 minutes (a 1-minute aggregation window multiplied by three windows). If the data type comes from an APM language agent and is aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3 with 1 minute aggregation windows. Important When creating NRQL conditions for data collected from Infrastructure Cloud Integrations such as AWS Cloudwatch or Azure, we recommend that you start with an evaluation offset of 15 minutes, then adjust up or down depending on how long it takes to collect your data. Fill data gaps Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with one of these settings: None: (Default) Choose this if you don't want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won't be in violation. Custom static value: Choose this if you'd like to insert a custom static value into the empty aggregation windows before they're evaluated. This option has an additional, required parameter of fillValue (as named in the API) that specifies what static value should be used. This defaults to 0. Last known value: This option inserts the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. Options for editing data gap settings: In the NRQL conditions UI, go to Condition settings > Advanced signal settings > fill data gaps with and choose an option. If using our Nerdgraph API (preferred), this node is located at: actor : account : alerts : nrqlCondition : signal : fillOption | fillValue NerdGraph is the preferred API but if you are using our REST API, you can find this setting in the REST API explorer under the \"signal\" section of the Alert NRQL conditions API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 64.228645,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "sections": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alert</em> <em>conditions</em>",
        "body": "You can use <em>NRQL</em> queries to create <em>alert</em> <em>conditions</em>. Once you&#x27;ve defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts &amp; AI"
      },
      "id": "603ef04864441fbc114e8883"
    },
    {
      "sections": [
        "Create baseline alert conditions",
        "How it works",
        "Set baseline thresholds",
        "Baseline rules and settings",
        "Rules governing creation of baseline",
        "Baseline direction: select upper or lower ranges",
        "Preview chart: select 2 or 7 days"
      ],
      "title": "Create baseline alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "a144b0cc3c5eed1c31dbfcd079959bbd5496346a",
      "image": "https://docs.newrelic.com/static/7ca56bff2292c37f14a7b98e3e919e36/c1b63/new-relic-alerts-baseline-thresholds.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions/",
      "published_at": "2021-04-16T14:30:10Z",
      "updated_at": "2021-03-13T05:42:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use baseline conditions to define violation thresholds that adjust to the behavior of your data. Baseline alerting is useful for creating conditions that: Only notify you when data is behaving abnormally. Dynamically adjust to changing data and trend s, including daily or weekly trends. In addition, baseline alerting works well with new applications when you do not yet have known behaviors. How it works When you choose a data source (for example, an APM metric) for a baseline condition, we'll use the past values of that data to dynamically predict the data's near-future behavior. The line of that predicted future behavior for that value is called a baseline. It appears as a dotted black line on the preview chart in the baseline condition UI. You'll use the baseline alert condition UI to: Adjust how sensitive the condition is to fluctuations in the data source. Set the behavior that will trigger a violation (for example: \"deviating for more than five minutes\"). Set whether you want the condition to check for upper violations, lower violations, or both. When your data escapes the predicted \"normal\" behavior and meets the criteria you've chosen, you'll receive a notification. Set baseline thresholds one.newrelic.com > AI & Alerts > Policies > (create or select policy) > Create alert condition: Baseline alert conditions give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline condition: When you start to create a condition, choose one of the following data sources: APM: Application metric baseline Browser: Metric baseline NRQL (and then choose a baseline type threshold) Here are some tips for setting baseline thresholds: Set the baseline direction to monitor violations that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for NRQL alert conditions.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline. The tighter the band around the baseline, the more sensitive it is and the more violations it will generate. Optional: You can create a Warning threshold (the darker gray area around the baseline). For NRQL alerts, see the allowed types of NRQL queries. If the alert condition applies to multiple apps, you can select a choice from the dropdown above the chart to use different metrics. (Not applicable for NRQL alert conditions.) Baseline rules and settings Here are some details about how the UI works: Rules governing creation of baseline The algorithm for baseline conditions is mathematically complex. Here are some of the major rules governing its predictive abilities: Data trait Baseline rules Age of data On initial creation, the baseline is calculated using between 1 to 4 weeks of data, depending on data availability and baseline type. After its creation, the algorithm will take into account ongoing data fluctuations over a long time period, although greater weight is given to more recent data. For data that has only existed for a short time, the baseline will likely fluctuate a good deal and not be very accurate. This is because there is not yet enough data to determine its usual values and behavior. The more history the data has, the more accurate the baseline and thresholds will become. Consistency of data For metric values that remain in a consistent range or that trend slowly and steadily, their more predictable behavior means that their thresholds will become tighter around the baseline. Data that is more varied and unpredictable will have looser (wider) thresholds. Regular fluctuations For shorter-than-one-week cyclical fluctuations (such as weekly Wednesday 1pm deployments or nightly reports), the baseline algorithm looks for these cyclical fluctuations and attempts to adjust to them. Baseline direction: select upper or lower ranges You can choose whether you want the condition to violate for behavior that goes above the baseline (\"upper\") or that goes below the baseline (\"lower\"), or that goes either above or below. You choose these with the Baseline direction selector. Example use cases for this: You might use the Upper setting for a data source like error rate, because you generally are only concerned if it goes up, and aren't concerned if it goes down. You might use the Lower setting for a data source like throughput, because sudden upward fluctuations are quite common, but a large sudden downswing would be a sign of a problem. Here are examples of how large fluctuations in your data would be treated under the different baseline direction settings. The red areas represent violations. Preview chart: select 2 or 7 days When setting thresholds, the preview chart has an option for displaying Since 2 days ago or Since 7 days ago. These selections are not the time period used to compute the baseline; they are only the time range used for a preview display. For more about the time range used to calculate the baseline, see the algorithm rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 59.31862,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create baseline <em>alert</em> <em>conditions</em>",
        "sections": "Create baseline <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alert</em> <em>conditions</em>",
        "body": " that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for <em>NRQL</em> <em>alert</em> <em>conditions</em>.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline"
      },
      "id": "6044095ee7b9d214955799e9"
    },
    {
      "sections": [
        "Streaming alerts: key terms and concepts",
        "Tip",
        "Why it matters",
        "Streaming alerts tools",
        "Loss of signal detection",
        "Gap filling",
        "Aggregation window",
        "Offset evaluation"
      ],
      "title": "Streaming alerts: key terms and concepts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Get started"
      ],
      "external_id": "1e971c3a992c0fed2c73d582fa78ee61dd369cbb",
      "image": "https://docs.newrelic.com/static/ee6e2e7f5d1fd4e68688994872aa6330/59000/streaming_alerts.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/get-started/streaming-alerts-key-terms-concepts/",
      "published_at": "2021-04-16T14:46:00Z",
      "updated_at": "2021-03-13T05:40:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The streaming alerts platform checks for violations based on data that’s present or missing in the stream of data coming into New Relic. The stream of data that comes into New Relic is called a signal. You can control what part of the signal is alerted on through NRQL conditions. These NRQL condition alerts are processed by the streaming algorithm. The NRQL query provides the signal filter for all of your incoming data. Tip You can read more about the streaming alerts platform in this Explorers Hub post. Why it matters Alerts violations are easy when they're caused by a specific event happening, but trickier when looking for events not happening. Only data that matches the conditions of the NRQL WHERE clause is alerted on. As data streams into New Relic, it's filtered by the NRQL condition. Before data is evaluated, it must meet the criteria defined by the NRQL query's WHERE clause. Instead of evaluating that data immediately for violations, the NRQL alert conditions collect the data over a period of time known as the aggregation window. An additional offset delay allows for slower data to come through before it's processed. Once the aggregation window plus the offset time have elapsed, New Relic groups the aggregated data into a single data point. Alerts then evaluates the data point using the NRQL condition in order to determine whether it meets the violation threshold criteria. Even if a data point meets the criteria for a violation, a violation isn't triggered. A violation is only triggered when data points consistently meet the threshold criteria over a period of time. This is the threshold duration. If the data points are in violation for an entire threshold duration, we'll send you a notification based on your policy settings. All of these configurable delays give you more control over how you're alerted on sporadic and missing data. Streaming alerts tools Streaming alerts provide a set of tools you can use to more effectively alert on your streaming data, giving you greater control and reducing the number of false alerts notifications. They are: Loss of signal detection Gap filling Aggregation window duration customization Offset evaluation Tip This article covers these tools at a conceptual level. You'll find direct instructions on how to use these tools in Create NRQL alert conditions. Loss of signal detection Loss of signal occurs when no data matches the NRQL condition over a specific period of time. A loss of signal is caused by different things. The WHERE clause in your NRQL query can filter out data before it's evaluated for violations. It could also mean a service or entity is offline or a periodic job has failed to run and no data is being sent to New Relic. In order to avoid unnecessary notifications, you can choose how long to wait before you're notified by a loss of signal violation. You can use loss of signal detection to open violations and be notified when a signal is lost. Alternately, you can use a loss of signal to close violations for ephemeral services or sporadic data, such as error counts. Gap filling Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with None, the last value received, or a static value. The default is None. Gaps in streaming data can be caused by network or host issues, a signal may be sparse, or some signals, such as error counts, may only have data when something is wrong. By filling the gaps with known values, the alert evaluation process can process those gaps and determine how they should affect the loss of signal evaluation. Aggregation window In order to make loss of signal detection more effective and to reduce unnecessary notifications, you can customize aggregation windows to the duration that you need. An aggregation window is a specific block of time. We gather data points together in an aggregation window, before using the aggregation function to evaluate the data. A longer aggregation window gives straggling data points more time to arrive before evaluating that data. When a data point arrives, its timestamp is used to put it in the proper aggregation window. You can set your aggregation window to anything between 1 second and 15 minutes. The default is 1 minute. Offset evaluation For data that consistently takes longer to arrive, you can use offset evaluation to consistently delay the NRQL condition evaluation. Waiting longer increases accuracy, but also increases latency. The offset time value is the number of aggregation windows you want to use. The duration for each window is set in the Aggregation window field. For example, if your aggregation window is 1 minute and your Offset evaluation is 3, then a straggling data point will have about 3 minutes to arrive before it might be dropped. In other words, streaming alerts will always keep 3 aggregation windows in the queue, waiting 1 minute before evaluating each window and adding a new one. The current default is 3.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 59.3183,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Streaming <em>alerts</em>: key terms and concepts",
        "sections": "Streaming <em>alerts</em>: key terms and concepts",
        "tags": "<em>Alerts</em> and Applied Intelligence",
        "body": ". Instead of evaluating that data immediately for violations, the <em>NRQL</em> <em>alert</em> <em>conditions</em> collect the data over a period of time known as the aggregation window. An additional offset delay allows for slower data to come through before it&#x27;s processed. Once the aggregation window plus the offset time have"
      },
      "id": "604427ca28ccbc87142c60a5"
    }
  ],
  "/automate-workflows/diagnose-problems": [
    {
      "sections": [
        "データエクスプローラーの概要",
        "ヒント",
        "重要な理由",
        "データのクエリ",
        "データエクスプローラーを使用する",
        "イベントを詳しく調べる",
        "メトリックスを詳しく調べる",
        "重要",
        "調査を可視化し絞り込む",
        "クエリエリア",
        "NRQLクエリ表示",
        "チャートエリア",
        "共有してエクスポート",
        "使用事例",
        "新規データを確認",
        "データを検証",
        "データの問題のトラブルシューティング",
        "その他のヘルプ"
      ],
      "title": "データエクスプローラーの概要",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "94545f74e5fd5ab0b18f47342f7a8f2a2fa82558",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-16T15:16:11Z",
      "updated_at": "2021-04-12T03:13:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データエクスプローラーを使用すれば、NRQLの知識がなくても、すべてのデータを視覚的に操作できます。データエクスプローラーを使用してデータにアクセスしクエリやカスタマイズ、視覚化を行い、サービスとサービスをつなぎ、一貫したキュレート済みの体験を実現します。 ヒント データエクスプローラー、およびその他のオブザーバビリティ プラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 システムの状態を調査しますか？リソースの計画を作成し、インシデントを特定しそれに対応し、動作不良のトラブルシューティングを行う必要がありますか？データエクスプローラーにより、NRQLを使用したりクエリを構築せずに、視覚的なメニューを通じて、探しているデータを簡単に特定、取得し、視覚化できます。 データエクスプローラーを使用して、次のことを行えます。 イベントやメトリックスデータに、迅速で直感的な方法でアクセスする。 視覚化し簡単に実行できるようにして、データのディメンションを詳しく調べる。 さまざまな観点からデータを把握する：生データや、進歩や配信などについての知見を提供するさまざまな視覚化。 フィルターによりデータを掘り下げる。 1回のクリックで検索をダッシュボードに追加する。 NRQLのしくみについて理解する: データエクスプローラーは、利用可能なデータを検索している間にクエリがどのように構築されるかを示します。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 データのクエリ データエクスプローラーにアクセスするには、one.newrelic.comに移動し ページの上部にあるデータをクエリアイコンをクリックします。 データのブラウズドロップダウンで、イベントまたはメトリクスを選択します。 データエクスプローラーは、New Relicにあるすべてのデータを詳しく調べるためのポータルです。データエクスプローラーUIにあるイベントやメトリックスを詳しく調べたり、LogsやTracesアプリを選択して詳しく調べることができます。また、タブをクリックして、いつでもクエリビルダーにアクセスすることもできます。 データエクスプローラーを使用する データエクスプローラーは、上部にある範囲絞り込みセクション（a）、左側のデータブラウジングエリア（b）、ワークスペース（c）で構成されます。 データエクスプローラーを使用するには： 調べる範囲を定義する：ブラウズするアカウントとデータタイプ（メトリックまたはイベント）を選択します。 タイムピッカーを使用して時間範囲を選択します。 左側のブロックを使用して、イベントかメトリックスのいずれかについて使用可能なデータをブラウズし、検索を作成します。1ブロックにつき1つの要素しか選択できません。ブロックは検索可能です。 イベントを詳しく調べる イベントタイプ 選択したアカウントで使用できるすべてのイベントを表示します。 デフォルトでは、イベントは名前で並び替えられます。 プロット 以前選択したイベントのすべての数字属性を表示します。 リストの最初の項目はcount( * )で、これは属性ではありません。選択したイベントの数を計算します。 デフォルトでは、属性は名前で並び替えられます。 プロットする関数を選択します。デフォルトでは、各属性は関数Averageに設定されます。 ディメンション 以前選択したイベントとプロットのすべてのディメンションを表示します。 ディメンションは、イベントについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 メトリックスを詳しく調べる APM 時間区切りデータを調べるには、AppID、AppName、またはEntityGuidをステップとして選択します（またはそれらのステップでグループ化します）。それ以外の場合は、すべてのエンティティの集計データを取得します。 メトリック 選択したアカウントで使用できるすべてのメトリックスを表示します。 デフォルトでは、メトリックスは名前で並べ替えられます。 ディメンション 以前選択したメトリックのすべてのディメンションを表示します。 ディメンションは、メトリックについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 重要 ユニットの表示には、メトリックシステム（メトリックSIプレフィックスを含む）が使用されています。 調査を可視化し絞り込む 調査の結果は、右側のワーキングスペースに表示されます。 調査を絞り込むか、チャートを共有する ワーキングスペースには、次のものが表示されます。 クエリエリア クエリエリアでは、クエリを異なる構成要素に分解します。ここで、NRQLクエリとして調査の結果を簡単に読み、プロットしている正確なデータをチェックできます。 NRQLに習熟していない場合、このエリアをチェックしクエリの作成方法について学習します。 クエリの別の部分は次のとおりです。 [ イベントのみ]FROM: 最初のブロックで選択したイベント。 SELECT: 選択したプロットまたはメトリック。この入力では、1つの値と1つの関数のみをプロットします。 GROUP BY: FACET句を表し、選択したディメンションごとにデータをグループ化します。 LIMIT: 表示する値の量を入力します。 WHERE: このフィールドを使用して、結果にさらにフィルターを適用します。この入力では、n値をプロットします。 各項目は、xをクリックしてクエリから削除できます。 NRQLクエリ表示 上記のフィールドと、タイムピッカーで選択した時間範囲で構成される、完全なクエリを表示できます。 ヒント より詳細な検索を行う、またはチャートをカスタマイズする必要がある場合データエクスプローラーから、クエリビルダーにアクセスしてクエリを編集できます。 チャートエリア デフォルトでは、データは線チャートで表示されます。チャートピッカーを使用して、面グラフ、円グラフ、およびバーチャートに簡単に切り替えることができます。結果の生データをテーブルまたはJSON形式として表示することもできます。 ディメンションを選択している場合、チャートは異なるファセットで更新されます。チャートの下に、ファセットのリストとそれぞれの値があるファセットの表が表示されます。 ファセットテーブルを使用して、データをドリルダウンします。クリックしたファセットはフィルターとして適用されます。表は表示されたままなので、別のファセットを簡単に選択して調査を続けることができます。 共有してエクスポート 右上にあるオプションメニューを使用して、チャートを画像として取得、またはリンクとして共有、ダッシュボードに追加できます。 また、URLをコピーし、その他のNew Relicユーザーと調査全体を共有することもできます。 使用事例 次の例で、データエクスプローラーをいつどのように使用するかについて学習してください。 新規データを確認 新規インストゥルメンテーションに接続したばかりで、新規データを利用できるかどうか確認したいと思っています。 アカウントとイベント、または新規データを生成しているメトリックを選択します。 データエクスプローラーで別のツールを使用して、利用できるようになった新規データを使ってみる：そのイベントまたはメトリックの生データを表として見る、またはリストとする、またはクリックしてチャートとしてプロットされることを確認します。 イベントやメトリックを選択した後、ディメンションでデータの形状を確認します。濃度を使用して、あらゆるデータの異なる視点を確認できます。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 データを検証 カスタムイベント/メトリックを変更したので、この変更が正常に行われたかどうかをチェックする必要がある。 データエクスプローラータブで、変更したアカウントとデータタイプ、イベント/メトリックを選択します。 エンティティがデータをレポートしていることと、すべての属性がプロットされていることを確認します。 変更した属性を検索し、更新が正常に行われたことをチェックします。 データの問題のトラブルシューティング アラートやダッシュボードからのイベント/メトリックで何か問題があることが分かっている。イベント/メトリック属性の動作について、根本原因を知る必要がある。 データエクスプローラーで、メニューを使用して、想定どおりに動作していないイベントやメトリックを選択し、データエクスプローラーでそのチャートをプロットします。 そこから、そのデータのディメンションを掘り下げて、関連する属性によりフィルターを適用できます。 また、次のような異なる観点からそのデータを把握することもできます：分布や値の順位、経時進化。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 59.27971,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "605343b4196a6754132d166e"
    },
    {
      "sections": [
        "ダッシュボード入門",
        "ヒント",
        "重要な理由",
        "New Relic全体にまたがるダッシュボードを表示する",
        "ダッシュボードの使用を開始",
        "ダッシュボードの作成",
        "ダッシュボードのクローンを作成",
        "ダッシュボードの削除",
        "ダッシュボードにお気に入りの印を付ける",
        "ダッシュボードの検索と並び替え",
        "ダッシュボードのアクセス許可",
        "タグを使用してダッシュボードを整理する",
        "主要な視覚化ツール",
        "一貫したチャートの色",
        "関連するニードル",
        "データスクラバー",
        "拡大ブラシ",
        "カスタムの可視化",
        "その他のヘルプ"
      ],
      "title": "ダッシュボード入門",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "36da9a58bf388d15522c769ef3ad709550eee043",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-04-17T03:24:45Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データを道路の複雑なシステムとして捉える：道路の標識や信号に従い運転し、収集する情報の意味を迅速に把握し実行する必要があります。New Relic Oneダッシュボードは、New Relicプラットフォームのあらゆる場所から、表示したい特定のデータを収集して、お望みの方法でチャートを作成します。 ヒント ダッシュボードとその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 New Relic Oneダッシュボードを使用して、収集するデータをカスタマイズして理解できます。カスタマイズされたユーザーフレンドリーなチャートでデータを詳しく調べ、つながりのあるソースの相関性を導き、システムとアプリケーションの状態を素早く理解することで、より迅速かつ効率的なトラブルシューティングを行います。 ダッシュボードを利用して、次のことを行います： 一貫したUIによるカスタムの高密のインタラクティブな可視化により、知見を深める。 プラットフォームのどこからでも、すべてのイベントと属性のチャートを作成する。詳細については、デフォルトのデータ収集に関する弊社のドキュメンテーションを参照してください。 カスタム属性の追加またはカスタムイベントタイプの送信を大半のイベントに対して行います。これにより、貴社のビジネスへの理解力を高め、ページビュー数やホストトランザクションなど、顧客とプラットフォームのインタラクションに関する具体的なポイントを確認できます。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度な補足説明機能とズームイン機能でデータの探索とコンテキスト化を行い、貴社システムのリアルタイムのアクティビティをモニターできます。 ダッシュボードで属性とメトリックスを検索します。 APIを使用してダッシュボードにデータを送信します。 New Relic全体にまたがるダッシュボードを表示する New Relic Oneのダッシュボードには、元々のNew Relicプラットフォームとの完全な下位互換性が備わっているため、Insightsで作成した全てのダッシュボードがダッシュボードで自動的に利用できるようになります。つまり、新たにダッシュボードを追加すると、Insightsでも作成されます。追加の設定は必要ありません。New Relic Oneでは、クロスアカウント検索を利用することで、組織全体にまたがるダッシュボードを表示できます。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 ダッシュボードの使用を開始 ダッシュボードにアクセスするには、one.newrelic.comに移動し、ナビゲーションメニューの上部にあるダッシュボードをクリックします。 ダッシュボードの索引で、New Relicアカウントに関連するすべてのダッシュボードとデータアプリを表示できます。これには、New Relic Oneプラットフォーム内で作成したダッシュボードと、Insightsで構築したダッシュボードが含まれます。 上部のバーから、エンティティエクスプローラーや、APMやBrowser、Infrastructure monitoring、Logs、インテリジェンスの応用などすべてのNew Relic機能に迅速にアクセスします。また、プラットフォーム全体で使用できるデータの検索やクエリなどのNew Relic Oneの中心的な機能も使用できます。 各ダッシュボードで、索引に次の情報が表示されます： 星で表される、お気に入りのステータス 名前：ダッシュボードの名前 アカウント：ダッシュボードが属するアカウント 作成者：ダッシュボードを作成したユーザー 最終編集日時：直近のダッシュボード変更の日時 作成日時：ダッシュボードの作成日時： 次のアクションを行えます： ダッシュボードの作成 ダッシュボードの索引の右上隅にある+ダッシュボードを作成ボタンを選択して、ダッシュボードからNew Relic Oneでダッシュボードを作成できます。 ダッシュボードに名前を付ける名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前（例として、サービスやアプリケーション）を付けることを推奨します。 ダッシュボードが属するアカウントを選択します。このアクションは変更できないため、慎重に選択してください。 作成を押して続けるか、キャンセルを押して索引に戻ります。 ヒント デフォルトでは、ダッシュボードはパブリック - 読み取りと書き込み許可で作成されます。ダッシュボードにアクセスした後、設定メニューから編集できます。 または、次のように新規のダッシュボードを作成することもできます： 既存のダッシュボードのクローンを作成して。 チャートから：チャートを任意のダッシュボードから新規または既存のダッシュボードにコピーします。 データエクスプローラーまたはクエリビルダーから: クエリ機能から作成したチャートを、新規または既存のダッシュボードに追加します。 エンティティエクスプローラーから：エンティティマネージャからダッシュボードにカスタムで表示を行います。 複数のページでダッシュボードを整理するには、ダッシュボードにページを追加します。 ダッシュボードのクローンを作成 索引のダッシュボード行の上にカーソルを移動すると表示されるダッシュボードのクローンを作成ボタンをクリックして、ダッシュボードのクローンを作成します。許可のレベルにかかわらず、あらゆるダッシュボードのクローンを作成できます。 ダッシュボードは自動的にコピーされ、クローンが索引に追加されます。画面にポップアップ表示されるメッセージをクリックして、新規ダッシュボードにアクセスします。 クローン版のダッシュボードには、元のダッシュボードの名前の後に「copy」が付けられます。たとえば、this is my dashboardという名前のダッシュボードのクローンを作成すると、クローンはthis is my dashboard copyとして作成されます。クローンの許可は、パブリック - 読み取りと書き込みとなります。 ダッシュボードの名前や許可などのその他のプロパティは、いつでも編集できます。 ヒント 索引には、並べ替えに従いダッシュボードが表示されます。クローン版のダッシュボードを迅速に検索するには、作成日でダッシュボードを並び替えます。新規のダッシュボードが先頭に表示されます。 ダッシュボードの削除 ダッシュボードを削除するには、削除ボタンが表示されるまで、索引のダッシュボード行の上にカーソルを移動します。自身で作成した場合、または許可がパブリック - 読み取りと書き込みの場合しか、ダッシュボードは削除できません。詳しくは、許可についての情報を参照してください。 ダッシュボードの設定パネルから、ダッシュボードを削除することもできます。 ダッシュボードにお気に入りの印を付ける ダッシュボードの隣にある星のアイコンをクリックすると、お気に入りがオンとオフで切り替わります。ダッシュボードをお気に入りにすると、リストの先頭にあるその他のお気に入りのダッシュボードと同じグループに入り、New Relic Oneのホームページで表示されます。 お気に入りからダッシュボードを削除するには、星のアイコンをもう一度選択します。 New Relic Oneは、Insightsからお気に入りのダッシュボードを取得しません。InsightsからNew Relic Oneへの移行の方法をご覧ください。 ダッシュボードの検索と並び替え 索引の上にある検索ボックスを使用して、ダッシュボード名と作成者別に、ダッシュボードの検索を行えます。 索引でダッシュボードの並べ替えも行えます。デフォルトでは、直近に編集したダッシュボードが、お気に入りとお気に入り以外のセクションの両方で、索引の先頭に表示されます。この順序を変更するには、索引の任意の列で両方のセクションを並べ替えると、直近の並べ替えの結果が、次回New Relic Oneにアクセスした際に表示されます。 ダッシュボードのアクセス許可 ダッシュボードには、次の3種類の権限があります。 パブリック - 読み取りと書き込み: すべてのユーザーが、ダッシュボードに対し完全な権利を有します。 パブリック - 読み取りのみ: すべてのユーザーはダッシュボードを表示できますが、ダッシュボードで作業を行う完全な権利を有するのはあなただけです。他のユーザーはダッシュボードにアクセスし、クローンを作成できますが、編集や削除はできません。 プライベート: ダッシュボードを表示できるのはあなただけです。 ダッシュボードを作成ボタンを使用して、または別のダッシュボードのクローンを作成してダッシュボードを作成すると、デフォルトでパブリック - 読み取りと書き込みの権利が付与されます。新規ダッシュボードにアクセスして、この設定を変更します。 タグを使用してダッシュボードを整理する タグ作成APIであるNerdGraphを使用して、タグを追加できます。 タグ別にダッシュボードをフィルターすることもできます。これによってユーザーアカウントやロケーションなどを特定できます。タグフィルターをクリックして使用可能なタグを表示すると、リストから1つ以上のタグを簡単に選択して、索引でダッシュボードを絞り込むことができます。 主要な視覚化ツール ダッシュボードには、詳細なデータ検索や迅速なトラブルシューティングのための、分かりやすい視覚化機能とツールが備わっています。 一貫したチャートの色 データやファセットをすぐに表示し関連付け、ダッシュボードで1つ以上のチャートに適用し、すべてのチャートでファセットの色を一貫したものにできます。 関連するニードル マウスをチャートの上に移動すると、関連するニードルが、同時にダッシュボードのすべてのチャートやデータポイントに重なって表示されます。ツールチップには、線チャートの最大値や最小値など、選択したファセットからの関連データポイントが記載されています。また、パイチャートで選択した属性をハイライト表示します。 データスクラバー チャートスクラバーを使用して、チャートが密集しており、ファセット間の距離が非常に近い場合に、チャートでデータポイントやファセットを選択できます。 マウスをニードルの側に移動し、隣にあるファセットをスムーズに選択し、関連するデータポイントを表示します。また、UIに表示される1つ以上の属性の選択を解除して、投入データの多いチャートのデータ投入を減らすこともできます。 拡大ブラシ ドラッグしてチャート上の時間セグメントを選択すると、ダッシュボードのすべてのチャートでその期間が自動的に拡大されます。 タイムピッカーは、ダッシュボードに表示される新規の期間を反映します。いつでもデフォルトやその他の時間設定に戻ることができます。 カスタムの可視化 ダッシュボードにカスタムの可視化を行うこともできます。これにより、データソースからの情報を含めることができるようになります。カスタムの可視化の詳細については、ダッシュボードのカスタムの可視化とダッシュボードにカスタムの可視化を追加をご覧ください。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 48.163956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053433228ccbcdc10c2fd60"
    },
    {
      "sections": [
        "ダッシュボードの管理",
        "ダッシュボードのカスタマイズ",
        "ヒント",
        "ダッシュボードを編集する",
        "設定メニュー",
        "TVモード",
        "ダークモード",
        "ダッシュボードをエクスポートする",
        "新規コンテンツをダッシュボードに追加する",
        "マークダウンエディタを使用して、カスタムコンテンツを追加する。",
        "ページのあるダッシュボードを整理する",
        "ページをダッシュボードに追加し編集する",
        "チャートとマークダウンコンテンツを管理する",
        "重要",
        "チャートにフィルターを適用して絞り込む",
        "チャート凡例を使用してフィルターを適用する",
        "ファセットを使用してダッシュボードにフィルターを適用する",
        "タイムピッカーを使用して時間設定を変更する",
        "データをエクスポートし共有する",
        "その他のヘルプ"
      ],
      "title": "ダッシュボードの管理",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d5e5a7705eda167da4867960df29bd237535a8e5",
      "image": "https://docs.newrelic.com/static/129e7a553450c47847a969c79a2f7f89/c1b63/Dashboards_conf.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-04-17T02:37:22Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneダッシュボードにアクセスし、チャートメニューから直接チャートを作成または管理し、ダッシュボードのレイアウトをカスタマイズし、表示モードを調整し、データのエクスポートを行います。 ダッシュボードをカスタマイズし、チャートを構築したら、データを詳しく知るための高度な視覚化機能とツールを使用して、データを関連付け分析します。 ダッシュボードのカスタマイズ ダッシュボードは非常に柔軟な設定となっています。ダッシュボードのレイアウトをカスタマイズし、チャートのサイズを調整してデータの表示方法を最適化できます。 ヒント をクリックして、メタデータを表示しタグを管理モーダルにアクセスします。ここで、ダッシュボードのガイドやアカウントID、アプリIDを表示し、ダッシュボードに追加されたすべてのタグを管理できます。 ダッシュボードには、次の機能が含まれます： ダッシュボードを編集する 編集 ボタンを使用して次のことを行う: ダッシュボードの名前を変更する。名前は検索可能なため、意味のある名前を付けることを推奨します。 ウィジェットを追加ボタンをクリックして、新規コンテンツを作成する。クエリビルダーを使用して新規チャートを追加する、またはマークダウンエディタを使用してテキストや画像、リンクを追加する。 新規ページを追加する。ページを使用して、ダッシュボードをより整理できます。 チャートのサイズと範囲を変更する。チャートを移動し、ダッシュボードのどこにも置くことができるため、お好みに合わせてレイアウトを設定します：関連性の高いチャートを上部に置いたり、あまり使用しないチャートを角に配置します。最大で12列のチャートを設定できます。 設定メニュー 右上にある設定メニューを使用します。 ダッシュボードの名前を変更する。名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前を付けることを推奨します。 ダッシュボードの許可を変更する。 設定メニューで、ダッシュボードの作成時期とダッシュボードに属するアカウントも表示できます。この値は変更できません。 TVモード テレビ画面での表示向けにダッシュボードを最適化する、全画面のTVモードを有効にできます。 TVモードを有効にするには、次の2つの方法があります。 New Relic Oneでダッシュボードを表示している際に、右上の アイコンを選択します。 このパラメーターをダッシュボードのページのURLに追加します：&platform[tvMode]=true TVモードを設定するには、ダッシュボードから アイコンを選択します。オプションに含まれるもの： ダッシュボード名が表示されます。 ダッシュボード名をオフにすると、画面上でダッシュボードのチャートのスペースが増えます。 ページの切り替え。 複数のページのあるダッシュボードでは、これによりページが自動的に切り替わります。 ダークモード 高コントラストモードを、ダッシュボードで使用できます。 アイコンを、右上のメニューバーから選択します。 ダッシュボードをエクスポートする アイコンをクリックして、PDFファイルとしてダッシュボードをエクスポートできます。 ヒント いつでも検索機能を使用して、New Relic One全体でデータを検索できます。 新規コンテンツをダッシュボードに追加する 複数の方法で、ダッシュボードに新規コンテンツを追加できます： データエクスプローラーおよびクエリビルダー機能から。 + ダッシュボードに追加ボタン（メインのダッシュボードのページから、または編集モードでアクセス可能）を使用して、クエリビルダーにアクセスするか、マークダウンエディタを使用してコンテンツ（テキストやリンク、画像など）を追加する。 ダッシュボードから既存のチャートをコピーする。 マークダウンエディタを使用して、カスタムコンテンツを追加する。 マークダウンエディタには、コンテンツを入力するマークダウンペインや、表示するプレビューペインが含まれます。マークダウン構文オプションの詳細については、Commonmarkのウェブサイトをご覧ください。 マークダウンウィジェットの楕円 アイコンをクリックし、編集をクリックして、既存のコンテンツを編集することもできます。 ページのあるダッシュボードを整理する 複数のページを使用して、さまざまな表示でダッシュボードを整理できます。ページをそのダッシュボードに追加すると、ダッシュボードUIの上部にあるタブを使用して、そのページにアクセスできます。 one.newrelic.com > Dashboards: ダッシュボードの上部にあるタブで表示された、複数のページのあるNew Relic Oneのダッシュボードの例は次のとおりです。ページをダッシュボードに追加し、既存のページをコピーし、ページタブを新たな位置にドラッグしてドロップできます。 この機能を使用して、関連するダッシュボード表示をグループ化できます。これは、特定のプロジェクトやチーム、主題に関連する多くのデータとチャートを集計する際に有用です。 たとえば、モバイルアプリチームは、国ごとにアプリのパフォーマンスに重点を置いたダッシュボードを構築できます。最初のダッシュボードのページを、すべての国のパフォーマンスの概要とし、その他のページで特定の国を取り上げることができます。 当社では、ダッシュボードをつなぐその他の機能を提供しています。 マークダウンテキストを含むウィジェットを作成して、特定のUIページやダッシュボードへのダイレクトリンクを追加します。 ファセットによるフィルタリングを使用して、自動的にその他のダッシュボードにリンクしフィルタリングを行うリンクを作成します。 ダッシュボード検索を使用して、似た名前のダッシュボードを検索します。この機能を活用して、チームやプロジェクトに固有の語句をダッシュボード名に追加できます。 New Relic Insightsでは、この機能はデータアプリと呼ばれていました。InsightsからNew Relic Oneの切り替えの詳細については、移行ガイドをご覧ください。 ページをダッシュボードに追加し編集する ページをダッシュボードに追加、またはページを編集するには： 新規または既存のダッシュボードで、 アイコンを選択して編集モードで入力します。 新規ページを追加する： ページを追加を選択して空白のページを追加します。 ダッシュボード名の隣にあるドロップダウンをクリックし、複製を選択して、既存のページのクローンを作成します。 編集モードの間、新規ページにウィジェットを追加し、ページタブを新たな場所にドラッグしてドロップしたり、その他のダッシュボード編集タスクを行えます。 終了したら、編集を完了を選択します。 チャートとマークダウンコンテンツを管理する マークダウン要素から、右上隅にあるアクセスメニューにアクセスし、編集または削除を行います。チャートから、右上角のチャートアクションメニューにアクセスし、次のことを行います。 チャートを全画面に拡張する。 画像として、またはリンクを付けてチャートを共有する。 チャートをダッシュボードにコピーする。 クエリビルダーにアクセスし、チャートに関連したクエリを表示または編集する。 チャートを削除する。 重要 ダッシュボードに対する許可が読み取り専用の場合、チャートのクエリは編集できません。 詳細については、チャートの使い方をご覧ください。 チャートにフィルターを適用して絞り込む フィルタリング機能を使用して、ディスプレイで情報を絞り込むことができます。この機能は、クエリ条件を視覚的に表すものです。 フィルターバーを使用して、表示する値や属性を選択し、チャートから残りの要素を削除する。 高度なフィルターバーを開いてboolean演算子（=、!=、CONTAINS、EXCLUDESなど）にアクセスし、データのフィルタリングのための複雑で組み合わされた条件を追加する。 フィルターを適用後、ダッシュボードには、選択した要素に関連するデータのみが表示されます。小さなカウンターは、1回にいくつのフィルターが適用されているかを表します。 デフォルト表示に戻るには、フィルターの横にある小さなXをクリックして削除します。 チャート凡例を使用してフィルターを適用する 凡例のついたチャートで凡例をクリックして、その系列のみを表示し、チャートから残りのものを削除します。これにより、分析するデータを隔離できます。 反対の動作では、CMD（Macの場合）またはCTRL（Windowsの場合）を使用します。選択した系列を削除し、残りを保存します。 ファセットを使用してダッシュボードにフィルターを適用する チャートのNRQLクエリにFACET句が含まれる場合、ファセットのついた属性を使用して、現在のダッシュボードまたは別の関連するダッシュボードにフィルターを適用できます。詳細については、ファセットによりフィルターを適用するをご覧ください。 タイムピッカーを使用して時間設定を変更する デフォルトでは、ダッシュボードの各チャートには、クエリビルダーで作成時に指定された期間のデータが表示されますが、タイムピッカーを使用して表示されるデータの時間範囲を変更し、すべてのチャートに同じ範囲を設定できます。これは、データを絞り込み特定の期間に何が発生したかを観察する必要がある場合、インシデントのトラブルシューティングの間に特に有用です。 更新率は、表示中の期間の長さにより異なります。将来と例については、チャートの更新間隔をご覧ください。 時間範囲を変更するには： ドロップダウンメニューから、利用可能なオプション（直近30分から直近7日まで）を1つ選択します。 カスタムメニューを使用して、特定の開始および終了タイムスタンプで時間範囲をカスタマイズします。 重要 ダッシュボードでは、Insightsとは異なり、タイムゾーンはお使いのノートパソコンの時間とは関連していません。タイムピッカーのカスタムメニューから簡単にアクセスできるユーザー設定で、使用するタイムゾーンを設定できます。 データをエクスポートし共有する 社内外でダッシュボードとチャートデータをエクスポートし共有することは、非常に簡単です。 右上のメニューバーにあるPDFとしてダッシュボードをエクスポートボタンを使用して、PDFファイルとしてダッシュボードをエクスポートできます。 チャートをPNG画像またはリンクとして共有することもできます。チャートメニューに移動し、画像として取得またはチャートリンクを取得オプションのいずれかを選択します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 48.163956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053437b196a67a8322d1626"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Tip",
        "Why it matters",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "8f390d6aa6f57d215b3c23f8cf08c02ef310bddc",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-17T02:08:27Z",
      "updated_at": "2021-03-16T11:03:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Tip To use the data explorer and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces apps to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From data explorer you can access query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 44.379883,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the data <em>explorer</em>",
        "sections": "Introduction to the data <em>explorer</em>",
        "tags": "<em>Explore</em> and query data",
        "body": " icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to <em>explore</em> all the data you have in New Relic. You can <em>explore</em> events and metrics on the data explorer UI, or select the Logs and Traces apps to <em>explore</em> those. You can also access the query builder any time"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    },
    {
      "sections": [
        "Data explorer: Query and chart event data",
        "Important",
        "Events vs metrics",
        "UI components",
        "Data samples",
        "Caution"
      ],
      "title": "Data explorer: Query and chart event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Use Insights UI",
        "Explore data"
      ],
      "external_id": "72a23b59b41a3cb521c184c24603d50c28cffdb1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/explore-data/data-explorer-query-chart-event-data/",
      "published_at": "2021-04-16T03:05:44Z",
      "updated_at": "2021-03-30T08:43:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you explore the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs metrics In New Relic Insights, the Data explorer page has two tabs: Events: In the context of the Insights UI, this refers to any data that can be queried via NRQL. This includes all our major data types, including events and the Metric, Log, and Span data types. Metrics: In the context of the Insights UI, this refers to metric timeslice data. (Note that metric timeslice data is available for querying with NRQL in New Relic One.) For an improved querying and charting experience, we recommend using New Relic One chart builder and dashboards. UI components Use the Events data explorer to view and explore the data available to you. The UI includes: A dropdown that lets you select a data type, like PageView or Transaction. A time-based chart for that data. A sample of that data type, showing its attached attributes, and the ability to see other samples. Ability to search by group by and search for specific attributes. Data samples The most recent sample for the chosen data type is listed at the bottom of the page. Default attributes are underlined. To see more samples, select See more samples. You may need to scroll left and right to see the full table of data. Caution The amount of data stored for a given event type can run into the hundreds of thousands, or even millions, of records. This report only shows a small sample. Use this UI to review the structure of the data, not the contents of a specific record. For example, you can use it to make sure an attribute is populating properly.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 39.58773,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data <em>explorer</em>: Query and chart event data",
        "sections": "Data <em>explorer</em>: Query and chart event data",
        "tags": "<em>Explore</em> data",
        "body": " our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you <em>explore</em> the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs"
      },
      "id": "6043efa0e7b9d2b78d5799d2"
    }
  ],
  "/automate-workflows/get-started-terraform": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/07-saturation-condition-1024x558.png",
      "url": "https://newrelic.com/blog/how-to-relic/observability-as-code-new-relic-terraform-provider",
      "sections": [
        "About the Terraform New Relic provider",
        "Before you begin",
        "Step1: Initialize your working folder",
        "Step 2: Provision an alert policy resource",
        "Step 3: Provision alert conditions based on the four golden signals",
        "1. Latency",
        "2. Traffic",
        "3. Errors",
        "4. Saturation",
        "Linking a notification channel",
        "Observability as code in practice"
      ],
      "published_at": "2021-04-16T04:24:42Z",
      "title": "Practicing Observability as Code: Defining New Relic Alert Policies with Terraform",
      "updated_at": "2021-04-14T00:08:56Z",
      "type": "",
      "external_id": "f6ed141e784fb49eb7e1a31fe5752bf78186209c",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Practicing Observability as Code: Defining New Relic Alert Policies with Terraform Apr 6, 2020 • 11 min read By Chris Trombley Observability is an essential part of operating modern, complex architectures. But building an observability system that consumes a wide breadth of data from numerous data sources to drive alerts with a high signal-to-noise ratio can be overwhelming. Furthermore, maintaining such configurations manually across a large organization with distributed teams creates the potential for human error and configuration drift. A ThoughtWorks Technology Radar report suggested software teams treat “observability ecosystem configurations” as code—making observability as code an important practice for any teams adopting infrastructure as code (IaC) for their monitoring and alerting infrastructure. At New Relic, we believe that observability as code through automation is a best practice, and recommend a single source of truth for observability configurations. In this blog post, we’ll use the IaC tool Terraform and the New Relic Terraform provider to practice observability as code. We’ll use the provider to create a monitoring and alerting configuration for a sample application based on the four golden signals of monitoring introduced in Google’s Site Reliability Engineering book: Latency: Measures the amount of time it takes your application to service a request. In other words, how responsive is your application? Traffic: Measures how much demand is being placed on your system. How many requests or sessions are aimed at your application? Errors: Measures the rate of requests that fail. How much traffic is unable to fulfill its requests or sessions? Saturation: Measures how “full” your service is. How are resources being stressed to meet the demands of your application? You can combine these four signals to create a fairly thorough depiction of the health of your system. We’ll build the alerting strategy for our sample application based on these signals. About the Terraform New Relic provider Terraform is an open-source infrastructure as code tool teams use to define and provision their infrastructure (physical machines, VMs, network switches, containers, SaaS services, and more) through repeatable automation. In Terraform, any infrastructure type can be represented as a resource, and providers expose how developers can interact with their APIs. The Terraform New Relic provider, officially supported by New Relic, integrates with core Terraform to allow for provisioning and managing resources in your New Relic account. Note: We wrote this post using version 0.12.21 of the Terraform CLI and version 1.14.0 of the Terraform New Relic provider. Future releases may impact the correctness of the examples included below. Before you begin To complete this walkthrough, you’ll need to install the Terraform CLI. Homebrew users can run brew install terraform. If you’re not a Homebrew user, check the Terraform download page for install instructions. Step1: Initialize your working folder Terraform configuration is based on a declarative language called HCL, which defines resources in terms of blocks, arguments, and identifiers. We’ll represent our New Relic resources in HCL to allow Terraform to provision and manage them. In your working folder, create a file called main.tf. Include the provider block to signal to Terraform that the New Relic provider will be used for the plan we are about to create: provider \"newrelic\" { api_key = var.newrelic_api_key } You can now initialize Terraform, which will facilitate the download of the New Relic provider. To run the initialization, run terraform init from the console. You should see a message that shows Terraform has been initialized successfully. Still, in your working folder, create a file called variables.tf. Include the newrelic_api_key variable definition to allow the Terraform CLI to prompt for your New Relic Admin’s API key for your user and account, then run the plan: variable \"newrelic_api_key\" { description = \"The New Relic API key\" type = string } Tip: If you want to suppress user prompts, you can also provide the API key via the NEWRELIC_API_KEY environment variable. You can combine this with a secret manager like Hashicorp's Vault to automate your Terraform runs while keeping secret values out of source control. See Terraform’s provider documentation for details. Your working folder is now initialized, and you’re ready to begin defining your New Relic resources with Terraform. Step 2: Provision an alert policy resource Now we’ll define an alerting strategy for a sample app—called “Web Portal”—already reporting to our New Relic account. We want to apply the principles of golden signal monitoring and alerting to this application. To do so, we’ll first need some details about the application we’re targeting and an alert policy in which we can define the appropriate alert conditions. In the main.tf file, define these resources in HCL: data \"newrelic_application\" \"web_portal\" { name = \"Web Portal\" } resource \"newrelic_alert_policy\" \"golden_signal_policy\" { name = \"Golden Signals - ${data.newrelic_application.web_portal.name}\" } These two blocks define a data source to retrieve application context for a New Relic application named “Web Portal” and a resource for provisioning a simple alert policy with the name “Golden Signals - Web Portal.” Take note that we’ve included two strings at the start of each block: The first represents the data source we are provisioning, as defined by the provider. Here we are using the newrelic_application data source and the newrelic_alert_policy (See the provider documentation for a full list of the available New Relic resource types.) The second is an identifier used for referencing this element from within the plan. In this case, we interpolate the application’s name, stored in its name attribute, into the alert policy name to avoid duplication in our configuration. The policy name defined here will be the one that shows in the New Relic UI, but the golden_signal_policy identifier is for use inside our Terraform configuration only.   Run terraform plan. You’ll be prompted for your admin API key. Once you enter it, you will see a diff-style representation of the execution plan Terraform is about to carry out on your behalf: ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: # newrelic_alert_policy.golden_signal_policy will be created + resource \"newrelic_alert_policy\" \"golden_signal_policy\" { + created_at          = (known after apply) + id                  = (known after apply) + incident_preference = \"PER_POLICY\" + name                = \"Golden Signals - WebPortal\" + updated_at          = (known after apply) } Plan: 1 to add, 0 to change, 0 to destroy. ------------------------------------------------------------------------ After verifying the details of the execution plan, run terraform apply to execute the plan and provision the resource: newrelic_alert_policy.golden_signal_policy: Creating... newrelic_alert_policy.golden_signal_policy: Creation complete after 1s [id=643964]Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Log into New Relic and navigate to the Alert Policies page for your account. You should see your alert policy has been created. When you created the alert policy in step 1.3, Terraform began tracking the state of your resource. If you ran terraform apply again, Terraform would compare the configuration in your main.tf file to the internally tracked state of the resource and determine that no action is necessary—this is the power of observability as code. You can delete the policy, with terraform destroy. Step 3: Provision alert conditions based on the four golden signals Next, we’ll want to add alert conditions for our application based on the four golden signals: latency, traffic, errors, and saturation. 1. Latency As described earlier, latency is a measure of the time it takes to service a request. Use the newrelic_alert_condition resource to create a basic alert condition resource for the response time of our sample application: resource \"newrelic_alert_condition\" \"response_time_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name            = \"High Response Time (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"response_time_web\" condition_scope = \"application\" # Define a critical alert threshold that will trigger after 5 minutes above 5 seconds per request. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } Here, we defined a condition named High Response Time (web) that will trigger if the overall response time of our application rises above five seconds for five minutes. Note that for the value of the policy_id attribute, we can link the alert policy we defined earlier with a reference to its identifier and its id attribute. We’re also using the ID of the application by referencing the application’s data source we defined in the previous section and by using its id attribute. Run terraform apply and verify that your alert condition has been created and linked to your alert policy. After Terraform runs, you can review the latency condition in New Relic. 2. Traffic The traffic signal represents how much demand is being placed on your system at any given moment. Use the application’s throughput as a metric for measuring the application’s traffic: resource \"newrelic_alert_condition\" \"throughput_web\" { policy_id = newrelic_alert_policy.golden_signal_policy.id   name            = \"Low Throughput (web)\" type            = \"apm_app_metric\" entities        = [data.newrelic_application.web_portal.id] metric          = \"throughput_web\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes below 1 request per minute. term { duration      = 5 operator      = \"below\" priority      = \"critical\" threshold     = \"1\" time_function = \"all\" } } Here, we define a condition named Low Throughput (web) that will trigger if the overall response time of our application falls below five requests per minute for five minutes. This type of alert is useful if we expect a constant baseline of traffic at all times throughout the day—a drop-off in traffic indicates a problem. Run terraform apply to create this condition. After Terraform runs, you can review the throughput condition in New Relic. 3. Errors Define a condition based on the error rate generated by our application: resource \"newrelic_alert_condition\" \"error_percentage\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name = \"High Error Percentage\" type  = \"apm_app_metric\" entities = [data.newrelic_application.web_portal.id] metric = \"error_percentage\" runbook_url = \"https://www.example.com\" condition_scope = \"application\"   # Define a critical alert threshold that will trigger after 5 minutes above a 5% error rate. term { duration      = 5 operator      = \"above\" priority      = \"critical\" threshold     = \"5\" time_function = \"all\" } } This condition, error percentage, will trigger if the overall error rate for our application rises above 5% for five minutes. Run terraform apply to create the condition. After Terraform runs, you can review the error condition in New Relic. 4. Saturation Saturation represents how “full” your service is and can take many forms, such as CPU time, memory allocation, or queue depth. Let’s assume that in this case, we have a New Relic Infrastructure agent on the hosts serving our sample application, and we’d like to measure their overall CPU utilization. Use the newrelic_infra_alert_condition resource to create an alert condition based on this metric: resource \"newrelic_infra_alert_condition\" \"high_cpu\" { policy_id = newrelic_alert_policy.golden_signal_policy.id name        = \"High CPU usage\" type        = \"infra_metric\" event       = \"SystemSample\" select      = \"cpuPercent\" comparison  = \"above\" runbook_url = \"https://www.example.com\" where       = \"(`applicationId` = '${data.newrelic_application.web_portal.id}')\"   # Define a critical alert threshold that will trigger after 5 minutes above 90% CPU utilization. critical { duration      = 5 value         = 90 time_function = \"all\" } } This alert will trigger if the aggregate CPU usage on these hosts rises above 90% for five minutes. Note that the definition for this resource is slightly different from the definition of newrelic_alert_condition—the New Relic provider documentation is the best source of information about the required or optional attributes on the resource. Run terraform apply to create the condition. After Terraform runs, you can review the saturation condition in New Relic. Your resources are now fully defined in code, and you can run terraform destroy or terraform apply at any time to remove or re-provision these resources in your New Relic account in a matter of seconds. Linking a notification channel We’ve created alert conditions for the four golden signals of our application in our New Relic account. Now we’ll want to set up notifications on those alerts. Our team uses PagerDuty, so let’s create a notification channel to integrate with that service. (For a full list of the supported notification channels, see the newrelic_alert_channel documentation.) Create a variable to store the PagerDuty service key to avoid storing sensitive values in your codebase. In variables.tf, create a new variable: variable \"pagerduty_service_key\" { description = \"The Pagerduty service key\" type = string } Define the channel with the newrelic_alert_channel resource, and link it to your policy defined earlier with the newrelic_alert_policy_channel resource: resource \"newrelic_alert_channel\" \"pagerduty_channel\" { name = \"Page Developer Toolkit Team\" type = \"pagerduty\" config { service_key = var.pagerduty_service_key } # The following block prevents configuration drift for channels that use sensitive data. # See the Getting Started guide for more info: # https://www.terraform.io/docs/providers/newrelic/guides/getting_started.html lifecycle { ignore_changes = [config] } } resource \"newrelic_alert_policy_channel\" \"golden_signal_policy_pagerduty\" { policy_id  = newrelic_alert_policy.golden_signal_policy.id channel_ids = [newrelic_alert_channel.pagerduty_channel.id] } Run terraform apply to apply your configuration. A PagerDuty notification channel set up in New Relic Alerts. Observability as code in practice Congratulations, you’re now a practitioner of observability as code. Now it’s time to create a repository—perhaps in GitHub—for your observability configuration and place it under version control. As your team evaluates the alerting system you’ve put in place, you’ll find that you may need to tweak configuration values, such as the alert threshold and duration. You can do this with a pull request to your alerting repository. Since you’re practicing observability as code, your team can review these changes right alongside the rest of your code contributions. You may also want to consider automating this process in your CI/CD pipeline, taking your observability as code practice to the next level. Don’t miss our latest video quick tip: Terraform Provider for New Relic—Getting Started Guide [embed]https://www.youtube.com/watch?v=UwJ-7BLylJo[/embed]   By Chris Trombley Chris Trombley is a Software Engineer at New Relic Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 294.45172,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Practicing Observability as Code: Defining New Relic <em>Alert</em> Policies with <em>Terraform</em>",
        "sections": "Step 3: Provision <em>alert</em> conditions based on the four <em>golden</em> <em>signals</em>",
        "body": "-provision these resources in your New Relic account in a matter of seconds. Linking a <em>notification</em> <em>channel</em> We’ve created <em>alert</em> conditions for the four <em>golden</em> <em>signals</em> of our application in our New Relic account. Now we’ll want to set up notifications on those <em>alerts</em>. Our team uses PagerDuty, so let’s"
      },
      "id": "60763298196a679eea64a7a3"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-04-16T14:38:31Z",
      "updated_at": "2021-04-06T07:43:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirements: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more sub-accounts, the notification channel includes only users for the currently selected master or sub-account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.1341,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> <em>channels</em>: Control where to send <em>alerts</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to select existing account team members and admins. To view the Users list or to add users to <em>alert</em> policies: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click <em>Notification</em> channels. If a user has configured the New Relic mobile app, the user <em>notification</em> <em>channel</em> also sends push"
      },
      "id": "603ecfbf64441f4ee54e885f"
    },
    {
      "sections": [
        "Test alert notification channels",
        "Request the test",
        "Troubleshoot the test results",
        "Tip"
      ],
      "title": "Test alert notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "c001fca5128a2fb8128ff655c44f9d51b6d5fa2a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/test-alert-notification-channels/",
      "published_at": "2021-04-16T14:39:15Z",
      "updated_at": "2021-03-16T06:45:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must save a new notification channel or any changes to an existing notification channel before testing it. Alerts will then send a test message to your chosen destination. Request the test To test a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Follow standard procedures to add a new notification channel or to update an existing notification channel, and save it. Select a notification channel, and then click Send a test notification. Review the test confirmation message, and then click Got it. Troubleshoot the test results A confirmation message will automatically show up in the user interface that indicates where the test was sent (for example, email) and whether it was successful. Also, the test notification message itself includes detailed information, including: The person who requested the test Links to policies for the channel Links to all notification channels and policies for the account Tip When troubleshooting problems, review the test notification message, and verify the setup requirements for the type of notification channel you selected. If necessary, make additional changes to your notification channel, and test it again as needed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.60461,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Test <em>alert</em> <em>notification</em> <em>channels</em>",
        "sections": "Test <em>alert</em> <em>notification</em> <em>channels</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": "You must save a new <em>notification</em> <em>channel</em> or any changes to an existing <em>notification</em> <em>channel</em> before testing it. <em>Alerts</em> will then send a test message to your chosen destination. Request the test To test a <em>notification</em> <em>channel</em>: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, then click"
      },
      "id": "603ec9ffe7b9d25b3d2a07a7"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/proactive_detection6-1024x765.png",
      "url": "https://newrelic.com/blog/nerdlog/new-capabilities-proactive-detection",
      "sections": [
        "Automatic analysis of every anomaly",
        "See all anomalies in a single view",
        "Alert, query, and leverage the power of anomalies in NRDB",
        "The full power of New Relic AI: anomalies integrated into Incident Intelligence",
        "Related Topics"
      ],
      "published_at": "2021-04-16T00:19:16Z",
      "title": "Enhancing New Relic AI With New Capabilities For Proactive Detection",
      "updated_at": "2021-04-13T23:31:44Z",
      "type": "",
      "external_id": "47801e8f396395e32a3da28b34d08b92af08bacb",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit AIOps Enhancing New Relic AI With New Capabilities For Proactive Detection May 4, 2020 • 6 min read By Annette Sheppard The rate of change within your software is faster than ever, and with this pace comes the risk that your team may miss issues, or lose critical time trying to diagnose the causes of errors. Proactive Detection, an essential part of our recently released AIOps solution, New Relic AI, helps DevOps teams avoid such problems and drive faster mean time to resolution (MTTR) by proactively detecting and analyzing anomalies using data from New Relic APM. Whether it’s alerts you didn’t know you needed to set up or dependent systems you may not even own, New Relic AI Proactive Detection surfaces and analyzes anomalies, bringing attention to potential problems before they become bigger issues—all within your team’s existing incident response workflows. Easy to set up, Proactive Detection simply needs a configuration name and a list of the applications to be monitored to begin discovering and analyzing anomalies in your system. Today we’re announcing four key enhancements to Proactive Detection: An in-depth analysis of each anomaly via the Analysis page A complete list of all anomalies in your environment with the Anomaly overview Integration with the New Relic Database (NRDB), so you can create dashboards and alerts based on anomaly data Integration with New Relic AI Incident Intelligence—via NRQL alerts—for deeper context into incidents Automatic analysis of every anomaly Not only does Proactive Detection flag and notify you of anomalies in your system, it also analyzes each anomaly to help you speed troubleshooting. The Analyze page automatically surfaces queries and context to help explain the cause of an anomaly. Each Proactive Detection notification delivered in Slack provides a link to the Analyze page, allowing you to easily investigate an anomaly or switch between anomalies as you dive deeper into issues. Anomalies delivered to your team via Slack quickly link to the Analyze page for deeper analysis The Analyze page provides an overview of the anomaly itself, as well as details and recent activity for an entity. When available, Proactive Detection automatically suggests attributes that help explain the cause of the anomaly and provide paths for further troubleshooting, as shown in the Key Attributes section: The three key attributes surrounding an error spike are visualized to provide you with multiple paths for troubleshooting. Proactive Detection uses APM event data to suggest queries that explain the anomaly, based either on statistical differences in the data or on historical usage. Finally, the Analyze page provides a table with sparklines that include anomalies related to the SRE “golden signals” (error rate, throughput, and response time) for the affected entity, and lists additional anomalies in related applications that are upstream or downstream of the initial anomaly. Sparklines include anomalies related to the SRE “golden signals” and additional anomalies in related upstream or downstream applications All of this gives your team a holistic view of the events leading up to the anomaly, helping you better identify what is happening in your application and environment. See all anomalies in a single view The Analyze page provides the context surrounding one anomaly, but the Anomaly overview page gives you a broader view of what's happening in your environment. You’ll have a full view of all detected anomalies, with the ability to instantly view more details for each one. If you want to dive in and learn even more about a specific anomaly, simply use the Analyze link. The Anomaly overview page gives you an overview of all anomalies detected in your environment. Alert, query, and leverage the power of anomalies in NRDB Since all anomalies are automatically written to the NRDB, you can use anomaly data to build dashboards, or create alerts. Query any Proactive Detection event from any configured application. For example, use Proactive Detection data in NRQL alerts to notify you when clusters of anomalies occur. Any anomaly can be plotted in a dashboard to discover trends and patterns. You can even build your dashboards to show anomalous events that are relevant to the specific applications you’re monitoring for anomalies in Proactive Detection. Be notified when clusters of anomalies occur. The full power of New Relic AI: anomalies integrated into Incident Intelligence Proactive Detection and Incident Intelligence are New Relic AI’s critical set of capabilities that help teams detect issues early, eliminate alert noise, and drive toward even faster MTTR. Incident Intelligence uses AI and machine learning (ML) to suppress alerts you don’t care about and correlate related incidents and events into single issues, without excessive configuration, training, or onboarding. Stronger together, you can now link anomalies detected with Proactive Detection to Incident Intelligence—via NRQL alerts—to receive enhanced context inside of your Incident Intelligence to gain the full power of New Relic AI. New Relic AI Proactive Detection has a free tier that you can start using today: If you’re new to New Relic, sign up for your free account. Already using New Relic? Get started with Proactive Detection in under 10 minutes by visiting http://one.newrelic.com > New Relic AI > Proactive Detection. Interested in learning more about New Relic AI, check out these resources: Accelerate Incident Response with AIOps: An introduction to AIOps best practices with New Relic AI (eBook) Accelerate Incident Response with AIOps (Webinar) New Relic AI documentation Request a demo   Related Topics AIOps By Annette Sheppard Annette Sheppard is a Senior Product Marketing Manager at New Relic. She is focused on AIOps and is always looking to learn something new. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.38383,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Alert</em>, query, and leverage the power of anomalies in NRDB",
        "body": " differences in the data or on historical usage. Finally, the Analyze page provides a table with sparklines that include anomalies related to the SRE “<em>golden</em> <em>signals</em>” (error rate, throughput, and response time) for the affected entity, and lists additional anomalies in related applications that are upstream"
      },
      "id": "607629e028ccbc02d751c161"
    },
    {
      "sections": [
        "Update alert notification channels",
        "Reference for updating channels",
        "Add or remove policies assigned to a channel",
        "Assign a channel to policies",
        "Change a channel's name",
        "Check for policies assigned to a user",
        "Check how many policies are assigned to a channel",
        "Create more channels",
        "Delete a channel",
        "Test a saved channelView assigned alert policies",
        "Basic process"
      ],
      "title": "Update alert notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "521bed5aa6fdcea5c1cffd11d01e6dad19bc7c40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/update-alert-notification-channels/",
      "published_at": "2021-04-16T14:39:15Z",
      "updated_at": "2021-03-16T08:08:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Depending on the selected channel type, different values appear. Reference for updating channels Here's a quick reference for updating channels which also includes links to more detailed information and procedures. Add or remove policies assigned to a channel To add or remove policies assigned to a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Choose a channel, and then click Alert policies. From the selected policy, use the windows to select, remove, or clear all notification channels. Assign a channel to policies To add a notification channel to one or more policies: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies. Choose a policy, click Notification channels, and then click Add notification channels. Choose a channel, and then click Update policy. Change a channel's name To rename an existing notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, then choose a channel. From the Channel details, change the name (maximum 64 characters) based on the channel type if applicable, and then save. Check for policies assigned to a user To check whether an account user has any policies assigned: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Optional: Search by \"user\" to browse users or a specific username or email. Choose the user, then click Alert policies. Check how many policies are assigned to a channel To check whether a notification channel has any policies assigned: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create more channels To create a new notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Click New notification channel. Delete a channel To delete a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. In the list, click the Delete icon. Test a saved channelView assigned alert policies To view the policies assigned to a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, choose a channel, and then click Alert policies. OR To view the notification channels assigned to a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, choose a policy, then click Notification channels. Basic process Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, then choose a channel. From the Channel details page, make any necessary changes, and then save. The user interface shows a Last modified time stamp for any changes to policies, including their conditions and notification channels.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.89487,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update <em>alert</em> <em>notification</em> <em>channels</em>",
        "sections": "Update <em>alert</em> <em>notification</em> <em>channels</em>",
        "tags": "<em>Alert</em> <em>notifications</em>",
        "body": " to a <em>notification</em> <em>channel</em>: Go to one.newrelic.com, in the top nav click <em>Alerts</em> &amp; AI, click <em>Notification</em> channels. Choose a <em>channel</em>, and then click <em>Alert</em> policies. From the selected policy, use the windows to select, remove, or clear all <em>notification</em> channels. Assign a <em>channel</em> to policies To add"
      },
      "id": "603eca45e7b9d2d1d82a0806"
    }
  ],
  "/automate-workflows/diagnose-problems/high-response-times": [
    {
      "sections": [
        "データエクスプローラーの概要",
        "ヒント",
        "重要な理由",
        "データのクエリ",
        "データエクスプローラーを使用する",
        "イベントを詳しく調べる",
        "メトリックスを詳しく調べる",
        "重要",
        "調査を可視化し絞り込む",
        "クエリエリア",
        "NRQLクエリ表示",
        "チャートエリア",
        "共有してエクスポート",
        "使用事例",
        "新規データを確認",
        "データを検証",
        "データの問題のトラブルシューティング",
        "その他のヘルプ"
      ],
      "title": "データエクスプローラーの概要",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "94545f74e5fd5ab0b18f47342f7a8f2a2fa82558",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-16T15:16:11Z",
      "updated_at": "2021-04-12T03:13:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データエクスプローラーを使用すれば、NRQLの知識がなくても、すべてのデータを視覚的に操作できます。データエクスプローラーを使用してデータにアクセスしクエリやカスタマイズ、視覚化を行い、サービスとサービスをつなぎ、一貫したキュレート済みの体験を実現します。 ヒント データエクスプローラー、およびその他のオブザーバビリティ プラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 システムの状態を調査しますか？リソースの計画を作成し、インシデントを特定しそれに対応し、動作不良のトラブルシューティングを行う必要がありますか？データエクスプローラーにより、NRQLを使用したりクエリを構築せずに、視覚的なメニューを通じて、探しているデータを簡単に特定、取得し、視覚化できます。 データエクスプローラーを使用して、次のことを行えます。 イベントやメトリックスデータに、迅速で直感的な方法でアクセスする。 視覚化し簡単に実行できるようにして、データのディメンションを詳しく調べる。 さまざまな観点からデータを把握する：生データや、進歩や配信などについての知見を提供するさまざまな視覚化。 フィルターによりデータを掘り下げる。 1回のクリックで検索をダッシュボードに追加する。 NRQLのしくみについて理解する: データエクスプローラーは、利用可能なデータを検索している間にクエリがどのように構築されるかを示します。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 データのクエリ データエクスプローラーにアクセスするには、one.newrelic.comに移動し ページの上部にあるデータをクエリアイコンをクリックします。 データのブラウズドロップダウンで、イベントまたはメトリクスを選択します。 データエクスプローラーは、New Relicにあるすべてのデータを詳しく調べるためのポータルです。データエクスプローラーUIにあるイベントやメトリックスを詳しく調べたり、LogsやTracesアプリを選択して詳しく調べることができます。また、タブをクリックして、いつでもクエリビルダーにアクセスすることもできます。 データエクスプローラーを使用する データエクスプローラーは、上部にある範囲絞り込みセクション（a）、左側のデータブラウジングエリア（b）、ワークスペース（c）で構成されます。 データエクスプローラーを使用するには： 調べる範囲を定義する：ブラウズするアカウントとデータタイプ（メトリックまたはイベント）を選択します。 タイムピッカーを使用して時間範囲を選択します。 左側のブロックを使用して、イベントかメトリックスのいずれかについて使用可能なデータをブラウズし、検索を作成します。1ブロックにつき1つの要素しか選択できません。ブロックは検索可能です。 イベントを詳しく調べる イベントタイプ 選択したアカウントで使用できるすべてのイベントを表示します。 デフォルトでは、イベントは名前で並び替えられます。 プロット 以前選択したイベントのすべての数字属性を表示します。 リストの最初の項目はcount( * )で、これは属性ではありません。選択したイベントの数を計算します。 デフォルトでは、属性は名前で並び替えられます。 プロットする関数を選択します。デフォルトでは、各属性は関数Averageに設定されます。 ディメンション 以前選択したイベントとプロットのすべてのディメンションを表示します。 ディメンションは、イベントについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 メトリックスを詳しく調べる APM 時間区切りデータを調べるには、AppID、AppName、またはEntityGuidをステップとして選択します（またはそれらのステップでグループ化します）。それ以外の場合は、すべてのエンティティの集計データを取得します。 メトリック 選択したアカウントで使用できるすべてのメトリックスを表示します。 デフォルトでは、メトリックスは名前で並べ替えられます。 ディメンション 以前選択したメトリックのすべてのディメンションを表示します。 ディメンションは、メトリックについての情報を提供する文字列値です。 濃度、すなわち選択した時間範囲にあるその属性の異なる値のuniqueCountを表します。要素が1つしかない場合、その属性の値を示します。 デフォルトでは、ディメンションは名前で並べ替えられます。 重要 ユニットの表示には、メトリックシステム（メトリックSIプレフィックスを含む）が使用されています。 調査を可視化し絞り込む 調査の結果は、右側のワーキングスペースに表示されます。 調査を絞り込むか、チャートを共有する ワーキングスペースには、次のものが表示されます。 クエリエリア クエリエリアでは、クエリを異なる構成要素に分解します。ここで、NRQLクエリとして調査の結果を簡単に読み、プロットしている正確なデータをチェックできます。 NRQLに習熟していない場合、このエリアをチェックしクエリの作成方法について学習します。 クエリの別の部分は次のとおりです。 [ イベントのみ]FROM: 最初のブロックで選択したイベント。 SELECT: 選択したプロットまたはメトリック。この入力では、1つの値と1つの関数のみをプロットします。 GROUP BY: FACET句を表し、選択したディメンションごとにデータをグループ化します。 LIMIT: 表示する値の量を入力します。 WHERE: このフィールドを使用して、結果にさらにフィルターを適用します。この入力では、n値をプロットします。 各項目は、xをクリックしてクエリから削除できます。 NRQLクエリ表示 上記のフィールドと、タイムピッカーで選択した時間範囲で構成される、完全なクエリを表示できます。 ヒント より詳細な検索を行う、またはチャートをカスタマイズする必要がある場合データエクスプローラーから、クエリビルダーにアクセスしてクエリを編集できます。 チャートエリア デフォルトでは、データは線チャートで表示されます。チャートピッカーを使用して、面グラフ、円グラフ、およびバーチャートに簡単に切り替えることができます。結果の生データをテーブルまたはJSON形式として表示することもできます。 ディメンションを選択している場合、チャートは異なるファセットで更新されます。チャートの下に、ファセットのリストとそれぞれの値があるファセットの表が表示されます。 ファセットテーブルを使用して、データをドリルダウンします。クリックしたファセットはフィルターとして適用されます。表は表示されたままなので、別のファセットを簡単に選択して調査を続けることができます。 共有してエクスポート 右上にあるオプションメニューを使用して、チャートを画像として取得、またはリンクとして共有、ダッシュボードに追加できます。 また、URLをコピーし、その他のNew Relicユーザーと調査全体を共有することもできます。 使用事例 次の例で、データエクスプローラーをいつどのように使用するかについて学習してください。 新規データを確認 新規インストゥルメンテーションに接続したばかりで、新規データを利用できるかどうか確認したいと思っています。 アカウントとイベント、または新規データを生成しているメトリックを選択します。 データエクスプローラーで別のツールを使用して、利用できるようになった新規データを使ってみる：そのイベントまたはメトリックの生データを表として見る、またはリストとする、またはクリックしてチャートとしてプロットされることを確認します。 イベントやメトリックを選択した後、ディメンションでデータの形状を確認します。濃度を使用して、あらゆるデータの異なる視点を確認できます。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 データを検証 カスタムイベント/メトリックを変更したので、この変更が正常に行われたかどうかをチェックする必要がある。 データエクスプローラータブで、変更したアカウントとデータタイプ、イベント/メトリックを選択します。 エンティティがデータをレポートしていることと、すべての属性がプロットされていることを確認します。 変更した属性を検索し、更新が正常に行われたことをチェックします。 データの問題のトラブルシューティング アラートやダッシュボードからのイベント/メトリックで何か問題があることが分かっている。イベント/メトリック属性の動作について、根本原因を知る必要がある。 データエクスプローラーで、メニューを使用して、想定どおりに動作していないイベントやメトリックを選択し、データエクスプローラーでそのチャートをプロットします。 そこから、そのデータのディメンションを掘り下げて、関連する属性によりフィルターを適用できます。 また、次のような異なる観点からそのデータを把握することもできます：分布や値の順位、経時進化。 関連性が見つかった場合ダッシュボードに保存するか、同僚と共有します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 59.27971,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "605343b4196a6754132d166e"
    },
    {
      "sections": [
        "ダッシュボード入門",
        "ヒント",
        "重要な理由",
        "New Relic全体にまたがるダッシュボードを表示する",
        "ダッシュボードの使用を開始",
        "ダッシュボードの作成",
        "ダッシュボードのクローンを作成",
        "ダッシュボードの削除",
        "ダッシュボードにお気に入りの印を付ける",
        "ダッシュボードの検索と並び替え",
        "ダッシュボードのアクセス許可",
        "タグを使用してダッシュボードを整理する",
        "主要な視覚化ツール",
        "一貫したチャートの色",
        "関連するニードル",
        "データスクラバー",
        "拡大ブラシ",
        "カスタムの可視化",
        "その他のヘルプ"
      ],
      "title": "ダッシュボード入門",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "36da9a58bf388d15522c769ef3ad709550eee043",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-04-17T03:24:45Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "データを道路の複雑なシステムとして捉える：道路の標識や信号に従い運転し、収集する情報の意味を迅速に把握し実行する必要があります。New Relic Oneダッシュボードは、New Relicプラットフォームのあらゆる場所から、表示したい特定のデータを収集して、お望みの方法でチャートを作成します。 ヒント ダッシュボードとその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 重要な理由 New Relic Oneダッシュボードを使用して、収集するデータをカスタマイズして理解できます。カスタマイズされたユーザーフレンドリーなチャートでデータを詳しく調べ、つながりのあるソースの相関性を導き、システムとアプリケーションの状態を素早く理解することで、より迅速かつ効率的なトラブルシューティングを行います。 ダッシュボードを利用して、次のことを行います： 一貫したUIによるカスタムの高密のインタラクティブな可視化により、知見を深める。 プラットフォームのどこからでも、すべてのイベントと属性のチャートを作成する。詳細については、デフォルトのデータ収集に関する弊社のドキュメンテーションを参照してください。 カスタム属性の追加またはカスタムイベントタイプの送信を大半のイベントに対して行います。これにより、貴社のビジネスへの理解力を高め、ページビュー数やホストトランザクションなど、顧客とプラットフォームのインタラクションに関する具体的なポイントを確認できます。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度な補足説明機能とズームイン機能でデータの探索とコンテキスト化を行い、貴社システムのリアルタイムのアクティビティをモニターできます。 ダッシュボードで属性とメトリックスを検索します。 APIを使用してダッシュボードにデータを送信します。 New Relic全体にまたがるダッシュボードを表示する New Relic Oneのダッシュボードには、元々のNew Relicプラットフォームとの完全な下位互換性が備わっているため、Insightsで作成した全てのダッシュボードがダッシュボードで自動的に利用できるようになります。つまり、新たにダッシュボードを追加すると、Insightsでも作成されます。追加の設定は必要ありません。New Relic Oneでは、クロスアカウント検索を利用することで、組織全体にまたがるダッシュボードを表示できます。 ヒント InsightsからNew Relic Oneに切り替える場合移行ガイドをご覧ください。 ダッシュボードの使用を開始 ダッシュボードにアクセスするには、one.newrelic.comに移動し、ナビゲーションメニューの上部にあるダッシュボードをクリックします。 ダッシュボードの索引で、New Relicアカウントに関連するすべてのダッシュボードとデータアプリを表示できます。これには、New Relic Oneプラットフォーム内で作成したダッシュボードと、Insightsで構築したダッシュボードが含まれます。 上部のバーから、エンティティエクスプローラーや、APMやBrowser、Infrastructure monitoring、Logs、インテリジェンスの応用などすべてのNew Relic機能に迅速にアクセスします。また、プラットフォーム全体で使用できるデータの検索やクエリなどのNew Relic Oneの中心的な機能も使用できます。 各ダッシュボードで、索引に次の情報が表示されます： 星で表される、お気に入りのステータス 名前：ダッシュボードの名前 アカウント：ダッシュボードが属するアカウント 作成者：ダッシュボードを作成したユーザー 最終編集日時：直近のダッシュボード変更の日時 作成日時：ダッシュボードの作成日時： 次のアクションを行えます： ダッシュボードの作成 ダッシュボードの索引の右上隅にある+ダッシュボードを作成ボタンを選択して、ダッシュボードからNew Relic Oneでダッシュボードを作成できます。 ダッシュボードに名前を付ける名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前（例として、サービスやアプリケーション）を付けることを推奨します。 ダッシュボードが属するアカウントを選択します。このアクションは変更できないため、慎重に選択してください。 作成を押して続けるか、キャンセルを押して索引に戻ります。 ヒント デフォルトでは、ダッシュボードはパブリック - 読み取りと書き込み許可で作成されます。ダッシュボードにアクセスした後、設定メニューから編集できます。 または、次のように新規のダッシュボードを作成することもできます： 既存のダッシュボードのクローンを作成して。 チャートから：チャートを任意のダッシュボードから新規または既存のダッシュボードにコピーします。 データエクスプローラーまたはクエリビルダーから: クエリ機能から作成したチャートを、新規または既存のダッシュボードに追加します。 エンティティエクスプローラーから：エンティティマネージャからダッシュボードにカスタムで表示を行います。 複数のページでダッシュボードを整理するには、ダッシュボードにページを追加します。 ダッシュボードのクローンを作成 索引のダッシュボード行の上にカーソルを移動すると表示されるダッシュボードのクローンを作成ボタンをクリックして、ダッシュボードのクローンを作成します。許可のレベルにかかわらず、あらゆるダッシュボードのクローンを作成できます。 ダッシュボードは自動的にコピーされ、クローンが索引に追加されます。画面にポップアップ表示されるメッセージをクリックして、新規ダッシュボードにアクセスします。 クローン版のダッシュボードには、元のダッシュボードの名前の後に「copy」が付けられます。たとえば、this is my dashboardという名前のダッシュボードのクローンを作成すると、クローンはthis is my dashboard copyとして作成されます。クローンの許可は、パブリック - 読み取りと書き込みとなります。 ダッシュボードの名前や許可などのその他のプロパティは、いつでも編集できます。 ヒント 索引には、並べ替えに従いダッシュボードが表示されます。クローン版のダッシュボードを迅速に検索するには、作成日でダッシュボードを並び替えます。新規のダッシュボードが先頭に表示されます。 ダッシュボードの削除 ダッシュボードを削除するには、削除ボタンが表示されるまで、索引のダッシュボード行の上にカーソルを移動します。自身で作成した場合、または許可がパブリック - 読み取りと書き込みの場合しか、ダッシュボードは削除できません。詳しくは、許可についての情報を参照してください。 ダッシュボードの設定パネルから、ダッシュボードを削除することもできます。 ダッシュボードにお気に入りの印を付ける ダッシュボードの隣にある星のアイコンをクリックすると、お気に入りがオンとオフで切り替わります。ダッシュボードをお気に入りにすると、リストの先頭にあるその他のお気に入りのダッシュボードと同じグループに入り、New Relic Oneのホームページで表示されます。 お気に入りからダッシュボードを削除するには、星のアイコンをもう一度選択します。 New Relic Oneは、Insightsからお気に入りのダッシュボードを取得しません。InsightsからNew Relic Oneへの移行の方法をご覧ください。 ダッシュボードの検索と並び替え 索引の上にある検索ボックスを使用して、ダッシュボード名と作成者別に、ダッシュボードの検索を行えます。 索引でダッシュボードの並べ替えも行えます。デフォルトでは、直近に編集したダッシュボードが、お気に入りとお気に入り以外のセクションの両方で、索引の先頭に表示されます。この順序を変更するには、索引の任意の列で両方のセクションを並べ替えると、直近の並べ替えの結果が、次回New Relic Oneにアクセスした際に表示されます。 ダッシュボードのアクセス許可 ダッシュボードには、次の3種類の権限があります。 パブリック - 読み取りと書き込み: すべてのユーザーが、ダッシュボードに対し完全な権利を有します。 パブリック - 読み取りのみ: すべてのユーザーはダッシュボードを表示できますが、ダッシュボードで作業を行う完全な権利を有するのはあなただけです。他のユーザーはダッシュボードにアクセスし、クローンを作成できますが、編集や削除はできません。 プライベート: ダッシュボードを表示できるのはあなただけです。 ダッシュボードを作成ボタンを使用して、または別のダッシュボードのクローンを作成してダッシュボードを作成すると、デフォルトでパブリック - 読み取りと書き込みの権利が付与されます。新規ダッシュボードにアクセスして、この設定を変更します。 タグを使用してダッシュボードを整理する タグ作成APIであるNerdGraphを使用して、タグを追加できます。 タグ別にダッシュボードをフィルターすることもできます。これによってユーザーアカウントやロケーションなどを特定できます。タグフィルターをクリックして使用可能なタグを表示すると、リストから1つ以上のタグを簡単に選択して、索引でダッシュボードを絞り込むことができます。 主要な視覚化ツール ダッシュボードには、詳細なデータ検索や迅速なトラブルシューティングのための、分かりやすい視覚化機能とツールが備わっています。 一貫したチャートの色 データやファセットをすぐに表示し関連付け、ダッシュボードで1つ以上のチャートに適用し、すべてのチャートでファセットの色を一貫したものにできます。 関連するニードル マウスをチャートの上に移動すると、関連するニードルが、同時にダッシュボードのすべてのチャートやデータポイントに重なって表示されます。ツールチップには、線チャートの最大値や最小値など、選択したファセットからの関連データポイントが記載されています。また、パイチャートで選択した属性をハイライト表示します。 データスクラバー チャートスクラバーを使用して、チャートが密集しており、ファセット間の距離が非常に近い場合に、チャートでデータポイントやファセットを選択できます。 マウスをニードルの側に移動し、隣にあるファセットをスムーズに選択し、関連するデータポイントを表示します。また、UIに表示される1つ以上の属性の選択を解除して、投入データの多いチャートのデータ投入を減らすこともできます。 拡大ブラシ ドラッグしてチャート上の時間セグメントを選択すると、ダッシュボードのすべてのチャートでその期間が自動的に拡大されます。 タイムピッカーは、ダッシュボードに表示される新規の期間を反映します。いつでもデフォルトやその他の時間設定に戻ることができます。 カスタムの可視化 ダッシュボードにカスタムの可視化を行うこともできます。これにより、データソースからの情報を含めることができるようになります。カスタムの可視化の詳細については、ダッシュボードのカスタムの可視化とダッシュボードにカスタムの可視化を追加をご覧ください。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 48.163956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053433228ccbcdc10c2fd60"
    },
    {
      "sections": [
        "ダッシュボードの管理",
        "ダッシュボードのカスタマイズ",
        "ヒント",
        "ダッシュボードを編集する",
        "設定メニュー",
        "TVモード",
        "ダークモード",
        "ダッシュボードをエクスポートする",
        "新規コンテンツをダッシュボードに追加する",
        "マークダウンエディタを使用して、カスタムコンテンツを追加する。",
        "ページのあるダッシュボードを整理する",
        "ページをダッシュボードに追加し編集する",
        "チャートとマークダウンコンテンツを管理する",
        "重要",
        "チャートにフィルターを適用して絞り込む",
        "チャート凡例を使用してフィルターを適用する",
        "ファセットを使用してダッシュボードにフィルターを適用する",
        "タイムピッカーを使用して時間設定を変更する",
        "データをエクスポートし共有する",
        "その他のヘルプ"
      ],
      "title": "ダッシュボードの管理",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d5e5a7705eda167da4867960df29bd237535a8e5",
      "image": "https://docs.newrelic.com/static/129e7a553450c47847a969c79a2f7f89/c1b63/Dashboards_conf.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-04-17T02:37:22Z",
      "updated_at": "2021-04-12T03:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneダッシュボードにアクセスし、チャートメニューから直接チャートを作成または管理し、ダッシュボードのレイアウトをカスタマイズし、表示モードを調整し、データのエクスポートを行います。 ダッシュボードをカスタマイズし、チャートを構築したら、データを詳しく知るための高度な視覚化機能とツールを使用して、データを関連付け分析します。 ダッシュボードのカスタマイズ ダッシュボードは非常に柔軟な設定となっています。ダッシュボードのレイアウトをカスタマイズし、チャートのサイズを調整してデータの表示方法を最適化できます。 ヒント をクリックして、メタデータを表示しタグを管理モーダルにアクセスします。ここで、ダッシュボードのガイドやアカウントID、アプリIDを表示し、ダッシュボードに追加されたすべてのタグを管理できます。 ダッシュボードには、次の機能が含まれます： ダッシュボードを編集する 編集 ボタンを使用して次のことを行う: ダッシュボードの名前を変更する。名前は検索可能なため、意味のある名前を付けることを推奨します。 ウィジェットを追加ボタンをクリックして、新規コンテンツを作成する。クエリビルダーを使用して新規チャートを追加する、またはマークダウンエディタを使用してテキストや画像、リンクを追加する。 新規ページを追加する。ページを使用して、ダッシュボードをより整理できます。 チャートのサイズと範囲を変更する。チャートを移動し、ダッシュボードのどこにも置くことができるため、お好みに合わせてレイアウトを設定します：関連性の高いチャートを上部に置いたり、あまり使用しないチャートを角に配置します。最大で12列のチャートを設定できます。 設定メニュー 右上にある設定メニューを使用します。 ダッシュボードの名前を変更する。名前は検索可能なため、ダッシュボードを簡単に検索できる意味のある名前を付けることを推奨します。 ダッシュボードの許可を変更する。 設定メニューで、ダッシュボードの作成時期とダッシュボードに属するアカウントも表示できます。この値は変更できません。 TVモード テレビ画面での表示向けにダッシュボードを最適化する、全画面のTVモードを有効にできます。 TVモードを有効にするには、次の2つの方法があります。 New Relic Oneでダッシュボードを表示している際に、右上の アイコンを選択します。 このパラメーターをダッシュボードのページのURLに追加します：&platform[tvMode]=true TVモードを設定するには、ダッシュボードから アイコンを選択します。オプションに含まれるもの： ダッシュボード名が表示されます。 ダッシュボード名をオフにすると、画面上でダッシュボードのチャートのスペースが増えます。 ページの切り替え。 複数のページのあるダッシュボードでは、これによりページが自動的に切り替わります。 ダークモード 高コントラストモードを、ダッシュボードで使用できます。 アイコンを、右上のメニューバーから選択します。 ダッシュボードをエクスポートする アイコンをクリックして、PDFファイルとしてダッシュボードをエクスポートできます。 ヒント いつでも検索機能を使用して、New Relic One全体でデータを検索できます。 新規コンテンツをダッシュボードに追加する 複数の方法で、ダッシュボードに新規コンテンツを追加できます： データエクスプローラーおよびクエリビルダー機能から。 + ダッシュボードに追加ボタン（メインのダッシュボードのページから、または編集モードでアクセス可能）を使用して、クエリビルダーにアクセスするか、マークダウンエディタを使用してコンテンツ（テキストやリンク、画像など）を追加する。 ダッシュボードから既存のチャートをコピーする。 マークダウンエディタを使用して、カスタムコンテンツを追加する。 マークダウンエディタには、コンテンツを入力するマークダウンペインや、表示するプレビューペインが含まれます。マークダウン構文オプションの詳細については、Commonmarkのウェブサイトをご覧ください。 マークダウンウィジェットの楕円 アイコンをクリックし、編集をクリックして、既存のコンテンツを編集することもできます。 ページのあるダッシュボードを整理する 複数のページを使用して、さまざまな表示でダッシュボードを整理できます。ページをそのダッシュボードに追加すると、ダッシュボードUIの上部にあるタブを使用して、そのページにアクセスできます。 one.newrelic.com > Dashboards: ダッシュボードの上部にあるタブで表示された、複数のページのあるNew Relic Oneのダッシュボードの例は次のとおりです。ページをダッシュボードに追加し、既存のページをコピーし、ページタブを新たな位置にドラッグしてドロップできます。 この機能を使用して、関連するダッシュボード表示をグループ化できます。これは、特定のプロジェクトやチーム、主題に関連する多くのデータとチャートを集計する際に有用です。 たとえば、モバイルアプリチームは、国ごとにアプリのパフォーマンスに重点を置いたダッシュボードを構築できます。最初のダッシュボードのページを、すべての国のパフォーマンスの概要とし、その他のページで特定の国を取り上げることができます。 当社では、ダッシュボードをつなぐその他の機能を提供しています。 マークダウンテキストを含むウィジェットを作成して、特定のUIページやダッシュボードへのダイレクトリンクを追加します。 ファセットによるフィルタリングを使用して、自動的にその他のダッシュボードにリンクしフィルタリングを行うリンクを作成します。 ダッシュボード検索を使用して、似た名前のダッシュボードを検索します。この機能を活用して、チームやプロジェクトに固有の語句をダッシュボード名に追加できます。 New Relic Insightsでは、この機能はデータアプリと呼ばれていました。InsightsからNew Relic Oneの切り替えの詳細については、移行ガイドをご覧ください。 ページをダッシュボードに追加し編集する ページをダッシュボードに追加、またはページを編集するには： 新規または既存のダッシュボードで、 アイコンを選択して編集モードで入力します。 新規ページを追加する： ページを追加を選択して空白のページを追加します。 ダッシュボード名の隣にあるドロップダウンをクリックし、複製を選択して、既存のページのクローンを作成します。 編集モードの間、新規ページにウィジェットを追加し、ページタブを新たな場所にドラッグしてドロップしたり、その他のダッシュボード編集タスクを行えます。 終了したら、編集を完了を選択します。 チャートとマークダウンコンテンツを管理する マークダウン要素から、右上隅にあるアクセスメニューにアクセスし、編集または削除を行います。チャートから、右上角のチャートアクションメニューにアクセスし、次のことを行います。 チャートを全画面に拡張する。 画像として、またはリンクを付けてチャートを共有する。 チャートをダッシュボードにコピーする。 クエリビルダーにアクセスし、チャートに関連したクエリを表示または編集する。 チャートを削除する。 重要 ダッシュボードに対する許可が読み取り専用の場合、チャートのクエリは編集できません。 詳細については、チャートの使い方をご覧ください。 チャートにフィルターを適用して絞り込む フィルタリング機能を使用して、ディスプレイで情報を絞り込むことができます。この機能は、クエリ条件を視覚的に表すものです。 フィルターバーを使用して、表示する値や属性を選択し、チャートから残りの要素を削除する。 高度なフィルターバーを開いてboolean演算子（=、!=、CONTAINS、EXCLUDESなど）にアクセスし、データのフィルタリングのための複雑で組み合わされた条件を追加する。 フィルターを適用後、ダッシュボードには、選択した要素に関連するデータのみが表示されます。小さなカウンターは、1回にいくつのフィルターが適用されているかを表します。 デフォルト表示に戻るには、フィルターの横にある小さなXをクリックして削除します。 チャート凡例を使用してフィルターを適用する 凡例のついたチャートで凡例をクリックして、その系列のみを表示し、チャートから残りのものを削除します。これにより、分析するデータを隔離できます。 反対の動作では、CMD（Macの場合）またはCTRL（Windowsの場合）を使用します。選択した系列を削除し、残りを保存します。 ファセットを使用してダッシュボードにフィルターを適用する チャートのNRQLクエリにFACET句が含まれる場合、ファセットのついた属性を使用して、現在のダッシュボードまたは別の関連するダッシュボードにフィルターを適用できます。詳細については、ファセットによりフィルターを適用するをご覧ください。 タイムピッカーを使用して時間設定を変更する デフォルトでは、ダッシュボードの各チャートには、クエリビルダーで作成時に指定された期間のデータが表示されますが、タイムピッカーを使用して表示されるデータの時間範囲を変更し、すべてのチャートに同じ範囲を設定できます。これは、データを絞り込み特定の期間に何が発生したかを観察する必要がある場合、インシデントのトラブルシューティングの間に特に有用です。 更新率は、表示中の期間の長さにより異なります。将来と例については、チャートの更新間隔をご覧ください。 時間範囲を変更するには： ドロップダウンメニューから、利用可能なオプション（直近30分から直近7日まで）を1つ選択します。 カスタムメニューを使用して、特定の開始および終了タイムスタンプで時間範囲をカスタマイズします。 重要 ダッシュボードでは、Insightsとは異なり、タイムゾーンはお使いのノートパソコンの時間とは関連していません。タイムピッカーのカスタムメニューから簡単にアクセスできるユーザー設定で、使用するタイムゾーンを設定できます。 データをエクスポートし共有する 社内外でダッシュボードとチャートデータをエクスポートし共有することは、非常に簡単です。 右上のメニューバーにあるPDFとしてダッシュボードをエクスポートボタンを使用して、PDFファイルとしてダッシュボードをエクスポートできます。 チャートをPNG画像またはリンクとして共有することもできます。チャートメニューに移動し、画像として取得またはチャートリンクを取得オプションのいずれかを選択します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 48.163956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Explore</em> and query data"
      },
      "id": "6053437b196a67a8322d1626"
    },
    {
      "sections": [
        "Introduction to the data explorer",
        "Tip",
        "Why it matters",
        "Query your data",
        "Use the data explorer",
        "Explore your events",
        "Explore your metrics",
        "Important",
        "Visualize and refine your exploration",
        "Querying area",
        "NRQL query display",
        "Chart area",
        "Share and export",
        "Use cases",
        "Discover your new data",
        "Validate your data",
        "Troubleshooting data issues"
      ],
      "title": "Introduction to the data explorer",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Explore data"
      ],
      "external_id": "8f390d6aa6f57d215b3c23f8cf08c02ef310bddc",
      "image": "https://docs.newrelic.com/static/e5a9353fdbe2b92dba6856c1ee912b02/c1b63/data_explorer_new.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/explore-data/introduction-data-explorer/",
      "published_at": "2021-04-17T02:08:27Z",
      "updated_at": "2021-03-16T11:03:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the data explorer you can navigate all your data visually, without any NRQL knowledge. Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. Tip To use the data explorer and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters Do you research the state of your systems? Do you need to plan resources, identify and respond to incidents, or troubleshoot faulty behaviors? The data explorer makes it easy to identify, fetch and visualize the data you are looking for through visual menus, without ever using NRQL or building queries. With the data explorer you can: Access events and metrics data in a quick, intuitive way. Exploit the dimensionality of data by making it visible and easily actionable upon. See data from different points of view: from raw data to different visualizations that provide insights on evolution, distribution, etc. Drill down into data with filters. Add your searches to a dashboard in a click. Understand how NRQL works: data explorer shows how queries are built while navigating the available data. Tip Want to switch to New Relic One from Insights? See our transition guide. Query your data To access the data explorer, go to one.newrelic.com and At the top of the page, click the Query your data icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to explore all the data you have in New Relic. You can explore events and metrics on the data explorer UI, or select the Logs and Traces apps to explore those. You can also access the query builder any time by clicking on the tab. Use the data explorer The data explorer consists of a scoping section on the top (a), a data browsing area on the left (b), and a workspace (c). To use the data explorer: Define the scope of the exploration: select the account and data type (metric or event) you want to browse. Select the time range using the time picker. Use the blocks on the left to browse the available data for either events or metrics, and build your search. You can only select one element per block. Blocks are searchable. Explore your events Event type Lists all available events for the selected account. By default, events are sorted by Name. Plot Lists all the numeric attributes of the event previously selected. The first item on the list is count( * ), which is not an attribute. It calculates the count of the selected event. By default attributes are sorted by Name. Select the function that you want to plot. By default each attribute is set to the function Average. Dimensions Lists all the dimensions of the event and plot previously selected. Dimensions are string values that provide information on the event. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are sorted by Name. Explore your metrics To explore APM timeslice data, select AppID, AppName, or EntityGuid as dimensions (or group by those dimensions). Otherwise, you'll get aggregated data for all entities. Metric Lists all the metrics available for the selected account. By default, metrics are sorted by Name. Dimensions Lists all the dimensions of the metric previously selected. Dimensions are string values that provide information on the metric. They represent the cardinality, that is, the uniqueCount of the different values of that attribute in the selected time range. If there is only one element it shows the value of the attribute. By default, dimensions are by Name. Important We use the metric system (including metric SI prefixes) to display our units. Visualize and refine your exploration The result of your exploration is displayed in the working space on the right. Refine your exploration, or share your chart At the working space you can see: Querying area The querying area breaks down the query into its different constituents. Here you can easily read the result of your exploration as a NRQL query, and check the exact data being plotted. If you are not familiar with NRQL, check this area to learn how queries are built. The different parts of the query are: [ EVENTS ONLY]FROM: the event selected on the first block. SELECT: the plot or metric selected. This input plots only one value and one function. GROUP BY: represents the FACET clause, and groups the data by the selected dimension. LIMIT: type in the amount of values you want to see. WHERE: use this field to further filter results. This input plots n values. Each item can be deleted from the query by clicking on the x. NRQL query display You can see the full query, which is composed by the fields above and the time range selected with the time picker. Tip Need to do more advanced searches or customize your charts? From data explorer you can access query builder to edit the query. Chart area By default data is displayed on a line chart. You can easily change to Area chart, Pie chart, and Bar chart using the chart picker. You can also choose to see your results' raw data as a table, or as in JSON format. If you have selected a dimension, the chart is updated with the different facets. Below the chart you can see the facets' table with the list of facets and the value for each one. Use the facet table to drill down data. By clicking on a facet, it is applied as a filter. The table stays visible so you can easily select another facet to continue your exploration. Share and export You can get the chart as an image, share it as a link, or add it to a dashboard using the Options menu on the top right corner. You can also copy the URL and share your whole exploration with other New Relic users. Use cases See the following examples to learn how and when to use the data explorer. Discover your new data I’ve just connected new instrumentation and want to see if new data is available. Select the account and event or metric that's generating the new data. Use the different tools in the data explorer to toy around the new data that has become available: have a look at the raw data of that event or metric as a table, shape it as a list, or click to see it plotted as a chart. After selecting an event or metric, discover the shape of the data in its dimensions. Guided by cardinality, you can see the different points of view of any data. Found anything relevant? Save it to a dashboard or share it with a colleague. Validate your data I changed a custom event/metric and need to check if this change has been successful. In the data explorer tab, select the account, data type and event/metric you made changes to. Verify the entity is reporting data, and that all the attributes are being plotted. Find the attribute you made changes to and check the update was successful. Troubleshooting data issues I know there’s something off with an event/metric from an alert or dashboard. I need to know the root cause about the event/metric/attribute behavior. In the data explorer, use the menus to select the event or metric that's not behaving as expected and let the data explorer plot that chart. From there, you can drill down in the dimensions of that data and filter by those attributes that are relevant. You can also see that data from different perspectives: its distribution, ranking of values, or evolution over time. Found anything relevant? Save it to a dashboard or share it with a colleague.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 44.379883,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the data <em>explorer</em>",
        "sections": "Introduction to the data <em>explorer</em>",
        "tags": "<em>Explore</em> and query data",
        "body": " icon. At the Browse data dropdown, select Events or Metrics. The data explorer is the portal to <em>explore</em> all the data you have in New Relic. You can <em>explore</em> events and metrics on the data explorer UI, or select the Logs and Traces apps to <em>explore</em> those. You can also access the query builder any time"
      },
      "id": "603e962e28ccbc6a92eba7a8"
    },
    {
      "sections": [
        "Data explorer: Query and chart event data",
        "Important",
        "Events vs metrics",
        "UI components",
        "Data samples",
        "Caution"
      ],
      "title": "Data explorer: Query and chart event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Use Insights UI",
        "Explore data"
      ],
      "external_id": "72a23b59b41a3cb521c184c24603d50c28cffdb1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/explore-data/data-explorer-query-chart-event-data/",
      "published_at": "2021-04-16T03:05:44Z",
      "updated_at": "2021-03-30T08:43:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you explore the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs metrics In New Relic Insights, the Data explorer page has two tabs: Events: In the context of the Insights UI, this refers to any data that can be queried via NRQL. This includes all our major data types, including events and the Metric, Log, and Span data types. Metrics: In the context of the Insights UI, this refers to metric timeslice data. (Note that metric timeslice data is available for querying with NRQL in New Relic One.) For an improved querying and charting experience, we recommend using New Relic One chart builder and dashboards. UI components Use the Events data explorer to view and explore the data available to you. The UI includes: A dropdown that lets you select a data type, like PageView or Transaction. A time-based chart for that data. A sample of that data type, showing its attached attributes, and the ability to see other samples. Ability to search by group by and search for specific attributes. Data samples The most recent sample for the chosen data type is listed at the bottom of the page. Default attributes are underlined. To see more samples, select See more samples. You may need to scroll left and right to see the full table of data. Caution The amount of data stored for a given event type can run into the hundreds of thousands, or even millions, of records. This report only shows a small sample. Use this UI to review the structure of the data, not the contents of a specific record. For example, you can use it to make sure an attribute is populating properly.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 39.58773,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data <em>explorer</em>: Query and chart event data",
        "sections": "Data <em>explorer</em>: Query and chart event data",
        "tags": "<em>Explore</em> data",
        "body": " our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you <em>explore</em> the data available to you. There are two data explorer tabs available: Events and Metrics. This document explains details about Events. For information on the Metrics tab, see Metrics data explorer. Events vs"
      },
      "id": "6043efa0e7b9d2b78d5799d2"
    }
  ],
  "/explore-docs/nerdpack-file-structure": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/New-Relic-One-Catalog.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-5",
      "sections": [
        "Subscribe to applications with the New Relic One Catalog",
        "Observability Maps",
        "Metric Aggregator",
        "Workload Geo Ops",
        "Check out these other resources for using—and building—New Relic One applications ",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "The Most Popular New Relic One Applications (Roundup #5)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "75f80d867fec167c4a6d62082f32cb2ff1ae0802",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #5) Jun 4, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Observability Maps Metric Aggregator Workload Geo Ops Subscribe to applications with the New Relic One Catalog Before we start accessing the applications via the CLI, let’s look at how to access these applications directly within New Relic One. To explore available applications, navigate to New Relic One and click on the New Relic One Catalog launcher. New Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. New Relic One Catalog If you deploy an application from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Observability Maps Observability Maps allows you to create a view beyond a traditional service map. Using Observability Maps, you can connect disparate entities in your environment into ad hoc relationships, creating your own relationships based on data available in New Relic. See your entities and environment in a way that makes the most sense to your team and business. Observability Maps App Fork or deploy the Observability Maps app from GitHub. Specific requirements for this app Requires data in NRDB from any or all of the New Relic products. Metric Aggregator The Metric Aggregator is a New Relic One application that helps you create events-to-metrics (E2M) rules, a real-time streaming service that converts event data into dimensional metrics at ingest. Converting events to metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Metric Aggregator App Fork or deploy the Metric Aggregator app from GitHub. Specific requirements for this app If you use New Relic, you already have New Relic Metrics. You can  create E2M rules immediately. Workload Geo Ops Workload Geo Ops links your workloads (collections of entities) to physical locations so you can quickly identify and resolve incidents. It's a geographic exploration of workload data tied to geographic data, including location metadata. You can define maps and then collect or assign entities to points on those maps. With workloads, a collection of entities can be managed by rules and tags to support the dynamic, ephemeral nature of modern IT infrastructure. Fork or deploy the Workload Geo Ops app from GitHub. Specific requirements for this app To get the most of this app, we recommend that you configure Workloads in New Relic One. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Workload Geo Ops to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One applications  Here are resources to help you build your own New Relic One applications. If you can imagine it, you can build it:  developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. NerdGraph GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity. Application/data access and permissions and security. NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 286.97058,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular <em>New</em> <em>Relic</em> <em>One</em> Applications (Roundup #5)",
        "sections": "Subscribe to applications with the <em>New</em> <em>Relic</em> <em>One</em> Catalog",
        "body": " Subscribe to applications with the <em>New</em> <em>Relic</em> <em>One</em> Catalog Before we start accessing the applications via the <em>CLI</em>, let’s look at how to access these applications directly within <em>New</em> <em>Relic</em> <em>One</em>. To explore available applications, navigate to <em>New</em> <em>Relic</em> <em>One</em> and click on the <em>New</em> <em>Relic</em> <em>One</em> Catalog <em>launcher</em>. <em>New</em>"
      },
      "id": "60762e1f64441fbf2e9d856e"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/attributory-screenshot-main.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-6",
      "sections": [
        "Subscribe to apps in the New Relic One Catalog",
        "Flex Manager",
        "GraphiQL Notebook",
        "Attributory",
        "What are you waiting for? Deploy these apps now.",
        "Check out these other resources for using—and building—New Relic One apps",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:26:51Z",
      "title": "The Most Popular New Relic One Applications (Roundup #6)",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "76394d24aebbff40a68e9bd6a7f867313e814d74",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #6) Jul 2, 2020 • 8 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the visibility and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source, so you can use them out-of-the-box, or submit a pull request for feedback and feature requests. In this edition, we cover three apps that help engineers do their jobs: Flex Manager GraphiQL Notebook Attributory Subscribe to apps in the New Relic One Catalog You can manage and deploy apps directly within New Relic One. To explore available apps, navigate to New Relic One and click on the New Relic One Catalog launcher. From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. If you deploy an app from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Flex Manager New Relic Flex is an application-agnostic, all-in-one tool that makes sending data to New Relic from third party sources easier than ever. Use Flex Manager to simplify the work of creating, managing, and deploying new integrations you’ve built with Flex. Fork or deploy the Flex Manager app from GitHub. Specific requirements for this app Flex Manager requires New Relic Infrastructure and the Flex integration. GraphiQL Notebook GraphiQL Notebook allows you to explore and learn about the NerdGraph—the New Relic GraphQL API—using a Jupyter Notebook style interface. Notebooks intermix GraphQL requests with data exploration links. You can create, update, save, and delete notebooks. You can also export and share notebooks as blocks of Base64-encoded JSON. Fork or deploy the GraphQL Notebook app from GitHub. Attributory Attributory is a dictionary of attributes from your APM, Browser, or Mobile applications stored in New Relic. It displays a list of attributes for each application. When you open a service or application from the entity explorer, you’ll find Attributes Dictionary listed as an application in the left-hand navigation. New Relic stores event data as key-value pairs. Built-in New Relic attributes include the definition of the attribute. For custom attributes, you can choose to add your own definitions. Fork or deploy the Attributory app from GitHub. Specific requirements for this app Applications with New Relic APM, Browser, or Mobile agents reporting into New Relic. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account Once you have these requirements in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Attributory to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One apps Here are resources to help you build your own New Relic One apps. If you can imagine it, you can build it: New Relic Developers: Build applications using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Open Source: New Relic’s open source website makes it easy for you to explore the open source projects we maintain and the open standards projects we participate in. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, review our Contributors Guide. Keep in mind that when you submit your Pull Request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 283.6119,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular <em>New</em> <em>Relic</em> <em>One</em> Applications (Roundup #6)",
        "sections": "Subscribe to apps in the <em>New</em> <em>Relic</em> <em>One</em> Catalog",
        "body": " to your <em>New</em> <em>Relic</em> account using the following commands: nr1 <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;nr1-attributory.git cd nr1-attributory nr1 <em>nerdpack</em>:publish nr1 <em>nerdpack</em>:deploy -c STABLE nr1 <em>nerdpack</em>:subscribe -c STABLE Then go to the homepage of <em>one</em>.newrelic.com and select the app’s <em>launcher</em>"
      },
      "id": "60762e1e28ccbcb5fd51c147"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Event-Stream-Screenshot.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-applications-4",
      "sections": [
        "Event Stream",
        "Specific requirements for this app",
        "Neon",
        "Network Telemetry",
        "SLO/R",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:39:54Z",
      "title": "The Most Popular New Relic One Applications (Roundup #4)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "0ac60d545488f3c1904bdd6e0d552af5c307ee5a",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #4) Jan 9, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs different types and combinations of insights into how their apps and systems are performing. That’s why New Relic One is programmable—you can build and deploy custom apps that give you the specific insights and information your company needs. To show you what’s possible—and to inspire you to create apps—we worked with members of the New Relic community to build a handful of open source applications, and the number of newly-developed apps continues to grow. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Event Stream Neon Network Telemetry SLO/R Event Stream During a launch or incident, you need the absolute latest data from your application. Event Stream is like Unix tail for APM data—it pulls in your Transaction and TransactionError data in a live stream, so you can find out exactly what's happening with your app right at that moment. You can also filter and facet the data to show the exact data you need. New Relic One Application Event Stream Fork or deploy the Event Stream app from GitHub. Specific requirements for this app Install the appropriate New Relic APM agent. Neon Need to create a single dashboard to track the health of entire business units or regions? Neon lets you create a status board based on New Relic alerts or the values from New Relic events. Fork or deploy the Neon app from GitHub. Specific requirements for this app To view the status of New Relic alerts, you’ll need to set up a webhook notification channel for the alert policies. See the New Relic documentation to learn more about managing notification channels. Network Telemetry Network Telemetry Screenshot The Network Telemetry app visualizes data collected through the Network Telemetry Infrastructure integration. The integration collects data from network devices that export Sflow or IPFIX network samples, and the app creates visualizations to help you examine the sources and destinations of communication within a network, as well as the volume of traffic between devices. Fork or deploy Network Telemetry from GitHub. Specific requirements for this app Install the New Relic Infrastructure agent, and ensure you have the related access to New Relic One. Install the New Relic Network Telemetry On-host integration.  SLO/R SLO/R Screenshot The SLO/R app calculates service-level objective (SLO) attainment for an application service. It allows you to quickly define SLOs for error, availability, capacity, and latency conditions. By measuring SLO attainment across your service estate, you'll be able to determine what signals are most important for a given service or set of services, developed and supported by a team, organization, or group. Using New Relic as a consistent basis to define and measure your SLOs offers better insight into comparative SLO attainment in your service delivery organization. Note: SLO/R is intended to work with services reporting to New Relic via an APM agent. The service provides an entity upon which to define SLOs. Error budget SLOs are defined directly from APM Transaction events; the other SLO types are defined using New Relic alerts. See \"Creating a webhook to forward Alert incidents to Insights\" for more details. Fork or deploy the SLO/R app from GitHub. Specific requirements for this app Install the appropriate New Relic APM agents. Create a New Relic alerts webhook to forward alert events to a SLOR_ALERTS New Relic database table. See \"Creating a webhook to forward Alert incidents to Insights\" for details. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Event Stream—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-event-stream.git cd nr1-event-stream nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Event Stream to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-event-stream.git cd nr1-event-stream   nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications. If you can imagine it, you can build it: developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 274.36157,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular <em>New</em> <em>Relic</em> <em>One</em> Applications (Roundup #4)",
        "sections": "Check out these other resources for using—and building!—<em>New</em> <em>Relic</em> <em>One</em> applications",
        "body": " in minutes using our <em>CLI</em> and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. <em>New</em> <em>Relic</em> documentation: Learn more about: The <em>Nerdpack</em> <em>file</em> <em>structure</em>, including how"
      },
      "id": "60762e2028ccbcaf8651c17c"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/DEPLOYMENT-ANALYZER-SCREENSHOT-1.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-3",
      "sections": [
        "Container Explorer",
        "Specific requirements for this app",
        "Deployment Analyzer",
        "Page View Map",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:25:05Z",
      "title": "Most Popular New Relic One Applications (Round up #3)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "6f0be6c93ebcc052fac27513c1e849c0dfd256e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic Most Popular New Relic One Applications (Round up #3) Nov 26, 2019 • 7 min read By Joel Worrall Hopefully, you’ve heard the news that the New Relic One observability platform is now programmable. As central component of an observability platform, we believe programmability gives you the ability to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the possibilities—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications … and then we kept going. In fact, new apps are coming in every day. And we hope to see app contributions by New Relic users continue. This blog series is our opportunity to spotlight the most popular apps available today from our GitHub repository. The best part: Every app is available under an open source license and can be deployed right now! In this edition, we cover: Container Explorer Deployment Analyzer Page View Map Container Explorer This app includes a launcher that gives you a global view of all containers associated with an account. You can also employ tags to segment and drill down into subsets of your global container inventory. The app also presents container CPU, memory, and disk I/O usage in the form of intuitive and efficient heat map visualizations. Container Explorer presents CPU, memory, and disk I/O usage for all containers associated with an account—displaying this data via intuitive and efficient heat map visualizations. In the New Relic One entity explorer, we provide a nerdlet that will show all of the containers that are running for a selected APM application (service). We can also detect whether infrastructure data is coming from third-party sources and can, if necessary, automatically present this container telemetry in-context. Container Explorer can detect whether infrastructure data is coming from third-party sources—and can, if necessary, automatically ingest and present this container telemetry in-context. Clicking on a node in the heatmap reveals details about that container, and you can also jump to its host in the entity explorer. Clicking on a node in the Container Explorer heatmap reveals details about that container, and users can also jump to its host in the entity explorer. Fork or deploy the Container Explorer app from GitHub. Specific requirements for this app The New Relic Infrastructure agent must be deployed on any host you want to monitor. Note: We generate per-container CPU and other metrics by summarizing all processes in a given containerId. This will, however, report an accurate value only if the agent reports one ProcessSample per process every 30 seconds. Deployment Analyzer Deployments of applications can be risky events, but you can correlate those events to the performance of your applications, using deployment markers in New Relic. This app builds further on this process—enabling teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Deployment Analyzer enables teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Fork or deploy the Deployment Analyzer app from GitHub. Specific requirements for this app You'll need an active New Relic APM Pro subscription in order to access deployment marker functionality. Page View Map This app creates geographic visualizations of New Relic Browser application data using the React Leaflet mapping library. Leaflet is a leading open-source JavaScript library for mobile-friendly interactive maps. In addition to providing a new way to visualize your business data, this app offers a great example of what's possible for developers working with our GraphQL service and a third party library. Page View Map creates geographic visualizations of New Relic Browser application data Fork or deploy the Page Views Map app from GitHub Specific requirements for this app You must have the New Relic Browser Agent(s) installed, as well as related access to New Relic One. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer.git cd nr1-container-explorer nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Container Explorer to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer cd nr1-container-explorer nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app's launcher (unless otherwise noted above). Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications: New Relic Developer Edition: Early access to the Developer Edition of New Relic One gives you a free, personal sandbox account where you can build your own experience with all the available New Relic tools. developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome contributions to any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series.   Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 274.36145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Most Popular <em>New</em> <em>Relic</em> <em>One</em> Applications (Round up #3)",
        "sections": "Check out these other resources for using—and building!—<em>New</em> <em>Relic</em> <em>One</em> applications",
        "body": " in minutes using our <em>CLI</em> and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. <em>New</em> <em>Relic</em> documentation: Learn more about: The <em>Nerdpack</em> <em>file</em> <em>structure</em>, including how"
      },
      "id": "60762e1f196a673d0a64a782"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programmability_cloud_optimize-1024x604_0.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-1",
      "sections": [
        "Top",
        "Specific requirements for this app",
        "Datalyzer",
        "Browser Analyzer",
        "Cloud Optimize",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open-source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:49:03Z",
      "title": "The Most Popular New Relic One Applications (Roundup #1)",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "4535d9710491dc32585422707013084b59e3372d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #1) Oct 25, 2019 • 8 min read By Joel Worrall You've probably heard the news by now: The New Relic One observability platform is programmable. As the central component of an observability platform, we believe programmability enables you to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the possibilities—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications ... and then we kept going. In fact, new apps are coming in every day. And we hope to see New Relic customers keep these app contributions coming. In this blog series, we’ll highlight some of he most popular contributed apps. And here's the best part: All of these apps are open source and ready to be deployed right now! In this edition, we cover: Top Datalyzer Browser Analyze Cloud Optimize Top One of our most popular applications to date, the Top app brings the classic Unix command into New Relic One. Top is a simple process monitor that lets you inspect the CPU, I/O, and memory of all processes running on a host. Install this app today and eliminate the drudgery of SSHing into hosts to run top—get all those summary metrics right in New Relic One. Select a host, and inspect the CPU, I/O and memory of all processes running on that host. Fork or deploy the Top app from GitHub. Specific requirements for this app You’ll need the New Relic Infrastructure agent deployed on any host you want to monitor. Datalyzer The New Relic data platform collects and stores several key data types—metrics, events, traces, and logs (also referred to as M.E.L.T.)—from many different entities. But this data is highly dimensional and complex. Finding exactly what you’re looking for in a sea of data can be a challenge—especially if you’re not asking the right questions. The Datalyzer app gives you an interactive view into all your data, so you can quickly slice and dice it with New Relic Query Language (NRQL) queries to answer questions, find the source of problems, and discover patterns you didn’t even know about. And from query to render time, it’s fast—lightning fast. More specifically, Datalyzer allows you to: Search for any event or metric type See all dimensions and the frequency distribution of the attributes to identify commonality and outliers Click an attribute and get an immediate refresh of data faceted by that attribute Click a facet to automatically filter the view and repopulate the attributes with the new context See the NRQL query updated in real time Pin the chart to a dashboard or add to an alert Use NRQL queries in Datalyzer to dive deeper into your data. The Datalyzer app is offered as a launcher from the New Relic One homepage, providing global visibility across all accounts, metrics, and events. You can also access it from the entity explorer: select a service, mobile app, or browser app, and use the Datalyzer to analyze relevant data specific to that entity: The Datalyzer app is available from within the New Relic One entity explorer. Fork or deploy the Datalyzer app from GitHub. Specific requirements for this app You’ll need a New Relic account with some data in it. Note: When you query against metrics, Datalyzer allows you to explore dimensional metric data gathered by the Metric API. Part of our open instrumentation initiative, the Metric API sends detailed metric data to New Relic, without the need for an agent. Our Telemetry SDKs (and the open-source exporters that use them) also send this type of data. Datalyzer does not support traditional (non-dimensional) metrics collected by older New Relic products. Browser Analyzer One day, our General Manager for New Relic Browser, Buddy Brewer, envisioned a simple way to visualize customer experience and satisfaction scores. He sent me a sketch, and two days later we had a production-ready application that showed not just what the customer experience scores were, but what they should be. The Browser Analyzer app lets you know how slow pages increase bounce rates and hurt your business. It shows you the exact impact and forecasts how improving the performance of your website can improve KPIs like bounce rate and traffic. The app also figures out which pages of your site have the worst impact on performance, so you know where to start making fixes. The analysis is based on your Browser Apdex score (pulled from the Browser PageView event). The Browser Analyzer app correlates customer satisfaction with opportunities for improved performance. Note: This app is not served as a launcher on the homepage of New Relic One. Instead, you'll have to navigate to a Browser app via the entity explorer. Fork or deploy the Browser Analyzer app from GitHub. Specific requirements for this app You’ll need to have New Relic Browser agents installed on the pages you want to monitor. Cloud Optimize For organizations that have made the great migration to the cloud, one question comes up time and again: “Are we wasting money on excess cloud capacity?” It can be difficult to connect the size and amount of infrastructure spending to the needs of your organization—especially if you operate at enterprise scale with dynamic, ephemeral resources. But optimizing the size of your instances could save you thousands of dollars  … or a lot more! Find out how much money you can save on your cloud spend with the Cloud Optimize app. The Cloud Optimize app evaluates the size of your cloud instances and their utilization, and shows the amount of money you could save by right-sizing your instances while still delivering an excellent digital customer experience. [embed]https://www.youtube.com/watch?v=qc4cHyPtylo&feature=youtu.be[/embed] Specific requirements for this app The Cloud Optimize app is compatible with Amazon Web Services (AWS), the Google Cloud, and the Microsoft Azure Cloud. You’ll need to have New Relic Infrastructure agent(s) installed on your cloud computing devices. To get the best possible data out of this application, we recommend that you install New Relic APM on applications hosted on your instances and group them by application. Then, depending on your cloud provider, choose one of the following: AWS: Activate the EC2 integration. GCP: Google Computer Engine integration. Azure: Azure VM’s integration. What are you waiting for? Deploy these apps now! To deploy any of these apps, you’ll need: Access to New Relic One (requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account Once you have all these requirements in place, deploying an application locally—in this example, Browser Analyzer—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-browser-analyzer.git cd nr1-browser-analyzer nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Browser Analyze to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-browser-analyzer cd nr1-browser-analyzer nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to one.newrelic.com, click the entity explorer, select a browser app from the available list, and then click on your newly deployed Site Analyzer: Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we’ve created plenty of resources to help you get started creating your own New Relic One applications: newrelic.com Start building applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API GraphQL Explorer: Explore your data using our GraphQL API New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open-source projects We welcome contributions on any of our open-source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our CLA. If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in as we preview more apps in future editions of this series.   Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 242.01317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular <em>New</em> <em>Relic</em> <em>One</em> Applications (Roundup #1)",
        "sections": "Check out these other resources for using—and building!—<em>New</em> <em>Relic</em> <em>One</em> applications",
        "body": ": The <em>Nerdpack</em> <em>file</em> <em>structure</em>, including how to link your application with an entity Application&#x2F;data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> and SDK <em>New</em> <em>Relic</em> Explorers Hub"
      },
      "id": "60762e1e64441fc1539d8555"
    }
  ],
  "/explore-docs/nr1-cli": [
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-16T22:12:16Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.6171,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.532,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.99478,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.99245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.99245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/build-apps/add-nerdgraphquery-guide": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/graphql_aws_services-1024x593.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/graphql-api",
      "sections": [
        "Using GraphQL in New Relic",
        "Example 1: Querying Infrastructure cloud integrations with NerdGraph",
        "Example 2: Modifying integration configurations with NerdGraph",
        "Transfering NerdGraph data to the terminal",
        "New Relic and GraphQL—easing the path for developers"
      ],
      "published_at": "2021-04-16T04:24:43Z",
      "title": "Getting Started With NerdGraph—The New Relic GraphQL API Explorer",
      "updated_at": "2021-04-14T00:03:23Z",
      "type": "",
      "external_id": "381e6b1a3bca81ebc8b6efc8199d2b75983befca",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Getting Started With NerdGraph—The New Relic GraphQL API Explorer Jun 11, 2020 • 12 min read By Mark Weitzel As you build observability into your workflows and processes, you need the ability to quickly retrieve, sort, and process all kinds of telemetry through APIs. With New Relic, you can gather a lot of data, but when you’re building dashboards and applications for working with your data, you want to minimize superfluous API operations. With the NerdGraph API explorer—built on GraphQL—you can more easily query the data you need, without over-or under-fetching, and reduce manual toil in your data analysis workflows. More specifically, in New Relic you can use NerdGraph to: Query all the entities associated with your account Query, create, and update the workloads associated with your account Create, manage, and add tags to entities Query distributed tracing data Fetch data when building a New Relic One application Understand upstream and downstream relationships with your services Configure your New Relic Infrastructure cloud integrations Query event data and custom event data with NRQL In this post, I’ll walk through two examples using NerdGraph to query information about New Relic Infrastructure cloud integrations and update their configuration values. But first a bit of history. Using GraphQL in New Relic Unlike typical REST APIs that often require loading from multiple endpoints, GraphQL provides a single endpoint that can manage complex queries so developers can get all the data their app needs from many services in one request. GraphQL is strongly typed, which allows developers to explicitly declare what information is available via queries to the GraphQL service. This declaration is done via a GraphQL schema. Schemas give developers the flexibility they need to express information about the data they return. For example, each field has a description, which developers can use to indicate the proper usage of the data. Schemas also provide the API blueprint developers need to build tools for properly constructing queries and guiding proper usage of any returned data. For example, developers can use the schema to indicate if a field has been deprecated so tools like IDEs can surface this fact and discourage use of that data. And “schema stitching”—creating a single schema from several underlying GraphQL APIs—allows developers to deliver a unified access experience across all of their APIs, as we’ve done at New Relic: The New Relic GraphQL implementation includes several underlying GraphQL APIs—including accounts, Infrastructure, and the New Relic database (for constructing NRQL queries). For more information on GraphQL, the following examples of querying cloud integration configuration data use GraphQL queries and mutations: Queries: GraphQL requests that only fetch data Mutations: GraphQL requests that modify and fetch data NerdGraph has a single endpoint: https://api.newrelic.com/graphiql. This launches (after authenticating the user) the NerdGraph API interface—an interactive, browser-based IDE for running GraphQL requests. In the NerdGraph API explorer, you build and run your query on the left, and the result is returned on the right. You can click into fields to drill into their definitions. For example, if you drill into actor, you’ll see it contains fields for user and accounts: { actor { user { name email } accounts { id name } } } The fields under actor expose data from different downstream services that are unified in the GrahQL schema delivered by the GraphQL server. When you issue a query, the GraphQL server pulls apart the query and invokes a resolver for each of the services. When the queries complete (or time out or encounter errors), the GraphQL server assembles the result and returns it to you. In the example above, we get information about the user and all the accounts that they have access to. Let’s walk through our examples to show the full power of GraphQL’s data collection capabilities. Example 1: Querying Infrastructure cloud integrations with NerdGraph In my first example, I’ll use NerdGraph to query for various data about the AWS integrations that are running in my New Relic account. I’ll use the data I gather in this example to update some specific settings in the next section. Tip: If you’re planning on following along, make sure you generate an API key that you can use with New Relic’s GraphQL API. In fact, you can generate one directly from NerdGraph. Let's start with a list of the AWS integrations I have available in New Relic Infrastructure: AWS integrations installed in New Relic Infrastructure. Next, let's retrieve some information about these AWS services via a GraphQL query. I’m going to query for the cloud provider (in this case, AWS) that’s linked to my account and the set of integrations from AWS that I’ve installed. To do this, I need to pass the ID of the account I want to query—this is the account(id: MY ACCOUNT ID) part of the query. Notice that I’m “nesting” requests to get information about the cloud provider and the integrations I’m using. If I were using a REST API, this would require multiple calls, but with the GraphQL API, I can gather this information with just one query.   { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { id name slug } integrations { id name service { id slug name createdAt updatedAt provider { name id } } } } } } } } When the query completes, the GraphQL server assembles the results about the AWS integrations I’ve installed, as shown below (note that I’ve truncated the example): { \"data\": { \"actor\": { \"account\": { \"cloud\": { \"linkedAccounts\": [ { \"authLabel\": \"arn:aws:iam::8xxxxxxx7:role/NewRelicInfrastructure-Integrations-Origami\", \"externalId\": \"8xxxxxxx7\", \"id\": 3542, \"integrations\": [ { \"id\": 75540, \"name\": \"RDS\", \"service\": { \"createdAt\": 1470991744, \"id\": 3, \"name\": \"RDS\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"rds\", \"updatedAt\": 1534242454 } }, { \"id\": 14233, \"name\": \"S3\", \"service\": { \"createdAt\": 1470991745, \"id\": 4, \"name\": \"S3\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"s3\", \"updatedAt\": 1534242454 } }, { \"id\": 12223, \"name\": \"Lambda\", \"service\": { \"createdAt\": 1477910055, \"id\": 14, \"name\": \"Lambda\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"lambda\", \"updatedAt\": 1534242454 } }, { \"id\": 172534, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 } }, } } ] } } } } } But what if I want more specific information about one of the integrations? Specifically, I want to see what tags (user-defined metadata) I’ve applied to a particular integration as well as its metrics polling interval (how often New Relic polls the integration for data), and when these settings were last updated. To do this, I’ll need to use one of the more nuanced features of GraphQL—interfaces, an abstract type that represents a collection of common fields that other object types can implement. So in my original query, I’ll add two new clauses: ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } Now, if my query hits a result that is of type CloudDynamodbIntegration or CloudReshiftIntegration, it also return the fields metricsPollingInterval, tagKey, tagValue, and updatedAt. Here's what my (truncated) query will like now: { actor { account(id: MY ACCOUNT ID) { cloud { linkedAccounts { id externalId name authLabel provider { ... } integrations { id name service { ... } } ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } ... on CloudRedshiftIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } } } } } } In the result, notice that the DynamoDb and Redshift configuration information contain the extra fields that I specified in the query using their interfaces. { \"id\": 173397, \"metricsPollingInterval\": 900, \"name\": \"Redshift\", \"service\": { \"createdAt\": 1497364366, \"id\": 21, \"name\": \"Redshift\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"redshift\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1544435410 }, { \"id\": 112183, \"metricsPollingInterval\": 900, \"name\": \"DynamoDB\", \"service\": { \"createdAt\": 1470991758, \"id\": 13, \"name\": \"DynamoDB\", \"provider\": { \"id\": 1, \"name\": \"Amazon Web Services\" }, \"slug\": \"dynamodb\", \"updatedAt\": 1534242454 }, \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1549499902 }, OK! I’ve successfully queried information about my AWS integrations in New Relic Infrastructure, and I’ve used an interface to get additional information about a specific integration. Now, I’ll use the GraphQL API to update the metrics data polling intervals in one of these integrations. Example 2: Modifying integration configurations with NerdGraph In GraphQL, when you modify data with a write operation, it’s called a mutation. In this example, I’ll build a mutation to update the polling intervals of an AWS integration. First, though, I’ll set a polling interval so that we'll notice when I change it with NerdGraph. Here are the configuration options for my AWS DynamoDB integration: DynamoDB integration configuration options in New Relic Infrastructure. As you can see, I’ve set the metrics data and inventory data polling intervals to every 5 minutes, and I’ve also toggled Collect tags to ON. Now I’ll build the mutation query. First, I'll start with the keyword mutation, and like any GraphQL API request, enclose it in a pair of curly braces,{ }. Next, I want to specify that I’m configuring a cloud integration; so I’ll add cloudConfigureIntegration, which takes two arguments: accountId and integrations. For accountId, I’ll use the same account id from the first example to get information about the Infrastructure-linked accounts. The second argument is the integrations that I want to update. Again, integrations are specified by cloud provider, so here I want to include aws. So far my mutation looks like this: mutation{ cloudConfigureIntegration( accountId:MY ACCOUNT ID integrations:{aws I want to specify that I’m updating the configuration for DynamoDB, so I’ll pass in an object with dynamodb as the key and an array that contains objects with the values I want to to set. Remember, for our mutation, we want to update the metricsPollingInterval (valid values are 300, 900, 1800, and 3600 seconds) and add a tagKey (metadata about the function of the integration). The final part of the mutation adds a set of fields to return if my request is successful and a set of fields to return if there are any errors. Here's the full query: mutation{ cloudConfigureIntegration( accountId:630060 integrations:{aws:{ dynamodb:[ { linkedAccountId:4912 metricsPollingInterval:1800 tagKey:\"mdw-test\" }] } } ) { integrations{ id name updatedAt ... on CloudDynamodbIntegration{ metricsPollingInterval tagKey tagValue updatedAt } } errors{ linkedAccountId message integrationSlug } } } And here’s the result, which shows no errors and indicates DynamoDB’s configuration was successfully updated: { \"data\": { \"cloudConfigureIntegration\": { \"errors\": [], \"integrations\": [ { \"id\": 177184, \"metricsPollingInterval\": 1800, \"name\": \"DynamoDB\", \"tagKey\": \"mdw-test\", \"tagValue\": null, \"updatedAt\": 1551139957 } ] } } } I can now return to New Relic Infrastructure and refresh the DynamoDB configuration page: Refreshing the DynamoDB configuration in New Relic Infrastructure. Our mutation changed the metric polling interval from 300 seconds (5 minutes) to 1800 seconds (30 minutes), and entered tag key value of mdw-test. That's it! I've successfully updated the configuration of a New Relic Infrastructure integration using NerdGraph. Transfering NerdGraph data to the terminal So, now you know how to explore the New Relic data available to you in NerdGraph, and you know how to create queries and mutations, but how do you transfer this data to your code? To capture code-ready queries and mutations, select the Tools drop down in the NerdGraph explorer. To copy a curl statement with the in-scope query to your clipboard, select Copy as CURL. Paste this code snippet into your terminal, or use it to populate an HTTP request in your code. If you’re working with the New Relic CLI, select Copy as New Relic CLI from the drop down to generate a command-line ready query or mutation. New Relic and GraphQL—easing the path for developers As these examples show, GraphQL is extremely flexible and lightweight, and dramatically reduces the overhead of working with your New Relic data. If you want to challenge yourself even more, create some more complex queries in the Query Builder. For example, can you create a query to grab the count of all of your reporting entities? Hint: check out NerdGraph’s entity search field. We’re passionate about making life for developers as easy as possible. Check out the resources available at developer.newrelic.com, and engage in the discussion with fellow developers on the Explorer’s Hub. By Mark Weitzel Mark Weitzel is General Manager, New Relic One at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 320.6056,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Started With <em>NerdGraph</em>—The New Relic <em>GraphQL</em> API Explorer",
        "sections": "Example 1: <em>Querying</em> Infrastructure cloud integrations with <em>NerdGraph</em>",
        "body": "QL—you can more easily <em>query</em> the <em>data</em> you need, without over-or under-fetching, and reduce manual toil in your <em>data</em> analysis workflows. More specifically, in New Relic you can use <em>NerdGraph</em> to: <em>Query</em> all the entities associated with your <em>account</em> <em>Query</em>, create, and update the workloads associated"
      },
      "id": "6076314c64441f483e9d8576"
    },
    {
      "sections": [
        "Drop data with drop filter rules",
        "Caution",
        "Why it matters",
        "How drop filter rules work",
        "Create drop filter rules",
        "Important",
        "Types of drop filter rules",
        "Drop log events",
        "Drop attributes",
        "Tip",
        "Cautions when dropping data",
        "Delete drop filter rules"
      ],
      "title": "Drop data with drop filter rules ",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "UI and data"
      ],
      "external_id": "9590bd4593abd451633a4beacd94d56eb1a481bd",
      "image": "https://docs.newrelic.com/static/62ef55a62dd87f45ce7e15d7b57fc980/38af3/NRDB2.png",
      "url": "https://docs.newrelic.com/docs/logs/log-management/ui-data/drop-data-drop-filter-rules/",
      "published_at": "2021-04-16T21:26:06Z",
      "updated_at": "2021-04-12T16:59:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After log event data has been shipped to New Relic, it can either be stored in our database (NRDB) or dropped (discarded). New Relic can drop both log events and event attributes via drop filter rules. You can manage drop filter rules using New Relic's log management or NerdGraph. Caution Use caution when deciding to drop data. The data you drop is not recoverable. Before using this feature, review Responsibilities and considerations. Why it matters Drop filter rules help you accomplish some very important goals: You lower costs by storing only logs relevant to your account. You protect privacy and security by removing personal identifiable information (PII). You reduce noise by removing irrelevant events and attributes. How drop filter rules work A drop filter rule matches data based on a query. When triggered, the drop filter rule removes the matching data from the ingestion pipeline before it is written to in NRDB. Since the data does not reach the backend, it cannot be queried: the data is gone and cannot be restored. During the ingestion process, log data can be parsed, transformed, or dropped before being stored. Create drop filter rules Caution You must have admin permissions in New Relic to create and edit drop filters, or be a member of a role with create and edit permissions for Logging Parsing Rules. Drop filter rules can be created from one.newrelic.com > Logs using new or existing log queries. To create a new drop filter rule: Filter or query to the specific set of logs which contain the data to be dropped. Once the query is active, click on Create drop filter in the Manage Data section on the left panel. You can choose to either drop the entire log event that matches the query or just a specific subset of attributes in the matching events. Save the drop filter rule. Before saving the rule, consider changing its name. Important Once a drop filter rule is active, it's applied to all log events ingested from that point onwards. Rules are not applied retroactively: logs collected prior to the creation of a rule are not filtered by that rule. Types of drop filter rules Drop log events The default type of drop filter rule is to drop logs. This option drops the entire log events that match the filter query. When creating a rule try to provide a specific query that only matches log data which should be dropped. New Relic won't let you create drop filter rules without values in the matching query: this prevents badly formed rules from dropping all log data. Drop attributes You can specify attributes to be dropped in a log event that matches your query. At least one or more attributes must be selected. Any attribute which is selected will be dropped; all remaining attributes will be kept and stored in NRDB. Tip We recommend this method for removing fields which could contain personal identifiable information (PII) or other sensitive attributes without losing valuable monitoring data. Cautions when dropping data When creating drop rules, you are responsible for ensuring that the rules accurately identify and discard the data that meets the conditions that you have established. You are also responsible for monitoring the rule, as well as the data you disclose to New Relic. New Relic cannot guarantee that this functionality will completely resolve data disclosure concerns you may have. New Relic does not review or monitor how effective the rules you develop are. Creating rules about sensitive data can leak information about what kinds of data you maintain, including the format of your data or systems (for example, through referencing email addresses or specific credit card numbers). Rules you create, including all information in those rules, can be viewed and edited by any user with the relevant role-based access control permissions. Delete drop filter rules Drop filter rules can be deleted from one.newrelic.com > Logs. To delete a drop filter rule: On the Manage data panel on the left, Click on the Drop Filters menu. Click the delete icon next to the drop filter rule you want to remove. Once deleted, rules no longer filter ingested log events.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 301.8692,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Drop</em> <em>data</em> with <em>drop</em> filter rules ",
        "sections": "<em>Drop</em> <em>data</em> with <em>drop</em> filter rules",
        "tags": "UI and <em>data</em>",
        "body": "After log event <em>data</em> has been shipped to New Relic, it can either be stored in our database (NRDB) or dropped (discarded). New Relic can <em>drop</em> both log events and event attributes via <em>drop</em> filter rules. You can manage <em>drop</em> filter rules using New Relic&#x27;s log management or <em>NerdGraph</em>. Caution Use"
      },
      "id": "603e813f28ccbc08c1eba787"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/5-server-error.png",
      "url": "https://newrelic.com/blog/nerdlog/apollo-server-plugin",
      "sections": [
        "Troubleshooting errors and latency",
        "Scenario 1: Troubleshooting an error",
        "Scenario 2: Latency is caused by an external service"
      ],
      "published_at": "2021-04-15T23:18:16Z",
      "title": "How to Monitor GraphQL Apps with New Relic Apollo Server Plugin",
      "updated_at": "2021-04-13T23:25:03Z",
      "type": "",
      "external_id": "ed9ecf22946c370441fabd487527ea21ce3cec38",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Nerdlog How to Monitor GraphQL Apps with New Relic Apollo Server Plugin Dec 15, 2020 • 6 min read By Rebecca Rodriguez Apollo Server, an open source GraphQL server that helps you connect a GraphQL schema to an HTTP server in Node, can be used with popular frameworks such as Express, Connect, Hapi, Koa, Restify, and AWS Lambda. Developed four years ago when Facebook open sourced GraphQL, it has accelerated in popularity over REST APIs, mainly due to its efficiency. However, GraphQL can be challenging to monitor. With GraphQL, you can fetch and retrieve data in a single query, enabling you to ask for exactly the data you need while minimizing the amount of data transferred over the network and improving performance. However, this single operation or endpoint is exactly what makes GraphQL operations challenging to monitor. Measuring the response time of one GraphQL endpoint won’t tell you enough about an application’s health. The New Relic Apollo Server plugin provides visibility into GraphQL payloads down to the resolver level and associated external service calls. To monitor your GraphQL applications, you want to understand the timing of individual GraphQL operations and then have the ability to filter down to the root cause of an issue. If a GraphQL operation is slow, the cause of the latency could be due to several things. For one, it could be the structure of the operation itself. For example, batched operations could cause the operation to take longer than desired. Resolvers, the functions responsible for populating the data for a single field in your schema, could also cause latency. In this case, you’d want to adjust the function call. However, latency could also be caused by an external service’s poor performance, such as an API or a database. Using distributed tracing, you can identify which external service the GraphQL field is calling and attribute the latency to that external service. By using the New Relic Apollo Server plugin to instrument your applications, you can get to the root cause of issues. The plugin records the overall timing of the operations and then parses the payload so you can uncover and diagnose the cause of your slow GraphQL operations. Distributed tracing goes further and provides the capability to understand if the latency is coming from the application itself or other services. Troubleshooting errors and latency Let’s walk through two troubleshooting scenarios: We built a simple example Node application that interfaces with NASA’s Near Earth Objects API (search for near earth object). The app allows us to monitor how close an asteroid is to Earth and when it will get here, so we have time to prepare and minimize impact. Using GraphQL, you can query NASA’s API for the asteroid’s relative velocity and distance from the Earth. It’s important that the GraphQL queries avoid errors and latency to avoid misjudging the time it will take the asteroid to reach us. Scenario 1: Troubleshooting an error In this first example, you see a GraphQL error on the error events page and will want to find the root cause to fix it quickly. 1. Click on the error class to see more detailed error information. 2. Select the transaction name in the transaction view, and explore it using distributed tracing. 3. In the distributed trace view, you can identify the transactions that are throwing the errors. 4. Click on a particular trace to get a detailed view of the operation span with the error message and the offending query. In this case, you can see an internal server error related to the resolver. 5. Finally, you can always keep track of your slow operations and resolvers through a custom dashboard view. Scenario 2: Latency is caused by an external service In this example, you have a transaction view that shows a slow transaction: 1. By hovering over it, you see it’s from a slow GraphQL query called ClosestAstroidFound. 2. To understand why the query is slow, click on the transaction and select Find distributed traces for this transaction. 3. When you see slow transactions, you can explore them using distributed tracing. 4. When exploring the transaction, expand the GraphQL resolver span and see it making a call to another instrumented service taking most of this transaction’s time. Instrument your apps to get to the root cause of GraphQL errors and slowness in GraphQL operations with the New Relic Apollo Server plugin. By Rebecca Rodriguez Rebecca Rodriguez is a Senior Product Manager at New Relic with a focus on Python, Node, and Browser observability data ingest. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 301.35132,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How to Monitor <em>GraphQL</em> <em>Apps</em> with New Relic Apollo Server Plugin",
        "body": " navigation <em>menu</em>, 4 items How to Relic Best Practices <em>Nerd</em> Life Nerdlog Search the blog Submit Nerdlog How to Monitor <em>Graph</em>QL Apps with New Relic Apollo Server Plugin Dec 15, 2020 • 6 min read By Rebecca Rodriguez Apollo Server, an open source <em>Graph</em>QL server that helps you connect a <em>Graph</em>QL schema"
      },
      "id": "6076284f196a67dc5764a7a5"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/app-server-breakdown.png",
      "url": "https://newrelic.com/blog/how-to-relic/go-agent-apm",
      "sections": [
        "Up and Running With the <br>New Relic APM Go Agent",
        "Overview",
        "My example",
        "Instrument all the things!",
        "Transactions",
        "Segments",
        "Attributes",
        "Related Topics"
      ],
      "published_at": "2021-04-16T00:00:57Z",
      "title": "Up and Running With the New Relic APM Go Agent",
      "updated_at": "2021-04-13T23:59:47Z",
      "type": "",
      "external_id": "76e4f026f6277f62a5571f68605f5c48ffeb67c9",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit APM Up and Running With the <br>New Relic APM Go Agent Aug 23, 2016 • 9 min read By Erika Arnold The Go programming language’s performance, ease of deployment, and simple concurrency model are common reasons developers switch to Go. I didn’t know much about Go, so I recently converted a personal Python project and started monitoring it with the New Relic Go Agent. Using my app as an example, I’ll overview the agent and dig into some of its coolest features, including transactions, segments, and attributes that give me insight into my application’s throughput, error rate, and response time like I used to have with the Python Agent. See also: The Most Popular Programming Languages of 2016 Overview The Go agent works a little differently than other New Relic agents, such as PHP or Ruby, which you import as a library or module and they “automagically” collect data. This magic is possible because those languages provide hooks into their virtual machine that the agents use to access and wrap functions. However, Go is a compiled language; it doesn’t use a virtual machine. This means the best way to monitor Go applications is to use an API. While this makes the Go agent a little more work to install, it provides tremendous flexibility and control over what gets instrumented. And it still has the magic, too! Simply importing the agent and creating an application gives you useful runtime information about the number of goroutines, garbage collection statistics, and memory and CPU usage. We even made a special “Go runtime” page for these metrics in New Relic APM. It’s useful, actionable information for any Go developer to have at a glance. Go runtime metrics Reporting these metrics for your application is easy. First, download the library from GitHub or via go get. Add it to your application’s import block, then create a config and an application in your main() or init() function: config := newrelic.NewConfig(\"Your App Name\", \"YOUR_LICENSE_KEY\") app, err := newrelic.NewApplication(config) The agent periodically records information sourced from the MemStats structure in the runtime package. We’ve already had several customers report that the goroutines chart has identified leaks they didn’t know existed. While Go provides several good monitoring tools, they are valuable only when used consistently. Integrating New Relic into your app automates monitoring and helps you quickly spot new issues with each deploy. My example Have you ever heard of the Kevin Bacon Six Degrees of Separation game? In that spirit, I had built a Python app called wikiGraph to query the shortest path between any two of Wikipedia’s 4.5 million pages, which I stuffed into a Neo4j graph database. This allows you to answer all sorts of interesting questions, like how many clicks does it take to get from Grace Hopper to sushi? [See bottom of post for answer.] When a user inputs two page names, the server queries a smaller SQLite database for page information and queries the graph database for the shortest path. It then asks the graph database for a selection of “neighboring” pages, assembles a graph, and passes it back to the frontend. Converting my Python app to Go was fun! I especially enjoyed using structs that could easily unmarshal into JSON and using goroutines to make my database queries concurrent. Once my app was in Go, I was ready to install the New Relic APM agent and start monitoring it. Instrument all the things! As mentioned earlier, runtime metrics are only the beginning of the information our Go agent can provide. With so much flexibility, though, how do you decide what to instrument? Should you collect information about every function? What if you want information about only a small block of code? I suggest starting with your most important areas of concern. I decided to focus on these two questions: What is the timing information for my server’s routes? What is the breakdown of time spent in the databases? Whatever questions you decide to tackle first, the next decision is how to handle the application structure you just created. You’ll need to access it within your handlers in order to create transactions and custom events. Should the application be a global variable or should it be passed around as a parameter? The answer mostly depends on your developer worldview. Choosing a global structure certainly makes access convenient. However, passing around parameters makes the application an explicit dependency of the function that uses it. The code becomes more modular and easier to test, since you can just swap in applications for a particular test. As a first pass, I recommend making the application global, but I don’t think I would leave it this way long term. Transactions What is a Go transaction? The short answer is that it’s whatever you want it to be. You can start and end a transaction around a route, a function, or just a block of code. In the New Relic realm, transactions are traditionally equated with server requests. For my app, I use half a dozen routes to serve frontend requests so that paradigm makes sense for me. With the New Relic APM Go agent, you have the power to (and you must) start and stop the transaction explicitly. If you don’t need to scope the transaction to a particular bit of code, defer statements are a convenient way to end a transaction: txn := app.StartTransaction(\"/query\", responseWriter, request) defer txn.End() But wait, there’s more: the Go agent has built-in support for request handling! If you are using the http standard library package, you can use the agent’s wrappers to automatically start and end transactions with the request and response writer. This is how I created transactions for each route: http.HandleFunc(newrelic.WrapHandleFunc(app, \"/query\", queryHandler)) One important restriction is that each transaction should be used in only a single goroutine. If you want to access the transaction in a new goroutine, just start a new transaction for it. You’ll probably want to access the current transaction within the handler to do fun things with segments and attributes. The newrelic.Transaction structure actually embeds the response writer, so be sure to use the transaction in place of the original writer. This means you can get the transaction with a simple type assertion. func queryHandler(w http.ResponseWriter, r *http.Request) { if txn, ok := w.(newrelic.Transaction); ok { txn.NoticeError(errors.New(\"my error message\")) } } Once I converted the handlers in my app to use the wrapper, I checked out what that looked like in New Relic APM: top 5 web transactions Sadly, it wasn’t a very colorful chart, but it did answer my first question: the vast majority of time is spent in the “/query” route. What is that handler spending all its time doing? Scoping transactions to entire routes can obfuscate important information. So let’s dig into the details using segments. Segments Segments are meaningful chunks of a transaction. The Go agent currently supports external, datastore, and generic segment flavors. I suspected the bulk of the query time in my app was spent in the datastores, so I started by adding segments for each call. As with transactions, you are responsible for stopping and starting your segments. Segment calls are safe to use even without checking whether the transaction is nil. If your call spans an entire function call, you can use a rather elegant single-line defer statement: defer newrelic.DatastoreSegment{ StartTime: newrelic.StartSegmentNow(txn), Product:   newrelic.DatastoreSQLite, Collection: \"pagenames_table\", Operation: \"SELECT\", }.End() err := db.QueryRow(query, item.value).Scan(&result) Because I found it easiest to interact with the Neo4j database through its REST API, I needed to make POST requests rather than use a driver. I wrapped the request with a Datastore segment (notice how I added Neo4j as a new product): segment := newrelic.DatastoreSegment{ StartTime: newrelic.StartSegmentNow(txn), Product:   newrelic.DatastoreProduct(\"Neo4j\"), Operation: r.operation, } response, err := http.Post(url, \"application/json\", bytes) segment.End() Let’s see what that looks like in New Relic. Under the “/query” transaction, I found the breakdown of time. As I expected, most of the time was spent in the graph database. The shortest-path query was about 50% of the total response time, with the neighbor page query making up another 30%. (The SQLite calls aren’t in this transaction since they are made by another handler.) app server breakdown     This chart answered my second question and I could keep an eye on these numbers as I further optimized the query times. Attributes Finally, I wanted to build a New Relic Insights dashboard to track some of the fun paths users were finding in my app. For those not familiar with custom attributes, they are key-value pairs you attach to events, which you can then use in Insights. I was particularly interested in database timing and the pages in the path. If there was an especially long response time, the start and end pages allow me to reproduce it. You get the total database duration for free with the transaction event, but in order to add the query results, I concatenated the pages into a string for the “path” value: txn.AddAttribute(\"path\", path) I added other attributes for the start/end pages, the path length, as well as the original query. Then I created a dashboard to explore the most recent path found, the longest path found, and the path with the longest response time: insights dashboard     In case you’re curious, here’s the NRQL query for the longest shortest path found: SELECT max(length) FROM Transaction WHERE query IS NOT NULL FACET query My favorite part is the filter I set up on the query attribute, which lets me click on an interesting path to filter the whole dashboard for that path result. Did you know the Louisville Zoo Wikipedia page links to Brazil nuts through just one other page, the Hyacinth macaw? That’s my tale of getting up and running with the New Relic APM Go agent. Hopefully it will give you ideas of how to use it on your own Go applications. We invite you to try it out and tell us what you think on the New Relic forums. For more details, check out our Go Agent guide and public Docs site.   [Answer] Three clicks. In 1991, Grace Hopper won the National Medal of Technology and Innovation, the same award that Frederick McKinley Jones and Joseph A. Numero won for advances in refrigeration, which had a huge influence on the rise of the Japanese sushi industry.   Gopher image cc 3.o original by Renee French. Related Topics APM By Erika Arnold Erika Arnold works on the PHP Agent team at New Relic. A former biologist, she’s collected bugs all over the world. Now she just enjoys finding bugs in code. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 289.10156,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Transactions</em>",
        "body": " used consistently. Integrating New Relic into your <em>app</em> automates monitoring and helps you quickly spot new issues with each deploy. My example Have you ever heard of the Kevin Bacon Six Degrees of Separation game? In that spirit, I had built a Python <em>app</em> called wiki<em>Graph</em> to <em>query</em> the shortest path"
      },
      "id": "60763073196a676eb464a79a"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/caitlin_halla-1.jpg?h=f55021f1&itok=fhf70Uhp",
      "url": "https://newrelic.com/blog/how-to-relic/graphql-chaos-engineering",
      "sections": [
        "The problem statement",
        "Enter the Chaos Panda",
        "Early days in our (chaotic) journey"
      ],
      "published_at": "2021-04-16T01:57:22Z",
      "title": "Meet Chaos Panda: How New Relic Does Chaos Engineering With the GraphQL API",
      "updated_at": "2021-04-14T00:37:12Z",
      "type": "",
      "external_id": "5baa6f5d586496e0bce35f4c85f22aabe9c978ba",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Meet Chaos Panda: How New Relic Does Chaos Engineering With the GraphQL API Mar 25, 2019 • 4 min read By Caitlin Halla At New Relic, we understand the value of testing our systems to ensure their efficiency and resiliency against hazardous conditions. Whether it’s through chaos engineering or adversarial gamedays, our DevOps teams employ reliability best practices to learn more about our systems and develop new ways to improve them. Chaos engineering involves carefully injecting harm into our systems to test the systems’ response to it. This allows us to prepare and practice for outages, and to minimize the effects of downtime before it occurs. The operative word here is carefully. We’re not trying to break our systems—we’re trying to make them stronger and more resilient. And despite the name, chaos engineering is not actually chaotic. Instead, chaos engineering involves thoughtful, planned, and controlled experiments designed to demonstrate how our systems behave in the face of failure. There is no shortage of chaos engineering resources, but recently the Unified API team leveraged our implementation of the GraphQL API as an entry point for our internal chaos engineering practices. Sure, Netflix has its Chaos Monkey, but New Relic has a Chaos Panda! The problem statement Unlike typical REST APIs that often require loading from multiple endpoints, GraphQL provides a single endpoint that can manage complex queries, so you can get the data your app needs from many services—all in one request. We’ve achieved this with “schema stitching,” which creates a single schema from several underlying GraphQL APIs and enables us to deliver a unified experience across all of our APIs, via our GraphQL server. To make a request for data with New Relic’s GraphQL API, consumers query for various fields in a data structure; for example, a query on the accounts field returns account information associated with the user who ran the query. The fields are resolved by making requests to various downstream services. In the event that a service is down or is running slowly, GraphQL may send back partial responses—the request won’t fully fail, but the response may be missing data. That’s different than in a REST API where a response usually indicates a simple success or failure. It’s these partial responses that we were interested in. Particularly, how could we test against latency and field errors, and in turn find opportunities to add more resilient code in our services that would respond proactively to partial request failures? Enter the Chaos Panda With our new Chaos Panda testing tool, internal New Relic teams can configure GraphQL in pre-production testing to do things like add latency to its responses or cause certain fields to fail at a specific failure rate. It’s as simple as running a GraphQL mutation (a basic GraphQL query type that can modify and fetch data). Here’s an example of a chaosStart mutation that kicks off a chaos session for the entitySearch and accounts fields and slows responses down by 5,000 ms: mutation { chaosStart(configuration: { fieldErrors: [ {name: \"entitySearch\", probability: 1.0}, {name: \"accounts\", probability: 0.70} ], latency: 5000 } ) } In this case, we’ve configured the entitySearch field with a probability of 1.0, so that field will return errors from GraphQL 100% of the time; we’ve given the accounts field a probably of 0.70, so it will return errors 70% of the time. We’ve also configured latency at 5,000 ms, so the GraphQL query response will be delayed 5,000 ms. Here’s the response with Chaos Panda running: { \"data\":  { \"currentUser\": { \"accounts\": null, \"entitySearch\": null } }, \"errors\": [ { \"locations\": [ { \"column\": 0, \"line\": 6 } ], \"message\": \"Chaos Panda strikes again: \\\"accounts\\\" failed to resolve.\", \"path\":  [ \"currentUser\", \"accounts\" ] }, { \"locations\": [ { \"column\": 0, \"line\": 3 } ], \"message\": \"Chaos Panda strikes again: \\\"entitySearch\\\" failed to resolve.\", \"path\": [ \"currentUser\", \"entitySearch\" ] } ], ... A mutation is scoped to the user who issues the request, so other users will not be affected. Any additional chaosStart mutations will overwrite the currently active chaos configuration for that user. Testing automatically expires after one hour, and order is restored. To manually disable a test, though, users can run the simple chaosStop mutation: Mutation { chaosStop } Here’s how it looks in action: Early days in our (chaotic) journey GraphQL dramatically reduces the overhead of working with New Relic data. The current iteration of Chaos Panda very much represents the start of our journey using the GraphQL API for chaos engineering. By building the API first, we’re making our developers' lives as easy as possible, and that applies to all aspects of the development process—from development to efficiency and resiliency testing. By Caitlin Halla Caitlin Halla is a software engineer at New Relic. When she’s not programming, she climbs rocks, reads, listens to records, and programs some more. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 277.74463,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Meet</em> Chaos Panda: How New Relic Does Chaos Engineering With the <em>GraphQL</em> API",
        "body": " APIs, via our <em>Graph</em>QL server. To make a request for <em>data</em> with New Relic’s <em>Graph</em>QL API, consumers <em>query</em> for various fields in a <em>data</em> structure; for example, a <em>query</em> on the accounts field returns <em>account</em> information associated with the user who ran the <em>query</em>. The fields are resolved by making requests"
      },
      "id": "6076393964441faf6d9d852d"
    }
  ],
  "/explore-docs/nerdstoragevault": [
    {
      "image": "https://docs.newrelic.com/static/1dacbe14521cd094da4f9ce4912e24a5/ae694/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/2020/10/store-data-encrypted-storage-solution-nerdstoragevault/",
      "sections": [
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "published_at": "2021-04-16T19:42:55Z",
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "updated_at": "2021-03-11T00:18:44Z",
      "type": "docs",
      "external_id": "de67c202e7343347b2a6b5bc615301b9fac1e524",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 358.47662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution with <em>NerdStorageVault</em>",
        "sections": "Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution with <em>NerdStorageVault</em>",
        "body": "NerdGraph allows you to <em>access</em> your <em>New</em> <em>Relic</em> <em>data</em>, but when you want to fetch third-party <em>data</em>, <em>NerdStorageVault</em> allows you to safely store a secret to authenticate with a third-party service. <em>NerdStorageVault</em> provides you with a secure and <em>encrypted</em> <em>storage</em> location where you can safely store"
      },
      "id": "6044694a64441fb9b2378f2d"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/jp/whats-new/",
      "sections": [
        "New Relicの新機能"
      ],
      "published_at": "2021-04-16T19:10:36Z",
      "title": "What's new in New Relic",
      "updated_at": "2021-04-16T19:10:36Z",
      "type": "docs-jp",
      "external_id": "cfaaa9015112cddf53bade5c9f859c3bfbc53a97",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "April 14 Distributed tracing for Mobile Get visibility to the entire journey of requests, originating in your mobile app as they travel through distributed systems April 12 A simpler, more intuitive log analytics experience Check out the changes we've made to the UI to help you see details and debug faster! Create alert conditions from any chart Now you can create an alert condition from just about anywhere in New Relic! Detect patterns and outliers in log data Create queries, alerts, and dashboards using log patterns and outliers April 9 Level up at FutureStack on May 25-27! Connect with Nerds from across the globe to learn, share, and get inspired at our free, virtual event April 8 Aggregated health and activity for your Workloads New Relic Workloads are now easier to read. April 5 Guided install for Java and .NET APM agents We’ve made it simple to set up APM (Java and .NET) using our recently-launched guided installation flow, so you can instrument your systems and start analyzing your telemetry data in 5 minutes - no instrumentation expertise required. April 1 NRQL Updates You can now use Regex within your NRQL queries, and sliding time windows March 31 Amazon CloudWatch Metric Streams More metrics, more often - fill gaps in your observability with Amazon CloudWatch Metric Streams and New Relic One. FedRAMP: Logs and Metrics now certified Protecting your data is our highest priority, which is why we achieved the US Government’s rigorous FedRAMP Moderate certification in 2020. And now we’re adding support for Logs and Metrics to our long list of supported services. March 30 Kubernetes: Metric Update Moving to container_memory_working_set_bytes and away from container_memory_usage_bytes metric Slow transactions on the service Summary Quickly dive into the most time-consuming requests to your application or service March 25 Nerdlog Roundup: New Relic Lookout, Guided Install, and Open Source Docs Get real-time visibility into your stack, simplify your instrumentation, and edit our docs March 18 Nerdlog Roundup: Root Cause Analysis, Topology (Relationship-Based) Correlation, and more! Reduce your MTTR with free Automatic Proactive Anomaly Detection, find problems fast with root cause analysis, and increase context for issues using topology correlation. March 17 AIOps Made Easy: Get to root cause and respond faster Automatically find root cause and respond faster than ever March 16 Heroku cloud integration for log management Detailed log data made easier than ever Visualize log details in Dashboards with our new Logs Table Widget More flexibility and control for log message visualizations March 15 AIOps Made Easy: Cut down on alert noise Reduce alert fatigue and prioritize what’s important March 10 AIOps Made Easy: Detect unusual changes instantly Automatic proactive anomaly detection for free Nerdlog Roundup: See hosts, services, containers, and more in one view with New Relic Navigator See hundreds of entities in a compact, high-level view March 8 Nerdlog Roundup: Muting Rules, Custom Data Visualizations, and more AIOps fun! Smarter incident intelligence and custom data visualizations February 25 Nerdlog Roundup: Ingesting OpenTelemetry Data, RUM, and more Ingest OpenTelemery data and logs, drop your data, and monitor your browser performance February 24 New Relic Explorer: Say goodbye to blindspots Gain unprecedented visibility into your entire system February 19 Nerdlog Roundup: K6 Load Testing and the ServiceNow and Snowflake Integrations Keep your issues in sync, view your Snowflake and k6 performance data in New Relic One. February 11 Data Dropping update: Now, drop entire dimensional metrics Filter sensitive or low-value data February 8 Check out the Nerdlog We have a new live-stream changelog on Twitch! January 28 Agentless syslog onboarding for New Relic log management Host-based log ingestion using rsyslog or syslog-ng with a new TCP endpoint January 21 New Python agent features Python agent now auto instruments HTTPX and Django ASGI January 19 New Anomalies feed as part of AI overview page View all your anomalies in a single place January 13 New Relic Snowflake Integration New Relic now integrates with Snowflake. January 6 Schedule recurring muting rules Suppress or mute notifications with ease December 7, 2020 Recap: Top 10 new observability features you need to know Our engineers and product managers share their favorite features, capabilities, and integrations to help you be more productive and collaborative. December 1, 2020 Alerts and Applied Intelligence new landing page Surface insights with a new landing page. Percentiles now available in events-to-metrics service For the events-to-metrics service, return an attribute's approximate value at a given percentile. November 12, 2020 API keys app There's a new app for managing your API keys. New Relic Lambda extension Our new extension improves observability of your Lambda data. Share dashboards and curated views with permalinks Sharing what you’re seeing just got easier. November 10, 2020 Invite a teammate See how easy it is to invite your team to New Relic. November 9, 2020 Enhanced errors experience in New Relic One We've improved the new errors experience. November 3, 2020 Troubleshoot performance and crash issues faster with New Relic's real-time Java profiling New Relic is excited to announce the availability of real-time Java profiling using Java Flight Recorder (JFR). October 30, 2020 Build high-resolution charts using sliding windows Increase your chart resolution with rolling aggregates, powered by sliding windows. Kafka Connect: Unlock open source and alternative instrumentation sources Build observability pipelines from open source tools and alternative instrumentation sources with the New Relic connector for Kafka Connect. Veneur sink: Your pipeline to 3rd party metrics Send metrics to New Relic using our Veneur sink. October 29, 2020 Three big updates for your native mobile apps Three big updates: The New Relic iOS and tvOS agents will now be distributed as the New Relic XCFramework Agent 7.0.0. For instrumenting React Native applications, we have an experimental open source React Native Module. Plus, we’ve improved reliability from our Android service and changed the way our service handles Android stack deobfuscation. October 27, 2020 Monitor ASGI apps using the Python agent The Python agent now supports monitoring Uvicorn, Starlette, and FastAPI ASGI applications. Monitor Apollo Server GraphQL Node applications Use our Node.js agent plugin to capture executed GraphQL queries. October 15, 2020 Applied Intelligence: Better, smarter webhooks Webhooks now automatically deliver anomaly charts. October 14, 2020 New Relic One now has a new UI for OpenTelemetry Check out our APM functionality for your OpenTelemetry data. October 13, 2020 Store data in an encrypted storage solution with NerdStorageVault Store and receive sensitive third-party secrets data. October 12, 2020 Saved views for log management Save your table column, time range, etc. in the logs UI October 9, 2020 Alerting: Loss of signal detection and configurable gap-filling strategies Specify how long the system should wait before a signal is considered lost. October 7, 2020 New Relic achieves AWS Outposts Ready designation New Relic has achieved the AWS Outposts Ready designation, part of the Amazon Web Services (AWS) Service Ready Program. October 1, 2020 Applied Intelligence now features accelerated suggested decisions Reduce alert noise by using our suggested correlation decisions. September 30, 2020 Applied Intelligence: Deployment events in the issue feed Applied Intelligence now includes any relevant APM deployment data. September 29, 2020 New Relic Edge with Infinite Tracing New Relic users with Pro or Enterprise Full-Stack Observability can now access and benefit from New Relic Edge. September 11, 2020 Anomalies visible in the activity stream The activity stream shows recent events so you can quickly see what's happening in your system. September 9, 2020 Windows Logs supported Support for Windows Logs with New Relic's infrastructure agent September 4, 2020 New Relic One has dark mode! We now have dark mode! New Relic Support for Amazon Web Services (AWS) Bottlerocket Gain full visibility into your workloads and infrastructure running on AWS Bottlerocket. What's new? Your in-product destination for New Relic One updates! September 1, 2020 Issue summary and analysis in Applied Intelligence Rely on the issue summary to help you identify and resolve relevant issues. Visual issue timeline in Applied Intelligence Use our Gantt-style timeline chart to see your related events. August 26, 2020 Real-user monitoring support for W3C trace context and Google Core Web Vitals We've added support for W3C trace context and Google Core Web Vitals! August 18, 2020 Alert analysis for Applied Intelligence Alert analysis gives you greater context for your alert violations and notifications. August 16, 2020 Ingest New Relic Logs directly with Amazon Web Services (AWS) Kinesis Data Firehose New Relic can ingest data from Amazon's Kinesis Data Firehose. Tracing the gap: AWS X-Ray integration Use New Relic with AWS X-Ray, a critical distributed tracing tool for getting visibility across your AWS services. August 10, 2020 Create Grafana dashboards with Prometheus data stored in New Relic You can create Grafana dashboards with Prometheus data stored in New Relic! July 30, 2020 Overall New Relic One experience updates We've made updates across all of New Relic One! Scheduled alert muting Schedule when you want to mute alerts to avoid messages during maintenance or deployments.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.04562,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What&#x27;s <em>new</em> in <em>New</em> <em>Relic</em>",
        "sections": "<em>New</em> <em>Relic</em>の新機能",
        "body": " Applied Intelligence: Better, smarter webhooks Webhooks now automatically deliver anomaly charts. October 14, 2020 <em>New</em> <em>Relic</em> <em>One</em> now has a <em>new</em> UI for OpenTelemetry Check out our APM functionality for your OpenTelemetry <em>data</em>. October 13, 2020 Store <em>data</em> in an <em>encrypted</em> <em>storage</em> solution"
      },
      "id": "6050daaa196a6746822d164e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/whats-new/",
      "sections": [
        "What's new in New Relic"
      ],
      "published_at": "2021-04-15T21:21:00Z",
      "title": "What's new in New Relic",
      "updated_at": "2021-04-15T01:51:31Z",
      "type": "docs",
      "external_id": "49467ca3d09d7a4f1c1c69fd16be4e20050a7686",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "April 12 A simpler, more intuitive log analytics experience Check out the changes we've made to the UI to help you see details and debug faster! Create Alert Conditions From Any Chart Now you can create an alert condition from just about anywhere in New Relic! Detect patterns and outliers in log data Create queries, alerts, and dashboards using log patterns and outliers April 9 Level up at FutureStack on May 25-27! Connect with Nerds from across the globe to learn, share, and get inspired at our free, virtual event April 8 Aggregated health and activity for your Workloads New Relic Workloads are now easier to read. April 5 Guided install for Java and .NET APM agents We’ve made it simple to set up APM (Java and .NET) using our recently-launched guided installation flow, so you can instrument your systems and start analyzing your telemetry data in 5 minutes - no instrumentation expertise required. April 1 NRQL Updates You can now use Regex within your NRQL queries, and sliding time windows March 31 Amazon CloudWatch Metric Streams More metrics, more often - fill gaps in your observability with Amazon CloudWatch Metric Streams and New Relic One. FedRAMP: Logs and Metrics now certified Protecting your data is our highest priority, which is why we achieved the US Government’s rigorous FedRAMP Moderate certification in 2020. And now we’re adding support for Logs and Metrics to our long list of supported services. March 30 Kubernetes: Metric Update Moving to container_memory_working_set_bytes and away from container_memory_usage_bytes metric Slow transactions on the service Summary Quickly dive into the most time-consuming requests to your application or service March 25 Nerdlog Roundup: New Relic Lookout, Guided Install, and Open Source Docs Get real-time visibility into your stack, simplify your instrumentation, and edit our docs March 18 Nerdlog Roundup: Root Cause Analysis, Topology (Relationship-Based) Correlation, and more! Reduce your MTTR with free Automatic Proactive Anomaly Detection, find problems fast with root cause analysis, and increase context for issues using topology correlation. March 17 AIOps Made Easy: Get to root cause and respond faster Automatically find root cause and respond faster than ever March 16 Heroku cloud integration for log management Detailed log data made easier than ever Visualize log details in Dashboards with our new Logs Table Widget More flexibility and control for log message visualizations March 15 AIOps Made Easy: Cut down on alert noise Reduce alert fatigue and prioritize what’s important March 10 AIOps Made Easy: Detect unusual changes instantly Automatic proactive anomaly detection for free Nerdlog Roundup: See hosts, services, containers, and more in one view with New Relic Navigator See hundreds of entities in a compact, high-level view March 8 Nerdlog Roundup: Muting Rules, Custom Data Visualizations, and more AIOps fun! Smarter incident intelligence and custom data visualizations February 25 Nerdlog Roundup: Ingesting OpenTelemetry Data, RUM, and more Ingest OpenTelemery data and logs, drop your data, and monitor your browser performance February 24 New Relic Explorer: Say goodbye to blindspots Gain unprecedented visibility into your entire system February 19 Nerdlog Roundup: K6 Load Testing and the ServiceNow and Snowflake Integrations Keep your issues in sync, view your Snowflake and k6 performance data in New Relic One. February 11 Data Dropping update: Now, drop entire dimensional metrics Filter sensitive or low-value data February 8 Check out the Nerdlog We have a new live-stream changelog on Twitch! January 28 Agentless syslog onboarding for New Relic log management Host-based log ingestion using rsyslog or syslog-ng with a new TCP endpoint January 21 New Python agent features Python agent now auto instruments HTTPX and Django ASGI January 19 New Anomalies feed as part of AI overview page View all your anomalies in a single place January 13 New Relic Snowflake Integration New Relic now integrates with Snowflake. January 6 Schedule recurring muting rules Suppress or mute notifications with ease December 7, 2020 Recap: Top 10 new observability features you need to know Our engineers and product managers share their favorite features, capabilities, and integrations to help you be more productive and collaborative. December 1, 2020 Alerts and Applied Intelligence new landing page Surface insights with a new landing page. Percentiles now available in events-to-metrics service For the events-to-metrics service, return an attribute's approximate value at a given percentile. November 12, 2020 API keys app There's a new app for managing your API keys. New Relic Lambda extension Our new extension improves observability of your Lambda data. Share dashboards and curated views with permalinks Sharing what you’re seeing just got easier. November 10, 2020 Invite a teammate See how easy it is to invite your team to New Relic. November 9, 2020 Enhanced errors experience in New Relic One We've improved the new errors experience. November 3, 2020 Troubleshoot performance and crash issues faster with New Relic's real-time Java profiling New Relic is excited to announce the availability of real-time Java profiling using Java Flight Recorder (JFR). October 30, 2020 Build high-resolution charts using sliding windows Increase your chart resolution with rolling aggregates, powered by sliding windows. Kafka Connect: Unlock open source and alternative instrumentation sources Build observability pipelines from open source tools and alternative instrumentation sources with the New Relic connector for Kafka Connect. Veneur sink: Your pipeline to 3rd party metrics Send metrics to New Relic using our Veneur sink. October 29, 2020 Three big updates for your native mobile apps Three big updates: The New Relic iOS and tvOS agents will now be distributed as the New Relic XCFramework Agent 7.0.0. For instrumenting React Native applications, we have an experimental open source React Native Module. Plus, we’ve improved reliability from our Android service and changed the way our service handles Android stack deobfuscation. October 27, 2020 Monitor ASGI apps using the Python agent The Python agent now supports monitoring Uvicorn, Starlette, and FastAPI ASGI applications. Monitor Apollo Server GraphQL Node applications Use our Node.js agent plugin to capture executed GraphQL queries. October 15, 2020 Applied Intelligence: Better, smarter webhooks Webhooks now automatically deliver anomaly charts. October 14, 2020 New Relic One now has a new UI for OpenTelemetry Check out our APM functionality for your OpenTelemetry data. October 13, 2020 Store data in an encrypted storage solution with NerdStorageVault Store and receive sensitive third-party secrets data. October 12, 2020 Saved views for log management Save your table column, time range, etc. in the logs UI October 9, 2020 Alerting: Loss of signal detection and configurable gap-filling strategies Specify how long the system should wait before a signal is considered lost. October 7, 2020 New Relic achieves AWS Outposts Ready designation New Relic has achieved the AWS Outposts Ready designation, part of the Amazon Web Services (AWS) Service Ready Program. October 1, 2020 Applied Intelligence now features accelerated suggested decisions Reduce alert noise by using our suggested correlation decisions. September 30, 2020 Applied Intelligence: Deployment events in the issue feed Applied Intelligence now includes any relevant APM deployment data. September 29, 2020 New Relic Edge with Infinite Tracing New Relic users with Pro or Enterprise Full-Stack Observability can now access and benefit from New Relic Edge. September 11, 2020 Anomalies visible in the activity stream The activity stream shows recent events so you can quickly see what's happening in your system. September 9, 2020 Windows Logs supported Support for Windows Logs with New Relic's infrastructure agent September 4, 2020 New Relic One has dark mode! We now have dark mode! New Relic Support for Amazon Web Services (AWS) Bottlerocket Gain full visibility into your workloads and infrastructure running on AWS Bottlerocket. What's new? Your in-product destination for New Relic One updates! September 1, 2020 Issue summary and analysis in Applied Intelligence Rely on the issue summary to help you identify and resolve relevant issues. Visual issue timeline in Applied Intelligence Use our Gantt-style timeline chart to see your related events. August 26, 2020 Real-user monitoring support for W3C trace context and Google Core Web Vitals We've added support for W3C trace context and Google Core Web Vitals! August 18, 2020 Alert analysis for Applied Intelligence Alert analysis gives you greater context for your alert violations and notifications. August 16, 2020 Ingest New Relic Logs directly with Amazon Web Services (AWS) Kinesis Data Firehose New Relic can ingest data from Amazon's Kinesis Data Firehose. Tracing the gap: AWS X-Ray integration Use New Relic with AWS X-Ray, a critical distributed tracing tool for getting visibility across your AWS services. August 10, 2020 Create Grafana dashboards with Prometheus data stored in New Relic You can create Grafana dashboards with Prometheus data stored in New Relic! July 30, 2020 Overall New Relic One experience updates We've made updates across all of New Relic One! Scheduled alert muting Schedule when you want to mute alerts to avoid messages during maintenance or deployments.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 244.51959,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What&#x27;s <em>new</em> in <em>New</em> <em>Relic</em>",
        "sections": "What&#x27;s <em>new</em> in <em>New</em> <em>Relic</em>",
        "body": " hosts, services, containers, and more in <em>one</em> view with <em>New</em> <em>Relic</em> Navigator See hundreds of entities in a compact, high-level view March 8 Nerdlog Roundup: Muting Rules, Custom <em>Data</em> Visualizations, and more AIOps fun! Smarter incident intelligence and custom <em>data</em> visualizations February 25 Nerdlog"
      },
      "id": "60422917196a677e2fa83ddf"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.271,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " a <em>New</em> <em>Relic</em>-monitored entity or <em>data</em> from another service or API. Get started Keep reading to learn more about what you can do with <em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>. If you want to get started building quickly, first read the requirements. Tip To use our developer site and <em>New</em> <em>Relic</em> <em>One</em>, as well as the rest of our"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-16T22:12:16Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.27863,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    }
  ],
  "/build-apps/map-pageviews-by-region": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/DEPLOYMENT-ANALYZER-SCREENSHOT-1.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-3",
      "sections": [
        "Container Explorer",
        "Specific requirements for this app",
        "Deployment Analyzer",
        "Page View Map",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:25:05Z",
      "title": "Most Popular New Relic One Applications (Round up #3)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "6f0be6c93ebcc052fac27513c1e849c0dfd256e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic Most Popular New Relic One Applications (Round up #3) Nov 26, 2019 • 7 min read By Joel Worrall Hopefully, you’ve heard the news that the New Relic One observability platform is now programmable. As central component of an observability platform, we believe programmability gives you the ability to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the possibilities—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications … and then we kept going. In fact, new apps are coming in every day. And we hope to see app contributions by New Relic users continue. This blog series is our opportunity to spotlight the most popular apps available today from our GitHub repository. The best part: Every app is available under an open source license and can be deployed right now! In this edition, we cover: Container Explorer Deployment Analyzer Page View Map Container Explorer This app includes a launcher that gives you a global view of all containers associated with an account. You can also employ tags to segment and drill down into subsets of your global container inventory. The app also presents container CPU, memory, and disk I/O usage in the form of intuitive and efficient heat map visualizations. Container Explorer presents CPU, memory, and disk I/O usage for all containers associated with an account—displaying this data via intuitive and efficient heat map visualizations. In the New Relic One entity explorer, we provide a nerdlet that will show all of the containers that are running for a selected APM application (service). We can also detect whether infrastructure data is coming from third-party sources and can, if necessary, automatically present this container telemetry in-context. Container Explorer can detect whether infrastructure data is coming from third-party sources—and can, if necessary, automatically ingest and present this container telemetry in-context. Clicking on a node in the heatmap reveals details about that container, and you can also jump to its host in the entity explorer. Clicking on a node in the Container Explorer heatmap reveals details about that container, and users can also jump to its host in the entity explorer. Fork or deploy the Container Explorer app from GitHub. Specific requirements for this app The New Relic Infrastructure agent must be deployed on any host you want to monitor. Note: We generate per-container CPU and other metrics by summarizing all processes in a given containerId. This will, however, report an accurate value only if the agent reports one ProcessSample per process every 30 seconds. Deployment Analyzer Deployments of applications can be risky events, but you can correlate those events to the performance of your applications, using deployment markers in New Relic. This app builds further on this process—enabling teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Deployment Analyzer enables teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Fork or deploy the Deployment Analyzer app from GitHub. Specific requirements for this app You'll need an active New Relic APM Pro subscription in order to access deployment marker functionality. Page View Map This app creates geographic visualizations of New Relic Browser application data using the React Leaflet mapping library. Leaflet is a leading open-source JavaScript library for mobile-friendly interactive maps. In addition to providing a new way to visualize your business data, this app offers a great example of what's possible for developers working with our GraphQL service and a third party library. Page View Map creates geographic visualizations of New Relic Browser application data Fork or deploy the Page Views Map app from GitHub Specific requirements for this app You must have the New Relic Browser Agent(s) installed, as well as related access to New Relic One. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer.git cd nr1-container-explorer nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Container Explorer to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer cd nr1-container-explorer nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app's launcher (unless otherwise noted above). Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications: New Relic Developer Edition: Early access to the Developer Edition of New Relic One gives you a free, personal sandbox account where you can build your own experience with all the available New Relic tools. developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome contributions to any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series.   Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.30502,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Most Popular New Relic One <em>Applications</em> (Round up #3)",
        "sections": "<em>Page</em> <em>View</em> <em>Map</em>",
        "body": " working with our GraphQL service and a third party library. <em>Page</em> <em>View</em> <em>Map</em> creates geographic visualizations of New Relic Browser application data Fork or deploy the <em>Page</em> <em>Views</em> <em>Map</em> <em>app</em> from GitHub Specific requirements for this <em>app</em> You must have the New Relic Browser Agent(s) installed, as well"
      },
      "id": "60762e1f196a673d0a64a782"
    },
    {
      "sections": [
        "Browser Geography: Webpage performance by location",
        "Contents",
        "View performance data by region",
        "Important",
        "Use page functions",
        "View drill-down details",
        "For more help"
      ],
      "title": "Browser Geography: Webpage performance by location",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Additional standard features"
      ],
      "external_id": "7b26e484a4645be8c580650fd7d71a159114bf50",
      "image": "https://docs.newrelic.com/static/793341e63f8e5b444d7cc98a1f5a7d90/c1b63/geo_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/additional-standard-features/browser-geography-webpage-performance-location/",
      "published_at": "2021-04-16T11:56:12Z",
      "updated_at": "2021-03-11T07:31:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's Geography page provides a world view with color-coded Apdex scores and other performance information about your end users' experience. You can select specific geographic regions, such as countries or states, and then you can drill down to detailed information about page load performance and historical performance. Contents View performance data by region Important Firewalls may have an impact on the geographical data collected about your end users. To view or sort the performance information by location: one.newrelic.com > Browser > (select an app) > Geo: This page provides a world view and drill-down details of color-coded performance information for geographic locations. Go to one.newrelic.com > Browser > (select an app) > Geo > Global (for a world view). OR Go to one.newrelic.com > Browser > (select an app) > Geo > (select a location) (for a specific location you identified in the Browser application settings). To drill down to a specific area, select a location from the list, or select any area on the geographical map. To view additional details about the selected location, select the Page load performance or Historical performance links. To return to the main Geography page, select X (Close). one.newrelic.com > B * *rowser > (select an app) > Geo > (select a location): If you selected specific locations from Settings > Application settings * * , the Geography page includes tabs to view their performance data directly. Use page functions Use any of our standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Geography page: If you want to... Do this... Change how the performance data appears Select your choice from the Sort by menu. Adjust the amount of information that appears Select or clear the Hide < % throughput checkbox ( < 1% for global view, < 2% for selected locations). View a map of a specific location Do any of these as applicable: Select the location's name from the Geo > Global list. Select its physical location on the map. If you have pre-selected the location from Application settings, select its tab. View summary performance information about a specific location Mouse over any colored area. View drill-down details After you select a specific location, the Page load performance page shows: Average page load time in seconds Number of page views and active sessions as pages per minute (ppm) Recent browser traces if applicable one.newrelic.com > Browser > (select an app) > Geo > (select a location): After you select a specific location, you can view specific details about Page load performance and Historical performance. In addition, the Historical performance page shows comparison data for the selected time period, yesterday, and last week for the selected location. This includes: Response time Apdex Throughput in pages per minute (ppm) For more help Additional documentation resources include the Page views page (details about end users' overall experience with your site).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.26984,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>View</em> performance data by <em>region</em>",
        "body": " performance and historical performance. Contents <em>View</em> performance data by <em>region</em> Important Firewalls may have an impact on the geographical data collected about your end users. To <em>view</em> or sort the performance information by location: one.newrelic.com &gt; Browser &gt; (select an <em>app</em>) &gt; Geo: This <em>page</em>"
      },
      "id": "604429e7196a67193d960f75"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/New-Relic-One-Catalog.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-5",
      "sections": [
        "Subscribe to applications with the New Relic One Catalog",
        "Observability Maps",
        "Metric Aggregator",
        "Workload Geo Ops",
        "Check out these other resources for using—and building—New Relic One applications ",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "The Most Popular New Relic One Applications (Roundup #5)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "75f80d867fec167c4a6d62082f32cb2ff1ae0802",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #5) Jun 4, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Observability Maps Metric Aggregator Workload Geo Ops Subscribe to applications with the New Relic One Catalog Before we start accessing the applications via the CLI, let’s look at how to access these applications directly within New Relic One. To explore available applications, navigate to New Relic One and click on the New Relic One Catalog launcher. New Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. New Relic One Catalog If you deploy an application from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Observability Maps Observability Maps allows you to create a view beyond a traditional service map. Using Observability Maps, you can connect disparate entities in your environment into ad hoc relationships, creating your own relationships based on data available in New Relic. See your entities and environment in a way that makes the most sense to your team and business. Observability Maps App Fork or deploy the Observability Maps app from GitHub. Specific requirements for this app Requires data in NRDB from any or all of the New Relic products. Metric Aggregator The Metric Aggregator is a New Relic One application that helps you create events-to-metrics (E2M) rules, a real-time streaming service that converts event data into dimensional metrics at ingest. Converting events to metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Metric Aggregator App Fork or deploy the Metric Aggregator app from GitHub. Specific requirements for this app If you use New Relic, you already have New Relic Metrics. You can  create E2M rules immediately. Workload Geo Ops Workload Geo Ops links your workloads (collections of entities) to physical locations so you can quickly identify and resolve incidents. It's a geographic exploration of workload data tied to geographic data, including location metadata. You can define maps and then collect or assign entities to points on those maps. With workloads, a collection of entities can be managed by rules and tags to support the dynamic, ephemeral nature of modern IT infrastructure. Fork or deploy the Workload Geo Ops app from GitHub. Specific requirements for this app To get the most of this app, we recommend that you configure Workloads in New Relic One. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Workload Geo Ops to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One applications  Here are resources to help you build your own New Relic One applications. If you can imagine it, you can build it:  developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. NerdGraph GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity. Application/data access and permissions and security. NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.98866,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic One <em>Applications</em> (Roundup #5)",
        "sections": "Subscribe to <em>applications</em> with the New Relic One Catalog",
        "body": " Relic One Catalog launcher From there, you can access all our global applications. If you’re a <em>Nerdpack</em> Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the <em>app</em> to add the application to the account you wish to grant access. If your team changes, and you need"
      },
      "id": "60762e1f64441fbf2e9d856e"
    },
    {
      "image": "https://newrelic.com/content/dam/component-assets/p03-product-image/browser/products_browsers_features_browserloadtime_sept2020_thumb.png",
      "url": "https://newrelic.com/products/browser-monitoring/features",
      "sections": [
        "New Relic Browser features",
        "Full Support for Google’s Core Web Vitals",
        "User Centric Perceived Performance",
        "Single Page App Route Changes",
        "Session Traces",
        "Browser Traces",
        "Page Load Time - Segmentation Chart",
        "Page Load Time - Histogram and Percentiles",
        "Geographic Reporting",
        "Page-Level AJAX Calls",
        "Page View Throughput",
        "Connect Browser with Backend Performance",
        "JavaScript Error Summary",
        "Errors by Browser",
        "Percentage of Page Views with Errors",
        "Source Map Support",
        "Best-in-class Customer Experience Monitoring",
        "Browser Throughput",
        "Browser Load Time - Segmentation Chart",
        "Browser Version Chart",
        "Error Instance Details",
        "AJAX Dashboard",
        "Calls by Page View",
        "Request Status Codes",
        "Data Transfer Per Request",
        "Quickly View App Health",
        "Custom dashboards",
        "Integrate with your ticketing system",
        "Alerting",
        "Filterable Geography",
        "U.S. and EU Data Regions",
        "SOC2 Audited",
        "Secure Data Center",
        "Continuous Monitoring",
        "Secure by Default",
        "Compliance Friendly",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2021-04-19T01:47:33Z",
      "title": "New Relic Browser | New Relic",
      "updated_at": "2021-03-12T01:54:25Z",
      "type": "",
      "external_id": "b30121e0e2deb44e52a48d9a83ca4f854e2fb470",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon New Relic Browser Overview Features Resources New Relic Browser features Sign up for free Page Load Performance JavaScript Errors Browser Performance AJAX Global Features Security Page Load Performance New Relic Browser is the world’s most deployed Real User Monitoring (RUM) solution because it’s easy to use, and instantly connects end-user experience with time spent in backend services. From easy-to-understand overviews to user-centric perceived performance metrics and events, Browser helps you benchmark and improve web performance and troubleshoot across your full stack. Full Support for Google’s Core Web Vitals By adding Cumulative Layout Shift, a score measuring the impact of sudden unexpected shifts in layout due to content dynamically resizing, we now offer full support for all three of Google’s Core Web Vitals for web health. Use NRQL to create dashboards for all three measurements, definitions below: Largest Contentful Paint (LCP) - measures loading performance First Input Delay (FID) - measures interactivity Cumulative Layout Shift (CLS) - measures visual stability User Centric Perceived Performance Web performance teams can use more modern metrics than just page load time to benchmark and improve end-user experience for their dynamic pages. Browser helps developers understand how code impacts customers, answering key questions on page performance. Monitor how long users wait for content to display (paint metrics), how long until users can interact with our page (interactivity metrics), and how long until marquee content renders (largest contentful paint). (see blogpost for more) Single Page App Route Changes View Single Page Application route change performance, regardless of what JavaScript framework you use. Powerful low-level instrumentation can even capture interactions beyond the route change that can be customized via API, allowing monitoring tailored to the architecture of your application, such as for custom frameworks. Session Traces Session Traces provide one of the most valuable assets an engineer requires - context. Beyond identifying long load times, and specific errors, Browser Session Traces provide the story that occurred both before and after an error or performance issue. Pivot from AJAX requests and JavaScript errors into a Session Trace and conversely pivot from a Session Trace out to a specific JavaScript error or Network error. Browser Traces Traces are snapshots of one user’s experience, surfaced as an outlier due to a longer than average load time. It provides details around when it took place, a segmented breakdown of where load time was spent, browser type, and the user’s geographic location. This report is excellent when dissecting areas of your application which are performing poorly for specific users. Page Load Time - Segmentation Chart Page load times capture metrics from the moment a user begins a transaction in the browser until the page completes loading. The reports show average page load time broken down into color-coded segments for: Request queuing, application code, network latency, DOM processing, and Page rendering. Page Load Time - Histogram and Percentiles Histograms and percentiles of browser page load times provide a holistic view of the speed of page loads, one that is not focused on averages alone. Histograms and percentiles surface every page load that occurred during a specified time window, providing the ability to drill into outliers that might have been overlooked otherwise. Geographic Reporting Understand how your end users’ experience with your site varies by geographical region. Identify if more CDN’s are required, or if high value customers in specific parts of the world are having a negative experience with your site’s performance. Page-Level AJAX Calls For a specific page, see all the AJAX calls being made as well as the response time, throughput (rpm), total number of calls, error status codes, and average data transfer made for each one. Page View Throughput Throughput is measured in requests per per minute. Throughput metrics help you understand which pages are being called most frequently. Connect Browser with Backend Performance From the Page views report, you can select single page URL and see all of the associated backend APM transactions (if you have the APM Agent installed in your application). Quickly view the total call time, average response time, and call count for any individual backend transaction. You can also dive deeper into a particular transaction and see diagnostics within our APM reports. JavaScript Errors The JavaScript error dashboards help you identify production JavaScript errors impacting your users' experiences and begin pinpointing how to resolve them. JavaScript Error Summary This summary view gives you a high level understanding of the types of JavaScript errors happening, the frequency at which they occur, and the percentage of users affected by the errors. Errors by Browser For each type of error, this chart shows you which browsers are being impacted by the error and the relative contribution it is making to your total error volume. Percentage of Page Views with Errors For each type of error, this chart shows you the percentage of page views affected by it. This allows you to quickly assess the reach and impact a particular error has on your end users. Source Map Support Troubleshoot minified production JavaScript code, with source map support giving you full visibility to where in your code the front-end error is. Intuitive drag-and-drop lets you locate issues in a click, while API integrations work seamlessly with your build pipeline. Best-in-class Customer Experience Monitoring Crash analysis in New Relic Mobile lets you analyze the most impactful crashes and fix them faster. Source map support in New Relic Browser gives you more actionable visibility into front-end JS errors by showing you exactly where in the original source the error occurred, even if your code is minified. Browser Performance New Relic's Browser dashboards provide information about your end users' experience based on browser type and version, so you can understand where to focus your time testing and optimizing for performance. Browser Throughput Provides a snapshot of the average number of pageviews received per minute broken down by browser type. Browser Load Time - Segmentation Chart For each type of browser, a segmented view of time spent on request queuing, application code, network latency, DOM processing, and Page rendering. Browser Version Chart Helps you understand which versions of each browser type your customers come from based on throughput. Error Instance Details Error Instance details grabs a snapshot of a single error and captures the stack trace details available from the browser, focusing on the actionable components, down to the line of code. These are metrics are combined with unique browser combinations down to the version level, and unique url. JavaScript diagnostics doesn't get more granular than this. AJAX If your applications use AJAX to update parts of a webpage after the initial page load, our AJAX dashboards will provide you with the level of visibility you need to understand how those requests are performing and ultimately affecting your users’ experience. AJAX Dashboard The main AJAX dashboard surfaces your site’s most resource intensive AJAX requests, filterable by time consumption, response time, throughput, callback time, and data transfer. From here you can drill into a particular call for detailed analysis. Calls by Page View Shows which page views are calling a particular server side controller, with page level detail around throughput, response time, total number of calls, and data transfer. Request Status Codes The status codes reporting indicates the return behavior from an AJAX call. A large number of non-200 status codes may indicate a problem with your AJAX endpoints. Data Transfer Per Request This shows data transfer which is requested and sent. Use this to look for correlations between high callback times and data transfer rates. Global Features The following features are used throughout New Relic’s product suite to help make our products easier to use and fit seamlessly into your existing workflows. Quickly View App Health New Relic uses color coded status indicators throughout to help you quickly spot performance issues. Custom dashboards Keep an eye on your most critical performance metrics quickly by adding them to a custom dashboard. Integrate with your ticketing system File tickets related to performance problems directly into your ticketing system. Learn which ticketing systems we support. Alerting Check out our new Alerts Features for Browser that report on JS error %, response time, throughput and much more! Filterable Geography Understand how your end users’ experience with your site varies by geographical region, down to the city level. Identify how a CDN or ASN/ Internet Service Provider is performing in different regions. Security New Relic is committed to helping customers make their applications fast and secure. We take protecting our customers' data seriously, here's an overview of how we do it. U.S. and EU Data Regions Our global data-hosting structure consists of two regions: European Union and United States. You can select your preferred data region during the account setup process, regardless of your physical location. (Note: We do not support migration or aggregation of data across regions.) SOC2 Audited New Relic has successfully completed a SOC 2 audit of processes and controls relevant to security and availability. This audit reviews our security process and controls and provides both ourselves, and more importantly our customers an independent, third-party assurance that we are taking the appropriate steps to protect our systems and our customer’s data. Secure Data Center The infrastructure that runs the New Relic service and stores our customer’s data resides in a Tier III, SSAE-16 certified data center. Customer data is backed up on a regular basis. Continuous Monitoring New Relic employs both internal and third-party services to perform continuous security scanning on both our network and applications to ensure that our applications and servers remain secure. Secure by Default We strongly believe in the concept of “secure by default”. Customers have to explicitly enable settings within New Relic to authorize the sending of sensitive data. We want to make sure that you are not accidentally exposing anything that you don’t want to. Compliance Friendly New Relic can be configured to operate securely in regulated environments such as PCI, HIPAA, or SOX. In addition we are Swiss and EU Privacy Shield certified. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.102005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Percentage of <em>Page</em> <em>Views</em> with Errors",
        "body": " (paint metrics), how long until users can interact with our <em>page</em> (interactivity metrics), and how long until marquee content renders (largest contentful paint). (see blogpost for more) Single <em>Page</em> <em>App</em> Route Changes <em>View</em> Single <em>Page</em> Application route change performance, regardless of what JavaScript"
      },
      "id": "5c66a952b5b9e17d23a27084"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/markdown-summary-for-syslog-facilities.png",
      "url": "https://newrelic.com/blog/how-to-relic/how-to-create-syslog-dashboard-using-new-relic-terraform",
      "sections": [
        "Understanding the Syslog format",
        "Step 1: Create your Terraform project",
        "Step 2: Create the Syslog dashboard",
        "Widget 1: Billboard counters by severity",
        "Widget 2: Billboard for log throughput",
        "Widget 3: Line chart to view problem-related trends over time",
        "Widget 4: Bar charts by application and node",
        "Widget 5: Line charts to view log counters by severity and facility over time",
        "Widget 6: Event table to display the top 100 logs",
        "Widget 7: Markdown summary for Syslog facilities",
        "Step 3: Apply your code",
        "Step 4: Add alerts for real-time notification",
        "Ready to create a Syslog dashboard?"
      ],
      "published_at": "2021-04-15T23:12:03Z",
      "title": "Dashboards as Code: How to Create a Syslog Dashboard Using New Relic and Terraform",
      "updated_at": "2021-04-13T23:16:12Z",
      "type": "",
      "external_id": "5372ca6e0d29c3dced938e55d3c17f22b01bbec4",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Dashboards as Code: How to Create a Syslog Dashboard Using New Relic and Terraform Mar 16, 2021 • 11 min read By Edmo Vamerlatti Dashboards are important tools that help you visualize your entire stack's performance to understand context and resolve issues quickly. They also help you answer questions such as, \"When did the problem start?\" and \"What's the impact of this issue?\" However, manually maintaining dashboards can be error prone and is sub-optimal in terms of efficiency and security. Manual updates to dashboards also do not provide any modification history, rollback mechanisms, peer reviews, or any of the benefits we normally expect in CI/CD pipelines. That’s why engineers are beginning to treat them like any other important resource: by creating dashboards as code. For example, using Terraform and the new, built-in log parser rule for Syslog RFC-5424 within New Relic One, you can implement observability as code with a dashboard that organizes Syslog RFC-5424 unstructured messages into attribute/value pairs and lets you drive alerts based on subsets of log data. With the new agentless option for onboarding syslog data, you have a variety of options for data ingest, so long as you properly parse the data when ingesting or directly from the New Relic UI. This blog post guides you through how to create a Syslog RFC-5424 dashboard as code. Understanding the Syslog format To build the dashboard, you first need to understand how log severities are defined in the Syslog RFC-5424 format. The PRI part of a syslog, which is a calculated priority value, is used to represent both the facility and severity of the log or event message. PRI calculates the value by first multiplying the facility number by 8 and then adding the numerical value of the severity. For example, a security/authorization (facility = 4) with a critical severity (severity = 2) would have a PRI value of 34 ((4 * 8) + 2). Based on this understanding, you can extract the log severity from the PRI log attribute using the following formula: (pri - ((floor(pri)/8) * 8)). Step 1: Create your Terraform project As an infrastructure-as-code tool that you can use to provision all kinds of infrastructure and services, Terraform uses a configuration language known as HCL. Its main purpose is to describe resources that are used to represent infrastructure objects. The resources are processed by specific plugins called providers. New Relic has an official Terraform provider. It allows you to manage different types of resources such as dashboards, alert channels, and alert policies. For more information about the Terraform provider, see the provider documentation and the quick-tip video shown here. Start by creating your project folder. Because Terraform is quite flexible and can be adapted depending on the requirements of your project (including multiple environments, multiple accounts, and so on), there are different ways of organizing a Terraform workspace. For simplicity’s sake, we’ll adopt a flat structure for this example. 1. Create a directory for your project. mkdir newrelic-syslog-monitoring 2. Create a file named versions.tf in your working directory. Terraform uses this file to configure the Terraform client and specify all required providers for the current module, in this case, the newrelic provider. terraform { required_version = \">= 0.13\" required_providers { newrelic = { source  = \"newrelic/newrelic\" version = \">= 2.12.0\" } } } 3. Provide input variables. The New Relic Terraform provider requires an Account ID, Personal Key, and Region (US or EU) to integrate with your account and manage resources. It supports two methods of configuration: using environment variables or a provider block. This simple example uses the provider block, and all required information is received through input variables. Create a file named variables.tf: variable \"NEWRELIC_ACCOUNT_ID\" { type    = number } variable \"NEWRELIC_API_KEY\" { type    = string } variable \"NEWRELIC_REGION\" { type    = string } 4. Create a file named main.tf to be the primary entry point for Terraform. The New Relic Terraform provider is also configured in this file using the input variables previously declared in the variables.tf file: provider \"newrelic\" { account_id = var.NEWRELIC_ACCOUNT_ID api_key    = var.NEWRELIC_API_KEY region     = var.NEWRELIC_REGION } Step 2: Create the Syslog dashboard All the dashboard data is retrieved from the Log data type using the NRQL query language. To simplify the queries and avoid repetition, use Terraform locals to represent the Syslog severity formula and the logType filter value. 1. Create a file named dashboards.tf. This file is used to describe the dashboard resource and its widgets/visualizations: locals { syslog   = \"syslog-rfc5424\" severity = \"(numeric(pri) - (floor(numeric(pri)/8) * 8))\" } resource \"newrelic_dashboard\" \"syslog_dashboard\" { title             = \"Syslog Dashboard\" grid_column_count = 12 } 2. Add widgets and visualizations. The first step in designing your dashboard is to define what you want to achieve and which visualizations will be most important to enable that. For this example, the dashboard gives an overview of application health. Note: All widget code goes inside the \"syslog_dashboard\" {...} block. Widget 1: Billboard counters by severity The log's severity is one of the most important fields available in the Syslog format and is widely used on this dashboard's visualizations. Billboard charts show the log counters by severity, coloring them yellow or red depending on the threshold_yellow and threshold_red values. The charts make it easy to see what's happening with your applications and catch your attention if any problematic log arrives. Because these billboard charts share nearly identical code, you can take advantage of Terrafrom's dynamic blocks and reuse the code to iterate through a severity_billboards map to configure every widget. To accomplish this, add a severity_billboards map inside the locals{...} block with the following content: locals { syslog   = \"syslog-rfc5424\" severity = \"(numeric(pri) - (floor(numeric(pri)/8) * 8))\" severity_billboards = tomap({ \"emergency\"     = { severity =  0, row = 1, column = 1, threshold_red = 1 }, \"alert\"         = { severity =  1, row = 2, column = 1, threshold_red = 1 }, \"critical\"      = { severity =  2, row = 1, column = 2, threshold_red = 1 }, \"error\"         = { severity =  3, row = 2, column = 2, threshold_yellow = 1 }, \"warning\"       = { severity =  4, row = 1, column = 3 }, \"notice\"        = { severity =  5, row = 2, column = 3 }, \"informational\" = { severity =  6, row = 1, column = 4 }, \"debug\"         = { severity =  7, row = 2, column = 4 } }) } Then add generic code for the widget inside the syslog_dashboard\" {...} block: dynamic \"widget\" { for_each = local.severity_billboards content { title            = \"\" nrql             = <<-EOF SELECT count(*) as '${title(widget.key)} (${widget.value.severity})' FROM Log WHERE logType = '${local.syslog}' AND ${local.severity} = ${widget.value.severity} EOF visualization    = \"billboard\" width            = 1 height           = 1 row              = widget.value.row column           = widget.value.column threshold_yellow = try(widget.value.threshold_yellow, null) threshold_red    = try(widget.value.threshold_red, null) } } Your final result should look similar to this:   Widget 2: Billboard for log throughput This chart shows the total number of logs and the rate per minute your applications are sending them. widget { title         = \"Throughput\" nrql          = <<-EOF SELECT rate(count(*), 1 minute) as 'Logs /min', count(*) as 'Total' FROM Log WHERE logType = '${local.syslog}' SINCE 1 hour ago EOF visualization = \"attribute_sheet\" width         = 2 height        = 2 row           = 1 column        = 5 } Your final result should look like this:   Widget 3: Line chart to view problem-related trends over time This chart counts all logs with severity equal to Error(3), Critical(2), Alert(1) or Emergency(0) and displays the result over time. Spikes on this graph show that you might have problems with your applications that require actions to be taken to resolve them. widget { title         = \"Logs (Emergency + Alert + Critical + Error)\" nrql          = <<-EOF SELECT count(*) FROM Log WHERE logType = '${local.syslog}' AND ${local.severity} < 4 TIMESERIES AUTO EOF visualization = \"line_chart\" width         = 6 height        = 3 row           = 3 column        = 1 } Your final result should look something like this:   Widget 4: Bar charts by application and node These charts show the number of logs by application and hostname. They can also be configured to filter the current dashboard just by clicking on the application/hostname bars. widget { title         = \"Top Applications\" nrql          = <<-EOF SELECT count(*) FROM Log WHERE logType = '${local.syslog}' FACET app.name EOF visualization = \"facet_bar_chart\" width         = 2 height        = 5 row           = 1 column        = 7 } widget { title         = \"Top Nodes\" nrql          = <<-EOF SELECT count(*) as 'Logs' FROM Log WHERE logType = '${local.syslog}' FACET hostname EOF visualization = \"facet_bar_chart\" width         = 2 height        = 5 row           = 1 column        = 9 } Your final result should look similar to this:   Widget 5: Line charts to view log counters by severity and facility over time The idea behind these charts is to display the number of logs by severity and facility your applications are sending over time. This way you can easily detect spikes of any severity or facility and identify when they started and stopped. widget { title         = \"Logs by Severity\" nrql          = <<-EOF SELECT count(*) FROM Log WHERE logType = '${local.syslog}' FACET string(${local.severity}) as 'Severity' TIMESERIES AUTO EOF visualization = \"faceted_line_chart\" width         = 3 height        = 3 row           = 6 column        = 1 } widget { title         = \"Logs by Facility\" nrql          = <<-EOF SELECT count(*) FROM Log WHERE logType = '${local.syslog}' FACET floor(numeric(pri)/8) as 'Facility' TIMESERIES AUTO EOF visualization = \"faceted_line_chart\" width         = 3 height        = 3 row           = 6 column        = 4 } Your final result should look similar to this:   Widget 6: Event table to display the top 100 logs This chart displays the 100 most important logs prioritized by severity. widget { title         = \"Top 100 Logs\" nrql          = <<-EOF SELECT ${local.severity} as 'Severity', app.name as 'Application', message FROM Log WHERE logType = '${local.syslog}' LIMIT 100 EOF column        = 7 row           = 6 visualization = \"event_table\" width         = 6 height        = 3 } Your final result should look like this:   Widget 7: Markdown summary for Syslog facilities This chart lists the names of the syslog facilities on your dashboard for easy reference. widget { title         = \"\" width         = 2 height        = 5 row           = 1 column        = 11 source        = <<-EOF ### Facilities 1. kernel messages 2. user-level messages 3. mail system 4. system daemons 5. security/authorization messages (note 1) 6. messages generated internally by syslogd 7. line printer subsystem 8. network news subsystem 9. UUCP subsystem 10. clock daemon (note 2) 11. security/authorization messages (note 1) 12. FTP daemon 13. NTP subsystem 14. log audit (note 1) 15. log alert (note 1) 16. clock daemon (note 2) to 23. local uses 0 to 7 (local n) EOF visualization = \"markdown\" } Your final dashboard should look similar to this: markdown summary for syslog facilities example   Step 3: Apply your code You can install the Terraform client either by downloading the binary from www.terraform.io/downloads.html or using your operating system's package manager. More instructions on how to install Terraform in different environments can be found here. After you install the Terraform client, run the following command in your working directory: terraform plan -var NEWRELIC_ACCOUNT_ID=<YOUR-ACCOUNT-ID> -var NEWRELIC_API_KEY=<YOUR-API-KEY> \\ -var NEWRELIC_REGION=<US or EU> The terraform plan command creates an execution plan and then determines which actions are necessary to achieve the desired state specified in the configuration files. In this case, your dashboard resource is added. Finally, run the following command to apply all pending actions and create the resources in the New Relic One platform: terraform apply -var NEWRELIC_ACCOUNT_ID=<YOUR-ACCOUNT-ID> -var NEWRELIC_API_KEY=<YOUR-API-KEY> \\ -var NEWRELIC_REGION=<US or EU> Terraform uses states to map your local resources to the real world. When you have a declared resource such as resource \"newrelic_dashboard\" in your files, Terraform uses the map to know that the New Relic Dashboard ID 1234 is represented by that resource. That said, if you apply this project in different machines without sharing the state, Terraform will recreate all resources instead of updating them. Setting up a remote state would prevent this situation. HashiCorp offers a Terraform Cloud solution that automates Terraform workflow out of the box. It's also possible to use Atlantis, which is a tool that automates Terraform through pull requests, taking your observability as code to the next level. Step 4: Add alerts for real-time notification Although dashboards are essential tools for detecting and troubleshooting problems, unless you’re watching them 24 hours a day, you can miss important logs. Setting up alerts gives you instant notification whenever an important metric hits a threshold. New Relic alerts help you solve your application issues faster and with less noise before they turn into critical incidents. New Relic’s third-party integrations, such as PagerDuty and Slack, make the notification process very efficient and adaptable to your team’s needs. The New Relic Terraform provider supports all required alerting resources to monitor your syslog applications. You can, for example, create different alert channels per team, responsibility, node, or application, notifying different people in various ways when applications are reporting errors. For the example, you can reuse the dashboard queries and define the following NRQL alert conditions: A static threshold alarm for critical severities Error(3), Critical(2), Alert(1) and Emergency(0). Baseline alarm in upper direction for log counters with severity < 4 to detect abnormal unhealthy spikes. Additional alerts depending on your environment and system characteristics, such as a static alert for logs with severity < 4 and facility equal to security/authorization messages(4), which would appropriately send a notification message to the #security-team Slack channel, for example, and not the whole company. (For more information about New Relic alerts with Terraform, see this blog post.) Ready to create a Syslog dashboard? All the code used in the example can be found in this GitHub repository. If you don't want to use Terraform but would like to try out the dashboard, you can import it by copying this JSON file content, replacing the <YOUR_ACCOUNT_ID> placeholder with your Account ID, and importing it into New Relic using the UI (Dashboard > Import dashboard option). If you’re new to New Relic and want to try out the New Relic Terraform provider, sign up for a new account with 100 GB/month of free ingest. By Edmo Vamerlatti Edmo is a Software Engineer at New Relic, where he works on the Logging team. His professional interests include distributed systems, high scalability, observability, and programming languages. In his spare time, he enjoys reading, eating out in restaurants, and skateboarding. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.12073,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Widget 3: Line chart to <em>view</em> problem-related trends over time",
        "body": "-ACCOUNT-ID&gt; -var NEWRELIC_API_KEY=&lt;YOUR-API-KEY&gt; \\ -var NEWRELIC_<em>REGION</em>=&lt;US or EU&gt; Terraform uses states to <em>map</em> your local resources to the real world. When you have a declared resource such as resource &quot;newrelic_dashboard&quot; in your files, Terraform uses the <em>map</em> to know that the New Relic Dashboard ID"
      },
      "id": "6076263d28ccbcffe951c16a"
    }
  ],
  "/components/charts": [
    {
      "sections": [
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "Tip",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs"
      ],
      "title": "Automate instrumentation",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "65d82617672b47497b59dcf7c55eaba535714676",
      "image": "https://docs.newrelic.com/static/82b9b43751f8e8c8dbf4be1242cc6cb3/c1b63/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation/",
      "published_at": "2021-04-16T10:15:36Z",
      "updated_at": "2021-03-16T10:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Tip Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.856705,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ". For example, the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "603ea2f7196a672323a83def"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/DEPLOYMENT-ANALYZER-SCREENSHOT-1.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-3",
      "sections": [
        "Container Explorer",
        "Specific requirements for this app",
        "Deployment Analyzer",
        "Page View Map",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:25:05Z",
      "title": "Most Popular New Relic One Applications (Round up #3)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "6f0be6c93ebcc052fac27513c1e849c0dfd256e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic Most Popular New Relic One Applications (Round up #3) Nov 26, 2019 • 7 min read By Joel Worrall Hopefully, you’ve heard the news that the New Relic One observability platform is now programmable. As central component of an observability platform, we believe programmability gives you the ability to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the possibilities—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications … and then we kept going. In fact, new apps are coming in every day. And we hope to see app contributions by New Relic users continue. This blog series is our opportunity to spotlight the most popular apps available today from our GitHub repository. The best part: Every app is available under an open source license and can be deployed right now! In this edition, we cover: Container Explorer Deployment Analyzer Page View Map Container Explorer This app includes a launcher that gives you a global view of all containers associated with an account. You can also employ tags to segment and drill down into subsets of your global container inventory. The app also presents container CPU, memory, and disk I/O usage in the form of intuitive and efficient heat map visualizations. Container Explorer presents CPU, memory, and disk I/O usage for all containers associated with an account—displaying this data via intuitive and efficient heat map visualizations. In the New Relic One entity explorer, we provide a nerdlet that will show all of the containers that are running for a selected APM application (service). We can also detect whether infrastructure data is coming from third-party sources and can, if necessary, automatically present this container telemetry in-context. Container Explorer can detect whether infrastructure data is coming from third-party sources—and can, if necessary, automatically ingest and present this container telemetry in-context. Clicking on a node in the heatmap reveals details about that container, and you can also jump to its host in the entity explorer. Clicking on a node in the Container Explorer heatmap reveals details about that container, and users can also jump to its host in the entity explorer. Fork or deploy the Container Explorer app from GitHub. Specific requirements for this app The New Relic Infrastructure agent must be deployed on any host you want to monitor. Note: We generate per-container CPU and other metrics by summarizing all processes in a given containerId. This will, however, report an accurate value only if the agent reports one ProcessSample per process every 30 seconds. Deployment Analyzer Deployments of applications can be risky events, but you can correlate those events to the performance of your applications, using deployment markers in New Relic. This app builds further on this process—enabling teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Deployment Analyzer enables teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Fork or deploy the Deployment Analyzer app from GitHub. Specific requirements for this app You'll need an active New Relic APM Pro subscription in order to access deployment marker functionality. Page View Map This app creates geographic visualizations of New Relic Browser application data using the React Leaflet mapping library. Leaflet is a leading open-source JavaScript library for mobile-friendly interactive maps. In addition to providing a new way to visualize your business data, this app offers a great example of what's possible for developers working with our GraphQL service and a third party library. Page View Map creates geographic visualizations of New Relic Browser application data Fork or deploy the Page Views Map app from GitHub Specific requirements for this app You must have the New Relic Browser Agent(s) installed, as well as related access to New Relic One. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer.git cd nr1-container-explorer nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Container Explorer to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer cd nr1-container-explorer nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app's launcher (unless otherwise noted above). Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications: New Relic Developer Edition: Early access to the Developer Edition of New Relic One gives you a free, personal sandbox account where you can build your own experience with all the available New Relic tools. developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome contributions to any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series.   Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 61.685005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: <em>nr1</em> <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>nr1</em>-container-explorer.git cd <em>nr1</em>-container-explorer <em>nr1</em> <em>nerdpack</em>:serve Or you could download, configure"
      },
      "id": "60762e1f196a673d0a64a782"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/New-Relic-One-Catalog.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-5",
      "sections": [
        "Subscribe to applications with the New Relic One Catalog",
        "Observability Maps",
        "Metric Aggregator",
        "Workload Geo Ops",
        "Check out these other resources for using—and building—New Relic One applications ",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "The Most Popular New Relic One Applications (Roundup #5)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "75f80d867fec167c4a6d62082f32cb2ff1ae0802",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #5) Jun 4, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Observability Maps Metric Aggregator Workload Geo Ops Subscribe to applications with the New Relic One Catalog Before we start accessing the applications via the CLI, let’s look at how to access these applications directly within New Relic One. To explore available applications, navigate to New Relic One and click on the New Relic One Catalog launcher. New Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. New Relic One Catalog If you deploy an application from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Observability Maps Observability Maps allows you to create a view beyond a traditional service map. Using Observability Maps, you can connect disparate entities in your environment into ad hoc relationships, creating your own relationships based on data available in New Relic. See your entities and environment in a way that makes the most sense to your team and business. Observability Maps App Fork or deploy the Observability Maps app from GitHub. Specific requirements for this app Requires data in NRDB from any or all of the New Relic products. Metric Aggregator The Metric Aggregator is a New Relic One application that helps you create events-to-metrics (E2M) rules, a real-time streaming service that converts event data into dimensional metrics at ingest. Converting events to metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Metric Aggregator App Fork or deploy the Metric Aggregator app from GitHub. Specific requirements for this app If you use New Relic, you already have New Relic Metrics. You can  create E2M rules immediately. Workload Geo Ops Workload Geo Ops links your workloads (collections of entities) to physical locations so you can quickly identify and resolve incidents. It's a geographic exploration of workload data tied to geographic data, including location metadata. You can define maps and then collect or assign entities to points on those maps. With workloads, a collection of entities can be managed by rules and tags to support the dynamic, ephemeral nature of modern IT infrastructure. Fork or deploy the Workload Geo Ops app from GitHub. Specific requirements for this app To get the most of this app, we recommend that you configure Workloads in New Relic One. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Workload Geo Ops to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One applications  Here are resources to help you build your own New Relic One applications. If you can imagine it, you can build it:  developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. NerdGraph GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity. Application/data access and permissions and security. NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 61.685005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The <em>Nerdpack</em> <em>file</em> <em>structure</em>, including how to link your application with an entity. Application&#x2F;data access and permissions and security. <em>NR1</em> Workshop: a step-by-step, self-paced, open source"
      },
      "id": "60762e1f64441fbf2e9d856e"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Event-Stream-Screenshot.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-applications-4",
      "sections": [
        "Event Stream",
        "Specific requirements for this app",
        "Neon",
        "Network Telemetry",
        "SLO/R",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:39:54Z",
      "title": "The Most Popular New Relic One Applications (Roundup #4)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "0ac60d545488f3c1904bdd6e0d552af5c307ee5a",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #4) Jan 9, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs different types and combinations of insights into how their apps and systems are performing. That’s why New Relic One is programmable—you can build and deploy custom apps that give you the specific insights and information your company needs. To show you what’s possible—and to inspire you to create apps—we worked with members of the New Relic community to build a handful of open source applications, and the number of newly-developed apps continues to grow. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Event Stream Neon Network Telemetry SLO/R Event Stream During a launch or incident, you need the absolute latest data from your application. Event Stream is like Unix tail for APM data—it pulls in your Transaction and TransactionError data in a live stream, so you can find out exactly what's happening with your app right at that moment. You can also filter and facet the data to show the exact data you need. New Relic One Application Event Stream Fork or deploy the Event Stream app from GitHub. Specific requirements for this app Install the appropriate New Relic APM agent. Neon Need to create a single dashboard to track the health of entire business units or regions? Neon lets you create a status board based on New Relic alerts or the values from New Relic events. Fork or deploy the Neon app from GitHub. Specific requirements for this app To view the status of New Relic alerts, you’ll need to set up a webhook notification channel for the alert policies. See the New Relic documentation to learn more about managing notification channels. Network Telemetry Network Telemetry Screenshot The Network Telemetry app visualizes data collected through the Network Telemetry Infrastructure integration. The integration collects data from network devices that export Sflow or IPFIX network samples, and the app creates visualizations to help you examine the sources and destinations of communication within a network, as well as the volume of traffic between devices. Fork or deploy Network Telemetry from GitHub. Specific requirements for this app Install the New Relic Infrastructure agent, and ensure you have the related access to New Relic One. Install the New Relic Network Telemetry On-host integration.  SLO/R SLO/R Screenshot The SLO/R app calculates service-level objective (SLO) attainment for an application service. It allows you to quickly define SLOs for error, availability, capacity, and latency conditions. By measuring SLO attainment across your service estate, you'll be able to determine what signals are most important for a given service or set of services, developed and supported by a team, organization, or group. Using New Relic as a consistent basis to define and measure your SLOs offers better insight into comparative SLO attainment in your service delivery organization. Note: SLO/R is intended to work with services reporting to New Relic via an APM agent. The service provides an entity upon which to define SLOs. Error budget SLOs are defined directly from APM Transaction events; the other SLO types are defined using New Relic alerts. See \"Creating a webhook to forward Alert incidents to Insights\" for more details. Fork or deploy the SLO/R app from GitHub. Specific requirements for this app Install the appropriate New Relic APM agents. Create a New Relic alerts webhook to forward alert events to a SLOR_ALERTS New Relic database table. See \"Creating a webhook to forward Alert incidents to Insights\" for details. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Event Stream—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-event-stream.git cd nr1-event-stream nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Event Stream to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-event-stream.git cd nr1-event-stream   nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications. If you can imagine it, you can build it: developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 61.685005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "—in this example, Event Stream—is as easy as running a few commands: <em>nr1</em> <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>nr1</em>-event-stream.git cd <em>nr1</em>-event-stream <em>nr1</em> <em>nerdpack</em>:serve Or you could download, configure, and deploy an account-specific instance of Event Stream to your New Relic account using"
      },
      "id": "60762e2028ccbcaf8651c17c"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/attributory-screenshot-main.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-6",
      "sections": [
        "Subscribe to apps in the New Relic One Catalog",
        "Flex Manager",
        "GraphiQL Notebook",
        "Attributory",
        "What are you waiting for? Deploy these apps now.",
        "Check out these other resources for using—and building—New Relic One apps",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:26:51Z",
      "title": "The Most Popular New Relic One Applications (Roundup #6)",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "76394d24aebbff40a68e9bd6a7f867313e814d74",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #6) Jul 2, 2020 • 8 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the visibility and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source, so you can use them out-of-the-box, or submit a pull request for feedback and feature requests. In this edition, we cover three apps that help engineers do their jobs: Flex Manager GraphiQL Notebook Attributory Subscribe to apps in the New Relic One Catalog You can manage and deploy apps directly within New Relic One. To explore available apps, navigate to New Relic One and click on the New Relic One Catalog launcher. From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. If you deploy an app from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Flex Manager New Relic Flex is an application-agnostic, all-in-one tool that makes sending data to New Relic from third party sources easier than ever. Use Flex Manager to simplify the work of creating, managing, and deploying new integrations you’ve built with Flex. Fork or deploy the Flex Manager app from GitHub. Specific requirements for this app Flex Manager requires New Relic Infrastructure and the Flex integration. GraphiQL Notebook GraphiQL Notebook allows you to explore and learn about the NerdGraph—the New Relic GraphQL API—using a Jupyter Notebook style interface. Notebooks intermix GraphQL requests with data exploration links. You can create, update, save, and delete notebooks. You can also export and share notebooks as blocks of Base64-encoded JSON. Fork or deploy the GraphQL Notebook app from GitHub. Attributory Attributory is a dictionary of attributes from your APM, Browser, or Mobile applications stored in New Relic. It displays a list of attributes for each application. When you open a service or application from the entity explorer, you’ll find Attributes Dictionary listed as an application in the left-hand navigation. New Relic stores event data as key-value pairs. Built-in New Relic attributes include the definition of the attribute. For custom attributes, you can choose to add your own definitions. Fork or deploy the Attributory app from GitHub. Specific requirements for this app Applications with New Relic APM, Browser, or Mobile agents reporting into New Relic. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account Once you have these requirements in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Attributory to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One apps Here are resources to help you build your own New Relic One apps. If you can imagine it, you can build it: New Relic Developers: Build applications using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Open Source: New Relic’s open source website makes it easy for you to explore the open source projects we maintain and the open standards projects we participate in. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, review our Contributors Guide. Keep in mind that when you submit your Pull Request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 61.684963,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: <em>nr1</em> <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>nr1</em>-attributory.git cd <em>nr1</em>-attributory <em>nr1</em> <em>nerdpack</em>:serve Or you could download, configure, and deploy an account-specific instance of Attributory"
      },
      "id": "60762e1e28ccbcb5fd51c147"
    }
  ],
  "/build-apps/build-hello-world-app": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/New-Relic-One-Catalog.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-5",
      "sections": [
        "Subscribe to applications with the New Relic One Catalog",
        "Observability Maps",
        "Metric Aggregator",
        "Workload Geo Ops",
        "Check out these other resources for using—and building—New Relic One applications ",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "The Most Popular New Relic One Applications (Roundup #5)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "75f80d867fec167c4a6d62082f32cb2ff1ae0802",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #5) Jun 4, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Observability Maps Metric Aggregator Workload Geo Ops Subscribe to applications with the New Relic One Catalog Before we start accessing the applications via the CLI, let’s look at how to access these applications directly within New Relic One. To explore available applications, navigate to New Relic One and click on the New Relic One Catalog launcher. New Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. New Relic One Catalog If you deploy an application from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Observability Maps Observability Maps allows you to create a view beyond a traditional service map. Using Observability Maps, you can connect disparate entities in your environment into ad hoc relationships, creating your own relationships based on data available in New Relic. See your entities and environment in a way that makes the most sense to your team and business. Observability Maps App Fork or deploy the Observability Maps app from GitHub. Specific requirements for this app Requires data in NRDB from any or all of the New Relic products. Metric Aggregator The Metric Aggregator is a New Relic One application that helps you create events-to-metrics (E2M) rules, a real-time streaming service that converts event data into dimensional metrics at ingest. Converting events to metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Metric Aggregator App Fork or deploy the Metric Aggregator app from GitHub. Specific requirements for this app If you use New Relic, you already have New Relic Metrics. You can  create E2M rules immediately. Workload Geo Ops Workload Geo Ops links your workloads (collections of entities) to physical locations so you can quickly identify and resolve incidents. It's a geographic exploration of workload data tied to geographic data, including location metadata. You can define maps and then collect or assign entities to points on those maps. With workloads, a collection of entities can be managed by rules and tags to support the dynamic, ephemeral nature of modern IT infrastructure. Fork or deploy the Workload Geo Ops app from GitHub. Specific requirements for this app To get the most of this app, we recommend that you configure Workloads in New Relic One. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Workload Geo Ops to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One applications  Here are resources to help you build your own New Relic One applications. If you can imagine it, you can build it:  developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. NerdGraph GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity. Application/data access and permissions and security. NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 247.7313,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic <em>One</em> <em>Applications</em> (Roundup #5)",
        "sections": "<em>Subscribe</em> to <em>applications</em> with the New Relic <em>One</em> <em>Catalog</em>",
        "body": " GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The <em>Nerdpack</em> <em>file</em> <em>structure</em>, including how to link your application with an entity. Application&#x2F;data access and permissions and security. <em>NR1</em> Workshop: a step-by-step, self-paced, open source"
      },
      "id": "60762e1f64441fbf2e9d856e"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/attributory-screenshot-main.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-6",
      "sections": [
        "Subscribe to apps in the New Relic One Catalog",
        "Flex Manager",
        "GraphiQL Notebook",
        "Attributory",
        "What are you waiting for? Deploy these apps now.",
        "Check out these other resources for using—and building—New Relic One apps",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:26:51Z",
      "title": "The Most Popular New Relic One Applications (Roundup #6)",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "76394d24aebbff40a68e9bd6a7f867313e814d74",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #6) Jul 2, 2020 • 8 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the visibility and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source, so you can use them out-of-the-box, or submit a pull request for feedback and feature requests. In this edition, we cover three apps that help engineers do their jobs: Flex Manager GraphiQL Notebook Attributory Subscribe to apps in the New Relic One Catalog You can manage and deploy apps directly within New Relic One. To explore available apps, navigate to New Relic One and click on the New Relic One Catalog launcher. From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. If you deploy an app from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Flex Manager New Relic Flex is an application-agnostic, all-in-one tool that makes sending data to New Relic from third party sources easier than ever. Use Flex Manager to simplify the work of creating, managing, and deploying new integrations you’ve built with Flex. Fork or deploy the Flex Manager app from GitHub. Specific requirements for this app Flex Manager requires New Relic Infrastructure and the Flex integration. GraphiQL Notebook GraphiQL Notebook allows you to explore and learn about the NerdGraph—the New Relic GraphQL API—using a Jupyter Notebook style interface. Notebooks intermix GraphQL requests with data exploration links. You can create, update, save, and delete notebooks. You can also export and share notebooks as blocks of Base64-encoded JSON. Fork or deploy the GraphQL Notebook app from GitHub. Attributory Attributory is a dictionary of attributes from your APM, Browser, or Mobile applications stored in New Relic. It displays a list of attributes for each application. When you open a service or application from the entity explorer, you’ll find Attributes Dictionary listed as an application in the left-hand navigation. New Relic stores event data as key-value pairs. Built-in New Relic attributes include the definition of the attribute. For custom attributes, you can choose to add your own definitions. Fork or deploy the Attributory app from GitHub. Specific requirements for this app Applications with New Relic APM, Browser, or Mobile agents reporting into New Relic. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account Once you have these requirements in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Attributory to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One apps Here are resources to help you build your own New Relic One apps. If you can imagine it, you can build it: New Relic Developers: Build applications using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Open Source: New Relic’s open source website makes it easy for you to explore the open source projects we maintain and the open standards projects we participate in. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, review our Contributors Guide. Keep in mind that when you submit your Pull Request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.23026,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic <em>One</em> <em>Applications</em> (Roundup #6)",
        "sections": "<em>Subscribe</em> to apps in the New Relic <em>One</em> <em>Catalog</em>",
        "body": " to your New Relic account using the following commands: <em>nr1</em> <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>nr1</em>-attributory.git cd <em>nr1</em>-attributory <em>nr1</em> <em>nerdpack</em>:publish <em>nr1</em> <em>nerdpack</em>:deploy -c STABLE <em>nr1</em> <em>nerdpack:subscribe</em> -c STABLE Then go to the homepage of <em>one</em>.newrelic.com and select the app’s launcher"
      },
      "id": "60762e1e28ccbcb5fd51c147"
    },
    {
      "sections": [
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "Tip",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs"
      ],
      "title": "Automate instrumentation",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "65d82617672b47497b59dcf7c55eaba535714676",
      "image": "https://docs.newrelic.com/static/82b9b43751f8e8c8dbf4be1242cc6cb3/c1b63/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation/",
      "published_at": "2021-04-16T10:15:36Z",
      "updated_at": "2021-03-16T10:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Tip Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.77087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ". For example, the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic <em>applications</em>. 3. Leverage the power of APIs Now"
      },
      "id": "603ea2f7196a672323a83def"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Event-Stream-Screenshot.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-applications-4",
      "sections": [
        "Event Stream",
        "Specific requirements for this app",
        "Neon",
        "Network Telemetry",
        "SLO/R",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:39:54Z",
      "title": "The Most Popular New Relic One Applications (Roundup #4)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "0ac60d545488f3c1904bdd6e0d552af5c307ee5a",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #4) Jan 9, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs different types and combinations of insights into how their apps and systems are performing. That’s why New Relic One is programmable—you can build and deploy custom apps that give you the specific insights and information your company needs. To show you what’s possible—and to inspire you to create apps—we worked with members of the New Relic community to build a handful of open source applications, and the number of newly-developed apps continues to grow. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Event Stream Neon Network Telemetry SLO/R Event Stream During a launch or incident, you need the absolute latest data from your application. Event Stream is like Unix tail for APM data—it pulls in your Transaction and TransactionError data in a live stream, so you can find out exactly what's happening with your app right at that moment. You can also filter and facet the data to show the exact data you need. New Relic One Application Event Stream Fork or deploy the Event Stream app from GitHub. Specific requirements for this app Install the appropriate New Relic APM agent. Neon Need to create a single dashboard to track the health of entire business units or regions? Neon lets you create a status board based on New Relic alerts or the values from New Relic events. Fork or deploy the Neon app from GitHub. Specific requirements for this app To view the status of New Relic alerts, you’ll need to set up a webhook notification channel for the alert policies. See the New Relic documentation to learn more about managing notification channels. Network Telemetry Network Telemetry Screenshot The Network Telemetry app visualizes data collected through the Network Telemetry Infrastructure integration. The integration collects data from network devices that export Sflow or IPFIX network samples, and the app creates visualizations to help you examine the sources and destinations of communication within a network, as well as the volume of traffic between devices. Fork or deploy Network Telemetry from GitHub. Specific requirements for this app Install the New Relic Infrastructure agent, and ensure you have the related access to New Relic One. Install the New Relic Network Telemetry On-host integration.  SLO/R SLO/R Screenshot The SLO/R app calculates service-level objective (SLO) attainment for an application service. It allows you to quickly define SLOs for error, availability, capacity, and latency conditions. By measuring SLO attainment across your service estate, you'll be able to determine what signals are most important for a given service or set of services, developed and supported by a team, organization, or group. Using New Relic as a consistent basis to define and measure your SLOs offers better insight into comparative SLO attainment in your service delivery organization. Note: SLO/R is intended to work with services reporting to New Relic via an APM agent. The service provides an entity upon which to define SLOs. Error budget SLOs are defined directly from APM Transaction events; the other SLO types are defined using New Relic alerts. See \"Creating a webhook to forward Alert incidents to Insights\" for more details. Fork or deploy the SLO/R app from GitHub. Specific requirements for this app Install the appropriate New Relic APM agents. Create a New Relic alerts webhook to forward alert events to a SLOR_ALERTS New Relic database table. See \"Creating a webhook to forward Alert incidents to Insights\" for details. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Event Stream—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-event-stream.git cd nr1-event-stream nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Event Stream to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-event-stream.git cd nr1-event-stream   nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications. If you can imagine it, you can build it: developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.22171,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic <em>One</em> <em>Applications</em> (Roundup #4)",
        "sections": "Check out these other resources for using—and building!—New Relic <em>One</em> <em>applications</em>",
        "body": " the following commands: <em>nr1</em> <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>nr1</em>-event-stream.git cd <em>nr1</em>-event-stream   <em>nr1</em> <em>nerdpack</em>:publish <em>nr1</em> <em>nerdpack</em>:deploy -c STABLE <em>nr1</em> <em>nerdpack:subscribe</em> -c STABLE Then go to the homepage of <em>one</em>.newrelic.com and select the app’s launcher. Check out these other"
      },
      "id": "60762e2028ccbcaf8651c17c"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/DEPLOYMENT-ANALYZER-SCREENSHOT-1.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-3",
      "sections": [
        "Container Explorer",
        "Specific requirements for this app",
        "Deployment Analyzer",
        "Page View Map",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:25:05Z",
      "title": "Most Popular New Relic One Applications (Round up #3)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "6f0be6c93ebcc052fac27513c1e849c0dfd256e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic Most Popular New Relic One Applications (Round up #3) Nov 26, 2019 • 7 min read By Joel Worrall Hopefully, you’ve heard the news that the New Relic One observability platform is now programmable. As central component of an observability platform, we believe programmability gives you the ability to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the possibilities—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications … and then we kept going. In fact, new apps are coming in every day. And we hope to see app contributions by New Relic users continue. This blog series is our opportunity to spotlight the most popular apps available today from our GitHub repository. The best part: Every app is available under an open source license and can be deployed right now! In this edition, we cover: Container Explorer Deployment Analyzer Page View Map Container Explorer This app includes a launcher that gives you a global view of all containers associated with an account. You can also employ tags to segment and drill down into subsets of your global container inventory. The app also presents container CPU, memory, and disk I/O usage in the form of intuitive and efficient heat map visualizations. Container Explorer presents CPU, memory, and disk I/O usage for all containers associated with an account—displaying this data via intuitive and efficient heat map visualizations. In the New Relic One entity explorer, we provide a nerdlet that will show all of the containers that are running for a selected APM application (service). We can also detect whether infrastructure data is coming from third-party sources and can, if necessary, automatically present this container telemetry in-context. Container Explorer can detect whether infrastructure data is coming from third-party sources—and can, if necessary, automatically ingest and present this container telemetry in-context. Clicking on a node in the heatmap reveals details about that container, and you can also jump to its host in the entity explorer. Clicking on a node in the Container Explorer heatmap reveals details about that container, and users can also jump to its host in the entity explorer. Fork or deploy the Container Explorer app from GitHub. Specific requirements for this app The New Relic Infrastructure agent must be deployed on any host you want to monitor. Note: We generate per-container CPU and other metrics by summarizing all processes in a given containerId. This will, however, report an accurate value only if the agent reports one ProcessSample per process every 30 seconds. Deployment Analyzer Deployments of applications can be risky events, but you can correlate those events to the performance of your applications, using deployment markers in New Relic. This app builds further on this process—enabling teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Deployment Analyzer enables teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Fork or deploy the Deployment Analyzer app from GitHub. Specific requirements for this app You'll need an active New Relic APM Pro subscription in order to access deployment marker functionality. Page View Map This app creates geographic visualizations of New Relic Browser application data using the React Leaflet mapping library. Leaflet is a leading open-source JavaScript library for mobile-friendly interactive maps. In addition to providing a new way to visualize your business data, this app offers a great example of what's possible for developers working with our GraphQL service and a third party library. Page View Map creates geographic visualizations of New Relic Browser application data Fork or deploy the Page Views Map app from GitHub Specific requirements for this app You must have the New Relic Browser Agent(s) installed, as well as related access to New Relic One. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer.git cd nr1-container-explorer nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Container Explorer to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer cd nr1-container-explorer nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app's launcher (unless otherwise noted above). Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications: New Relic Developer Edition: Early access to the Developer Edition of New Relic One gives you a free, personal sandbox account where you can build your own experience with all the available New Relic tools. developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome contributions to any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series.   Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.2216,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Most Popular New Relic <em>One</em> <em>Applications</em> (Round up #3)",
        "sections": "Check out these other resources for using—and building!—New Relic <em>One</em> <em>applications</em>",
        "body": ", and deploy an account-specific instance of Container Explorer to your New Relic account using the following commands: <em>nr1</em> <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>nr1</em>-container-explorer cd <em>nr1</em>-container-explorer <em>nr1</em> <em>nerdpack</em>:publish <em>nr1</em> <em>nerdpack</em>:deploy -c STABLE <em>nr1</em> <em>nerdpack:subscribe</em> -c"
      },
      "id": "60762e1f196a673d0a64a782"
    }
  ],
  "/build-apps/set-up-dev-env": [
    {
      "sections": [
        "Transition to New Relic One from Insights",
        "Important",
        "Steps for a successful transition",
        "Get started with New Relic One",
        "Query anything",
        "Visualize more data"
      ],
      "title": "Transition to New Relic One from Insights",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "4af99cd8030909a71d21a359a60af5ac93b93a66",
      "image": "https://docs.newrelic.com/static/37a6b5e8b87c365c4b1bf9ea778696a7/c1b63/new-relic-one-dashboard-example_1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/transition-new-relic-one-insights/",
      "published_at": "2021-04-16T22:09:48Z",
      "updated_at": "2021-04-05T03:35:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Released in 2014, New Relic Insights was our original way to create custom queries, charts, and dashboards. With New Relic One, we have modernized the experience for you to access, analyze, and visualize your data. New Relic One offers an improved charts and dashboards experience, and it provides a platform where we can more rapidly bring new innovations to you. This transition guide can help you understand: What are some of the new and improved features you get with New Relic One charts, dashboards, and queries Why it's easy to transition to New Relic One What to know and considerations when you make the switch How to get the most out of using New Relic One Steps for a successful transition The transition to New Relic One has two parts: the UI and mobile app experience (April 12, 2021) and the Dashboard API (July 2021). Insights functionality Transition to New Relic One UI We have already taken care of your transition from Insights to New Relic One for you! As of April 12, 2021, your old Insights web URLs redirect automatically to New Relic One. We recommend that you familiarize yourself with the new UI features available to you, as described in this transition guide. If you need to view any Insights charts embedded in other websites, go to one.newrelic.com > More > Manage Data. (These older embedded charts will continue to function as expected.) Mobile apps Your Insights mobile app is deprecated as of April 11, 2021. Go to the Google Play Store 2 or Apple App store. Delete your old Insights mobile app, and download the New Relic One mobile app. tvOS apps and large displays New Relic's tvOS app is still available. No action is needed by you at this time. Some New Relic customers with the original pricing model may have set up dashboards on wall screens for restricted users with kiosk mode. No action is required for you to continue to view these dashboards. APIs The Insights API to create dashboards will be deprecated and replaced with the new Dashboards API as of July 2021. We encourage you to start exploring the capabilities of the Dashboards API in NerdGraph now! You can continue to use your Insights insert API key with the Dashboards API, or you can create a new user API key. Every user who wants to query with the NerdGraph API will need their own user API key. The REST API for Insights queries is not affected by this change and will not be deprecated. For more information about which key to use with our APIs, see our documentation about API keys. Easily access your insert and query API keys by going to one.newrelic.com > More > Manage Insights Data> API Keys Partnership accounts This applies only if your account is one of the few using our partnership account structure to deliver New Relic services to your direct customers. In this situation, the Insights EOL will not affect your customers’ pricing. This is simply an EOL for the UI, not an EOL for the account type. Questions If you have questions about the transition, please comment in our Explorers Hub post. Or, if you work with an account team, they will be happy to help you. Get started with New Relic One New Relic One dashboards are an improvement to the Insights experience. New Relic One has all the dashboard and charting features that Insights has, and more! one.newrelic.com > Dashboards: New Relic One offers a better querying and charting experience than Insights. Switching to New Relic One is easy and seamless. All of the dashboards you previously created in Insights are automatically available in New Relic One. Query anything With New Relic One, you get: Better querying and charting experiences: Query access is available globally, no matter where you are in New Relic One. This includes a \"basic\" query mode that doesn't require knowledge of NRQL. Improved query experience: You can query both the Metric data type and metric timeslice data. Easy customization: Every visualization now has the query accessible. You can augment any curated chart just by changing the NRQL. Visualize more data Not only can you select a wide range of visualization options, you can also add more to your dashboards: Better display options: Make your data easier to understand by using visualizations other than dense, line-heavy charts. New Relic One also offers a better TV mode. More charts or widgets across dashboards: Insights restricted you to a 3-across limit. Now you can display up to 12 across your dashboard, providing increased data density along with improved tooltips and tracking across charts. Easier creation of multi-page dashboards: Insights referred to these as data apps. Your Insights data apps are preserved as multi-page dashboards in New Relic One. Chart consistency and flexibility: Dashboards include facet color consistency across widgets and faster loading times for more performant dashboards. Also, you can add any chart type to a dashboard in New Relic One! The New Relic Insights UI has served our users well for many years, but it's time to give you an even better experience. Join us and make the switch to New Relic One!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.48694,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "sections": "Transition to <em>New</em> <em>Relic</em> <em>One</em> from Insights",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " and considerations when you make the switch How to get the most out of using <em>New</em> <em>Relic</em> <em>One</em> Steps for a successful transition The transition to <em>New</em> <em>Relic</em> <em>One</em> has two parts: the UI and mobile app experience (April 12, 2021) and the Dashboard <em>API</em> (July 2021). Insights functionality Transition to <em>New</em>"
      },
      "id": "6044171164441f454a378ee2"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.532,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " a <em>New</em> <em>Relic</em>-monitored entity or data from another service or <em>API</em>. Get started Keep reading to learn more about what you can do with <em>New</em> <em>Relic</em> <em>One</em> apps. If you want to get started building quickly, first read the requirements. Tip To use our <em>developer</em> site and <em>New</em> <em>Relic</em> <em>One</em>, as well as the rest of our"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-16T22:12:16Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.00046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use the <em>API</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph <em>API</em> to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.99478,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.99245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " <em>Relic</em> Insightsを使用してダッシュボードを作成した場合、<em>New</em> <em>Relic</em> <em>One</em>ダッシュボードとして使用できます。 <em>New</em> <em>Relic</em> <em>One</em>で構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他の<em>New</em> <em>Relic</em>がモニターするデータとともに、<em>New</em> <em>Relic</em> <em>One</em>プラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 <em>New</em> <em>Relic</em>が監視するエンティティ、またはサービスや<em>API</em>からのデータなど、貴社が望むソースからのデータを"
      },
      "id": "6052b11f196a6772252d168c"
    }
  ],
  "/build-apps/custom-visualizations-and-the-new-relic-one-sdk": [
    {
      "sections": [
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "Tip",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs"
      ],
      "title": "Automate instrumentation",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "65d82617672b47497b59dcf7c55eaba535714676",
      "image": "https://docs.newrelic.com/static/82b9b43751f8e8c8dbf4be1242cc6cb3/c1b63/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation/",
      "published_at": "2021-04-16T10:15:36Z",
      "updated_at": "2021-03-16T10:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Tip Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.25957,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ". For example, the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "603ea2f7196a672323a83def"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.77335,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom New Relic <em>One</em> application ",
        "sections": "Build a custom New Relic <em>One</em> application",
        "tags": "New Relic <em>One</em>",
        "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic <em>One</em> platform, alongside your other dashboards and data. Feature <em>visualizations</em> that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-16T22:12:16Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.003876,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic <em>One</em>",
        "body": "To view workloads, go to <em>one</em>.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.00101,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic <em>One</em>",
        "body": "New Relic <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.99984,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "New Relic <em>One</em>で構築",
        "tags": "New Relic <em>One</em>",
        "body": "New Relic <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント New Relic <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    }
  ],
  "/build-apps/customize-visualizations-with-configuration": [
    {
      "sections": [
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "Tip",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs"
      ],
      "title": "Automate instrumentation",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "65d82617672b47497b59dcf7c55eaba535714676",
      "image": "https://docs.newrelic.com/static/82b9b43751f8e8c8dbf4be1242cc6cb3/c1b63/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation/",
      "published_at": "2021-04-16T10:15:36Z",
      "updated_at": "2021-03-16T10:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Tip Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.77087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ". For example, the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "603ea2f7196a672323a83def"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/1qf2g217c4q7m/promo-image.1608575584.png",
      "url": "https://learn.newrelic.com/getting-started-with-dashboards-nrql",
      "sections": [
        "Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations.",
        "About this workshop",
        "Getting started with Dashboards & NRQL"
      ],
      "published_at": "2021-04-20T01:39:15Z",
      "title": "[Webinar] Getting started with Dashboards & NRQL",
      "updated_at": "2021-04-20T01:39:15Z",
      "type": "",
      "external_id": "20be8b6c5a3882e951f9dfd70354ea7ceaa38c7c",
      "popularity": 1,
      "body": "Sign In [Webinar] Getting started with Dashboards & NRQL Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations. Register | FREE Already registered? Sign In About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.  These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.  Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.   In this hands-on session, you’ll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.  Using a sandbox account you’ll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.  Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL April 20, 2021, 1 p.m. - April 20, 2021, 3 p.m. BST 104 Getting started with Dashboards & NRQL May 6, 2021, noon - May 6, 2021, 2 p.m. PDT 148 Getting started with Dashboards & NRQL May 11, 2021, 1 p.m. - May 11, 2021, 3 p.m. BST 148 Getting started with Dashboards & NRQL June 8, 2021, 1 p.m. - June 8, 2021, 3 p.m. BST 150 Getting started with Dashboards & NRQL June 8, 2021, noon - June 8, 2021, 2 p.m. PDT 150 About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.  These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.  Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.   In this hands-on session, you’ll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.  Using a sandbox account you’ll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.  Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Live events Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL April 20, 2021, 1 p.m. - April 20, 2021, 3 p.m. BST 104 Getting started with Dashboards & NRQL May 6, 2021, noon - May 6, 2021, 2 p.m. PDT 148 Getting started with Dashboards & NRQL May 11, 2021, 1 p.m. - May 11, 2021, 3 p.m. BST 148 Getting started with Dashboards & NRQL June 8, 2021, 1 p.m. - June 8, 2021, 3 p.m. BST 150 Getting started with Dashboards & NRQL June 8, 2021, noon - June 8, 2021, 2 p.m. PDT 150 © 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.67432,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "[Webinar] Getting started with Dashboards &amp; <em>NRQL</em>",
        "sections": "Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of <em>NRQL</em>. Progress to working directly with <em>NRQL</em> to create a wider range of charts and <em>visualizations</em>.",
        "body": " registered? Sign In About this workshop New Relic <em>One</em> offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and <em>visualizations</em>.  These charts can be combined to create powerful dashboards to help you"
      },
      "id": "5fe29f8528ccbcf532f15668"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.64117,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom New Relic <em>One</em> application ",
        "sections": "Build a custom New Relic <em>One</em> application",
        "tags": "New Relic <em>One</em>",
        "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic <em>One</em> platform, alongside your other dashboards and data. Feature <em>visualizations</em> that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/cloud-migration-quickstart-2.png",
      "url": "https://newrelic.com/blog/how-to-relic/dashboards-and-custom-visualizations",
      "sections": [
        "Visualize your data from scratch or a quickstart",
        "Extend capabilities with the dashboards API and customizations UI",
        "Let’s build together"
      ],
      "published_at": "2021-04-16T04:27:09Z",
      "title": "New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil",
      "updated_at": "2021-04-13T23:29:41Z",
      "type": "",
      "external_id": "5d1ed7d2f89c24024b85aac381ce3940605bd0e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil Feb 25, 2021 • 4 min read By Sebastian Galiano Molina If you’re like most engineers, you may find yourself parsing through data from more sources than ever before. Chances are that you need a way to visualize and customize all the data to fit your organization’s needs, and report and efficiently communicate your analysis to different stakeholders. Starting from scratch isn’t the most efficient way. The good news is that you don’t have to start from scratch. As a New Relic One user, you can begin accessing new dashboards and custom visualization capabilities today that give you access to a library of dashboards, third-party custom visualization capabilities, and quickstart visualizations, based on common use cases in the New Relic One Catalog and the New Relic One Dashboard API. Visualize your data from scratch or a quickstart If you would like a custom visualization, you can create smaller-scale custom widgets and pin them to a dashboard. Is there a visualization you like in a popular JavaScript charting library like D3 or Recharts? You can now use it in your custom visualization connected to the data already in the Telemetry Data Platform. Are you looking for maps, heat maps, and traffic lights to visualize your system movements? We have you covered. Sample charts you can generate using the D3 or Recharts charting library.   To make it even easier to find the template you want, you can access a Quickstarts Library, a community repository of New Relic dashboards, alerts, and installation instructions. Deploy the app in your account to quickly find the template you want and start using it in your account. Best of all? We built this all in open source, which means you can provide feedback and suggestions on use cases you’re looking to solve. Create an issue or send a pull request—we’re building this library for you and your needs. Sample cloud migration quickstart. Extend capabilities with the dashboards API and customizations UI New Relic One dashboards provide custom visualizations that can be automated through templates and a full dashboard CRUD API, with custom chart widgets built with React.js, the ability to pull in third-party library widgets, and a library of templates to get started fast—and all of it in open source. With the recent customization updates, you can now quickly add widgets directly to dashboards simply by clicking “add to dashboards” in the Query Builder. You can also customize existing widgets to display data as you need it: Number and time formatter: Define decimals (e.g., number of 9s in your SLO) and formatting your dates and timestamps (e.g., US format or EU format) Customize y-axis: You can now define how you want your y-axis to behave by setting it to a specific value and ignore outliers Customize y-axis min/max   Format date and time to fit your needs.   Format numbers to appropriate decimal places for more precision.   As a busy engineer, reducing toil is a must. You can use the API to deploy a standard set of dashboards for every new service you create. And if you need inspiration, a large inventory of pre-built custom dashboards reflect observability best practices. You’ll find a range of subject areas, including infrastructure monitoring, cloud, browser, and mobile monitoring. Let’s build together We designed these new capabilities to help you innovate. We’re continuously listening to your feedback and adding more templates, resources, and visualizations to our libraries. Because we’re invested in working in the “open source way” and providing you transparency, our visualization builder pulls from the open source ecosystem, so you can visualize data in any way that you prefer. If you have feedback or suggestions, please feel free to submit it through New Relic One. We’re building an extensive library and we encourage you to join us. Check out developer.newrelic.com to learn more. By Sebastian Galiano Molina Sebastian Galiano Molina is a Senior Product Manager Data Visualization, Data Exploration and Dashboards at New Relic, based in Barcelona. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.58737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic Dashboards and Custom <em>Visualizations</em>: Flexibility with Less Toil",
        "sections": "<em>Visualize</em> your data from scratch or a quickstart",
        "body": " is that you don’t have to start from scratch. As a New Relic <em>One</em> user, you can begin accessing new dashboards and custom visualization capabilities today that give you access to a library of dashboards, third-party custom visualization capabilities, and quickstart <em>visualizations</em>, based on common use"
      },
      "id": "60762965196a677f8464a77b"
    },
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "A more consistent and unified platform",
        "Quickly understand context",
        "Know your relationships and dependencies",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "What’s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-16T22:11:14Z",
      "updated_at": "2021-03-30T13:06:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence functionality. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip To use New Relic One and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. A more consistent and unified platform Before our release of New Relic One, our platform was separated into various products, like APM, Browser, and Mobile. With our move to New Relic One, you can view and interact with all the data from across your entire system more easily. For more information, see our New Relic One transition guide. Quickly understand context New Relic One gives you and your teams a connected view that cuts through complexity and allows you to: Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities in your system. The New Relic Navigator gives you a high density overview of all your entities so you can detect any issues at a glance. And the New Relic Lookout shows entities recently experiencing behavior deviations. Organize your environments and manage data more effectively with tags. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. View everything you’re monitoring in one place, like entities or dashboards across your organization. Cross-account access brings all types of data together while still making everything easy to find. Group any entities together into functional team-focused or project-focused groupings with workloads. Tailor custom dashboards for your unique needs. Create visuals that showcase your business needs at a glance, and make the most of your expertise. Get more context while you query with the query builder which surfaces data definitions as you craft and edit queries. Know your relationships and dependencies We provide multiple ways to understand dependencies, so you can easily see how everything fits together and troubleshoot problems. If you want to... Use this Have an overall view of your system, and drill down to get performance details. The New Relic Explorer gives you context to the performance data from all your monitored applications, services, hosts, or containers. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Organize everything you monitor and provide context for your entities. Add tags to all your entities. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity you’re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Know which teams are responsible for specific entities across your organization. Create tags for teams and all the services they monitor. Query your data more easily At the top of all UI pages, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the NRQL mode query builder. Run PromQL-style queries in the query builder. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. What’s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.30034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>One</em>",
        "sections": "Introduction to New Relic <em>One</em>",
        "tags": "New Relic <em>One</em>",
        "body": " with dashboards in New Relic <em>One</em>. New Relic <em>One</em> dashboards let you build better <em>visualizations</em> more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards"
      },
      "id": "603ec19164441f9e704e8896"
    }
  ],
  "/build-apps/ab-test/third-party-service": [
    {
      "image": "https://docs.newrelic.com/static/1dacbe14521cd094da4f9ce4912e24a5/ae694/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/2020/10/store-data-encrypted-storage-solution-nerdstoragevault/",
      "sections": [
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "published_at": "2021-04-16T19:42:55Z",
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "updated_at": "2021-03-11T00:18:44Z",
      "type": "docs",
      "external_id": "de67c202e7343347b2a6b5bc615301b9fac1e524",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.04403,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store <em>data</em> in <em>an</em> encrypted storage solution with NerdStorageVault",
        "sections": "Store <em>data</em> in <em>an</em> encrypted storage solution with NerdStorageVault",
        "body": "NerdGraph allows you to access your New Relic <em>data</em>, but when you want to <em>fetch</em> <em>third</em>-<em>party</em> <em>data</em>, NerdStorageVault allows you to safely store a secret to authenticate with a <em>third</em>-<em>party</em> <em>service</em>. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store"
      },
      "id": "6044694a64441fb9b2378f2d"
    },
    {
      "sections": [
        "PHP agent not reporting errors",
        "Problem",
        "Solution",
        "Cause",
        "For more help"
      ],
      "title": "PHP agent not reporting errors",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Troubleshooting"
      ],
      "external_id": "320f6c881ef688a15d6a6d90d0adf83ea4119835",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/troubleshooting/php-agent-not-reporting-errors/",
      "published_at": "2021-04-16T07:13:47Z",
      "updated_at": "2021-04-16T07:13:46Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem Errors in your application aren't reported or captured by the PHP agent as expected. Solution If you are using a third party error handler (for example: XDebug or Laravel's error handler): Disable the third party error handler. Confirm the errors are reporting by viewing the APM errors page. If you are not using a third party error handler, but you still do not see expected errors (for example: 404 errors): Ensure PHP is handling the error, because New Relic cannot report errors that are not recognized by PHP (such as 404 errors for static assets on the web server). Manually instrument the error you are expecting to see by using the newrelic_notice_error() API call. Confirm the errors are reporting by viewing the APM errors page. Cause PHP handles errors with its own default handler. Many third party handlers, such as XDebug or Laravel's error handler, often override PHP's default handler and capture the error instead of PHP. The PHP agent has its own error handler that relies on PHP capturing the error. Since only one handler can handle an error, the agent does not see errors that were already handled by the third party handler before it could get captured by PHP. Additionally, some errors (for example: 404 errors) often occur at the web server level, which means that PHP is never involved and the error is never captured by the agent. If PHP is used to handle 404 errors, use the newrelic_notice_error() API call to manually instrument those errors. For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.77652,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP <em>agent</em> not reporting errors",
        "sections": "PHP <em>agent</em> not reporting errors",
        "tags": "<em>Agents</em>",
        "body": "Problem Errors in your application aren&#x27;t reported or captured by the PHP agent as expected. Solution If you are using a <em>third</em> <em>party</em> error handler (for example: XDebug or Laravel&#x27;s error handler): Disable the <em>third</em> <em>party</em> error handler. Confirm the errors are reporting by viewing the APM errors page"
      },
      "id": "603e8eef28ccbc6a8eeba761"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programability_browser_analyze_1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-developers-guide-roundup",
      "sections": [
        "Intro to New Relic One SDK",
        "New Relic One CLI",
        "Intro to NerdStorageVault - New Feature!",
        "Create a \"Hello, World\" app",
        "Practice diagnosing common issues using New Relic",
        "Get coding and get inspired",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:23:24Z",
      "title": "New Relic Developers Guide Roundup",
      "updated_at": "2021-04-13T23:23:31Z",
      "type": "",
      "external_id": "9322d4fbb3dbbeb84cc7c3f26c9cc2c275e3a11d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Relic Developers Guide Roundup Jan 5, 2021 • 7 min read By Vi Tran When we first launched our programmable platform, one of our executives envisioned a simple way to visualize customer experience and satisfaction scores. He sent the following sketch to an engineer: Two days later, he had a production-ready application, built on New Relic One, that showed not just what the customer experience scores were, but what they should be. The browser analyzer application This New Relic One application is called the browser analyzer—it’s open source and available for you to use today. But now it’s your turn to go from sketch to app. We’ve given you the same tools our own engineers use, so you can build and deploy applications in New Relic One that connect your observability data, gathered from myriad sources—including third-party open source data—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK The New Relic One SDK provides the necessary components you need to build New Relic One applications. Components of the SDK include: React UI components for controlling text and layout in a New Relic One application Chart components for representing different types of charts Query and storage components for fetching and storing New Relic data Platform APIs that enable your application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build your applications, create visualizations, and fetch New Relic or third-party data. New Relic One CLI In addition to the SDK, you’ll need the New Relic One CLI to build apps on the platform. You’ll use the CLI to build, publish, and manage your app. More specifically, you’ll use the CLI to do the following: Generate Nerdpack/Nerdlet templates—(a Nerdpack is a package containing all the files needed by an application; a Nerdlet is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Intro to NerdStorageVault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store your data. NerdStorageVault lets you store and retrieve sensitive data secrets such as: Personal access tokens License keys API keys Other third-party secrets You can explore NerdStorageVault fields and response types with the NerdGraph API explorer. NerdStorageVault is encrypted with AES-256 encryption. In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes. Check out the guide for more information. Create a \"Hello, World\" app In this guide, you’ll build a \"Hello, World!\" application in New Relic One in nine quick steps. You’ll create a local version of the New Relic One site where you can prototype your application, and when you're ready to share the application with others, you can publish it to New Relic One. [embed]https://www.youtube.com/watch?v=7omo0qHxku8&feature=youtu.be[/embed] To get started, make sure you have accounts in GitHub and New Relic. You’ll also need to install Node.js and familiarize yourself with the New Relic One CLI. Tip: Check out Set up your development environment to make sure you have everything in order before you jump in. Practice diagnosing common issues using New Relic Every time you deploy an application, you hope that it's efficient and free of errors. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled demo environment. Acme Telco Lite is a telecom business that maintains an e-commerce website for its customers. The site's architecture has eight interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. Check out the full guide for more on prerequisites and deployment details. Get coding and get inspired Explore more guides and tutorials on New Relic Developers, because we’re constantly adding content. Best of all? The site is built completely in open source—feel free to submit a pull request while you’re there. Related Topics Extend New Relic By Vi Tran Vi Tran is a Senior Product Marketing Manager for Developer Ecosystem at New Relic. Her focus is on growing and enabling the developer ecosystem to extend New Relic One. Before New Relic, she was on the global strategic alliances team at Splunk and was a management consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.67417,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create <em>a</em> &quot;Hello, World&quot; <em>app</em>",
        "body": ", gathered <em>from</em> myriad sources—including <em>third</em>-<em>party</em> open source <em>data</em>—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK"
      },
      "id": "607627f464441f7e2b9d8537"
    },
    {
      "sections": [
        "Introduction to on-host integrations",
        "Tip",
        "Get started",
        "Features",
        "Monitor remote and multi-tenant configurations"
      ],
      "title": "Introduction to on-host integrations",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "Get started"
      ],
      "external_id": "0e84cd158def0d2b748d2a54a0716f9820691f0d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/get-started/introduction-host-integrations/",
      "published_at": "2021-04-16T16:38:06Z",
      "updated_at": "2021-03-13T02:07:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic infrastructure integrations allow you to send data from popular products and services to New Relic. You can select from our list of available on-host integrations to collect and send data to our platform. Tip To use on-host integrations and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Get started To get started with on-host integrations: Browse the lists of on-host integrations. If you do not already have New Relic infrastructure monitoring enabled, install the infrastructure agent. Follow the procedures to install and configure the selected on-host integration, including prerequisites for compatibility and other requirements. If we don't currently offer an integration for a service you use, consider creating your own integration with Flex. Features After you install and activate an integration, you will be able to: Filter and analyze the metrics and configuration data in Infrastructure UI. Create custom queries and charts of your integration data. Create alert conditions to monitor problems with your services' performance in New Relic's alerts. Monitor remote and multi-tenant configurations Some configurations may use third party elements, such as databases, which reside in non-accessible, remote hosts. Our integrations can fetch data from local and remote hosts or servers, ensuring a continuous monitoring of your service. They also support multi-tenant clustered configurations—by abstracting the service from the host, multiple entities can be monitored as remote instances. You can activate remote monitoring and multi-tenancy in the Apache, Cassandra, MySQL, NGINX, and Redis integrations with the remote_monitoring parameter.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.04057,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Monitor remote <em>and</em> multi-tenant configurations",
        "body": " Relic&#x27;s alerts. Monitor remote and multi-tenant configurations Some configurations may use <em>third</em> <em>party</em> elements, such as databases, which reside in non-accessible, remote hosts. Our integrations can <em>fetch</em> <em>data</em> <em>from</em> local and remote hosts or servers, ensuring a continuous monitoring of your <em>service</em>"
      },
      "id": "6044e41ce7b9d2ad305799ef"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/iOS-9-chart.jpg",
      "url": "https://newrelic.com/blog/best-practices/ios9-background-execution",
      "sections": [
        "Understanding iOS app execution states",
        "Downloading and uploading in the background with NSURLSession",
        "Downloading remote content opportunistically",
        "App termination special cases",
        "Takeaways",
        "Additional Resources",
        "Related Topics"
      ],
      "published_at": "2021-04-16T01:40:18Z",
      "title": "Introduction to iOS 9 Background Execution and Fetch",
      "updated_at": "2021-04-14T02:13:29Z",
      "type": "",
      "external_id": "962ca0846078d4d56fe29be2bf1514cc4ecd8333",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit DevOps Introduction to iOS 9 Background Execution and Fetch Jan 13, 2016 • 10 min read By Clay Smith For iOS 9 apps that depend on real-time information, location services, or communication with external devices, developers can use background execution to improve user experience by allowing the app to perform tasks even when the app isn’t in the foreground. Performing network requests in the background can be especially helpful when downloading or uploading large amounts of data. iOS restricts apps from running indefinitely in the background, and for good reasons. If an app isn't active, then it shouldn't be allowed to use an unreasonable amount of system resources, especially when it comes to data transfer. But as apps have become more connected to backend services, fetching data in the background has become more important for a good user experience. Unfortunately, it isn’t always clear what’s the best way to implement background network requests. The latest iOS SDK provides multiple options, and familiarity with different background fetch APIs is useful when deciding which technique to use. Because runaway background tasks can result in a massive drain on device battery life and difficult-to-reproduce behavior, correct implementation of iOS background execution APIs is important. This post offers an introduction to the issues, and examines some common pitfalls. Understanding iOS app execution states Most iOS users are familiar with the multitasking UI in iOS 9, which brings up a list of recently used apps when you double-tap the Home button. Swiping up on an app will then cause the operating system to force quit that app. However, apps displayed in the multitasking UI aren't necessarily executing code or fetching data. Listed apps may be suspended or not running at all (a fact that has long confused iOS users in search of a trick to prolong battery life). iOS 9 Multitasking Interface   Using Swift, the current execution state of an app is available from UIApplication.sharedApplication().applicationState If the state is active, the application is visible on the screen and ready to receive events. When it’s not visible the app can be in the background or inactive. Apple has a nice diagram of all of the states on its developer site. Most developers respond to state changes using delegate methods on UIApplication or a dozen-plus notification types that are posted. The Xcode 7 iOS template includes these delegate methods for responding to changes: // App is almost ready to run func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool // App is going from active to inactive func applicationWillResignActive(application: UIApplication) // Background mode was just activated func applicationDidEnterBackground(application: UIApplication) // App is now visible and ready to receive UI events func applicationDidBecomeActive(application: UIApplication) // App is about to terminate func applicationWillTerminate(application: UIApplication) Nothing exciting happens by default when the application enters the background—it’s merely a brief transition the app passes through on the way to being suspended. Background state can even be disabled (although that is discouraged by Apple). While there are several different use cases for background execution, including communication with Bluetooth devices and playing audio, many apps use background execution for downloading remote content. Downloading and uploading in the background with NSURLSession When an app is working with data that needs to be uploaded or downloaded, the operation should ideally continue if the user sends a text message or switches to a different app. Fortunately, the NSURLSession class can hand off downloads and uploads to the operating system when the app becomes inactive. As with almost all background execution APIs, if the user force quits from the multitasking UI, the background operation will terminate. (Note that if an app is tracking location and is force quit by the user, it will be relaunched.) Enabling NSURLSession to be background-capable requires instantiating a NSURLSessionConfiguration object with the background initializer and an identifier that’s reused for all background sessions: let sessionConfig = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier(\"com.newrelic.bgt\") If an app is especially polite, there is a flag on NSURLSessionConfiguation called “discretionary” that allows iOS to optimize the request for performance, so in certain situations (like a bad connection with a low battery) the request never actually occurs. backgroundSessionConfig.discretionary = true As long as the app is making an HTTP or HTTPS request, a NSURLSession needs to be instantiated with the configuration object and a delegate to receive notifications when a download or upload completes. There are a few other limitations outlined here: let session = NSURLSession(configuration: backgroundSessionConfig, delegate: self, delegateQueue: NSOperationQueue.mainQueue()) To download a static PDF file, for example, the session with the background configuration can then be used in a standard download task: let downloadTask = session.downloadTaskWithURL(NSURL(string: \"https://try.newrelic.com/rs/newrelic/images/nr_getting_started_guide.pdf\")!) downloadTask.resume() The NSURLSession delegate methods get called when the operation is complete or if it had errors. There will be a path to a temporary file on-disk that can be opened for reading or moving to another location. One last thing about NSURLSession: it has supported HTTP/2 since iOS 9. More details on using the API are available on Apple’s developer site. Downloading remote content opportunistically In iOS 7, Apple added support for background fetch—a kind of smart, per-app crontab that wakes up at opportunistic times. There is no way to force background fetches to execute at exact intervals. iOS checks how much data and battery power was used during previous background fetches when scheduling future callbacks. Adding support involves editing your application’s property list (see UIBackgroundModes) and setting a fetch interval early in the app lifecycle: application.setMinimumBackgroundFetchInterval(UIApplicationBackgroundFetchIntervalMinimum) This UIApplicationDelegate method gets called when iOS decides a background fetch can happen: func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: (UIBackgroundFetchResult) -> Void) The method has approximately 30 seconds to return a UIBackgroundFetchResult to the completionHandler function before the app is terminated. The value of UIBackgroundFetchResult is used to determine when the background fetch delegate method gets called again. If there’s frequently data at a particular time (for example, in the early morning for a news app), this helps iOS know when to execute the background fetch: enum UIBackgroundFetchResult : UInt { case NewData case NoData case Failed} Background fetches can also be triggered by remote push notification and have a very similar delegate method with the same completion handler. To test a background fetch event in the iOS Simulator, Xcode has a “Launch due to background fetch event” toggle under options in the Scheme editor and a “Simulate Background Fetch” item under the debug menu. It will invoke the performFetchWithCompletionHandler method as shown here: Enabling “Launch due to background fetch event” in Xcode.   As of early 2016, developers noted issues with using the iOS simulator to test background fetch, so testing on real devices with a clean install of the app is preferred. Additionally, the Xcode debugger changes how the operating system suspends the app and may also cause issues when testing inactive states. Testing on a device without the debugger attached (exactly as your users would interact with your app) is sometimes the only way to reliably reproduce certain states. App termination special cases The user force quitting from the multitasking UI can be the source of unreproducible crashes. It’s possible for an app to be killed without any notification at all. For example, if the app is suspended and the operating system terminates it due to low memory, no notification will be sent. Only when iOS wants to terminate an app that is not suspended and in the background state will applicationWillTerminate be called. Different ways an app can be terminated in iOS 9.   In iOS 9, apps should not depend on applicationWillTerminate: being called. It’s better to save state and perform cleanup in applicationDidEnterBackground:. However, it’s important to clean up and stop any background tasks that are running if applicationWillTerminate is signaled, as there may be a crash if iOS has to force kill the running background task. This is sometimes a source of difficult-to-reproduce bugs. For performance and battery life reasons, iOS limits the amount of time in the background. The amount of time remaining in the background execution state is available from UIApplication.sharedApplication().backgroundTimeRemaining The amount of backgroundTimeRemaining reported isn’t always guaranteed. Force quitting will stop any background tasks, regardless of how much time is left. Assumptions about execution state delegate methods always getting called (or even that they will be called in a particular order) may not be borne out in the real world. Carefully audit any code that assumes one execution state will always occur before another state. Takeaways When writing iOS code that executes in the background: Determine which background execution API to use. For network requests that take many seconds to complete, NSURLSession is useful. Using opportunistic background fetch provided by iOS to trigger the background fetch delegate is useful for apps that need content on a schedule. Remote push notifications can be an effective mechanism to trigger background code and fetches. Log execution state changes, test on real devices with and without the debugger attached, and beware of simulator quirks. Using an open-source iOS logging library like CocoaLumberjack or XCGLogger can be helpful. Beware of accessing the Keychain or using the iOS Data Protection feature. Background execution can happen when the phone is locked behind a passcode, which can cause issues when reading and writing to protected resources. Performant background code is important: iOS prioritizes the app in the foreground and strictly limits the resources and time an app has to complete background tasks. With rising mobile data usage and new iOS 9 features like split-view multitasking on iPads, managing app execution state is important to build quality apps—a constant progress indicator when an app opens is guaranteed to annoy users. Background execution and fetch is Apple’s compromise with developers designed to balance customer experience with legitimate concerns about battery drain and high network latency on data networks. Utilizing background fetch APIs to keep information up-to-date and taking care to avoid common pitfalls helps meet customer expectations that apps are always fast, relevant, and never crash. Additional Resources Apple Developer Documentation: Background Execution io Article on iOS 7 Multitasking Apple Developer Documentation: Using NSURLSession Background Modes in Swift Tutorial Apple Insider: Stop Force Closing Apps on Your Phone Bryce Buchanan, an iOS engineer on New Relic’s Mobile team, contributed to this post with a technical review and invaluable suggestions.   Background image courtesy of Shutterstock.com. Related Topics DevOps By Clay Smith Clay Smith is a Developer Advocate at New Relic in San Francisco. He previously has worked at early stage software companies as a senior software engineer, including founding the mobile engineering team at PagerDuty and shipping one of the first iOS apps written in Swift. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.90053,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to iOS 9 Background Execution <em>and</em> <em>Fetch</em>",
        "sections": "Understanding iOS <em>app</em> execution states",
        "body": " devices, developers can use background execution to improve user experience by allowing the app to perform tasks even when the app isn’t in the foreground. Performing network requests in the background can be especially helpful when downloading or uploading large amounts of <em>data</em>. iOS restricts apps <em>from</em>"
      },
      "id": "60764fc9e7b9d227aaa5c63f"
    }
  ],
  "/build-apps/ab-test/chart-headings": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-guidelines/levels-headings/",
      "sections": [
        "Levels of headings",
        "Use parallel construction",
        "Keep it short, avoid -ing words",
        "Do not use h1 headings",
        "Use level two headings to identify chunks of information",
        "Important",
        "Avoid using level three headings"
      ],
      "published_at": "2021-04-16T06:43:56Z",
      "title": "Levels of headings",
      "updated_at": "2021-03-16T13:09:18Z",
      "type": "docs",
      "external_id": "981282f676b2697e24f69ad23bce7e3412bb1d22",
      "document_type": "page",
      "popularity": 1,
      "body": "Taking some time to consider your headings and document titles will be time well spent. Titles and headings are not only important for search results, but they can make your docs easier to skim. For all headings and document titles, use sentence case. Use parallel construction Use parallel construction when naming headers. For example, use all nouns (\"Organization,\" \"Tone\"), all verbs (\"Create,\" \"Delete\"), etc. Keep it short, avoid -ing words For all headers, keep the title as short as possible. In particular, avoid headers that are more than a line long. As with all our writing, you should feel free to address the reader directly: Install the agent, for example, rather than Agent installation. You should also avoid -ing words, which add to character count without contributing clarity. Do not use h1 headings After you publish your doc, the Docs site will automatically use what you added to the Title field as the doc's level one heading (h1). To ensure that your doc is properly indexed for search, do not manually create additional h1 headings. If your doc's title is long and you would like a shorter title to appear in the sidebar menu, create a GitHub issue and we'll help you with that change. Use level two headings to identify chunks of information Organize chunks of information into sections with level two headings (##). For example: ## Create a new user [#create-new-user] Copy Important If you don't specify an ID manually, the site will use your header text as that header's ID. Create a manual ID to preserve links to that header if you change the header text. If you have too many level sections, consider splitting the document into multiple pages. Avoid using level three headings Avoid using ### headings unless it makes sense for the content or if the content is lengthy. Collapsers, tables, and other structural elements are often a better choice. Be particularly careful about level three headings that make a level two section longer than a single screen height. Here are two examples of good scenarios for using level three headings: Example #1: Events-to-metrics API doc Example #2: Infrastructure integration doc",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.01845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Levels of <em>headings</em>",
        "sections": "Levels of <em>headings</em>",
        "body": " feel free to address the reader directly: Install the agent, for example, rather than Agent installation. You should also avoid -ing words, which <em>add</em> to character count without contributing clarity. Do not use h1 <em>headings</em> After you publish your doc, the Docs site will automatically use what you added"
      },
      "id": "604221d3196a677e3aa83db4"
    },
    {
      "sections": [
        "Capitalization",
        "Use sentence case in headings",
        "Products and features",
        "UI elements and UI page paths",
        "Watermarks"
      ],
      "title": "Capitalization",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "7a4d6c67e7c4737414cc99d452577f79dfc79ffc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/quick-reference/capitalization/",
      "published_at": "2021-04-16T05:17:16Z",
      "updated_at": "2021-03-16T09:10:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In general, we only capitalize things when we need to. Read on for some guidelines on how to decide what to capitalize in a document's title, headings, products, features, and other elements of the page. Use sentence case in headings Use sentence case for headings. This includes category headings and document titles. With sentence case, capitalize only the first letter of: The first word Proper nouns Acronyms and abbreviations We have some exceptions: If the heading is a code term, such as a variable or function, then capitalize it exactly as it's used in the code; for example: noticeError. If the heading includes a colon, follow the Microsoft Style Guide for titles and headings, and capitalize the first word that appears after the colon; for example: APM Error profiles: Troubleshoot trends. Products and features Item Example We use title case for products. New Relic Infrastructure We don't capitalize features. \"Use transaction traces to...\" not \"Use Transaction Traces to...\" UI elements and UI page paths Item Example We use sentence case and bold for UI elements, even if the UI element is in a different case in the UI. \"From the Transactions page, select Transaction traces and...\" We use sentence case and bold for each element in a path that references UI pages. Go to one.newrelic.com > APM > Transactions > Transaction traces > (select a trace) > Another thing. Watermarks Item Example We use all caps for BETA or NR ONLY. <div id=\"watermark\">NR ONLY</div> Copy Otherwise use sentence case. <div id=\"watermark\">Legacy</div> Copy Include break (br /) for longer watermarks. <div id=\"watermark\">Limited <br /> release</div> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.25397,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use sentence case in <em>headings</em>",
        "body": "In general, we only capitalize things when we need to. Read on for some guidelines on how to decide what to capitalize in a document&#x27;s title, <em>headings</em>, products, features, and other elements of the page. Use sentence case in <em>headings</em> Use sentence case for <em>headings</em>. This includes category <em>headings</em>"
      },
      "id": "60421e50196a67d785a83d97"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Delayed-Jobs-New-Relic-1024x837.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/monitoring-delayedjob",
      "sections": [
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "Monitoring DelayedJob",
      "updated_at": "2021-04-14T00:06:04Z",
      "type": "",
      "external_id": "2e9c1f784c773aa1fa509a112bcd338cac37c70e",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit APM Monitoring DelayedJob Sep 12, 2012 • 6 min read By Bill Kayser Like many Ruby shops we use the DelayedJob job runner to run many of our background tasks. The New Relic agent has had some basic DelayedJob instrumentation for a while now but until recently you were limited to a few metrics which could only be viewed using the somewhat limited and unwieldy custom charts. But no longer! In the latest release of the Ruby Agent we are sending much richer, useful metrics for DelayedJob workers, and the recently released Custom Dashboards allows you to to build a truly useful view for monitoring and troubleshooting your jobs. Here's what it looks like: This is a Custom Dashboard we built for our DelayedJobs workers running in production. Below, I'll show you the steps to create this in your own New Relic account. But first let me explain what we are looking at. There are four graphs with data reported by the agent running in the DelayedJob worker. Job Queue Length shows the number of jobs waiting to be executed at any given time, based on one minute samples. We break out these numbers by priority since we manage separate workers in three different priority levels. In the graph above, you can see that our highest priority worker maintains a pretty healthy queue while we get a few spikes in our low priority worker every now and then, since the jobs in the low priority queue tend to run a little longer. In our configuration, we destroy jobs when they've run successfully and leave the failed ones. The agent polls the failed jobs and reports the count which we graph in the Failed Jobs chart. We pay particular attention to this chart during a deploy to look for any jump in failing jobs caused by a regression. Locked Jobs is particularly interesting. Jobs are locked while executing, so the number of jobs locked at any given time should not exceed the number of workers. With idle workers, the count will be low. With workers fully utilized, the number will approach the total number of workers. We find you do have to be careful as some jobs occasionally fail without clearing their lock, so you have to manually clear those out. But you can use the Locked Jobs graph as a gauge of your overall worker utilization. The Average Job Execution time graph is simply a graph of the average response time of the DelayedJob transactions. Creating a Custom Dashboard for DelayedJobs Let's walk through the steps to get this set up in a typical account. The first thing you need is the current version of the Ruby Agent gem. You must be running at least version 3.4.2. Then follow these steps in the New Relic application: 1) Select the application where DelayedJob is running. In our case it's \"Background Jobs\". 2) From the Custom Dashboards menu choose Create custom dashboard. Enter the title and \"Grid\" chart type. 3) Choose Add chart to add the first chart to your dashboard.  Fill in the basic properties, including the titles and chart type, which is \"Stacked Area.\" 4) Select the DelayedJob queue lengths for the graph. Start typing in Workers/. Initially it will say the metric doesn't exist, but when you enter the slash it will display the list of available metrics in the Workers namespace. Keep typing Workers/DelayedJob/queue_length/priority/*.  The metrics will auto-complete as you enter each segment. The asterisk at the end indicates that you want to break down the graph by priority. If you don't use priorities you can chart a single line for the queue length using the metric name Workers/DelayedJob/queue_length/all. 5. That's generally good enough to display the chart, but there are a couple of other properties you can customize. In our case, we removed the limit on the number of different priorities it will show, added \"jobs\" to the y-axis labels, and fixed the application to \"RPM Background\" where the DelayedJob agent reports to. Here's what it looks like: 6. Add the Failed Jobs chart. Repeat steps 3 - 5 but enter the metric for tracking failed jobs: Workers/DelayedJob/failed_jobs. 7. Add the Locked Jobs chart. Repeat steps 3 - 5 but enter the metric for tracking locked jobs: Workers/DelayedJob/locked_jobs. 8. Add the Job Execution Time chart. Repeat steps 3 - 5 but enter the metric for the response time of delayed jobs:  OtherTransaction/DelayedJob/all. We show execution time in milliseconds so we chose To Milliseconds for the Number Format and \"ms\" as the y-axis unit label. We also hide the legend. That's enough to get you started with a good dashboard for monitoring your DelayedJob workers. But you don't have to stop there. You can add a table showing you the summary metrics for each job or a breakdown chart of all the jobs. In addition to showing the response time of jobs, you could chart the throughput. We combine our staging and production servers onto one dashboard by duplicating the charts and picking a different application. Custom Dashboards now makes it easy to configure the charts for the exact data you want to display. If you haven't already, try New Relic today to see how you can improve the performance of your Ruby applications. And as always, we welcome your feedback on this post. Let us know what you think of Custom Dashboards and how you're using them to monitor your applications. Related Topics APM By Bill Kayser Bill has been with New Relic from the beginning as both a developer and a data scientist. Having worked in application performance management for nearly two decades, his role now entails discovering new ways of exploring and interpreting data as well as prototyping innovative new features. Follow the author Bill Kayser on Twitter Bill Kayser on GitHub Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.43854,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " in the New Relic application: 1) Select the application where DelayedJob is running. In our case it&#x27;s &quot;Background Jobs&quot;. 2) From the Custom Dashboards menu choose Create custom dashboard. Enter the title and &quot;Grid&quot; <em>chart</em> type. 3) Choose <em>Add</em> <em>chart</em> to <em>add</em> the first <em>chart</em> to your dashboard.  Fill"
      },
      "id": "607631ece7b9d201aea5c63a"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/server-overview-dashboard.png",
      "url": "https://newrelic.com/blog/how-to-relic/server-overview-dashboard",
      "sections": [
        "Building a Server Overview dashboard",
        "Creating custom dashboards is easy"
      ],
      "published_at": "2021-04-16T04:25:53Z",
      "title": "How to Create a Server Overview Dashboard in New Relic Insights",
      "updated_at": "2021-04-14T02:02:40Z",
      "type": "",
      "external_id": "a682a93ac23e587fc70b52a65c2440851f9214aa",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic How to Create a Server Overview Dashboard in New Relic Insights Aug 10, 2017 • 7 min read By Phil Weber New Relic Infrastructure gives you real-time, searchable, filterable visibility across your entire infrastructure. But what if you want to view key metrics about a server on a single dashboard? Thanks to New Relic Insights, you can! Because Infrastructure stores its data in the New Relic Database (NRDB, the same data store used by Insights), it’s easy to create a Server Overview dashboard. In this post I’d like to walk you through how it’s done. Building a Server Overview dashboard First, log into your New Relic account and navigate to Infrastructure’s Compute page: If you look closely above each chart, you’ll notice a small icon that resembles a chart on an easel: Click this icon to open the chart’s underlying NRQL query in Insights: From here, you can customize the query, give the chart a title, and add it to a dashboard. The NRQL AS clause allows you to customize the label of a query attribute. Let’s add some AS clauses to make the chart legend easier to read. Change the NRQL query to SELECT average(cpuSystemPercent) AS 'CPU System %', average(cpuIOWaitPercent) AS 'CPU I/O Wait %', average(cpuUserPercent)   AS 'CPU User %', average(cpuStealPercent) AS 'CPU Steal %' FROM SystemSample SINCE 60 minutes ago TIMESERIES Click the Run button to execute the query. Give the resulting chart a title, such as “CPU Usage,” and click Add to a Dashboard. In the Add to a Dashboard dialog, select Add to a new dashboard and give your new dashboard a name, such as “Server Overview.” Now go back to Infrastructure and repeat the process for the Load and Memory charts. Infrastructure draws a custom chart to display Used and Available memory as a stacked-area chart. Unfortunately, it is not possible to replicate this chart in Insights. Instead, change the NRQL query to SELECT average(memoryUsedBytes / memoryTotalBytes * 100) AS 'Percent Used', 100 AS 'Max' FROM SystemSample SINCE 60 minutes ago TIMESERIES The SELECT...100 AS 'Max' clause forces the Y-axis to a scale of 0 to 100, allowing us to display the memory used as an easy-to-read percentage. From Infrastructure’s Storage page, change the chart to display Total Utilization %, view the query in Insights, and change it to SELECT average(totalUtilizationPercent) FROM StorageSample FACET entityAndMountPoint SINCE 60 minutes ago TIMESERIES To display network throughput, use the following query: SELECT average(transmitBytesPerSecond / 1024) AS 'Transmitted', average(receiveBytesPerSecond / 1024) AS 'Received' FROM NetworkSample SINCE 60 minutes ago TIMESERIES It can be helpful to see which processes are running on a server, in case one of them is consuming a large amount of CPU or memory, for example. You can use the following query to display a list of running processes, the name of the user who started each process, and how much CPU and memory each process is using: SELECT uniqueCount(processId), latest(userName),   average(cpuPercent) AS 'CPU Percent', average(memoryResidentSizeBytes) / 1024 AS 'Memory (MB)' FROM ProcessSample FACET processDisplayName SINCE 1 hour ago New Relic Infrastructure captures information about system events, such as user logins, package deployments, etc. Let’s add a widget to our dashboard to display recent events: SELECT * FROM InfrastructureEvent SINCE 1 day ago Finally, we need a way to select an individual host, so we can see an overview of a single server. Let’s add a table based on the following query: SELECT average(cpuPercent) AS 'CPU %', average(memoryUsedBytes / memoryTotalBytes) * 100 AS 'Memory Used %' FROM SystemSample FACET hostname SINCE 5 minutes ago LIMIT 10 That query displays the Top 10 host names reporting to your account, in order of CPU usage. After adding the above table to your dashboard, click the ellipsis icon in the upper-right corner of the chart widget and select Edit link: In the resulting Link to dashboard dialog, link the widget to the Current dashboard and save your changes. Now you can select a host name from the table to filter the dashboard to that host: To view the information for a host that’s not included in the Top 10, click in the Search hostname field at the top of the page and select the desired hostname. Creating custom dashboards is easy Pulling key server metrics into a single dashboard takes just a few minutes; now you can easily see the status of an individual server at a glance. Because New Relic Infrastructure stores its data in NRDB, it’s easy to export and customize charts from Infrastructure to Insights, and create custom dashboards that display whatever information you want to see. For more information on using New Relic Insights to share and view Infrastructure data, check out the documentation.   By Phil Weber Phil Weber is a Senior Technical Training Specialist with New Relic University. He worked as a software developer for over 15 years, and has been a technical trainer since 2005. As a consultant, he worked for such clients as Intel and Kaiser Permanente. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.38046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to open the <em>chart</em>’s underlying NRQL query in Insights: From here, you can customize the query, give the <em>chart</em> a title, and <em>add</em> it to a dashboard. The NRQL AS clause allows you to customize the label of a query attribute. Let’s <em>add</em> some AS clauses to make the <em>chart</em> legend easier to read. Change"
      },
      "id": "60764d40196a67ef7f64a7c0"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-guidelines/five-questions-help-write-docs/",
      "sections": [
        "Five questions to help write docs",
        "There's really only 1Q",
        "5Qs and sub-questions",
        "1. Did you use or observe the thing you are writing about?",
        "2. Is this the best place to put this information?",
        "3. Can readers tell in ten seconds if they are in the right place?",
        "4. Is the information in the best possible format?",
        "5. Is the language approachable, expert, and visionary?"
      ],
      "published_at": "2021-04-15T22:21:53Z",
      "title": "Five questions to help write docs",
      "updated_at": "2021-04-05T09:54:28Z",
      "type": "docs",
      "external_id": "14fd5c4efd0e8aa26e04d97ae61da33eef9489ee",
      "document_type": "page",
      "popularity": 1,
      "body": "Our five questions form the core of how our Tech Docs team thinks about writing excellent technical documentation. Informally, we call these our 5Qs. Anyone can contribute to our Docs site. We want you to feel confident and proud that your contributions provide valuable content and quality. We also want our readers to trust and easily use the information in our docs. To help you plan, write, and edit excellent docs, ask yourself these five questions. There's really only 1Q Read on for our five questions, but before you do: Know that these questions all exist to help answer one question. Whenever you write a doc, ask yourself: What problem are we trying to solve? It's critical you know what you're trying to do and why that goal matters to your readers. Asking the five questions (and the sub-questions!) will help you ensure you're building the right thing. 5Qs and sub-questions Each of the five questions includes sub-questions to help guide your thinking. 1. Did you use or observe the thing you are writing about? Think about who your audience is and the level of complexity they need. End users' point of view Ask yourself: Audience Do you know who is reading your document (dev/ops teams, support personnel, non-technical staff, etc.)? Can you articulate what this thing is (feature, procedure) and why it matters to our customers? For conceptual info, did you interview multiple stakeholders? Testing Put yourself in the user's shoes. For example: Did you use the thing on your own? Did you watch a subject matter expert use the thing? If you can't do it on your own or observe, did you send the draft to at least three SMEs? Before publishing Did you compare the final version of your text against the thing you're writing about? 2. Is this the best place to put this information? Think about where this information belongs. Where does this information belong? Ask yourself: What problem are you trying to solve? Is text always the best answer? Does this doc need to exist at all? For example: Are we duplicating content from somewhere else in the Docs site? Are we duplicating content already in the UI? Could customers have a better experience if we modified the UI design or copy instead of creating a doc? Would another web property be a better home for this information? For example: The Explorer's Hub? NRU course? NRU video embedded into the doc? The public New Relic blog? The public New Relic website? 3. Can readers tell in ten seconds if they are in the right place? Think about what the content is and what you can do to make the information easy to skim to find information. Can users skim to find information? Ask yourself: Title and headings Does the title accurately represent what's in the doc? Do the headings accurately represent what's in the doc? Do the title and headings use words the way your readers do? Do the title and headings avoid New Relic jargon? Structure Does the overall structure of the doc help readers find what they're looking for? Is the doc trying to address too many topics? When you glance at the doc, do you see short paragraphs, short sentences, and other visual aids? Or do you see a dense wall of text? Introduction Does the intro give a concise synopsis of what's in the doc? Does the intro give readers an alternate path if they're in the wrong place? 4. Is the information in the best possible format? Think about how to present the information visually. Presentation of information Ask yourself: Visual formats Did you use visual formats appropriately? Would a screenshot make any of the information easier to understand? Does your image caption clearly explain what matters so that the user does not necessarily even need to read the surrounding text? Would a diagram make any of the information easier to understand? Is there a video we could embed to make things clearer? Can step-by-step UI procedures be replaced with a \"show me\" video? Procedures Are your procedures well-structured? Do step-by-step UI procedures even need to be documented? Did you limit the procedural text to action steps and omit detailed explanatory text or edge cases? If detailed explanations need to enhance a procedure, have you organized the info in a way that expert users can skip the details? Text flow Read your draft more than once. Is the documentation direct and to the point? Did you use bullets, tables, or clamshells to improve flow? 5. Is the language approachable, expert, and visionary? Think about why the information matters and why readers will trust and use it. For more information, see the Marketing brand guidelines PDF (34.7M). (This is an internal New Relic link.) Effective language Ask yourself: Readers' point of view Did you tell users why as well as how? Can you articulate not only what this thing is (feature, procedure) and also why it matters to our customers? Did you include useful examples or use cases? Did you include information about relationships this feature has to other New Relic platform tools? Style guide resources Did you follow our style guide? Did you use our edit checklist? Did you use pronouns, contractions, and a conversational tone throughout? Did you review the usage dictionary and other resources in the style guide to make sure that terms are used correctly? Readability Is the text easy to read? Is the language clear? Do you have to reread any sentences or paragraphs to understand them? If so, can you simplify the wording and sentence structure? Does the doc score 40 or better on the Flesch-Kinkaid reading ease scale? If not, try taking another pass at the prose. But don't chase the Flesch-Kincaid score in itself: we're not out to frustrate ourselves, but to write docs that are a pleasure to read. Where to go from here Did you offer readers a clear \"next step\" in each section? If it is necessary to tell a user not to do something, did you also tell them what to do instead? Is the topic complete? Is the doc actionable?",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.89205,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "? The public New Relic website? 3. Can readers tell in ten seconds if they are in the right place? Think about what the content is and what you can do to make the information easy to skim to find information. Can users skim to find information? Ask yourself: Title and <em>headings</em> Does the title accurately"
      },
      "id": "60421ef3196a676926a83d81"
    }
  ],
  "/build-apps/ab-test/persist-version": [
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/fs14-square.jpg?h=d9bcd22f&itok=iug-FAmH",
      "url": "https://newrelic.com/blog/best-practices/angularjs",
      "sections": [
        "Web GUI vs. MVC",
        "The View-Controller: Computed Properties",
        "Transforming properties and creating new values",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "Adventures in AngularJS: The View-Controller and Computed Properties",
      "updated_at": "2021-04-14T02:12:39Z",
      "type": "",
      "external_id": "ca59ea844b12eb0f03036ef062768e79f477b857",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit DevOps Adventures in AngularJS: The View-Controller and Computed Properties Aug 11, 2014 • 6 min read By Vicente Reig Rincón de Arellano On the Business Engineering team at New Relic, we rely on AngularJS to build and maintain a variety of internal apps to help us keep shipping new features and products. We build rich user interfaces that leverage the browser to support the daily internal operations. AngularJS provides an excellent base to let them grow. As soon as we started our second AngularJS application, however, we realized that we were having to make the same decisions all over again: From training the new hires on GUI programming and Angular's intricacies to then building a framework on top of Angular, and finally building the application. We needed a way to simplify and rationalize the process. Web GUI vs. MVC The first thing that hits you when diving into Web GUI development is that, despite the naming conventions, the patterns to build the application are slightly different compared to model-view-controller (MVC) server-side frameworks. MVCs rely heavily on the browser to translate what the user wants to do into the business logic that the application holds. Views are composed in the server-side, and objects have a shorter life-span: the request cycle. Richer, more complex client GUIs need a different toolset to solve a handful of problems, which traditionally have been addressed by native GUI development: Keeping the application state throughout the user interaction Installing the application in the user's device Building a model that reacts to the user's decisions and perception. (Yehuda Katz condenses this dilemma very well in a 30-minute talk, A Tale of Two MVCs.) To address these issues, we began establishing our own conventions to shape current and forthcoming applications in a uniform manner. AngularJS offers a fantastic foundation to build the framework to construct client-side applications. In fact, we built a sample application—¡Hola, Playlists!—to synthesize all our experiences and opinions in AngularJS in a workshop for New Relic employees. Let’s take a look at the first of the conventions we found useful to build the foundation that supports our GUIs, which addresses putting the View-Controller into shape using Computed Properties. (In subsequent posts, we’ll address additional conventions we’ve established, including ways to let controllers communicate to each other as well as how to mediate routing and nested views to hold together various parts of your application.) Computed Properties have been extensively used to represent the state and its dependencies in an application’s UI, propagating changes throughout the data-binding pipeline. In Java you can observe a Bound Property through a PropertyChangeListener. Cocoa and Objective-C provide Key-Value Observing to accomplish the same mission. Apple’s new Swift programming language incorporates a special syntax called Computed Properties. In the Javascript browser-based space, Ember.js includes Computed Properties as part of the core Object Model and the future ECMAScript already enables data-binding through the Object.observe method. The View-Controller: Computed Properties Angular's Controllers hold the representation of the knowledge—the traditional model— and also act as the link between the user and the system. While the UI is automatically updated by using bidirectional binding to the $scope, Angular doesn't provide a convention to represent richer models, other than assigning POJOs and functions to it: Basically, static properties. Without an existing convention, we found ourselves trying to name the new patterns we were using without using lower level concepts such as listeners, objects, or scope. And that's how we found out about Computed Properties: a little tool to take a source property and create a new value, syncing any change to it whenever the source changes. Computed Properties are made out of three components: A variable to store the results of the computation. This is usually assigned to the $scope to make it available to the template and child controllers A Property Observer implementing the value transformation needed A watcher that triggers the observer every time an attribute in the collection changes. Transforming properties and creating new values For our sample application, we wanted to create playlists out of the selected tunes, enabling the “Create Playlist” button only when at least one song has been selected. We used a Computed Property to represent the state of the button—enabled or disabled—and aggregate the selected tracks. First, we need to aggregate all the selected tracks every time the user selects one by checking the associated checkbox: <table> <tbody> <tr ng-repeat=\"track in tracks\"> <td><input type=\"checkbox\" ng-model=\"track.selected\"/></td> <td>{{ track.name }}</td> <td>{{ track.artists | pluck:'name' | join:', ' }}</td> <td>{{ track.album.name }}</td> </tr> </tbody> </table> The controller associated to this view, by either using the ng-controller directive or binding it to a template in a route, can easily watch the collection of tracks and filter out those that aren't selected. This controller becomes the root controller of this view. // tracks is an Array injected from the resolve section in the current route. app.controller('TracksController', ['$scope', 'tracks', function($scope, tracks){ $scope.tracks = tracks;   $scope.selectedTracks; this.selectedTracksWillChange = function(tracks) { $scope.selectedTracks = tracks.filter(function(track){ return track.selected; }); }; $scope.$watch('tracks', this.selectedTracksWillChange, true); }]); We can finally add our Create Playlist button, governed by a controller in charge of watching how many tunes did the user select, enabling or disabling the button in consequence. <button ng-controller=\"PlaylistController\" ng-click=\"createPlaylist()\" ng-disabled=\"createPlaylistDisabled\"> Create a Playlist </button> We can also use a Computed Property to persist the state of the button, publishing it to the view through the $scope object. Each time the selectedTracks property changes in the root controller, TracksController, createPlaylistDisabled is computed and made available to the template, triggering Angular's render loop. app.controller('PlaylistController', ['$scope', function($scope){ $scope.createPlaylistDisabled = true; this.createPlaylistDisabledWillChange = function(selectedTracks){ $scope.createPlaylistDisabled = (selectedTracks.length == 0); }; $scope.$watch('selectedTracks', this.createPlaylistDisabledWillChange, true) }]); We found that Computed Properties helped us to build useful, ubiquitous conventions for use by developers in New Relic’s Business Engineering team. They also helped us write our code for fellow human beings, revealing what the code is supposed to do and providing a description of how the model gets transformed when the user interacts with the interface. Of course, we’re still battle-testing common ways to shape applications against many different scenarios to find the most robust architecture. So this is just the first in a series of posts presenting the lessons we’ve learned about JavaScript GUI development. Planned follow-up posts will cover patterns of controller communication and how routes mediate to stitch your application together. Related Topics DevOps By Vicente Reig Rincón de Arellano Vicente Reig Rincón de Arellano is a senior engineer in New Relic's Business Engineering team. Prior to joining New Relic, he worked building massively concurrent systems, data integration architectures, and GUIs in a wide variety of technologies such as Ruby, Java, Objective-C, and Javascript. Follow the author Vicente Reig Rincón de Arellano on Twitter Vicente Reig Rincón de Arellano on GitHub Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.92947,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Adventures in AngularJS: <em>The</em> View-Controller and Computed Properties",
        "sections": "<em>The</em> View-Controller: Computed Properties",
        "body": "(&#x27;tracks&#x27;, this.<em>selected</em>TracksWillChange, true); }]); We can finally add our Create Playlist button, governed by a controller in charge of watching how many tunes did the user <em>select</em>, enabling or disabling the button in consequence. &lt;button ng-controller=&quot;PlaylistController&quot; ng-click=&quot;createPlaylist"
      },
      "id": "60764f97196a6739ac64a7c3"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/infrastructure-release-notes/infrastructure-agent-release-notes/new-relic-infrastructure-agent-151/",
      "sections": [
        "Infrastructure agent v1.5.1",
        "Notes",
        "Changed",
        "Windows only"
      ],
      "published_at": "2021-04-16T12:46:32Z",
      "title": "Infrastructure agent v1.5.1",
      "updated_at": "2021-03-16T11:39:25Z",
      "type": "docs",
      "external_id": "e238766863ed226ce722c629b6a2a3e9a1f50487",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "Notes A new version of the agent has been released. Follow standard procedures to update your Infrastructure agent. Changed Improved StorageSample metrics performance. Please refer to the New Relic event data dictionary for a detailed description of them. Windows only IMPORTANT: This version was deleted from the Windows repository to avoid causing issues on the platform. Improved hostname flipping issue mitigation using a new endpoint for agent identity retrieval. Cases where a host flipping its hostname (because DNS lookup is not available or any other reasons) caused host entity identification to change (and some alerts to fail) should be mitigated, but some cases could still persist.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.02696,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Notes A new <em>version</em> of the agent has been released. Follow standard procedures to update your Infrastructure agent. Changed Improved StorageSample metrics performance. Please refer to the New Relic event data dictionary for a detailed description of them. Windows only IMPORTANT: This <em>version</em>"
      },
      "id": "603eaaf3e7b9d27fc72a07db"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/webstorageAPImethods.png",
      "url": "https://newrelic.com/blog/best-practices/html5-web-storage-cookies-are-so-1994",
      "sections": [
        "Related Topics"
      ],
      "published_at": "2021-04-16T01:01:13Z",
      "title": "HTML5 Web Storage - Cookies Are So 1994!",
      "updated_at": "2021-04-14T01:21:56Z",
      "type": "",
      "external_id": "79a1031d93293f8e7635287676342fdcc664c58b",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Customer Experience HTML5 Web Storage - Cookies Are So 1994! Sep 18, 2012 • 15 min read By Leigh Shevchik Matthew Setter is a professional technical writer and passionate web application developer. He’s also the founder of Malt Blue, the community for PHP web application development professionals and PHP Cloud Development Casts – learn Cloud Development through the lens of PHP. You can connect with him on Twitter, Facebook, LinkedIn or Google+ anytime. In this two part series, we’re going to look at Web Storage, one of the best and most interesting features to come out of the HTML5 spec. We’ll look at the history of both Web Storage and cookies, and consider the following points: * How and why cookies are used * Web Storage’s strengths and limitations * Current browser support for Web Storage and cookies * The future of managing transaction state in web applications * How to use Web Storage to build offline apps As this is a hands-on series, we’ll work through a simple application that makes use of Web Storage. We’ll use it to create an application that is usable whether the browser is on or offline and supply the code so you can take it away and play with. A Brief History of Cookies For those not as familiar with them, cookies were introduced by Netscape in 1994 as part of the Mosaic Netscape browser beta version 0.9. (Which later became Netscape Navigator and then Mozilla Firefox.) Netscape’s client, MCI, was looking for a way to retain a sense of state, but not on the server side. Cookies were chosen as the technical solution to this challenge. Simple in form and structure, cookies are an effective solution that allow small text files of information to be stored on a users computer. They store this information to allow a site to provide a more personalized experience in ways such as: * Last logged in * Last page viewed * Page view count * Track advertisements * Retain state about a shopping cart How Cookies Work Cookies are created when a browser receives a Set-Cookie header from the web in response to a page request. Look at this example modified from Wikipedia: [sourcecode language=\"HTML\"] HTTP/1.1 200 OK Content-type: text/html Set-Cookie: page_loaded=25; Expires=Wed, 09 Jun 2021 10:18:14 GMT [/sourcecode] The browser receives a HTTP 200 code indicating the response was successful and the content type of the response. It also receives a Set-Cookie header and creates a cookie with the following structure: Unless it’s refreshed before, on Wed, 09 Jun 2021 10:18:14, the cookie will expire and be removed by the browser. If it’s not expired, in all future requests for that site the browser will respond by sending back a header similar to the following: [sourcecode language=\"HTML\"] GET /spec.html HTTP/1.1 Host: www.example.org Cookie: page_loaded=25; [/sourcecode] There are a number of options that can be specified when setting a cookie. These include the domain and path and whether it’s a secure or HttpOnly only cookie. The Downside of Cookies Despite their clear benefits and simplicity, cookies have long had a bad reputation with respect to potential privacy and security implications.  They are vulnerable to a host of security issues including such key attack vectors as Cross Site Request Forgery (CSRF), Cross Site Scripting Attacks (XSS) and Session Hijacking. Now to be fair, a diligent and professional developer would never put secure details in a cookie and would implement a range of methods to mitigate the possibility of these types of attacks. Cookies don’t need to be seen as an automatic threat. Without them, a lot of the personalization we’ve come to expect from the web wouldn’t have been possible. A Brief Introduction to HTML5 Storage HTML5 introduces Web Storage as an alternative to Cookies. This storage comes in two delicious flavors: local and session. Depending on the focus of your application, you can pick the type of storage that best suits your purposes. As with cookies (and most everything else), HTML5 storage has its fair share of strengths and weaknesses. Web Storage Weaknesses * Data is stored as a simple string; manipulation is needed to store objects of differing types, such as booleans, objects, ints and floats * It has a default 5mb limit; more storage can be allowed by the user if required * It can be disabled by the user or systems administrator * Storage can be slow with complex sets of data Web Storage Strengths * Apps can work both online and off * An easy API to learn and use * Has the ability to hook in to browser events, such as offline, online, storage change * Has less overhead than cookies; no extra header data is sent with browser requests * Provides more space than cookies so increasingly complex information can be kept Web Storage API The Web Storage API is simple and very easy to learn. It consists of only four methods: These methods provide all that we need to work with localStorage. As with everything in coding, we can then create classes and objects or use third party libraries to make the interaction more sophisticated, such as in this post from Ben Nadel. To make working with Web Storage a lot simple, you can use one of a number of third party libraries (such as Modernizr and jStorage.) Browser Events HTML5 exposes a number of events that we as developers can make use of. In this post, I’m looking at offline and online. You can see the full list over on tutorialspoint. Security HTML5 may be all shiny and new, but that doesn’t mean it’s any more secure than before. Keep in mind the same security considerations as you did with cookies. Most importantly, don’t store sensitive information with Web Storage! I’m sure this goes without saying, but it bears repeating. As with cookies, the user can view the information and delete it, and information stored there is still subject to cross site scripting attacks. So make sure to stay diligent when using it. One key improvement Web Storage offers is the distinction between local and session storage. Session storage removes all information stored when the window or tab closes. Local storage persists the information across tab and window sessions.  Through having data automatically removed when a tab or window is closed, gives us a safer environment with which to store it. I stress, safer, not safe. It has the added benefit of making it simpler again to work with. If we know that we’ll only need it for a short period of time, then we can place it there and know that it will, likely, be cleared up for us with interaction on our parts. But don’t take that as an advocation for laziness or sloppy coding practices. Browser Support While localStorage is an amazing development, it doesn’t mean that every browser vendor supports it equally. The table below to shows which version each of the major browsers supports it. Currently all modern browsers support localStorage. But you’ll have to consider older versions to ensure it implements properly for your users. it properly for your audience. Table recreated courtesy of html5rocks. Why HTML5 Storage is the Future for Transaction State For reasons that I’ve already covered or alluded to, I believe that HTML5 storage is the future of transaction state. This is primarily driven by the irrepressible rise of the mobile web, through the proliferation of iOS, Android and now Windows Phone 7 (and shortly 8) smartphones. As you can see in the table below, the total number of smartphones sold worldwide in Q4 2011 alone is staggering. Table, courtesy of gartner.com. Judging by these figures, it won’t be long before these devices will eventually overtake desktop internet usage. The problem is, they’re not guaranteed to be always connected. Intermittent signal coverage is all too common. Whether we’re in transit on underground train networks, in flight round the world, in more remote country regions, where data roaming is less effective and more, there’s many ways in which we can’t guarantee a permanent connection. Secondly, it’s not as much the case with the release of iOS 5 and potentially Windows Phone, but Android phones are known for being very battery hungry. So the less that is required to be done, the less data that is required to be sent and received, will result in the most effective and responsive applications for the end user. Storage allows us to do this in a number of ways, including: * By not having to send Cookies with each request * By being able to operate when no data connectivity is present and merge the offline state with the server when connectivity is resumed * By being able to store and manipulate more information locally Now it’s a bit of a wait and see approach to know which of the available solutions will be the one that reaches ubiquity with developers. At this stage, especially with Mozilla’s attitude to Web SQL, it’s likely to be Web Storage. OK, we’ve considered a lot of information so far. Now, let’s look at a sample application using storage so that we can get our hands dirty and see how it works. Your challenge is to improve upon the obvious and not so obvious weaknesses in this specific implementation and make it better. A Sample Application Now that we’ve gone through and had a good introduction to what storage is and what it can do, let’s have a look at a simple application that makes use of it. The application is a simple user list that’s available both online and off. The application works by retrieving a list of users from a PHP script, get-records.php. It persists that information to localStorage and then a set of simple jQuery functions are called to render the data in a table, so that the user can see the current list of users available. A user can then add new users with three bits of information: first name, last name and email address. When the form is submitted, the details are sent to add-record.php. The SQLite database is updated and another request is made for the information, re-populating the list of records before redisplaying the user information. This application isn’t the most effective in how it works, but it tracks when the browser goes online and off, and allows for the form to continue working either way. If the application is offline, the form data is stored in a second record ready for when the browser comes back online and at that point is stored in the database, via add-record.php again, the data cleared and re-populated. Look at the code below and you’ll see how the process works: [sourcecode language=\"javascript\"] <script type=\"text/javascript\"> /* PHP scripts to call */ var getRecords = 'get-records.php'; var addRecords = 'add-record.php'; [/sourcecode] Here we keep a simple copy of the two PHP scripts that we’re interacting with. You can see a copy of them below. [sourcecode language=\"javascript\"] function supports_html5_storage() { try { return 'localStorage' in window && window['localStorage'] !== null; } catch (e) { return false; } } [/sourcecode] Now we quickly check if html5 storage is available. If it returns false, we’re unable to work with it: [sourcecode language=\"javascript\"] function clearPrimaryCache() { localStorage.removeItem('records.user.hasRecords'); localStorage.removeItem('records.user.records'); } function clearOfflineCache() { localStorage.removeItem('records.user.local.records'); localStorage.removeItem('records.offline.status'); } [/sourcecode] We have two key caches that we use: one for the online data that is displayed to the user and one for the offline data. It’s simple to clear each separately. [sourcecode language=\"javascript\"] function getRecords() { if (!supports_html5_storage()) { return false; } $(function() { $(document).ready(function() { $.getJSON(getRecords, function(data) { clearPrimaryCache(); var records = []; records.push(data.records); if (records.length !== 0) { localStorage.setItem('records.user.records', JSON.stringify(records)); localStorage.setItem('records.user.hasRecords', JSON.stringify(true)); } }); return false; }); }); } [/sourcecode] Next we retrieve the records from get-records.php, clear out the primary cache, cache the retrieved records, and set a variable indicating we have records available. [sourcecode language=\"javascript\"] function showCurrentRecords() { if (!supports_html5_storage()) { return false; } var hasRecords = JSON.parse(localStorage.getItem(\"records.user.hasRecords\")); if (!hasRecords) { $('#current-records > tbody').append(' <tr> <td colspan=\"4\">No Records available</td> </tr> '); } else { var userRecords = JSON.parse(localStorage.getItem(\"records.user.records\")); $.each(userRecords[0], function(index, row) { $('#current-records > tbody').append( ' <tr> <td>' + (index + 1) + '</td> <td>' + row.firstname + '</td> <td>' + row.lastname + '</td> <td>' + row.emailaddress + '</td> </tr> ' ); }); } } [/sourcecode] The above renders the currently available records from the cache on to the page. We check if records are available, and if so, iterate over them, building up a simple HTML table. [sourcecode language=\"javascript\"] function clearRecords() { $(\"#current-records > tbody > tr\").remove(); } Now we clear the existing records in the HTML table. [sourcecode language=\"javascript\"] function reloadRecords() { getRecords(); clearRecords(); showCurrentRecords(); } [/sourcecode] This is a simple utility function that allows us to retrieve records from the PHP script, remove the existing HTML table and re-build it with the records retrieved. [sourcecode language=\"javascript\"] function goOnline() { // persist the local records to the remote and clear the buffer var userRecords = JSON.parse(localStorage.getItem(\"records.user.local.records\")); // process any records retrieved if (userRecords.length >= 1) { $.each(userRecords, function(index, row) { var dataString = 'firstname='+ row.firstname + '&lastname=' + row.lastname + '&emailaddress=' + row.emailaddress; $.ajax({ type: \"POST\", url: \"add-record.php\", data: dataString, success: function() { reloadRecords() } }); }); // clear out the offline cache after processing clearOfflineCache(); // reload the records so that the user sees them reloadRecords(); } // set the indicator flag to show that we're now online localStorage.setItem('records.offline.status', JSON.stringify('online')); } [/sourcecode] goOnline takes the application online when the online state is detected. It retrieves any cached records and stores them by calling the add-records.php script, clears out the offline cache and calls the reloadRecords function, which re-renders the records so that the user can see them. It finishes up by setting the status indicator to online. [sourcecode language=\"javascript\"] function goOffline() { localStorage.setItem('records.offline.status', JSON.stringify('offline')); } goOffline takes the application offline by setting the status indicator appropriately. function isOffline() { var offlineStatus = JSON.parse(localStorage.getItem(\"records.offline.status\")); if (offlineStatus) { return true; } return false; } [/sourcecode] isOffline inspects the offline indicator and returns true if the browser is offline and false if online. [sourcecode language=\"javascript\"] function persistRemotely() { var firstname = $(\"input#firstname\").val(); var lastname = $(\"input#lastname\").val(); var emailaddress = $(\"input#emailaddress\").val(); var dataString = 'firstname='+ firstname + '&lastname=' + lastname + '&emailaddress=' + emailaddress; // if online, submit to remote script $.ajax({ type: \"POST\", url: \"add-record.php\", data: dataString, success: function() { reloadRecords() } }); return false; } [/sourcecode] persistRemotely persists the information that’s received from the form when it’s submitted. It retrieves the values from the first name, last name and email address fields, builds a simple, data, query string as the request POST data and submits it via AJAX to the add-record.php script. [sourcecode language=\"javascript\"] function persistToOfflineCache() { var firstname = $(\"input#firstname\").val(); var lastname = $(\"input#lastname\").val(); var emailaddress = $(\"input#emailaddress\").val(); // retrieve the locally persisted records var records = JSON.parse(localStorage.getItem(\"records.user.local.records\")); // parse the string to a json array var userRecord = {'firstname':firstname,'lastname':lastname,'emailaddress':emailaddress}; if (records != null) { // store the record in the local records records.push(userRecord); } else { var records = []; // store the record in the local records records.push(userRecord); } // write the information back to local storage localStorage.setItem('records.user.local.records', JSON.stringify(records)); } [/sourcecode] persistToOfflineCache caches the form data when the browser is offline. As with persistRemotely, it retrieves the form input and adds it as a JSON object to the offline cache. If there are existing records, it adds it to them. If there aren’t, then it creates the offline cache with this first object. [sourcecode language=\"javascript\"] $(document).ready(function() { // intercept the online event window.addEventListener(\"online\", function() { goOnline(); }, true); // intercept the offline event window.addEventListener(\"offline\", function() { goOffline(); }, true); // intercept the form submit event $('form').submit(function() { if (isOffline()) { persistToOfflineCache(); } else { persistRemotely(); } $('#recordsform').reset(); return false; }); }); getRecords(); // ]]></script> [/sourcecode] And this is the test harness of the application. When the page is fully loaded, we listen for the online and offline events, and call goOnline and goOffline respectively. We intercept the form submit method and call either persistToOfflineCache or persistRemotely depending on the current browser state, resetting the form after either is called and prevent the normal form response from being fired. PHP Scripts The PHP scripts for adding and storing records are rather trivial. As you can see below, the records are stored in a SQLite (3) database. The add-record.php script retrieves the POST data and uses prepared statements to insert the record into the database. get-records.php retrieves all of the existing records from the database and outputs them, JSON encoded. add-record.php [sourcecode language=\"php\"] <!--?php // Set default timezone date_default_timezone_set('UTC'); $dsn = \"sqlite:databases/mydb.sq3\"; try { $dbh = new PDO($dsn); // Set errormode to exceptions $dbh--->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); } catch (PDOException $e) { echo 'Connection failed: ' . $e->getMessage(); } $userList = null; // Select all data from file db messages table $result = $dbh->query('SELECT * FROM users'); if (!empty($_POST['firstname']) && !empty($_POST['lastname']) && !empty($_POST['emailaddress'])) { $sql = \"INSERT INTO users (firstname, lastname, emailaddress) VALUES (:firstname, :lastname, :emailaddress)\"; $q = $dbh->prepare($sql); $q->execute(array( ':firstname' => $_POST['firstname'], ':lastname' => $_POST['lastname'], ':emailaddress' => $_POST['emailaddress'] )); } [/sourcecode] get-records.php [sourcecode language=\"php\"] <!--?php // Set default timezone date_default_timezone_set('UTC'); $dsn = \"sqlite:databases/mydb.sq3\"; try { $dbh = new PDO($dsn); // Set errormode to exceptions $dbh--->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); } catch (PDOException $e) { echo 'Connection failed: ' . $e->getMessage(); } $userList = null; // Select all data from file db messages table $result = $dbh->query('SELECT * FROM users'); foreach ($result as $row) { $userList['records'][] = array( \"firstname\" => $row['firstname'], \"lastname\" => $row['lastname'], \"emailaddress\" => $row['emailaddress'] ); } print json_encode($userList); [/sourcecode] The Running App No application would be complete without an obligatory screenshot : ) So you can see below what it looks like. Based on the amazing Twitter Bootstrap project, a simple navigation menu is followed by the form and finally the current records. In Conclusion I hope that this post has given you a good introduction to the power and flexibility of HTML5 Web Storage, and you caught a glimpse of what is possible with it and why it’s so very important in the growing age of the mobile web. Share your thoughts in the comments about your experience and how you’re planning to integrate it in to your applications. Further Reading * Introduction to HTML5 Web Storage * Introduction to Client Side Storage * Exploring HTML5’s localStorage - Persistent Client-Side Key-Value Pairs * HTML5 Storage Security * Gartner Says Worldwide Smartphone Sales Soared in Fourth Quarter of 2011 With 47 Percent Growth * HTTP Cookie Related Topics Customer Experience By Leigh Shevchik Marketing Manager, Content Follow the author Leigh Shevchik on Twitter Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.60022,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is on or offline and supply the code so you can take it away and play with. A Brief History of Cookies For those not as familiar with them, cookies were introduced by Netscape in 1994 as part of the Mosaic Netscape browser beta <em>version</em> 0.9. (Which later became Netscape Navigator and then Mozilla Firefox"
      },
      "id": "607643b428ccbc9ceb51c16f"
    },
    {
      "sections": [
        "PHP agent support for Guzzle",
        "Sequential requests",
        "Parallel requests",
        "Timing with Guzzle 6",
        "Disable Guzzle support",
        "For more help"
      ],
      "title": "PHP agent support for Guzzle",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Frameworks and libraries"
      ],
      "external_id": "130381985c74a1e0818602388e92cb9a461d4bfe",
      "image": "https://docs.newrelic.com/static/683623f20c7da568183263e431fc9d22/c1b63/guzzle_sequential.png",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/frameworks-libraries/guzzle/",
      "published_at": "2021-04-16T05:59:53Z",
      "updated_at": "2021-04-16T05:59:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic supports versions 3, 4, 5, and 6 of the Guzzle HTTP client library with New Relic PHP agent version 5.4 or higher. The Guzzle library allows both sequential and parallel requests. This page describes how each type of request will appear in the Summary page in the New Relic UI. To discover which call was the slowest, view the External Services page which displays timing for individual external calls. Sequential requests This PHP code makes multiple sequential requests with Guzzle: $client = new \\GuzzleHttp\\Client; $response = $client->get('http://YOUR_SITE.com/api/foo'); $client->delete('http://YOUR_SITE.com/api/foo/'.$response->getBody()); Copy This code would appear in the New Relic UI as: one.newrelic.com > APM > (selected app) > Overview > Web transactions time: Sequential requests with Guzzle in the New Relic UI. Response time is shown as the dark blue line. The green web external time represents time spent in the Guzzle library. Because the requests were made sequentially, the response time is equal to the total time spent in PHP, MySQL, and web external activities. Parallel requests This PHP code makes multiple requests in parallel by unwrapping an array of promises: $client = new \\GuzzleHttp\\Client; $promises = [ $client->getAsync('http://YOUR_SITE.com/api/foo'), $client->getAsync('http://YOUR_SITE.com/api/bar'), $client->getAsync('http://YOUR_SITE.com/api/quux'), ]; \\GuzzleHttp\\Promise\\unwrap($promises); Copy This code would appear in the New Relic UI as: one.newrelic.com > APM > (selected app) > Summary > Web transactions time: Parallel requests with Guzzle in the New Relic UI The green web external time represents time spent in the Guzzle library. Because the requests were performed asynchronously, the total time spent in PHP, MySQL, and web external is greater than the response time. Timing with Guzzle 6 Unlike previous versions, Guzzle 6 does not generate an event when a request is sent. Instead, the agent begins timing a request when the request object is created. If a request object is created and additional work is done before sending, New Relic may report that the request took longer than it actually did. Disable Guzzle support To disable Guzzle support: Add newrelic.guzzle.enabled = false to your newrelic.ini file. Restart your web server (Apache, Nginx, PHP-FPM, etc.). For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.0011,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "New Relic supports versions 3, 4, 5, and 6 of the Guzzle HTTP client library with New Relic PHP agent <em>version</em> 5.4 or higher. The Guzzle library allows both sequential and parallel requests. This page describes how each type of request will appear in the Summary page in the New Relic UI. To discover"
      },
      "id": "60440f5ee7b9d2a9a65799ff"
    },
    {
      "sections": [
        "Versions analysis",
        "Versions analysis details",
        "Viewing drill-down details",
        "How version numbers are obtained",
        "Android",
        "iOS",
        "For more help"
      ],
      "title": "Versions analysis",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Usage pages"
      ],
      "external_id": "3906aba3231864c2adb43694636f085ae5332d0e",
      "image": "https://docs.newrelic.com/static/f359bb98f6fbf2a5c90dd604778a5dcd/c1b63/screen-versions_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/usage-pages/versions-analysis/",
      "published_at": "2021-04-16T21:40:14Z",
      "updated_at": "2021-03-16T09:41:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Mobile includes a comparative analysis of adoption and performance between versions of your application, including top versions by: Interaction time Active sessions Error rate The Versions page also includes a table comparing each version by date created, average memory, average CPU, average sessions per minute, and average requests per minute (RPM) per active app. You can also drill down into additional details about a specific version. Versions analysis details rpm.newrelic.com/mobile > (select an app) > Usage > Versions: The Versions analysis includes color-coded charts of mobile app usage, plus a table that summarizes mobile app versions and their averages for memory, CPU, active users, and network RPM (requests per minute). The Versions page provides a list of all versions of your app that have been detected, plus overview information on all versions active in the last seven days. To view the comparative analysis: Go to rpm.newrelic.com/mobile > (select an app) > Usage > Versions. To select the time period, use the time picker below the New Relic menu bar. Optional: Select the Sort by options. To view details only for a specific version, select its name. The Versions page provides a list of all versions of your app that have been active in the selected time window. Use any of New Relic's standard user interface functions and page functions to drill down into detailed information. Viewing drill-down details rpm.newrelic.com/mobile > (select an app) > Usage > Versions > (selected version): Here is an example of details for a selected version. The details page provides further insight into how the selected version compares to a reference version (a recent or popular version), and the average of other versions of your app. Time series show the comparison across error rate, response time, active sessions, and memory usage. To exit the details page, select the Close (X) button. How version numbers are obtained The way that New Relic Mobile obtains the version number varies by platform: Android The Android agent obtains the version information from the android:versionName property in the manifest. iOS The iOS agent uses both CFBundleShortVersionString and CFBundleVersion properties to obtain the app version. The agent accesses those properties through iOS APIs. It does not obtain them by reading the info.plist file. For more help Additional documentation resources include: Devices page (performance details about the top devices using your mobile application, including comparisons by interaction time, HTTP request time, network failures, and active sessions) OS versions page (performance details about the top operating system versions using your mobile application)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 71.43697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Versions</em> analysis",
        "sections": "<em>Versions</em> analysis",
        "body": ", average sessions per minute, and average requests per minute (RPM) per active app. You can also drill down into additional details about a specific <em>version</em>. Versions analysis details rpm.newrelic.com&#x2F;mobile &gt; (<em>select</em> an app) &gt; Usage &gt; Versions: The Versions analysis includes color-coded charts of mobile"
      },
      "id": "603eaeeae7b9d262be2a080c"
    }
  ],
  "/build-apps/ab-test/nerdstoragevault": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programability_browser_analyze_1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-developers-guide-roundup",
      "sections": [
        "Intro to New Relic One SDK",
        "New Relic One CLI",
        "Intro to NerdStorageVault - New Feature!",
        "Create a \"Hello, World\" app",
        "Practice diagnosing common issues using New Relic",
        "Get coding and get inspired",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:23:24Z",
      "title": "New Relic Developers Guide Roundup",
      "updated_at": "2021-04-13T23:23:31Z",
      "type": "",
      "external_id": "9322d4fbb3dbbeb84cc7c3f26c9cc2c275e3a11d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Relic Developers Guide Roundup Jan 5, 2021 • 7 min read By Vi Tran When we first launched our programmable platform, one of our executives envisioned a simple way to visualize customer experience and satisfaction scores. He sent the following sketch to an engineer: Two days later, he had a production-ready application, built on New Relic One, that showed not just what the customer experience scores were, but what they should be. The browser analyzer application This New Relic One application is called the browser analyzer—it’s open source and available for you to use today. But now it’s your turn to go from sketch to app. We’ve given you the same tools our own engineers use, so you can build and deploy applications in New Relic One that connect your observability data, gathered from myriad sources—including third-party open source data—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK The New Relic One SDK provides the necessary components you need to build New Relic One applications. Components of the SDK include: React UI components for controlling text and layout in a New Relic One application Chart components for representing different types of charts Query and storage components for fetching and storing New Relic data Platform APIs that enable your application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build your applications, create visualizations, and fetch New Relic or third-party data. New Relic One CLI In addition to the SDK, you’ll need the New Relic One CLI to build apps on the platform. You’ll use the CLI to build, publish, and manage your app. More specifically, you’ll use the CLI to do the following: Generate Nerdpack/Nerdlet templates—(a Nerdpack is a package containing all the files needed by an application; a Nerdlet is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Intro to NerdStorageVault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store your data. NerdStorageVault lets you store and retrieve sensitive data secrets such as: Personal access tokens License keys API keys Other third-party secrets You can explore NerdStorageVault fields and response types with the NerdGraph API explorer. NerdStorageVault is encrypted with AES-256 encryption. In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes. Check out the guide for more information. Create a \"Hello, World\" app In this guide, you’ll build a \"Hello, World!\" application in New Relic One in nine quick steps. You’ll create a local version of the New Relic One site where you can prototype your application, and when you're ready to share the application with others, you can publish it to New Relic One. [embed]https://www.youtube.com/watch?v=7omo0qHxku8&feature=youtu.be[/embed] To get started, make sure you have accounts in GitHub and New Relic. You’ll also need to install Node.js and familiarize yourself with the New Relic One CLI. Tip: Check out Set up your development environment to make sure you have everything in order before you jump in. Practice diagnosing common issues using New Relic Every time you deploy an application, you hope that it's efficient and free of errors. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled demo environment. Acme Telco Lite is a telecom business that maintains an e-commerce website for its customers. The site's architecture has eight interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. Check out the full guide for more on prerequisites and deployment details. Get coding and get inspired Explore more guides and tutorials on New Relic Developers, because we’re constantly adding content. Best of all? The site is built completely in open source—feel free to submit a pull request while you’re there. Related Topics Extend New Relic By Vi Tran Vi Tran is a Senior Product Marketing Manager for Developer Ecosystem at New Relic. Her focus is on growing and enabling the developer ecosystem to extend New Relic One. Before New Relic, she was on the global strategic alliances team at Splunk and was a management consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 562.00494,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro to <em>NerdStorageVault</em> - New Feature!",
        "body": " to the catalog Intro to <em>NerdStorageVault</em> - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store <em>your</em> data. <em>NerdStorageVault</em> lets you store and retrieve sensitive data secrets such as: Personal <em>access</em> tokens License keys API keys Other third-party"
      },
      "id": "607627f464441f7e2b9d8537"
    },
    {
      "image": "https://docs.newrelic.com/static/1dacbe14521cd094da4f9ce4912e24a5/ae694/nerdgraph-mutation.png",
      "url": "https://docs.newrelic.com/whats-new/2020/10/store-data-encrypted-storage-solution-nerdstoragevault/",
      "sections": [
        "Store data in an encrypted storage solution with NerdStorageVault"
      ],
      "published_at": "2021-04-16T19:42:55Z",
      "title": "Store data in an encrypted storage solution with NerdStorageVault",
      "updated_at": "2021-03-11T00:18:44Z",
      "type": "docs",
      "external_id": "de67c202e7343347b2a6b5bc615301b9fac1e524",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "NerdGraph allows you to access your New Relic data, but when you want to fetch third-party data, NerdStorageVault allows you to safely store a secret to authenticate with a third-party service. NerdStorageVault provides you with a secure and encrypted storage location where you can safely store: Personal access tokens License keys API keys Third-party secrets NerdStorageVault is currently only available in the alpha release of the nr1-community component library and is not available in the New Relic One core components library. The feature uses AES-256 encryption.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 418.1332,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Store data in an encrypted <em>storage</em> solution with <em>NerdStorageVault</em>",
        "sections": "Store data in an encrypted <em>storage</em> solution with <em>NerdStorageVault</em>",
        "body": "<em>Nerd</em>Graph allows you to <em>access</em> <em>your</em> New Relic data, but when you want to fetch third-party data, <em>NerdStorageVault</em> allows you to safely store a secret to authenticate with a third-party service. <em>NerdStorageVault</em> provides you with a secure and encrypted <em>storage</em> location where you can safely store"
      },
      "id": "6044694a64441fb9b2378f2d"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/jp/whats-new/",
      "sections": [
        "New Relicの新機能"
      ],
      "published_at": "2021-04-16T19:10:36Z",
      "title": "What's new in New Relic",
      "updated_at": "2021-04-16T19:10:36Z",
      "type": "docs-jp",
      "external_id": "cfaaa9015112cddf53bade5c9f859c3bfbc53a97",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "April 14 Distributed tracing for Mobile Get visibility to the entire journey of requests, originating in your mobile app as they travel through distributed systems April 12 A simpler, more intuitive log analytics experience Check out the changes we've made to the UI to help you see details and debug faster! Create alert conditions from any chart Now you can create an alert condition from just about anywhere in New Relic! Detect patterns and outliers in log data Create queries, alerts, and dashboards using log patterns and outliers April 9 Level up at FutureStack on May 25-27! Connect with Nerds from across the globe to learn, share, and get inspired at our free, virtual event April 8 Aggregated health and activity for your Workloads New Relic Workloads are now easier to read. April 5 Guided install for Java and .NET APM agents We’ve made it simple to set up APM (Java and .NET) using our recently-launched guided installation flow, so you can instrument your systems and start analyzing your telemetry data in 5 minutes - no instrumentation expertise required. April 1 NRQL Updates You can now use Regex within your NRQL queries, and sliding time windows March 31 Amazon CloudWatch Metric Streams More metrics, more often - fill gaps in your observability with Amazon CloudWatch Metric Streams and New Relic One. FedRAMP: Logs and Metrics now certified Protecting your data is our highest priority, which is why we achieved the US Government’s rigorous FedRAMP Moderate certification in 2020. And now we’re adding support for Logs and Metrics to our long list of supported services. March 30 Kubernetes: Metric Update Moving to container_memory_working_set_bytes and away from container_memory_usage_bytes metric Slow transactions on the service Summary Quickly dive into the most time-consuming requests to your application or service March 25 Nerdlog Roundup: New Relic Lookout, Guided Install, and Open Source Docs Get real-time visibility into your stack, simplify your instrumentation, and edit our docs March 18 Nerdlog Roundup: Root Cause Analysis, Topology (Relationship-Based) Correlation, and more! Reduce your MTTR with free Automatic Proactive Anomaly Detection, find problems fast with root cause analysis, and increase context for issues using topology correlation. March 17 AIOps Made Easy: Get to root cause and respond faster Automatically find root cause and respond faster than ever March 16 Heroku cloud integration for log management Detailed log data made easier than ever Visualize log details in Dashboards with our new Logs Table Widget More flexibility and control for log message visualizations March 15 AIOps Made Easy: Cut down on alert noise Reduce alert fatigue and prioritize what’s important March 10 AIOps Made Easy: Detect unusual changes instantly Automatic proactive anomaly detection for free Nerdlog Roundup: See hosts, services, containers, and more in one view with New Relic Navigator See hundreds of entities in a compact, high-level view March 8 Nerdlog Roundup: Muting Rules, Custom Data Visualizations, and more AIOps fun! Smarter incident intelligence and custom data visualizations February 25 Nerdlog Roundup: Ingesting OpenTelemetry Data, RUM, and more Ingest OpenTelemery data and logs, drop your data, and monitor your browser performance February 24 New Relic Explorer: Say goodbye to blindspots Gain unprecedented visibility into your entire system February 19 Nerdlog Roundup: K6 Load Testing and the ServiceNow and Snowflake Integrations Keep your issues in sync, view your Snowflake and k6 performance data in New Relic One. February 11 Data Dropping update: Now, drop entire dimensional metrics Filter sensitive or low-value data February 8 Check out the Nerdlog We have a new live-stream changelog on Twitch! January 28 Agentless syslog onboarding for New Relic log management Host-based log ingestion using rsyslog or syslog-ng with a new TCP endpoint January 21 New Python agent features Python agent now auto instruments HTTPX and Django ASGI January 19 New Anomalies feed as part of AI overview page View all your anomalies in a single place January 13 New Relic Snowflake Integration New Relic now integrates with Snowflake. January 6 Schedule recurring muting rules Suppress or mute notifications with ease December 7, 2020 Recap: Top 10 new observability features you need to know Our engineers and product managers share their favorite features, capabilities, and integrations to help you be more productive and collaborative. December 1, 2020 Alerts and Applied Intelligence new landing page Surface insights with a new landing page. Percentiles now available in events-to-metrics service For the events-to-metrics service, return an attribute's approximate value at a given percentile. November 12, 2020 API keys app There's a new app for managing your API keys. New Relic Lambda extension Our new extension improves observability of your Lambda data. Share dashboards and curated views with permalinks Sharing what you’re seeing just got easier. November 10, 2020 Invite a teammate See how easy it is to invite your team to New Relic. November 9, 2020 Enhanced errors experience in New Relic One We've improved the new errors experience. November 3, 2020 Troubleshoot performance and crash issues faster with New Relic's real-time Java profiling New Relic is excited to announce the availability of real-time Java profiling using Java Flight Recorder (JFR). October 30, 2020 Build high-resolution charts using sliding windows Increase your chart resolution with rolling aggregates, powered by sliding windows. Kafka Connect: Unlock open source and alternative instrumentation sources Build observability pipelines from open source tools and alternative instrumentation sources with the New Relic connector for Kafka Connect. Veneur sink: Your pipeline to 3rd party metrics Send metrics to New Relic using our Veneur sink. October 29, 2020 Three big updates for your native mobile apps Three big updates: The New Relic iOS and tvOS agents will now be distributed as the New Relic XCFramework Agent 7.0.0. For instrumenting React Native applications, we have an experimental open source React Native Module. Plus, we’ve improved reliability from our Android service and changed the way our service handles Android stack deobfuscation. October 27, 2020 Monitor ASGI apps using the Python agent The Python agent now supports monitoring Uvicorn, Starlette, and FastAPI ASGI applications. Monitor Apollo Server GraphQL Node applications Use our Node.js agent plugin to capture executed GraphQL queries. October 15, 2020 Applied Intelligence: Better, smarter webhooks Webhooks now automatically deliver anomaly charts. October 14, 2020 New Relic One now has a new UI for OpenTelemetry Check out our APM functionality for your OpenTelemetry data. October 13, 2020 Store data in an encrypted storage solution with NerdStorageVault Store and receive sensitive third-party secrets data. October 12, 2020 Saved views for log management Save your table column, time range, etc. in the logs UI October 9, 2020 Alerting: Loss of signal detection and configurable gap-filling strategies Specify how long the system should wait before a signal is considered lost. October 7, 2020 New Relic achieves AWS Outposts Ready designation New Relic has achieved the AWS Outposts Ready designation, part of the Amazon Web Services (AWS) Service Ready Program. October 1, 2020 Applied Intelligence now features accelerated suggested decisions Reduce alert noise by using our suggested correlation decisions. September 30, 2020 Applied Intelligence: Deployment events in the issue feed Applied Intelligence now includes any relevant APM deployment data. September 29, 2020 New Relic Edge with Infinite Tracing New Relic users with Pro or Enterprise Full-Stack Observability can now access and benefit from New Relic Edge. September 11, 2020 Anomalies visible in the activity stream The activity stream shows recent events so you can quickly see what's happening in your system. September 9, 2020 Windows Logs supported Support for Windows Logs with New Relic's infrastructure agent September 4, 2020 New Relic One has dark mode! We now have dark mode! New Relic Support for Amazon Web Services (AWS) Bottlerocket Gain full visibility into your workloads and infrastructure running on AWS Bottlerocket. What's new? Your in-product destination for New Relic One updates! September 1, 2020 Issue summary and analysis in Applied Intelligence Rely on the issue summary to help you identify and resolve relevant issues. Visual issue timeline in Applied Intelligence Use our Gantt-style timeline chart to see your related events. August 26, 2020 Real-user monitoring support for W3C trace context and Google Core Web Vitals We've added support for W3C trace context and Google Core Web Vitals! August 18, 2020 Alert analysis for Applied Intelligence Alert analysis gives you greater context for your alert violations and notifications. August 16, 2020 Ingest New Relic Logs directly with Amazon Web Services (AWS) Kinesis Data Firehose New Relic can ingest data from Amazon's Kinesis Data Firehose. Tracing the gap: AWS X-Ray integration Use New Relic with AWS X-Ray, a critical distributed tracing tool for getting visibility across your AWS services. August 10, 2020 Create Grafana dashboards with Prometheus data stored in New Relic You can create Grafana dashboards with Prometheus data stored in New Relic! July 30, 2020 Overall New Relic One experience updates We've made updates across all of New Relic One! Scheduled alert muting Schedule when you want to mute alerts to avoid messages during maintenance or deployments.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 280.907,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " with <em>NerdStorageVault</em> Store and receive sensitive third-party secrets data. October 12, 2020 Saved views for log management Save <em>your</em> table column, time range, etc. in the logs UI October 9, 2020 Alerting: Loss of signal detection and configurable gap-filling strategies Specify how long the system should wait before"
      },
      "id": "6050daaa196a6746822d164e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/whats-new/",
      "sections": [
        "What's new in New Relic"
      ],
      "published_at": "2021-04-15T21:21:00Z",
      "title": "What's new in New Relic",
      "updated_at": "2021-04-15T01:51:31Z",
      "type": "docs",
      "external_id": "49467ca3d09d7a4f1c1c69fd16be4e20050a7686",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "April 12 A simpler, more intuitive log analytics experience Check out the changes we've made to the UI to help you see details and debug faster! Create Alert Conditions From Any Chart Now you can create an alert condition from just about anywhere in New Relic! Detect patterns and outliers in log data Create queries, alerts, and dashboards using log patterns and outliers April 9 Level up at FutureStack on May 25-27! Connect with Nerds from across the globe to learn, share, and get inspired at our free, virtual event April 8 Aggregated health and activity for your Workloads New Relic Workloads are now easier to read. April 5 Guided install for Java and .NET APM agents We’ve made it simple to set up APM (Java and .NET) using our recently-launched guided installation flow, so you can instrument your systems and start analyzing your telemetry data in 5 minutes - no instrumentation expertise required. April 1 NRQL Updates You can now use Regex within your NRQL queries, and sliding time windows March 31 Amazon CloudWatch Metric Streams More metrics, more often - fill gaps in your observability with Amazon CloudWatch Metric Streams and New Relic One. FedRAMP: Logs and Metrics now certified Protecting your data is our highest priority, which is why we achieved the US Government’s rigorous FedRAMP Moderate certification in 2020. And now we’re adding support for Logs and Metrics to our long list of supported services. March 30 Kubernetes: Metric Update Moving to container_memory_working_set_bytes and away from container_memory_usage_bytes metric Slow transactions on the service Summary Quickly dive into the most time-consuming requests to your application or service March 25 Nerdlog Roundup: New Relic Lookout, Guided Install, and Open Source Docs Get real-time visibility into your stack, simplify your instrumentation, and edit our docs March 18 Nerdlog Roundup: Root Cause Analysis, Topology (Relationship-Based) Correlation, and more! Reduce your MTTR with free Automatic Proactive Anomaly Detection, find problems fast with root cause analysis, and increase context for issues using topology correlation. March 17 AIOps Made Easy: Get to root cause and respond faster Automatically find root cause and respond faster than ever March 16 Heroku cloud integration for log management Detailed log data made easier than ever Visualize log details in Dashboards with our new Logs Table Widget More flexibility and control for log message visualizations March 15 AIOps Made Easy: Cut down on alert noise Reduce alert fatigue and prioritize what’s important March 10 AIOps Made Easy: Detect unusual changes instantly Automatic proactive anomaly detection for free Nerdlog Roundup: See hosts, services, containers, and more in one view with New Relic Navigator See hundreds of entities in a compact, high-level view March 8 Nerdlog Roundup: Muting Rules, Custom Data Visualizations, and more AIOps fun! Smarter incident intelligence and custom data visualizations February 25 Nerdlog Roundup: Ingesting OpenTelemetry Data, RUM, and more Ingest OpenTelemery data and logs, drop your data, and monitor your browser performance February 24 New Relic Explorer: Say goodbye to blindspots Gain unprecedented visibility into your entire system February 19 Nerdlog Roundup: K6 Load Testing and the ServiceNow and Snowflake Integrations Keep your issues in sync, view your Snowflake and k6 performance data in New Relic One. February 11 Data Dropping update: Now, drop entire dimensional metrics Filter sensitive or low-value data February 8 Check out the Nerdlog We have a new live-stream changelog on Twitch! January 28 Agentless syslog onboarding for New Relic log management Host-based log ingestion using rsyslog or syslog-ng with a new TCP endpoint January 21 New Python agent features Python agent now auto instruments HTTPX and Django ASGI January 19 New Anomalies feed as part of AI overview page View all your anomalies in a single place January 13 New Relic Snowflake Integration New Relic now integrates with Snowflake. January 6 Schedule recurring muting rules Suppress or mute notifications with ease December 7, 2020 Recap: Top 10 new observability features you need to know Our engineers and product managers share their favorite features, capabilities, and integrations to help you be more productive and collaborative. December 1, 2020 Alerts and Applied Intelligence new landing page Surface insights with a new landing page. Percentiles now available in events-to-metrics service For the events-to-metrics service, return an attribute's approximate value at a given percentile. November 12, 2020 API keys app There's a new app for managing your API keys. New Relic Lambda extension Our new extension improves observability of your Lambda data. Share dashboards and curated views with permalinks Sharing what you’re seeing just got easier. November 10, 2020 Invite a teammate See how easy it is to invite your team to New Relic. November 9, 2020 Enhanced errors experience in New Relic One We've improved the new errors experience. November 3, 2020 Troubleshoot performance and crash issues faster with New Relic's real-time Java profiling New Relic is excited to announce the availability of real-time Java profiling using Java Flight Recorder (JFR). October 30, 2020 Build high-resolution charts using sliding windows Increase your chart resolution with rolling aggregates, powered by sliding windows. Kafka Connect: Unlock open source and alternative instrumentation sources Build observability pipelines from open source tools and alternative instrumentation sources with the New Relic connector for Kafka Connect. Veneur sink: Your pipeline to 3rd party metrics Send metrics to New Relic using our Veneur sink. October 29, 2020 Three big updates for your native mobile apps Three big updates: The New Relic iOS and tvOS agents will now be distributed as the New Relic XCFramework Agent 7.0.0. For instrumenting React Native applications, we have an experimental open source React Native Module. Plus, we’ve improved reliability from our Android service and changed the way our service handles Android stack deobfuscation. October 27, 2020 Monitor ASGI apps using the Python agent The Python agent now supports monitoring Uvicorn, Starlette, and FastAPI ASGI applications. Monitor Apollo Server GraphQL Node applications Use our Node.js agent plugin to capture executed GraphQL queries. October 15, 2020 Applied Intelligence: Better, smarter webhooks Webhooks now automatically deliver anomaly charts. October 14, 2020 New Relic One now has a new UI for OpenTelemetry Check out our APM functionality for your OpenTelemetry data. October 13, 2020 Store data in an encrypted storage solution with NerdStorageVault Store and receive sensitive third-party secrets data. October 12, 2020 Saved views for log management Save your table column, time range, etc. in the logs UI October 9, 2020 Alerting: Loss of signal detection and configurable gap-filling strategies Specify how long the system should wait before a signal is considered lost. October 7, 2020 New Relic achieves AWS Outposts Ready designation New Relic has achieved the AWS Outposts Ready designation, part of the Amazon Web Services (AWS) Service Ready Program. October 1, 2020 Applied Intelligence now features accelerated suggested decisions Reduce alert noise by using our suggested correlation decisions. September 30, 2020 Applied Intelligence: Deployment events in the issue feed Applied Intelligence now includes any relevant APM deployment data. September 29, 2020 New Relic Edge with Infinite Tracing New Relic users with Pro or Enterprise Full-Stack Observability can now access and benefit from New Relic Edge. September 11, 2020 Anomalies visible in the activity stream The activity stream shows recent events so you can quickly see what's happening in your system. September 9, 2020 Windows Logs supported Support for Windows Logs with New Relic's infrastructure agent September 4, 2020 New Relic One has dark mode! We now have dark mode! New Relic Support for Amazon Web Services (AWS) Bottlerocket Gain full visibility into your workloads and infrastructure running on AWS Bottlerocket. What's new? Your in-product destination for New Relic One updates! September 1, 2020 Issue summary and analysis in Applied Intelligence Rely on the issue summary to help you identify and resolve relevant issues. Visual issue timeline in Applied Intelligence Use our Gantt-style timeline chart to see your related events. August 26, 2020 Real-user monitoring support for W3C trace context and Google Core Web Vitals We've added support for W3C trace context and Google Core Web Vitals! August 18, 2020 Alert analysis for Applied Intelligence Alert analysis gives you greater context for your alert violations and notifications. August 16, 2020 Ingest New Relic Logs directly with Amazon Web Services (AWS) Kinesis Data Firehose New Relic can ingest data from Amazon's Kinesis Data Firehose. Tracing the gap: AWS X-Ray integration Use New Relic with AWS X-Ray, a critical distributed tracing tool for getting visibility across your AWS services. August 10, 2020 Create Grafana dashboards with Prometheus data stored in New Relic You can create Grafana dashboards with Prometheus data stored in New Relic! July 30, 2020 Overall New Relic One experience updates We've made updates across all of New Relic One! Scheduled alert muting Schedule when you want to mute alerts to avoid messages during maintenance or deployments.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.08536,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Check out our APM functionality for <em>your</em> OpenTelemetry data. October 13, 2020 Store data in an encrypted <em>storage</em> solution with <em>NerdStorageVault</em> Store and receive sensitive third-party secrets data. October 12, 2020 Saved views for log management Save <em>your</em> table column, time range, etc. in the logs UI"
      },
      "id": "60422917196a677e2fa83ddf"
    },
    {
      "image": "https://developer.newrelic.com/static/AaronSoto-d72d9bb5f5e6165751e67367612525f4.jpg",
      "url": "https://developer.newrelic.com/nerd-days/",
      "sections": [
        "Nerd Days is a free 1-day event focused on building more perfect software",
        "Register for Nerd Days 1.0",
        "What’s is Nerd Days exactly…",
        "Save the date & join us online",
        "Upcoming Nerd Days",
        "Speaker line up",
        "Aaron Soto",
        "Caitlin Halla",
        "David Shanker",
        "Jeremy Cooper",
        "Joel Worrall",
        "John Vajda",
        "Jon Thurman",
        "Justin Eveland",
        "Leon Chapman",
        "Lindsy Farina",
        "Talia Nassi",
        "Thomas Martin",
        "Alec Swanson",
        "Brian Thomason",
        "Chris Trombley",
        "Sander Blue",
        "Gabe O'Brien",
        "Liam Hurrell",
        "Michael Caron",
        "Phil Weber",
        "Sebastian Remirez",
        "Jewels Nocera",
        "Nica Fee",
        "Stijn Polfliet",
        "Brad Schmitt",
        "Eric Mittelhammer",
        "Colin MacNaughton",
        "Tracks",
        "Observability",
        "Cloud migration",
        "Open source",
        "Devops journey",
        "Fundamentals",
        "Nerd Days AMER Agenda",
        "DevOps journey",
        "Keynote: Jemiah Sius, Lew Cirne, and Special Guest Announcements",
        "Instrumenting your service using agents",
        "New Relic CLI Wizardry",
        "5 Steps to Kubernetes Observability",
        "Delivering SRE as a Service",
        "Building applications on New Relic One",
        "Exploring your data using NRQL",
        "New Relic AI",
        "Going Serverless: Chipping at the monolith",
        "Logging for Modern Organizations",
        "Power up your Prometheus metrics with the Telemetry Data Platform",
        "Lunch with Lew",
        "Custom Instrumentation",
        "Exploring Data with NerdGraph",
        "Consolidating Your Data with New Relic’s Telemetry Data Platform",
        "Testing in Production",
        "How Open Source powers the New Relic One Catalog",
        "Alerts Best Practices",
        "The Art & Science of Deciphering Perceived Performance: A look at how user behavior affects your data",
        "Monitoring your Cloud Usage and Spend",
        "Scaling the Developer Toolkit Team: Writing Code that Writes Code",
        "Reducing toil with Terraform",
        "True availability using Synthetics",
        "How Observability-Driven Development accelerates DevOps transformations",
        "AWS Modernization",
        "Writing Reliably Bad Software, AKA 'How to get paid to write memory leaks'",
        "NerdStorageVault: ThirdParty Secrets",
        "Closing + Swag",
        "Engage with the developer community"
      ],
      "published_at": "2021-04-20T01:56:27Z",
      "title": "New Relic Developers",
      "updated_at": "2020-11-04T01:52:48Z",
      "type": "developer",
      "external_id": "0b8374051901a77e242ce296c00eeb3c760439d1",
      "document_type": "page",
      "popularity": 1,
      "body": "Nerd Days is a free 1-day event focused on building more perfect software Register for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region) What’s is Nerd Days exactly… A FREE developer focused live digital conference covering a broad range of topics at varying levels for all skill sets. Including: Live workshops Live coding and demos Customer examples Panel / Q&A sessions Presented by Relics, partners, Developer Champions, and customers Save the date & join us online Whether you’re new or a data nerd, there’s an interactive session for you. Choose the sessions you're interested in and add Nerd Days to your calendar. Date: October 13, 2020 Time: 9AM PST - 3PM PST We look forward to building with you during Nerd Days! If you have any questions about Nerd Days please emails deco@newrelic.com. Upcoming Nerd Days EMEA RegistrationNov 10, 2020 Speaker line up Get hands on with sessions presented by the following Relics, partners, Developer Champions, and customers. Aaron Soto Sr. Partner Solutions Architect AWS Caitlin Halla Software Engineer New Relic David Shanker Director, Platform Engineering Kinect Consulting Jeremy Cooper Sr. TechOps Strategy Consultant New Relic Joel Worrall Director, Open Source and Developer Advocacy New Relic John Vajda Senior Product Manager New Relic Jon Thurman Senior Solutions Consultant New Relic Justin Eveland Software Engineer New Relic Leon Chapman Senior TechOps Strategy Consultant New Relic Lindsy Farina Senior Product Manager New Relic Talia Nassi Developer Advocate Split Software Thomas Martin Director, Site Reliability 27 Global Alec Swanson Software Engineer New Relic Brian Thomason Senior Partner Solutions Consultant New Relic Chris Trombley Senior Software Engineer New Relic Sander Blue Senior Software Engineer New Relic Gabe O'Brien Senior Software Engineer New Relic Liam Hurrell Senior Technical Training Specialist New Relic Michael Caron Senior Technical Training Specialist New Relic Phil Weber Senior Technical Training Specialist New Relic Sebastian Remirez Lead Software Engineer New Relic Jewels Nocera Senior Software Engineer New Relic Nica Fee Developer Advocate New Relic Stijn Polfliet Principal TechOps Strategy Consultant New Relic Brad Schmitt Senior TechOps Strategy Consultant New Relic Eric Mittelhammer Senior TechOps Strategy Consultant New Relic Colin MacNaughton Lead Software Engineer New Relic Tracks Tracks will vary by region. All sessions will be recorded and distributed after the event. Observability Cloud migration Open source Devops journey Fundamentals Nerd Days AMER Agenda We’ve got a packed schedule with thought-leaders of their respective industries Fundamentals Observability Cloud migration DevOps journey Open source 9:00AM PST Keynote: Jemiah Sius, Lew Cirne, and Special Guest Announcements Lew Cirne 10:00AM PST Instrumenting your service using agents Michael Caron New Relic CLI Wizardry Jon Thurman 5 Steps to Kubernetes Observability Stijn Polfliet & Brad Schmitt Delivering SRE as a Service Thomas Martin Building applications on New Relic One Joel Worrall 11:00AM PST Exploring your data using NRQL Phil Weber New Relic AI Sebastian Ramirez Going Serverless: Chipping at the monolith Nica Fee Logging for Modern Organizations Jeremy Cooper & Leon Chapman Power up your Prometheus metrics with the Telemetry Data Platform Liam Hurrell & Colin MacNaughton 12:00PM PST Lunch with Lew Lew Cirne & Jemiah Sius 1:00PM PST Custom Instrumentation Michael Caron Exploring Data with NerdGraph Caitlin Halla Consolidating Your Data with New Relic’s Telemetry Data Platform Eric Mittelhammer Testing in Production Talia Nassi How Open Source powers the New Relic One Catalog Justin Eveland 2:00PM PST Alerts Best Practices Phil Weber The Art & Science of Deciphering Perceived Performance: A look at how user behavior affects your data Lindsy Farina Monitoring your Cloud Usage and Spend Jewels Nocera Scaling the Developer Toolkit Team: Writing Code that Writes Code Sander Blue Reducing toil with Terraform Jon Thurman 3:00PM PST True availability using Synthetics Michael Caron How Observability-Driven Development accelerates DevOps transformations Dave Shanker AWS Modernization Aaron Soto & Brian Thomason Writing Reliably Bad Software, AKA 'How to get paid to write memory leaks' Gabe O’Brien & Alec Swanson NerdStorageVault: ThirdParty Secrets John Vajda 4:00PM PST Closing + Swag Jemiah Sius Engage with the developer community @newrelic New Relic Forum Developers Hopin logo Event powered by Hopin",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 207.55356,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Nerd</em> Days is a free 1-day event focused on building more perfect software",
        "body": " transformations Dave Shanker AWS Modernization Aaron Soto &amp; Brian Thomason Writing Reliably Bad Software, AKA &#x27;How to get paid to write memory leaks&#x27; Gabe O’Brien &amp; Alec Swanson <em>NerdStorageVault</em>: ThirdParty Secrets John Vajda 4:00PM PST Closing + Swag Jemiah Sius Engage with the developer community @newrelic New Relic Forum Developers Hopin logo Event powered by Hopin"
      },
      "id": "5f3dd5bf28ccbc2349f56e4e"
    }
  ],
  "/build-apps/ab-test/version-descriptions": [
    {
      "sections": [
        "ISpan",
        "Syntax",
        "Description",
        "AddCustomAttribute",
        "Parameters",
        "Returns",
        "Usage considerations",
        "Examples"
      ],
      "title": "ISpan",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "d2a095fb3000fc46c42ea24c1450b3a586c13e26",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/net-agent-api/ispan/",
      "published_at": "2021-04-16T05:33:29Z",
      "updated_at": "2021-03-11T08:04:14Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax Public interface ISpan Copy Provides access to span-specific methods in the New Relic API. Description Provides access to span-specific methods in the New Relic .NET agent API. To obtain a reference to ISpan, use: The CurrentSpan property on IAgent (Recommended). The CurrentSpan property on ITransaction. This section contains descriptions and parameters of ISpan methods: Name Description AddCustomAttribute Add contextual information from your application to the current span in form of attributes. AddCustomAttribute Adds contextual information about your application to the current span in the form of attributes. This method requires .NET agent version and .NET agent API version 8.25 or higher. Syntax ISpan AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current span. Usage considerations For details about supported data types, see the Custom Attributes guide. Examples IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ISpan currentSpan = agent.CurrentSpan; currentSpan .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.00656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Description</em>",
        "body": " on ITransaction. This section contains <em>descriptions</em> and parameters of ISpan methods: Name Description <em>Add</em>CustomAttribute <em>Add</em> contextual information from your application to the current span in form of attributes. <em>Add</em>CustomAttribute Adds contextual information about your application to the current span"
      },
      "id": "6044129664441f542c378ed3"
    },
    {
      "sections": [
        "Update the home page",
        "Update a link's URL",
        "Add a new tile to the home page",
        "Add a new section to the home page"
      ],
      "title": "Update the home page",
      "type": "docs",
      "tags": [
        "home page",
        "landing pages"
      ],
      "external_id": "d637697a72493d8dbe0c9538e5b35f13f62d7474",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/edit-homepage/",
      "published_at": "2021-04-16T01:37:41Z",
      "updated_at": "2021-04-11T08:27:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can't just hit the edit button docs.newrelic.com to make edits to the home page. The page that opens is index.js, the file that manages the parts of the home page, but not the content. It's rare that you'll need to make changes to this file. Most home page changes will be to add a new tile or section to the page, or update links. These types of changes are handled in two files: src/data/homepage.yml - contains home page section titles, section descriptions, and the URLs for tiles. src/i18n/translations/en/translation.json - contains tile info, including the title and short description of tiles. Update a link's URL Change or add new links using homepage.yml. In homepage.yml, search for the link you want to change. Edit the URL, save, commit, and PR the change. Add a new tile to the home page You'll make changes to both homepage.yml and translations.json On the translations.json doc, find the spot where you want to add the new tile (which section, and in what order you want it to appear), and add a new entry with this format: \"t#\": { \"title\": \"tile name\", \"description\": \"Short description.\" }, Copy Make sure you update the number on the tile. If you want to insert it in the middle of a group, update all the subsequent tile numbers as well. Save the file. Open homepage.yml, find the spot where the new tile will be, and add a new line with the relative link for the new tile. For example, - /docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster Save and check that your new tile builds properly on a local build. Commit, push, PR when you're ready. Add a new section to the home page On the translations.json page, add a new section modeled in the spot where you want the new section to appear. Include at least one title. For example, here's the TDP entry, with one tile: \"tdp\": { \"title\": \"Telemetry Data Platform\", \"description\": \"Ingest, visualize, and alert on all your telemetry data in one place.\", \"t1\": { \"title\": \"Introduction to Telemetry Data Platform\", \"description\": \"How to manage all your monitoring in one place.\" }, Copy When you're done creating the info, save the file. In the homepage.yml page, find the corresponding location for the new section, and add the short name you provided in the translation.json file, title, description, and tile URLs. For example, here's the corresponding TDP section on homepage.yml. tdp: title: Telemetry Data Platform description: Ingest, visualize, and alert on all your telemetry data in one place. tiles: - /docs/data-ingest-apis/get-data-new-relic/getting-started/get-started-telemetry-data-platform Copy Save, build locally, commit, PR.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.97591,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> a new tile to the home page",
        "body": "You can&#x27;t just hit the edit button docs.newrelic.com to make edits to the home page. The page that opens is index.js, the file that manages the parts of the home page, but not the content. It&#x27;s rare that you&#x27;ll need to make changes to this file. Most home page changes will be to <em>add</em> a new tile"
      },
      "id": "6072b300e7b9d231b2a5c663"
    },
    {
      "sections": [
        "Amazon ElastiCache monitoring integration",
        "Features",
        "Activate integration",
        "Configuration and polling",
        "Find and use data",
        "Metric data",
        "Standard ElastiCache data",
        "Tip",
        "Redis-specific ElastiCache data",
        "Memcached-specific ElastiCache data",
        "Inventory data"
      ],
      "title": "Amazon ElastiCache monitoring integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "Amazon integrations",
        "AWS integrations list"
      ],
      "external_id": "32f4adc526f74a05b541691ab1b1ba2b5df39f3e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/amazon-integrations/aws-integrations-list/aws-elasticache-monitoring-integration/",
      "published_at": "2021-04-16T17:44:48Z",
      "updated_at": "2021-03-11T10:45:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic infrastructure integrations include an integration for reporting your Amazon ElastiCache data to New Relic. This document explains how the integration works and what data can be reported. Features Amazon ElastiCache is a web service that makes it easy to deploy, operate, and scale an in-memory data store or cache in the cloud. New Relic's ElastiCache integration reports data from your Amazon ElastiCache instances, including CPU data, bytes in and out, memory, and data specific to the Redis and Memcached services. New Relic integrations give you the ability to create alert conditions for your data, as well as query and create charts in New Relic One. Activate integration To enable this integration follow standard procedures to Connect AWS services to New Relic. Configuration and polling You can change the polling frequency and filter data using configuration options. Default polling information for the Amazon ElastiCache integration: New Relic polling interval: 5 minutes Amazon CloudWatch data interval: 1 minute or 5 minutes Find and use data To find this integration's data, go to one.newrelic.com > Infrastructure > AWS and select one of the ElastiCache integration links. You can query and explore your data using the DatastoreSample event type, with a provider value of ElastiCacheRedisNode, ElastiCacheRedisCluster, or ElastiCacheMemcachedNode. For more on how to find and use integration data, see Understand integration data. Metric data Standard ElastiCache data This integration collects the following data from all ElastiCache instances: Tip For full descriptions, see Amazon ElastiCache Metrics and Dimensions. Name Data type CPUUtilization percent CpuCreditUsage count CpuCreditBalance count DatabaseMemoryUsagePercentage percent FreeableMemory bytes NetworkBytesIn bytes NetworkBytesOut bytes SwapUsage bytes Redis-specific ElastiCache data This integration collects the following information from Redis instances, in addition to the standard ElastiCache data. Tip For full descriptions, see Amazon ElastiCache Metrics for Redis. Name Data type BytesUsedForCache bytes CacheHits integer CacheHitRate percent CacheInteger integer CacheMisses integer CurrConnections integer CurrItems count Db0AverageTtl integer (milliseconds) EvalBasedCmds count EvalBasedCmdsLatency integer (microseconds) Evictions integer GeoSpatialBasedCmds count GeoSpatialBasedCmdsLatency integer (microseconds) GetTypeCmds count GetTypeCmdsLatency integer (microseconds) HashBasedCmds count HashBasedCmdsLatency integer (microseconds) HyperLogLogBasedCommands integer HyperLogLogBasedCmdsLatency integer (microseconds) KeyBasedCmds count KeyBasedCmdsLatency integer (microseconds) ListBasedCmds count ListBasedCmdsLatency integer (microseconds) MasterLinkHealthStatus integer MemoryFragmentationRatio integer NewConnections integer PubSubBasedCmds count PubSubBasedCmdsLatency integer (microseconds) Reclaimed integer ReplicationBytes bytes ReplicationLag integer (seconds) SaveInProgress integer SetBasedCmds count SetBasedCmdsLatency integer (microseconds) SetTypeCmds count SetTypeCmdsLatency integer (microseconds) SortedSetBasedCmds count SortedBasedCmdsLatency integer (microseconds) StreamBasedCmdsLatency integer (microseconds) StringBasedCmds count StringBasedCmdsLatency integer (microseconds) Memcached-specific ElastiCache data This integration collects the following data from Memcached instances, in addition to the standard ElastiCache data. Tip For full descriptions, see Amazon ElastiCache Metrics for Memcached. Name Data type bytesReadIntoMemcached bytes bytesusedForCacheItems bytes bytesWrittenOutFromMemcached bytes casBadval count casHits count casMisses count cmdFlush count cmdGet count cmdSet count decrHits count decrMisses count deleteHits count deleteMisses count getHits count getMisses count incrHits count incrMisses count bytesUsedForHash bytes cmdConfigGet count cmdConfigSet count cmdTouch count currConfig count evictedUnfetched count expiredUnfetched count slabsMoved count touchHits count touchMisses count newItems count unusedMemory bytes Inventory data This integration reports ElastiCache configuration options as inventory data. For more about inventory data, see Understand integration data. Tip For full descriptions, see Amazon ElastiCache Snapshot. Name Data type autoMinorVersionUpgrade boolean awsRegion string cacheNodeType string engine string engineVersion string numCacheNodes integer preferredAvailabilityZone string replicationGroupId string snapshotRetentionLimit integer (days)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.380775,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " inventory data, see Understand integration data. Tip For full <em>descriptions</em>, see Amazon ElastiCache Snapshot. Name Data type autoMinor<em>Version</em>Upgrade boolean awsRegion string cacheNodeType string engine string engine<em>Version</em> string numCacheNodes integer preferredAvailabilityZone string replicationGroupId string snapshotRetentionLimit integer (days)"
      },
      "id": "6044aa46e7b9d22e105799c2"
    },
    {
      "sections": [
        ".NET agent install resources",
        "Important",
        "Microsoft's .NET profiler",
        ".NET agent download library",
        "Zip files for manual .NET agent install (Windows)",
        "Caution",
        ".NET Framework environment variables for manual install",
        ".NET Core environment variables for manual install",
        "Need for custom instrumentation",
        "Install-related environment variables",
        "Scriptable installers (Windows only)",
        "Scriptable installer for .NET Framework",
        "Tip",
        "Scriptable installer for .NET Core",
        "Local install",
        "Global install"
      ],
      "title": ".NET agent install resources",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "15e6347108ca11e12ccb535fb9fc3fa90d3f4a40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/net-agent-install-resources/",
      "published_at": "2021-04-15T22:15:59Z",
      "updated_at": "2021-03-16T02:42:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains detailed descriptions of resources and procedures that are referenced in the New Relic .NET agent install procedures. Important This document is not meant to be read as a standalone document. For install instructions, see Introduction to .NET agent install. Microsoft's .NET profiler New Relic’s .NET agent relies on the Microsoft profiling API to report data from your .NET application. .NET monitoring solutions other than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .NET monitoring service in the past and haven’t completely disabled/removed it, the profiler may still be in use, which will cause profiler conflicts when you try to enable the .NET agent. .NET agent download library The New Relic .NET agent download library contains install file packages that are referenced in specific install procedures. For more on these files, see the download library’s ReadMe file. Zip files for manual .NET agent install (Windows) To manually install the agent using a ZIP file, choose the correct file for the application you wish to monitor: Go to the .NET agent download site and get the file matching your application's runtime and architecture: .NET Framework (32-bit): newrelic-agent-win-x86-VERSION.zip .NET Framework (64-bit): newrelic-agent-win-x64-VERSION.zip .NET Core (32-bit): newrelic-netcore20-agent-win-x86-VERSION.zip .NET Core (64-bit): newrelic-netcore20-agent-win-x64-VERSION.zip Unzip the agent folder in the desired location. Set environment variables for the process you wish to monitor. Caution We do not recommend setting these environment variables globally. Setting these environment variables globally can cause all .NET processes running on the system to get instrumented and report to New Relic. If you are installing the agent manually, we expect that you have the means to set these environment variables only for the processes you wish to monitor. .NET Framework environment variables for manual install For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_HOME=path\\to\\agent\\directory COR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy .NET Core environment variables for manual install For .NET Core, the following variables are required: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory CORECLR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy Restart your application. If using IIS, restart IIS. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Need for custom instrumentation After installing a .NET agent, most .NET application frameworks will automatically report data to your New Relic account. (See app framework compatibility: .NET Framework | .NET Core.) If your .NET application uses an application framework that is not automatically instrumented, or if the app has no framework (like a console app), after the install you will need to manually set up instrumentation of your app. Here are the steps to do that: Follow the relevant install instructions for your application and framework. Custom instrument your application to define what activity is reported to New Relic. Install-related environment variables A .NET agent install requires setting environment variables. For some install procedures (like for IIS-hosted .NET applications), these environment variables are set automatically. For other install procedures, you will have to manually set them. To see the required environment variables for both .NET Framework and .NET Core applications, see Environment variables. For installations requiring you to manually set environment variables, you can also set other configuration options via environment variables. Here's a look at two that are commonly set: License key. The environment variable for setting the New Relic license key is: NEW_RELIC_LICENSE_KEY = YOUR_LICENSE_KEY Copy You can also set this in the newrelic.config file or the app's config file. App name. Setting a meaningful application name is recommended, but you can also set this after install. The environment variable is: NEW_RELIC_APP_NAME = YOUR_APP_NAME Copy You can also set this via the newrelic.config, the app's config file, or the API. Scriptable installers (Windows only) The scriptable installers are ZIP archives containing a PowerShell script for installing the .NET agent. There is a separate zip archive for .NET Framework versus .NET Core. Important We recommend using the MSI installer over the scriptable installer. If you want to automate your install, consider running the MSI installer from the command line. Scriptable installer for .NET Framework To use the scriptable installer to install the .NET agent for a .NET Framework app: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation. Download the scriptable installer package for .NET Framework from the download site. By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package. Open a command shell and navigate into the unzipped package's folder. For a simple install with no options, use this command: .\\install.cmd -LicenseKey YOUR_LICENSE_KEY Copy To install with one or more additional options, use the format below. See table below for a description of the install options. install.cmd -LicenseKey YOUR_LICENSE_KEY [-NoIISReset] [-InstrumentAll] [-InstallPath PATH_TO_INSTALL] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description LicenseKey Required. Your New Relic license key. NoIISReset Optional. Use this option to prevent the installer from initiating an IIS reset. Important If you use this option, you need to do an IIS reset manually before New Relic starts instrumenting any IIS-hosted applications. InstrumentAll Optional. By default, the .NET agent will instrument all IIS-hosted applications. Use this option to enable instrumentation of other types of .NET applications. InstallPath Optional. Use this option to choose a different installation location. The default install location is C:\\Program Files\\New Relic. Uninstalling the agent with the scriptable uninstaller: Tip You can add the Force option to the uninstall script to force an uninstall without prompting to restart IIS. Execute the following command to uninstall the .NET Framework agent: .\\uninstall.cmd Copy Scriptable installer for .NET Core Important Before installing the agent: Understand the agent requirements, including the permissions requirements. Note that admin rights in an elevated shell are required (specifically for selecting a custom log directory and performing an IISReset). Caution For security reasons, it is necessary to execute the installAgent.ps1 script as shown below, by prepending ./ to the script filename, rather than by prepending powershell to the script. If you execute the script by prepending powershell, and any of your supplied arguments (e.g. the install path or custom log path) have spaces in them, these arguments will be corrupted, which would lead to the agent being installed to a location other than the intended location, which could be unsecure. To use the scriptable installer to install the .NET agent for a .NET Core application: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation Download the .NET Core agent's scriptable installer package from the .NET agent download site . By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package in the desired location. Open a command shell and navigate into the unzipped package's folder. You can install the agent either locally or globally: Local install For a simple install, with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy Global install Important The global install will instrument all .NET Core processes on your system. Only choose the global install if you want all .NET Core processes monitored. For a simple install with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description Destination Required. The location where the agent is installed. This can be an absolute or relative path. Wrapping quotes are required. InstallType Required. Determines whether this is a local (app-specific) or global (system-wide) install. LicenseKey Required. Your New Relic license key. AppName Optional. Sets the default application name associated with your agent installation. LogDir Optional. Sets a custom logging location for the agent. By default, the agent puts the logs directory in the install directory. X86 Optional. Installs the 32-bit version of the agent rather than the 64-bit version. New Relic does not recommend installing the 32-bit version of the agent globally. ResetIIS Optional. Performs an iisreset after the installation. Important Only use this if your .NET Core app is hosted via an IIS reverse proxy. Force Optional. Forces the installation process to overwrite a previous install or to install into an existing folder. Caution This overwrites any configuration customizations. New Relic recommends backing up your configuration file and any custom instrumentation files prior to forcing an over-install. Help Optional. Displays usage information for this script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 70.127304,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "This document contains detailed <em>descriptions</em> of resources and procedures that are referenced in the New Relic .NET agent install procedures. Important This document is not meant to be read as a standalone document. For install instructions, see Introduction to .NET agent install. Microsoft&#x27;s .NET"
      },
      "id": "603eb8ba28ccbc3daceba773"
    },
    {
      "sections": [
        "Introduction to New Relic's REST API Explorer",
        "Features",
        "Differences from API version 1",
        "Tip",
        "For more help"
      ],
      "title": "Introduction to New Relic's REST API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "457d31007ab690d5e6f3679e150814c280b49441",
      "image": "https://docs.newrelic.com/static/c506cb08149178347d12b6cbb236c855/23592/API_explorer_main_page.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/introduction-new-relics-rest-api-explorer/",
      "published_at": "2021-04-16T14:53:48Z",
      "updated_at": "2021-03-11T11:44:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several APIs, including the New Relic REST API. This document introduces you to the REST API Explorer, which allows admin users and those with the API Key to: Browse the available REST API endpoints. Interact with the REST API within a user interface (the API Explorer). View a live source of documentation. Obtain curl commands for API actions. Share configured API calls with colleagues by copy and pasting API Explorer's URLs. This helps you to quickly search for solutions and test your API calls before adding them to your own software components. Features New Relic's API Explorer includes an interactive user interface for your selected account. The API Explorer UI lists the types of API calls (Applications, Users, etc.) and their available functions, such as GET metric data, PUT (update) applications, DELETE applications, etc. As you type values for Parameters, they automatically appear in the Request so that you can test and verify your syntax before sending the request. The UI indicates required fields, field descriptions, their type (integer, float, Boolean, etc.), and their location (path, query, etc.). For information on API keys, see REST API keys. https://rpm.newrelic.com/api/explore: The New Relic API Explorer makes it easy to test and send requests for any API endpoint. After you select your account and your choice of functions for the type of API call (applications, browsers, users, etc.), the UI provides an interactive form to view requirements and test your parameter values. Differences from API version 1 This API Explorer applies only to the New Relic REST API version 2, which focuses on data in and data out of New Relic. Version 2 replaces New Relic's deprecated REST API version 1. Be aware there are some differences between version 2 and 1: Names for data may be different. Some cURL commands for v2 are different than v1. Tip The New Relic agents use different APIs and are not accessible via the API Explorer. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.182175,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Differences from API <em>version</em> 1",
        "body": ", they automatically appear in the Request so that you can test and verify your syntax before sending the request. The UI indicates required fields, field <em>descriptions</em>, their type (integer, float, Boolean, etc.), and their location (path, query, etc.). For information on API keys, see REST API keys. https"
      },
      "id": "6043ff97196a67c2f2960f65"
    }
  ],
  "/build-apps/ab-test/nerdstorage": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programability_browser_analyze_1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-developers-guide-roundup",
      "sections": [
        "Intro to New Relic One SDK",
        "New Relic One CLI",
        "Intro to NerdStorageVault - New Feature!",
        "Create a \"Hello, World\" app",
        "Practice diagnosing common issues using New Relic",
        "Get coding and get inspired",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:23:24Z",
      "title": "New Relic Developers Guide Roundup",
      "updated_at": "2021-04-13T23:23:31Z",
      "type": "",
      "external_id": "9322d4fbb3dbbeb84cc7c3f26c9cc2c275e3a11d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Relic Developers Guide Roundup Jan 5, 2021 • 7 min read By Vi Tran When we first launched our programmable platform, one of our executives envisioned a simple way to visualize customer experience and satisfaction scores. He sent the following sketch to an engineer: Two days later, he had a production-ready application, built on New Relic One, that showed not just what the customer experience scores were, but what they should be. The browser analyzer application This New Relic One application is called the browser analyzer—it’s open source and available for you to use today. But now it’s your turn to go from sketch to app. We’ve given you the same tools our own engineers use, so you can build and deploy applications in New Relic One that connect your observability data, gathered from myriad sources—including third-party open source data—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK The New Relic One SDK provides the necessary components you need to build New Relic One applications. Components of the SDK include: React UI components for controlling text and layout in a New Relic One application Chart components for representing different types of charts Query and storage components for fetching and storing New Relic data Platform APIs that enable your application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build your applications, create visualizations, and fetch New Relic or third-party data. New Relic One CLI In addition to the SDK, you’ll need the New Relic One CLI to build apps on the platform. You’ll use the CLI to build, publish, and manage your app. More specifically, you’ll use the CLI to do the following: Generate Nerdpack/Nerdlet templates—(a Nerdpack is a package containing all the files needed by an application; a Nerdlet is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Intro to NerdStorageVault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store your data. NerdStorageVault lets you store and retrieve sensitive data secrets such as: Personal access tokens License keys API keys Other third-party secrets You can explore NerdStorageVault fields and response types with the NerdGraph API explorer. NerdStorageVault is encrypted with AES-256 encryption. In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes. Check out the guide for more information. Create a \"Hello, World\" app In this guide, you’ll build a \"Hello, World!\" application in New Relic One in nine quick steps. You’ll create a local version of the New Relic One site where you can prototype your application, and when you're ready to share the application with others, you can publish it to New Relic One. [embed]https://www.youtube.com/watch?v=7omo0qHxku8&feature=youtu.be[/embed] To get started, make sure you have accounts in GitHub and New Relic. You’ll also need to install Node.js and familiarize yourself with the New Relic One CLI. Tip: Check out Set up your development environment to make sure you have everything in order before you jump in. Practice diagnosing common issues using New Relic Every time you deploy an application, you hope that it's efficient and free of errors. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled demo environment. Acme Telco Lite is a telecom business that maintains an e-commerce website for its customers. The site's architecture has eight interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. Check out the full guide for more on prerequisites and deployment details. Get coding and get inspired Explore more guides and tutorials on New Relic Developers, because we’re constantly adding content. Best of all? The site is built completely in open source—feel free to submit a pull request while you’re there. Related Topics Extend New Relic By Vi Tran Vi Tran is a Senior Product Marketing Manager for Developer Ecosystem at New Relic. Her focus is on growing and enabling the developer ecosystem to extend New Relic One. Before New Relic, she was on the global strategic alliances team at Splunk and was a management consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.637,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro to <em>NerdStorageVault</em> - New Feature!",
        "body": " to the catalog Intro to <em>NerdStorage</em>Vault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store <em>your</em> data. <em>NerdStorage</em>Vault lets you store and retrieve sensitive data secrets such as: Personal <em>access</em> tokens License keys API keys Other third-party"
      },
      "id": "607627f464441f7e2b9d8537"
    },
    {
      "image": "https://opensource.newrelic.com/static/New_Relic_One_Catalog_Project-044e387f68b03896ff65f46edcffb1f3.png",
      "url": "https://opensource.newrelic.com/oss-category/",
      "sections": [
        "Categories",
        "Community Project",
        "Requirements",
        "Community Plus",
        "New Relic One Catalog",
        "Example Code",
        "New Relic Experimental",
        "Archived"
      ],
      "published_at": "2021-04-20T01:56:53Z",
      "title": "New Relic Open Source Categories",
      "updated_at": "2021-03-20T01:49:06Z",
      "type": "opensource",
      "external_id": "87c1876d27bdde7fb6636382fb5e659ae47c496a",
      "document_type": "page",
      "popularity": 1,
      "info": "",
      "body": "External Projects Highlighted Projects New Relic Projects Standards Menu External Projects Highlighted Projects New Relic Projects Standards Categories Community Project Community Plus New Relic One Catalog Example Code New Relic Experimental Archived For the code snippets that appear in the project's README file, see this documentation. Community Project This code is developed in the open with input from the community through issues and PRs. There is an active maintainer team within New Relic, troubleshooting support in the New Relic Explorers Hub, and the documentation is available in the project repository. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Has active maintainer / maintainers, including at least one Relic Troubleshooting support via the New Relic Explorers Hub Issues and PR’s managed in GitHub Documentation reviewed by the New Relic documentation team Linted code An automated release pipeline Community Plus This code is developed in the open with input from the community through issues and PRs. A New Relic engineering team serves as the maintainer. Troubleshooting support is available in the New Relic Explorers Hub, and documentation is available in the project repository and docs.newrelic.com. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Is maintained by a New Relic engineering team Troubleshooting support via the New Relic Explorers Hub Issues and PR’s managed in GitHub For additional details on support options, see the Open Source Support Policy Documentation reviewed by the New Relic documentation team Linted code An automated release pipeline New Relic One Catalog This code is a part of the New Relic One Catalog. It meets the criteria for a Community Project; but it also contains UI workflows for configuration. Most Catalog projects seek to maintain a public roadmap, often expressed in a GitHub Project board and Issues within the repository. Requirements All the requirements of a Community Project An empty state application workflow that guides users through the setup of configuration data that is stored in NerdStorage Architectural review (including UX) by New Relic (Optional) maintains a public roadmap (recommended via a GitHub project in the repo) Example Code This code demonstrates an aspect of building on the New Relic One platform. Find the complete description of its usage and other relevant docs in the README. There is no long-term maintainer for this code nor is support provided, but the author(s) may address future updates / needs as platform features change. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file (optional) Issues are available at the project author's discretion Documentation reviewed by the New Relic documentation team Linted code New Relic Experimental This code solves an interesting problem but does not yet have an active maintainer(s). The project is being developed in the open for the purpose of feedback on a new feature or function. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Typically hosted in the New Relic Experimental GitHub org (Optional) Issues at the project owner's discertion Archived This code is read-only. There is neither a maintainer team nor support. Requirements Complies with New Relic's legal requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Previous references to Support should be modified or removed from the README Project is read-only and available for cloning only",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.8989,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " roadmap, often expressed in a GitHub Project board and Issues within the repository. Requirements All the requirements of a Community Project An empty state application workflow that guides users through the setup of configuration data that is stored in <em>NerdStorage</em> Architectural review (including"
      },
      "id": "5f31822228ccbc916988dff8"
    },
    {
      "image": "https://newrelic.com/sites/default/files/2021-04/kubernetes-background-min_2.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/how-to-use-kubernetes-volumes",
      "sections": [
        "About Kubernetes volumes",
        "Working with volumes",
        "Working with persistent volumes",
        "Wrapping up",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:05:35Z",
      "title": "Kubernetes Fundamentals, Part 5: Working with Kubernetes Volumes",
      "updated_at": "2021-04-13T23:26:43Z",
      "type": "",
      "external_id": "c01178efe6ec0a04b34c33b89108a5ed74c0a9c6",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Kubernetes Monitoring Kubernetes Fundamentals, Part 5: Working with Kubernetes Volumes Oct 26, 2020 • 7 min read This is the final installment of a five-part series on Kubernetes Fundamentals. There are many advantages to using containers to run applications. However, ease of storage is certainly not one of them. To do its job, a container must have a temporary file system. But when a container shuts down, any changes made to its file system are lost. A side effect of easily fungible containers is that they lack an inherent concept of persistence. While Docker has solved this issue with mount points from the host, on Kubernetes we face more difficulties along the way. The smallest deployable unit of computing in Kubernetes is a Pod. Multiple instances of a Pod may be hosted on multiple physical machines. Even worse, different containers might run in the same Pod but access the same storage. In this post, we’ll discuss two tools Kubernetes offers to help solve storage issues: volumes and persistent volumes. We’ll cover how and why you’d use each. About Kubernetes volumes Volumes offer storage shared between all containers in a Pod. This allows you to reliably use the same mounted file system with multiple services running in the same Pod. This is, however, not automatic. Containers that want to use a volume have to specify which volume they want to use, and where to mount it in the container’s file system. Additionally, volumes come with a clearly defined lifetime. They are bound to the lifecycle of the Pod they belong to. As long as the Pod is active, the volume is there, too. However, when you restart the Pod, the volume gets reset. If this is not what you want, you should either use persistent volumes (discussed in the next section) or change your application's logic to accommodate this behavior appropriately. While Kubernetes only cares about the formal definition of a volume, you also need to have a real (physical) file system allocated somewhere. This is where Kubernetes goes beyond what Docker offers. While Docker only maps a path from the host to the container, Kubernetes allows essentially anything as long as there is a proper provider for the storage. You could use cloud options such as Amazon Elastic Block Store (EBS) or Azure Blob Storage, or open-source solutions such as Ceph. Using something as simple and generic as NFS is possible, too. If you want to use something similar to Docker’s mount path, you can fall back to the hostPath volume type. So how do you create these volumes? You do so in the Pod definition. Working with volumes For example, consider creating a new Pod called sharedvolumeexample using two containers—both just sleeping. Using the volumes key, you can describe your volumes to be used within the containers. kind: Pod apiVersion: v1 metadata: name: sharedvolumeexample spec: containers: - name: c1 image: centos:7 command: - \"bin/bash\" - \"-c\" - \"sleep 10000\" volumeMounts: - name: xchange mountPath: \"/tmp/xchange\" - name: c2 image: centos:7 command: - \"bin/bash\" - \"-c\" - \"sleep 10000\" volumeMounts: - name: xchange mountPath: \"/tmp/data\" volumes: - name: xchange emptyDir: {} To use a volume in a container, you need to specify volumeMounts as shown above. The mountPath key describes the volume access path. To demonstrate how this shares the volume between the two containers, let’s run a little test. First, you should create the Pod from the spec (for example, sharedvolumeexample.yml): kubectl apply -f sharedvolumeexample.yml Then, you can access the terminal on the first container, c1, using kubectl: kubectl exec -it sharedvolumeexample -c c1 -- bash Next, write some data into a file under the /tmp/xchange mount point: echo 'some data' > /tmp/xchange/file.txt Let’s open another terminal, connecting to the container called c2. kubectl exec -it sharedvolumeexample -c c2 -- bash The difference is that this time you read from its mounted storage at /tmp/data: cat /tmp/data/file.txt This yields “some data,” as expected. Now you can remove the Pod: kubectl delete pod/sharedvolumeexample Working with persistent volumes When (regular) volumes don’t meet your needs, you can switch to a persistent volume. A persistent volume is a storage object that lives at the cluster level. As a result, its lifetime isn’t tied to that of a single Pod, but rather to the cluster itself. A persistent volume makes it possible to share data between Pods. One advantage of a persistent volume is that it can be shared not only between containers of a single Pod but also among multiple Pods. This means persistent volumes can be scaled by expanding their size. Reducing size, however, is not possible. A persistent volume offers the same options for selecting the physical provider as a regular volume. Provisioning, however, is a bit different. There are two ways to provision a persistent volume: Statically: You already allocated everything on the storage side. Nothing to be done. The physical storage behind will always be the same. Dynamically: You may want to extend the available storage space when the demand grows. The demand is settled via a volume claim resource, which we’ll discuss in a bit. To enable dynamic storage provisioning, you have to enable the DefaultStorageClass admission controller on the Kubernetes API server. For growing systems with demand increase backed by scalable resources, dynamic provisioning makes more sense. Otherwise, we recommend staying with the simpler static provisioning. Let’s try to create a persistent volume for a hostPath backed storage. Note that instead of configuring kind as Pod, we instead configure as PersistentVolume: kind: PersistentVolume apiVersion: v1 metadata: name: persvolumeexample labels: type: local spec: capacity: storage: 10Gi accessModes: - ReadWriteOnce hostPath: path: \"/tmp/data\" Same as Pods, these resources are created using the kubectl tool: kubectl apply -f persvolumeexample.yml In the example above, we created a new persistent volume named persvolumeexample, with the maximum storage capacity of 10 GB. As for the different access modes, you could specify ReadWriteOnce, ReadOnlyMany, and ReadWriteMany, though not all of these modes are available for every storage provider. For instance, AWS EBS only supports ReadWriteOnce. You can use the created persistent volume via another resource: PersistentVolumeClaim. The claim ensures that there is enough space available. This may fail even if, during dynamic provisioning, Kubernetes actively tries to allocate more space. Let’s create a claim for provisioning 3 GB: kind: PersistentVolumeClaim apiVersion: v1 metadata: name: myclaim-1 spec: accessModes: - ReadWriteOnce resources: requests: storage: 3Gi The provisioning requires the use of kubectl: kubectl apply -f myclaim-1.yml When you run this command, Kubernetes looks for a persistent volume that matches the claim. Using the claim is simple: kind: Pod apiVersion: v1 metadata: name: volumeexample spec: containers: - name: c1 image: centos:7 command: - \"bin/bash\" - \"-c\" - \"sleep 10000\" volumeMounts: - name: xchange mountPath: \"/tmp/xchange\" - name: c2 image: centos:7 command: - \"bin/bash\" - \"-c\" - \"sleep 10000\" volumeMounts: - name: xchange mountPath: \"/tmp/data\" volumes: - name: xchange persistentVolumeClaim: claimName: myclaim-1 If you compare this example with the previous one, you’ll see that only the volumes section has changed, nothing else. The claim manages only a fraction of the volume. To free this fraction, you’d have to delete the claim. The reclaim policy for a persistent volume tells Kubernetes what to do with the volume after it has been released of its claim. The options are Retain, Recycle (deprecated in preference of dynamic provisioning), and Delete. To set the reclaim policy, you need to define the persistentVolumeReclaimPolicy option in the spec section of the PersistentVolume config. For instance, in the previous config this would look like: kind: PersistentVolume apiVersion: v1 metadata: name: persvolumeexample labels: type: local spec: capacity: storage: 10Gi accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Retain hostPath: path: \"/tmp/data\" Wrapping up Both volumes and persistent volumes allow you to add data storage that survives container restarts. While volumes are bound to the lifecycle of the Pod, persistent volumes can be defined independently of a specific Pod. They can then be used in any Pod. The one you choose depends on your needs. A volume is deleted when the containing Pod shuts down, yet it is perfect when you need to share data between containers running in a Pod. Since persistent volumes outlive individual Pods, they’re ideal when you have data that must survive Pod restarts or has to be shared between Pods. Both types of storage are easy to set up and use in a cluster. Happy orchestrating! Ready for a deep dive into Kubernetes monitoring? Check out A Complete Introduction to Monitoring Kubernetes with New Relic. Related Topics Kubernetes Monitoring Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.91223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " machines. Even worse, different containers might run in the same Pod but <em>access</em> the same <em>storage</em>. In this post, we’ll discuss two tools Kubernetes offers to help solve <em>storage</em> issues: volumes and persistent volumes. We’ll cover how and why you’d use each. About Kubernetes volumes Volumes offer <em>storage</em>"
      },
      "id": "607628b3196a670fb264a7bb"
    },
    {
      "sections": [
        "Integrations and custom roles",
        "Recommended role",
        "Optional role",
        "Important",
        "List of permissions",
        "Common permissions",
        "Service-specific permissions",
        "Permissions to link projects through the UI"
      ],
      "title": "Integrations and custom roles",
      "type": "docs",
      "tags": [
        "Integrations",
        "Google Cloud Platform integrations",
        "Get started"
      ],
      "external_id": "d4f60e2d8413ddde9a342980d75a0e216af9baa4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/google-cloud-platform-integrations/get-started/integrations-custom-roles/",
      "published_at": "2021-04-16T16:37:10Z",
      "updated_at": "2021-04-16T16:37:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To read the relevant data from your Google Cloud Platform (GCP) account, New Relic uses the Google Stackdriver API and also other specific services APIs. To access these APIs in your Google Cloud project, the New Relic authorized account needs to be granted a certain set of permissions; GCP uses roles to grant these permissions. Recommended role By default we highly recommend using the GCP primitive role Project Viewer, which grants \"permissions for read-only actions that do not affect your cloud infrastructure state, such as viewing (but not modifying) existing resources or data.\" This role is automatically managed by Google and updated when new Google Cloud services are released or modified. Optional role Alternatively, you can create your own custom role based on the list of permissions, which specifies the minimum set of permissions required to fetch data from each GCP integration. This will allow you to have more control over the permissions set for the New Relic authorized account. Important New Relic has no way of identifying problems related to custom permissions. If you choose to create a custom role, it is your responsibility to maintain it and ensure proper data is being collected. To customize your role you need to: Create a Google Cloud IAM Custom Role in each one of the GCP projects you want to monitor with New Relic. In each custom role, add the permissions that are specifically required for the cloud services you want to monitor according to the following list. Assign the custom role(s) to the New Relic authorized account. List of permissions Common permissions All integrations need the following permission: monitoring.timeSeries.list service.usage.use Service-specific permissions For some GCP integrations, New Relic will also need the following permissions, mainly to collect labels and inventory attributes. Integration Permissions Google AppEngine n/a; Google App Engine does not require additional permissions. Google BigQuery bigquery.datasets.get bigquery.tables.get bigquery.tables.list Google Cloud Functions cloudfunctions.locations.list Google Cloud Load Balancing n/a; Google Cloud Load Balancing does not require additional permissions. Google Cloud Pub/Sub pubsub.subscriptions.get pubsub.subscriptions.list pubsub.topics.get pubsub.topics.list Google Cloud Spanner spanner.instances.list spanner.databases.list spanner.databases.getDdl Google Cloud SQL cloudsql.instances.list Google Cloud Storage storage.buckets.list Google Compute Engine compute.instances.list compute.disks.get compute.disks.list Google Kubernetes Engine container.clusters.list Permissions to link projects through the UI To be able to see the list of projects that you can link to New Relic through the UI, your New Relic authorized service account needs the following permissions: resourcemanager.projects.get monitoring.monitoredResourceDescriptors.list If you do not want to grant New Relic authorized account the permissions that are needed for the linking process through the UI, you have the following options: Assign the Project Viewer or Monitoring Viewer role initially to the authorized account to link Google Cloud projects to New Relic through the UI. After the projects are linked, assign a Google Cloud custom role to the authorized account. Use New Relic NerdGraph to link Google Cloud projects to New Relic. This does not involve listing the viewable projects. However, you must know the id of the project you want to monitor. For more information, see the NerdGraph GraphiQL cloud integrations API tutorial.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.49786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "To read the relevant data <em>from</em> <em>your</em> Google Cloud Platform (GCP) account, New Relic uses the Google Stackdriver API and also other specific services APIs. To <em>access</em> these APIs in <em>your</em> Google Cloud project, the New Relic authorized account needs to be granted a certain set of permissions; GCP uses"
      },
      "id": "603ebb3564441f34b64e8874"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Medvedev.png",
      "url": "https://newrelic.com/blog/how-to-relic/machine-learning-aws-lambda-amazon-elastic-file-system",
      "sections": [
        "A definition in terms",
        "This doesn’t mean your Lambda has a memory now",
        "But there’s a lot you can do now",
        "Some caveats",
        "How New Relic lets you monitor this cool new thing",
        "Related Topics"
      ],
      "published_at": "2021-04-16T00:08:38Z",
      "title": "Machine Learning on AWS Lambda Has a New Best Friend",
      "updated_at": "2021-04-13T23:31:45Z",
      "type": "",
      "external_id": "afa4c5b3ba01a5d9d6bc9e2deaebb65e2e71a51a",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit AIOps Machine Learning on AWS Lambda Has a New Best Friend Jun 16, 2020 • 4 min read By Nočnica Fee Amazon Web Services (AWS) just announced a new integration with AWS Lambda and Amazon Elastic File System (Amazon EFS). I had a chance to explore some of the features ahead of the release date, and in this post, I’ll explain what this means for the future of AWS Lambda. A definition in terms AWS Lambda is serverless computation on AWS. The term “serverless” is often used synonymously with AWS Lambda, but more vendors than AWS offer serverless functions, and Lambda is only the compute part of serverless on AWS. I won’t say too much more about Lambdas or serverless as a concept, suffice to say it’s kind of a big deal. EFS is distributed file storage. Because of its distributed design, Amazon EFS avoids the bottlenecks and constraints inherent to traditional file servers. Distributed data storage allows multithreaded applications and applications that concurrently access data from multiple Amazon EC2 instances to drive substantial levels of aggregate throughput and input-output operations (IOPS). This doesn’t mean your Lambda has a memory now Medvedev / CC BY-SA (https://creativecommons.org/licenses/by-sa/3.0) So, if you can now add persistent storage to your Lambda functions, does that make them stateful? With a place to save files, you can have each run of a function affect subsequent runs, allowing iterators and accumulators across functions. That’s a not-great idea. AWS Lambda is designed as a stateless service for event-driven architectures, and you’re going to run into multiple issues trying to create a state machine or other stateful services: Lambda functions run “at least once” in response to an event, so you aren’t guaranteed to get steady accumulation from repeatedly calling a function. If your functions must “chain” to work correctly, a single failure can break the whole sequence, and suddenly your robust service is fragile. For complex state machines, other tools like step functions, EC2 instances, or containers make more sense for this kind of work But there’s a lot you can do now The use of serverless compute for machine learning is an obvious use case for this new feature: using EFS as a datastore, you can have Lambda functions asynchronously train to build a model. Further, you can use EFS as a source for reference files as needed when running Lambda functions, e.g., for more detailed recognition tasks. For tasks like virus scanning of .zip files, Lambda developers will finally have a place to put a large number of files, all of which need to be scanned individually. Some caveats You must configure Amazon EFS to run in a virtual private cloud (VPC) EFS is not the same as S3 and isn’t intended for hosting files used outside of your private cloud. As such, you’ll need to tackle VPC’s if you haven’t already. EFS supports 25,000 simultaneous connections This includes both Lambda functions and EC2 instances connected to the same file system. The simple way to prevent problems here is to limit the max concurrency of functions that have access to the file system, although this is a quite high ceiling most operations will probably not have to deal with. Understand Security Controls With EFS, security is paramount, with multiple checks in place to make sure data access is authorized. You can find more info on using IAM authorization and access points with EFS in this post. To connect a Lambda function to an EFS file system, you need: IAM permissions for the Lambda function to access the Virtual Private Cloud (VPC) and mount the EFS file system Network visibility, including VPC routing/peering and security group Configuration can further limit access: An EFS access point can limit access to a specific file path File system security (user ID, group ID, permissions) can limit read, write, or executable access for each file or directory mounted by a Lambda function How New Relic lets you monitor this cool new thing At launch, Amazon Cloudwatch will include some key metrics about how your EFS-Lambda connection is performing, including: Burst rate (if you have burst credits) Burst credit balance % IO limit (Amount of IOPs consumed on your filesystem relative to the IOPS limit) New Relic’s Infrastructure monitoring tool gathers Cloudwatch metrics, and we’ll soon add these stats to Lambda functions using EFS. Sign up for the New Relic users Slack channel to get updates and discuss the cutting edge of serverless infrastructure. Related Topics AIOps By Nočnica Fee Nočnica Fee is a Dev Advocate for New Relic specializing in serverless. She's a frequent contributor to The New Stack and Dev.to. In her downtime, she enjoys drum machines and woodworking. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.26384,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "This doesn’t mean <em>your</em> Lambda has a memory now",
        "body": " avoids the bottlenecks and constraints inherent to traditional file servers. Distributed data <em>storage</em> allows multithreaded applications and applications that concurrently <em>access</em> data <em>from</em> multiple Amazon EC2 instances to drive substantial levels of aggregate throughput and input-output operations (IOPS"
      },
      "id": "607629e1196a67b91164a7bb"
    }
  ],
  "/build-apps/ab-test/catalog": [
    {
      "image": "https://developer.newrelic.com/static/futurestack-registration-86e612c0605fb3c49cfd28f35977135d.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Futurestack: Master Observability",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2021-04-20T01:36:57Z",
      "title": "New Relic Developers",
      "updated_at": "2021-04-16T01:37:39Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Data Nerds, get ready to hack the future. Level Up your observability game at Futurestack 2021. Rack up your experience points with new tools, new skills, and whole new ways to play with your data through Observability. Connect with Nerds from across the globe to learn, share, and get inspired as we reinvent the future of software — and have lots of fun doing it. Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired Add a table to your app 30 min Add a table to your New Relic One app Collect data - any source 15 min APIs, agents, OS emitters - get any data Automate common tasks 20 min Use the New Relic CLI to tag apps and create deployment markers Create a custom map view 30 min Build an app to show page view data on a map Add a time picker to your app 20 min Add a time picker to a sample application Add custom attributes   Use custom attributes for deeper analysis Show 29 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.74474,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add a table to <em>your</em> <em>app</em>",
        "body": " filtering and organization Start the guide 12 min Build a Hello, World! <em>app</em> Build a Hello, World! <em>app</em> and publish it to <em>your</em> local New Relic One <em>Catalog</em> Start the guide Get inspired Add a table to <em>your</em> <em>app</em> 30 min Add a table to <em>your</em> New Relic One <em>app</em> Collect data - any source 15 min APIs, agents, OS"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/New-Relic-One-Catalog.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-5",
      "sections": [
        "Subscribe to applications with the New Relic One Catalog",
        "Observability Maps",
        "Metric Aggregator",
        "Workload Geo Ops",
        "Check out these other resources for using—and building—New Relic One applications ",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "The Most Popular New Relic One Applications (Roundup #5)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "75f80d867fec167c4a6d62082f32cb2ff1ae0802",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #5) Jun 4, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Observability Maps Metric Aggregator Workload Geo Ops Subscribe to applications with the New Relic One Catalog Before we start accessing the applications via the CLI, let’s look at how to access these applications directly within New Relic One. To explore available applications, navigate to New Relic One and click on the New Relic One Catalog launcher. New Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. New Relic One Catalog If you deploy an application from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Observability Maps Observability Maps allows you to create a view beyond a traditional service map. Using Observability Maps, you can connect disparate entities in your environment into ad hoc relationships, creating your own relationships based on data available in New Relic. See your entities and environment in a way that makes the most sense to your team and business. Observability Maps App Fork or deploy the Observability Maps app from GitHub. Specific requirements for this app Requires data in NRDB from any or all of the New Relic products. Metric Aggregator The Metric Aggregator is a New Relic One application that helps you create events-to-metrics (E2M) rules, a real-time streaming service that converts event data into dimensional metrics at ingest. Converting events to metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Metric Aggregator App Fork or deploy the Metric Aggregator app from GitHub. Specific requirements for this app If you use New Relic, you already have New Relic Metrics. You can  create E2M rules immediately. Workload Geo Ops Workload Geo Ops links your workloads (collections of entities) to physical locations so you can quickly identify and resolve incidents. It's a geographic exploration of workload data tied to geographic data, including location metadata. You can define maps and then collect or assign entities to points on those maps. With workloads, a collection of entities can be managed by rules and tags to support the dynamic, ephemeral nature of modern IT infrastructure. Fork or deploy the Workload Geo Ops app from GitHub. Specific requirements for this app To get the most of this app, we recommend that you configure Workloads in New Relic One. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Workload Geo Ops to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One applications  Here are resources to help you build your own New Relic One applications. If you can imagine it, you can build it:  developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. NerdGraph GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity. Application/data access and permissions and security. NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.16901,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>The</em> Most Popular New Relic One <em>Applications</em> (Roundup #5)",
        "sections": "Subscribe to <em>applications</em> with <em>the</em> New Relic One <em>Catalog</em>",
        "body": " Relic One <em>Catalog</em> launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the <em>app</em> to add the application to the account you wish to grant access. If <em>your</em> team changes, and you need"
      },
      "id": "60762e1f64441fbf2e9d856e"
    },
    {
      "sections": [
        "Magento-specific functionality",
        "Magento 1",
        "Magento 2",
        "Web APIs",
        "FrontControllerInterface plugins",
        "Escape automatic transaction naming",
        "For more help"
      ],
      "title": "Magento-specific functionality",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Frameworks and libraries"
      ],
      "external_id": "69bf5ad584ab59bb4059d6742405a12a57af23bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/frameworks-libraries/magento-specific-functionality/",
      "published_at": "2021-04-16T05:41:45Z",
      "updated_at": "2021-04-16T05:41:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's PHP agent includes support for automatic transaction naming for the Community and Enterprise editions of Magento 1 and 2. This document describes how this works and how you can use the automated names to track issues on your Magento application. Magento 1 Transactions in Magento 1 applications are named based on the module, controller, and action that handle the request. For example, a transaction for the default customer account page will be named customer/account/index, which indicates that the indexAction() method in Mage_Customer_AccountController (the account controller in the customer module) was responsible for the transaction. Magento 2 Normal web transactions in Magento 2 applications are named similarly to Magento 1 transactions: the transaction name encodes the module, controller, and action that handled the request. For example, a request handled by the Magento\\Customer\\Controller\\Account\\Index controller class will also be named customer/account/index. Web APIs Magento 2 also includes built-in support for web APIs. These are web services that are made available through REST and SOAP. As of PHP agent version 7.0, New Relic supports automatically naming transactions that use this functionality. Previous versions of the PHP agent named web API transactions as unknown by default. Magento 2 web APIs Comments SOAP SOAP transactions are named based on the service class and method that handled the request. For example, the transaction name Webapi/Soap/Magento\\Catalog\\Api\\CategoryManagementInterface/getTree indicates that a SOAP request was handled by the getTree() method on the model implementing Magento\\Catalog\\Api\\CategoryManagementInterface. WSDL transactions are also named automatically: Webapi/Soap/WsdlList is used for transactions that return the list of available APIs, whereas Webapi/Soap/Wsdl is used for transactions that get the WSDL for a specific SOAP API. REST From Magento 2.1 onwards, REST transactions are named similarly to SOAP transactions. The only difference is that REST requests are prefixed with Webapi/Rest instead of Webapi/Soap. On Magento 2.0, the PHP agent is unable to automatically name the specific service class and method that handled the transaction. Instead, REST requests currently receive the generic name FrontController/Magento\\Webapi\\Controller\\Rest\\Interceptor. This may be improved in a future PHP agent release. As a workaround, New Relic recommends using newrelic_name_transaction() in the service method if greater resolution is required. FrontControllerInterface plugins It is possible in Magento 2 to register a plugin or interceptor for the Magento\\Framework\\App\\FrontControllerInterface interface to replace the default routing engine. For example, this is how the web API features operate. If an interceptor is registered for Magento\\Framework\\App\\FrontControllerInterface, the name of that class will be used as the default transaction name when using New Relic's PHP agent version 7.0 or higher. You can also use newrelic_name_transaction() for manual naming if needed. Escape automatic transaction naming If automatic transaction naming is not useful, you can override the PHP agent's automatic transaction naming by using the newrelic_name_transaction() API function. For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.65958,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>For</em> more help",
        "body": "New Relic&#x27;s PHP agent includes support for automatic transaction naming for the Community and Enterprise editions of Magento 1 and 2. This document describes how this works and how you can use the automated names to track issues on <em>your</em> Magento application. Magento 1 Transactions in Magento 1"
      },
      "id": "6043d26328ccbc04a22f68b5"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Screen-Shot-2020-03-30-at-8.32.03-AM.png",
      "url": "https://newrelic.com/blog/nerdlog/new-programmability-features",
      "sections": [
        "What is the New Relic One Catalog?",
        "But wait, there’s more. What is the New Relic Developer Toolkit?",
        "The Developer Toolkit includes:",
        "Let’s build together",
        "Related Topics"
      ],
      "published_at": "2021-04-15T22:46:43Z",
      "title": "New Capabilities to Extend Development On New Relic One",
      "updated_at": "2021-04-13T23:49:50Z",
      "type": "",
      "external_id": "9b2b9d3ad38b6c5517a46c777520f4bbbbc3876c",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Capabilities to Extend Development On New Relic One Mar 30, 2020 • 4 min read By Mark Weitzel At FutureStack in September 2019, we announced programmability as the ability to build custom applications on the New Relic One platform. We were excited to take that first step in the programmability journey, but we recognized there was a need to be able to configure and customize all your data—regardless of where you are in the programmability adoption journey. You voiced that need to us and today, we’re excited to announce the General Availability (GA) of the New Relic One Catalog and the Developer Toolkit. These features will allow you to experience the power of programmability with just a few clicks. What is the New Relic One Catalog? The New Relic One Catalog significantly lowers the barrier of entry to adopting New Relic One applications. By providing a user experience directly in the platform, the New Relic One Catalog makes the discovery, installation, and management of 16-plus global applications seamless and intuitive—and we’re always adding more. To get started using applications (e.g., Cloud Optimize, Datalyzer), you will no longer have to download the CLI, clone a repository, and run the deploy command. New Relic One Catalog But wait, there’s more. What is the New Relic Developer Toolkit? We are also announcing the Developer Toolkit, a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a cross-product command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your core business. We created these tools to provide developers with the ability to integrate observability into automation workflows. As a developer, you have complete control through the New Relic Client. When you deploy a service, you want to embed the New Relic configuration in code with the rest of the service definition. When you audit your systems, you want an easy way to verify the New Relic configuration is defined as expected. You might have heard of this concept, Observability as Code. As a refresher, observability means you can answer any questions about what's happening on the inside of the system just by observing the outside of the system, without having to ship new code to answer new questions. However, with programmability, you can use code to extend the capabilities of observability. This is where the Developer Toolkit comes in handy.  The Developer Toolkit includes: New Relic Terraform Provider: Enables Observability as Code, reduces developer toil, and allows users to manage their entire ecosystem in a single place. New Relic Client: Provides the building blocks for many tools in the toolkit, enabling quick access to the suite of New Relic APIs. As a library, it can also be leveraged within your own custom applications. New Relic CLI: Enables integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic AWS CloudFormation Integration: Enables developers using CloudFormation to provision a subset of New Relic resources easily. Let’s build together We’re on the programmability journey together, and we’re always excited to see developers in the wild use our programmability features. Check out how Picnic, the fastest online supermarket in Europe, extended its capabilities for inventory management and customer experience. We are continuously working on new projects to improve the developer experience. We truly believe in being open, connected, and programmable, which is why we’d love to engage with you.  If you have any questions or comments about any of the new product features mentioned, please reach out to our team at deco@newrelic.com or join in on the conversation with the developer community at discuss.newrelic.com. [embed]https://www.youtube.com/watch?v=0plNgMVAqYY[/embed] Related Topics Extend New Relic By Mark Weitzel Mark Weitzel is General Manager, New Relic One at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.67201,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What is <em>the</em> New Relic One <em>Catalog</em>?",
        "body": " The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights <em>App</em> for iOS Search toggle Log"
      },
      "id": "60762e1e64441fbeca9d8575"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/attributory-screenshot-main.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-6",
      "sections": [
        "Subscribe to apps in the New Relic One Catalog",
        "Flex Manager",
        "GraphiQL Notebook",
        "Attributory",
        "What are you waiting for? Deploy these apps now.",
        "Check out these other resources for using—and building—New Relic One apps",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:26:51Z",
      "title": "The Most Popular New Relic One Applications (Roundup #6)",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "76394d24aebbff40a68e9bd6a7f867313e814d74",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #6) Jul 2, 2020 • 8 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the visibility and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source, so you can use them out-of-the-box, or submit a pull request for feedback and feature requests. In this edition, we cover three apps that help engineers do their jobs: Flex Manager GraphiQL Notebook Attributory Subscribe to apps in the New Relic One Catalog You can manage and deploy apps directly within New Relic One. To explore available apps, navigate to New Relic One and click on the New Relic One Catalog launcher. From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. If you deploy an app from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Flex Manager New Relic Flex is an application-agnostic, all-in-one tool that makes sending data to New Relic from third party sources easier than ever. Use Flex Manager to simplify the work of creating, managing, and deploying new integrations you’ve built with Flex. Fork or deploy the Flex Manager app from GitHub. Specific requirements for this app Flex Manager requires New Relic Infrastructure and the Flex integration. GraphiQL Notebook GraphiQL Notebook allows you to explore and learn about the NerdGraph—the New Relic GraphQL API—using a Jupyter Notebook style interface. Notebooks intermix GraphQL requests with data exploration links. You can create, update, save, and delete notebooks. You can also export and share notebooks as blocks of Base64-encoded JSON. Fork or deploy the GraphQL Notebook app from GitHub. Attributory Attributory is a dictionary of attributes from your APM, Browser, or Mobile applications stored in New Relic. It displays a list of attributes for each application. When you open a service or application from the entity explorer, you’ll find Attributes Dictionary listed as an application in the left-hand navigation. New Relic stores event data as key-value pairs. Built-in New Relic attributes include the definition of the attribute. For custom attributes, you can choose to add your own definitions. Fork or deploy the Attributory app from GitHub. Specific requirements for this app Applications with New Relic APM, Browser, or Mobile agents reporting into New Relic. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account Once you have these requirements in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Attributory to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One apps Here are resources to help you build your own New Relic One apps. If you can imagine it, you can build it: New Relic Developers: Build applications using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Open Source: New Relic’s open source website makes it easy for you to explore the open source projects we maintain and the open standards projects we participate in. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, review our Contributors Guide. Keep in mind that when you submit your Pull Request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.217476,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>The</em> Most Popular New Relic One <em>Applications</em> (Roundup #6)",
        "sections": "Subscribe to <em>apps</em> in <em>the</em> New Relic One <em>Catalog</em>",
        "body": " <em>Catalog</em> launcher. From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the <em>app</em> to add the application to the account you wish to grant access. If <em>your</em> team changes, and you need to remove"
      },
      "id": "60762e1e28ccbcb5fd51c147"
    }
  ],
  "/build-apps/ab-test/chart-group": [
    {
      "sections": [
        "Tutorial: Add new user groups and roles (New Relic One user model)",
        "Requirements",
        "Overview",
        "View available accounts",
        "Grant groups access to roles and accounts",
        "Tip",
        "Create custom role",
        "Add users"
      ],
      "title": "Tutorial: Add new user groups and roles (New Relic One user model)",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "New Relic One user management"
      ],
      "external_id": "b1e5f303b6446f264c9d8c5020871a6990e052fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-user-management/tutorial-add-new-user-groups-roles-new-relic-one-user-model/",
      "published_at": "2021-04-15T22:24:23Z",
      "updated_at": "2021-04-12T11:29:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This tutorial will walk you through some common procedures for managing users on the New Relic One user model. Requirements Some notes on who this tutorial is for and requirements: This tutorial is for managing users on our New Relic One user model. Assigning new group access grants requires Pro or Enterprise tier. For details, see user management requirements. Role requirements: Using the Organization and access UI to manage group access requires Authentication domain manager and Organization manager roles. Using the User management UI to add/edit users requires Authentication domain manager role. Overview Before using this tutorial, we first recommend reading these docs: Where to find user management features in the UI Important user management concepts This tutorial will walk you through how to: View available accounts How to grant groups access to roles and accounts How to create custom roles How to add users to groups View available accounts Understanding the accounts in your New Relic organization is important for granting groups access, because you must choose what accounts to grant them access to. To view the accounts in your organization: go to the account dropdown, click Administration, click Organizations and access, and then click Accounts. Grant groups access to roles and accounts Groups are used to manage what your users are able to do in New Relic. By default, organizations on the New Relic One account/user structure have two available groups: Admin and User. These default groups automatically have access to specific standard roles and are assigned to the account in which they were initially added. If you're on our Pro or Enterprise tier, you have the ability to create new groups and new roles, and to assign groups to other accounts in your organization. Tip Note that you can also import users from your identity provider. To view existing group access grants: from the account dropdown, click Administration, and then click Organization and access. To grant a user group access to a role and an account: From the Organization and access UI, click Group access. Complete the UI prompts to assign an existing group or a new group access to a specific role on a specific account. If you have questions about these concepts, see User management concepts. Optional: To give a group the ability to manage other users, under Scope, select Organization and choose the Authentication domain manager role. For more on the difference between organization- and account-scoped roles, see Standard roles. (Note that these users must also have an account-scoped role. Without that, you may see a message that the user doesn't belong to an organization.) Optional: to continue adding access for the same group, select Add another at the bottom before clicking Add access. Some important tips to understand when managing groups: If a group has basic users in it, their basic user status overrides any group-related restrictions. When you create a new group, note that your users don't have access to that group until both of these steps are done: 1) The group has been granted access, and 2) Users have been added to that group. Create custom role When granting a group access to roles and accounts, you can use our default standard roles that have default capabilities, or you can create your own roles with unique sets of capabilities. To view existing roles: from the account dropdown, click Administration, then click Organization and access, and then click Roles. To create a custom role, click Add new custom role. Note that there are some hidden capabilities that are not available for adding to a custom role. For details, see Capabilities. To learn more about how roles and groups relate, see User management concepts. Add users If you've created a new group, you must make sure that the users are added to that group. If users don't have the group assigned, no access will be granted. To view or manage users: from the account dropdown, click Administration, and click User management. If you don’t see that option, review the requirements. Groups reside within the boundaries of an authentication domain. If your organization has more than one authentication domain, the domain switcher in the top left will show which one you’re in. To add a user, click Add user. Complete the prompts in the UI, including choosing the user type and group. Any custom groups you’ve added should be available from the group dropdown. If the custom group you choose has been granted access to a role and an account, once you add the user to that group, that user will now have access. To edit a user’s group or other details: click on the user you want to edit and make changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.61394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Tutorial: <em>Add</em> new user <em>groups</em> <em>and</em> roles (New Relic One user model)",
        "sections": "Tutorial: <em>Add</em> new user <em>groups</em> <em>and</em> roles (New Relic One user model)",
        "tags": "<em>Accounts</em>",
        "body": " or Enterprise tier. For details, see user management requirements. Role requirements: Using the Organization and access UI to manage <em>group</em> access requires Authentication domain manager and Organization manager roles. Using the User management UI to <em>add</em>&#x2F;edit users requires Authentication domain manager"
      },
      "id": "603e7d67196a671e26a83dc5"
    },
    {
      "sections": [
        "Group infrastructure results by specific attributes",
        "Group charts by specific attributes",
        "Combine filter sets and grouping",
        "Increased CPU usage on a single host"
      ],
      "title": "Group infrastructure results by specific attributes",
      "type": "docs",
      "tags": [
        "Infrastructure",
        "Manage your data",
        "Filter and group"
      ],
      "external_id": "8436b1d0391cd7caa2a79c4080528697ff7a012d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/infrastructure/new-relic-infrastructure/filter-group/group-infrastructure-results-specific-attributes/",
      "published_at": "2021-04-16T11:53:18Z",
      "updated_at": "2021-03-11T10:49:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In our infrastructure monitoring tool, you can use the Group by feature to group chart results by specific attributes. For example, on the Hosts page, you might display the AWS regions with the highest CPU usage grouped by awsRegion. Group by is available near the top of some infrastructure monitoring UI pages. Group charts by specific attributes On some infrastructure pages you can use Group by to group page results and charts by a specific attribute, such as host name, entity ID, or AWS region. The attributes available to group by will depend on your system setup. These may include: Default infrastructure attributes Custom attributes APM-related attributes To group infrastructure results by a specific attribute: On pages that have this feature, select Group by (located beside the time picker). From the dropdown, select an attribute to group by. Combine filter sets and grouping Grouping applies to any filter sets you have selected. By combining filter sets with Group by, you can find detailed system information quickly. Increased CPU usage on a single host On the Filter sets sidebar, you see alert threshold violations as Critical icon or Warning icon on one of your filter sets. To view only the hosts related to the filter set on your Hosts page, click the filter set name. To determine which of the hosts is causing the problem, select Group by, then select the hostname attribute. Review the charts which now show the hosts, by name, with the highest CPU usage.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.869385,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Group</em> infrastructure results by specific <em>attributes</em>",
        "sections": "<em>Group</em> <em>charts</em> by specific <em>attributes</em>",
        "tags": "Filter <em>and</em> <em>group</em>",
        "body": "In our infrastructure monitoring tool, you can use the <em>Group</em> by feature to <em>group</em> <em>chart</em> results by specific attributes. For example, on the Hosts page, you might display the AWS regions with the highest CPU usage grouped by awsRegion. <em>Group</em> by is available near the top of some infrastructure"
      },
      "id": "6043edcd64441fd920378ecf"
    },
    {
      "sections": [
        "Filter sets: Organize your hosts",
        "Benefits of filter sets",
        "Create filter sets",
        "Edit filter sets",
        "Delete filter sets",
        "Combine filter sets with grouping",
        "Copy filters from filter set to alerts",
        "Important",
        "Filter set logic",
        "Inclusion and exclusion",
        "Recommended: Select values by matching a string",
        "Tip",
        "Select values individually",
        "And/Or"
      ],
      "title": "Filter sets: Organize your hosts",
      "type": "docs",
      "tags": [
        "Infrastructure",
        "Manage your data",
        "Filter and group"
      ],
      "external_id": "ae70ce239865f3cb006e2ed47fc9bf3fc0598d81",
      "image": "",
      "url": "https://docs.newrelic.com/docs/infrastructure/new-relic-infrastructure/filter-group/filter-sets-organize-your-infrastructure-hosts/",
      "published_at": "2021-04-16T11:51:49Z",
      "updated_at": "2021-03-11T08:50:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic infrastructure monitoring, you can combine filters into a filter set to organize hosts based on criteria that matter the most to you. Read on to learn about the benefits, use, and logic of filter sets. Benefits of filter sets You can create filter sets using available attributes or tags. For example, you can organize your infrastructure into categories such as: Regions Operating system versions Hosts associated with Docker containers Test environments You can share filter sets with other people in your account, and you can quickly identify infrastructure problems by checking the color-coded health status of each host in the filter set. Create filter sets The default infrastructure filter set is All hosts, and it serves as a template for you to create filter sets. To create a filter set: Go to one.newrelic.com > Infrastructure and click Hosts, Inventory, or Events. If All hosts is not displayed in the left sidebar, open that filter set by selecting Saved filter sets > All hosts. In All hosts, click Filter hosts. In the list, click an item to see a list of values. Click Include or Exclude (see Filter set logic). Click values individually or enter text to match multiple values. Continue adding filters until you have the filter set you want. To name your filter, click the icon, type a name, and click Save. Edit filter sets To change an existing filter set: Go to one.newrelic.com > Infrastructure and click Hosts, Inventory, or Events. In the sidebar, click Saved filter sets to open a list. Locate the filter set by scrolling or by entering a search term. Click the filter set to open it. In the sidebar, click an option to update your filter set, and then save. Delete filter sets You can delete any saved filter set except the default All hosts. Go to one.newrelic.com > Infrastructure > Settings > Filter sets. Click to delete the filter set. Combine filter sets with grouping On some pages you can use Group by to group chart results by specific attributes. For example, on the Hosts page, you can group by awsRegion to display the AWS regions with the highest CPU usage. Grouping applies to the selected filter sets. By combining filter sets with grouping, you can find detailed system information quickly. For an example of using these tools to troubleshoot a problem, see Combining filter sets and grouping. Copy filters from filter set to alerts When you create an alert condition, you can build filters individually, or you can copy all the filters from a filter set into a new alert condition. This is a quick shortcut to populate a new alert condition with some filters. Important When you copy filter set filters to a new alert condition, these filters are no longer tied to the filter set. If you make changes to the filter set, the alert filters are not affected. To copy filter set filters to a new alert condition: Go to one.newrelic.com > Infrastructure and click Hosts, Inventory, or Events. In the sidebar, click Saved filter sets to open a list. Locate the filter set by scrolling or by entering a search term. Click the filter set to open it. Mouse over any chart and click > Create alert. Enter an alert condition name. Make adjustments to filters as necessary. Complete the remaining alert fields (see Create alert conditions). Filter set logic When you create a filter set, you generate a list of attributes and/or tags that narrow the results. This section explains how filter sets apply various rules to the list. Inclusion and exclusion As part of building a filter set, you designate whether a filter should include or exclude entities that match certain values. The way the inclusion or exclusion works depends on how you select values: Recommended: Select values by matching a string You can generate a list of values by entering a string that you want values to match. This is useful for matching multiple values. Tip String matching efficiently generates a list of values, and this approach scales as you add new entities. Here is the logic filter sets use with string matching: Comparator Logic Include If you click Include and then enter a string that you want values to match, the filter uses the comparator LIKE, which means the results include any entities that are like the string. For example, you could filter by the term East-, and all entities that contain that term are returned. Exclude If you click Exclude and then enter a string that you want values to match, the filter uses the comparator NOT LIKE, which means the results exclude any entities that are like the string. For example, you could filter by the term West-, and all entities that do not contain that term are returned. Select values individually You can click through the list of attributes/tags to identify individual values. Tip This approach does not scale well if you add new entities. Here is the logic filter sets use with individual value selection: Comparator Logic Include If you click Include and then click specific values, the filter uses the comparator IN, which means the filter looks for entities that exactly match one or more values in your list of selections. Exclude If you click Exclude and then click specific values, the filter set uses the comparator NOT IN, which means the filter returns all entities that do not exactly match one or more values in your list of selections. And/Or Filter sets use the logical operators AND and OR behind the scenes to join the data. Here are the rules for AND and OR: When you click values from multiple attributes or tags, they are joined by AND. When you click values from within an attribute or tags, they are joined by OR. The filter results display hosts for which both of the following are true: Hosts containing any one of the selected infrastructure agent versions Hosts in any one of the selected AWS availability zones",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.84273,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Combine filter sets with <em>grouping</em>",
        "tags": "Filter <em>and</em> <em>group</em>",
        "body": " to one.newrelic.com &gt; Infrastructure &gt; Settings &gt; Filter sets. Click to delete the filter set. Combine filter sets with grouping On some pages you can use <em>Group</em> by to <em>group</em> <em>chart</em> results by specific attributes. For example, on the Hosts page, you can <em>group</em> by awsRegion to display the AWS regions with the highest"
      },
      "id": "6043ed8ee7b9d289955799cb"
    },
    {
      "sections": [
        "Add and manage users, groups, and roles",
        "Important",
        "Requirements",
        "Tip",
        "Manage users in the UI",
        "Overview of user management concepts",
        "User management definitions",
        "Example user management tasks",
        "Add and edit users",
        "Create new groups and roles",
        "Grant users ability to manage other users",
        "Control how basic users upgrade to full users",
        "Track changes"
      ],
      "title": "Add and manage users, groups, and roles",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "New Relic One user management"
      ],
      "external_id": "9e37836740ce56302734d4af636bdbe087b4dbc3",
      "image": "https://docs.newrelic.com/static/b1c2da968a637f68569e890c8bd72a1c/c1b63/new-relic-one-user-mgmt.png",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-user-management/add-manage-users-groups-roles/",
      "published_at": "2021-04-16T06:51:51Z",
      "updated_at": "2021-04-12T09:44:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For users on our New Relic One user model, we provide various user management features, including the ability to: Use role based access control (RBAC) to assign default or custom roles to user groups Create custom user groups Grant user groups access to specific roles and accounts Important This doc applies to users on the New Relic One user model. For managing users on our original user model, see Original users. Not sure which user model you're on? See User models. Requirements Tip To quickly check if you can access these user management features, go to the user management UI and see what you have access to. Requirements: These features allow managing of users on the New Relic One user model. To learn more, see User models. Some capabilities require the Organization manager role and some require the Authentication domain manager role. For details, see Standard roles. Pricing tier requirements: To manage user groups, roles, and access grants: Pro or Enterprise tier is required. To import users from an identity provider: Enterprise tier is required A New Relic user can have a maximum of either three concurrent active sessions, or three unique IP addresses in use at any given time. Manage users in the UI For users on the New Relic One user model, to find your user management options: From the account dropdown, select Administration. There are two user management UI pages there: User management: Use this to add users, update user information, and approve upgrade requests. Organization and access: Use this page to create and manage groups, roles, and access grants. Important If you can't use or access these UI pages, it may be because your users are on our original user model or because you don't have the required user management role. Overview of user management concepts To optimally use our more advanced user management features, it's important to first understand the concept of the \"access grant.\" An access grant gives a group of users access to a) a role and b) an account. For a New Relic organization that has many accounts, groups typically require more than one access grant because users in a group usually need access to multiple accounts and roles. The diagram below explains the elements that make up an access grant. Note that if you're on our Standard tier and want to assign a user to a default group (Admin or User), you don't need to create an access grant: you would simply add a user to that group and you're done. But for Pro and Enterprise tier accounts, if you're trying to grant users access to a custom group, a custom role, or to other accounts, you must create an access grant. A diagram explaining how you can grant user groups access to roles and accounts. Note that this applies to users on our New Relic One user model (and not our original user model). Some tips on setting up access grants: It may help to first plan out how your access grants will be organized. How many accounts will you have? What user groups will get access to which roles and which accounts? Will you use our default groups and roles or create your own custom groups and roles? For smaller, flatter organizations okay with full internal transparency, you may only need a couple groups. A common configuration for organizations with many accounts (roughly 20 or more) is setting up groups with the more organization-scoped roles (Organization manager, Authentication domain manager, and Billing user) on the primary account, and then on other accounts, setting up groups with the more product-scoped roles (like All product admin, Standard user, or custom roles). User management definitions Here are some definitions of our user management terms and how they relate to each other: A capability is an ability to use or edit a specific, granular New Relic feature. Examples of capabilities: The ability to modify APM settings The ability to delete alert conditions A role is a set of capabilities. Our default standard roles have various capability sets, and you can create custom roles that have a custom set of capabilities. A user group has one or more roles associated with it. You assign your users to a group. We have default user groups (Admin and User), and you can make your own groups. An access grant is what grants a user group access to roles and specific New Relic accounts. An access grant essentially states, \"This group is assigned this role on this New Relic account.\" Adding a user to a group doesn’t do anything unless that group is included in an access grant. An authentication domain contains a set of users who are added to New Relic and who log in to New Relic in the same way. For example, you may have one authentication domain for users who log in via username/password and another authentication domain for users who log in via SAML. If a user is a basic user, this takes precedence over any role-related limitations. For more on this, see Basic user and roles. Example user management tasks In the Organization and access UI, you can create custom groups, roles, and grant access to user groups. Here are some example user management procedures: Add and edit users To add or edit users, use the User management UI. To add users there: If you have multiple authentication domains, choose one from the authentication domain dropdown. Click Add user. Complete the process, including choosing user type and user group. Create new groups and roles See our user management tutorial. Grant users ability to manage other users To grant your users the ability to manage other users, you'll need to add users to a group that has the Authentication domain manager role. Important Users cannot have only organization-scoped roles assigned; they must also be in a group that has account-scoped roles (for example, the default Admin group). You have two options: From the User management UI, you can add a user to the default Admin group, which includes both of those roles. OR You can assign those roles to a custom group. From the Organization and access UI: Select Access grants, and choose To this organization. Create an access grant that assigns the Authentication domain manager role to a custom group. From the User management UI, add users to that group. To see a tutorial on creating new groups and roles, see Tutorial. Control how basic users upgrade to full users See the authentication domain settings. Track changes To see an audit log of changes to your account, including user management actions, you can query the NrAuditEvent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.05699,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> <em>and</em> manage users, <em>groups</em>, <em>and</em> roles",
        "sections": "<em>Add</em> <em>and</em> manage users, <em>groups</em>, <em>and</em> roles",
        "tags": "<em>Accounts</em>",
        "body": " grant: you would simply <em>add</em> a user to that <em>group</em> and you&#x27;re done. But for Pro and Enterprise tier accounts, if you&#x27;re trying to grant users access to a custom <em>group</em>, a custom role, or to other accounts, you must create an access grant. A diagram explaining how you can grant user groups access"
      },
      "id": "603e7bce28ccbc415beba74c"
    },
    {
      "sections": [
        "Infrastructure monitoring Hosts page",
        "System tab",
        "System tab functions",
        "APM and infrastructure data",
        "Important",
        "Network tab",
        "Network tab functions",
        "Processes tab",
        "Tip",
        "Processes tab functions",
        "Storage tab",
        "Storage tab functions",
        "Docker containers tab",
        "Docker containers tab functions"
      ],
      "title": "Infrastructure monitoring Hosts page",
      "type": "docs",
      "tags": [
        "Infrastructure",
        "Infrastructure monitoring UI",
        "Infrastructure UI"
      ],
      "external_id": "41d8a2ac3ecbbdee164fd0bec6ac94bb3e8def64",
      "image": "",
      "url": "https://docs.newrelic.com/docs/infrastructure/infrastructure-ui-pages/infrastructure-ui/infrastructure-hosts-page/",
      "published_at": "2021-04-16T02:54:06Z",
      "updated_at": "2021-03-09T04:04:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Hosts page to better understand important performance metrics, like resource usage, network and processes performance, and data about your containers. You can filter your hosts by attributes and compare their performance with inventory change events to help determine root causes. You can also set alert notifications to help prevent problems. To view your hosts information, go to one.newrelic.com > Infrastructure > Hosts, then click any of the following tabs: System: Overview of your hosts' performance Network: Bandwidth and error data about your network interfaces Processes: Data about CPU percentage, I/O bytes, and memory usage for individual or groups of processes Storage: Resources' capacity and efficiency, including your devices' overall utilization, disk usage, or I/O operations Docker containers: CPU percentage, I/O bytes, and memory usage for individual or group of containers System tab Here are the default graphs shown on the Hosts page. For additional chart options, select the dropdown for any chart. CPU %: On the System tab, CPU Percent is a derived metric that is part of the SystemSample event. The CPU percentage is not collected by New Relic, but derived from several other metrics. Specifically, the cpuPercent attribute is an aggregation of cpuUserPercent, cpuSystemPercent, cpuIoWaitPercent and cpuStealPercent. Load average five minute: represents an average of the number of tasks waiting to do work on a system over the last 5 minutes. Memory free %: compares the amount of free memory bytes to the amount of used memory bytes. For explanations of different chart metrics, see Default infrastructure attributes and events. Functions for adjusting chart data include: Select different host groups: Use the host filter. Change time range: Use the time picker above the charts, or drag and select a time range on a chart. Change the number of elements on charts: use the Chart shows dropdown. Change data used to order hosts: Use the table below the charts to order the chart elements by different metrics; for example, from highest to lowest CPU user % to lowest, or from lowest to highest Disk free. System tab functions Here are some of the things you can do from the System tab: If you want to... Do this... Filter and group hosts Use filter sets to show only hosts matching certain criteria, or use group by to aggregate the results. Understand host health Use the Health column of the table. To see more details about specific violations, select the health status icons. Find root causes of issues Use the Events heatmap at the top of the page to compare performance to important events happening in your infrastructure. For more, see Events heatmap. Set an alert condition for a metric Mouse over a chart, select and then Create alert. View host's alert threshold violation If present, select the host's Critical icon or Warning icon. APM and infrastructure data If you have APM data associated with your infrastructure data, there are several ways to access your APM data on the Hosts page: Use the hosts filter to filter on hosts running specific applications. In the host list below the charts, select the Application column to filter on specific applications. From the chart selector dropdown beside a chart's name, select one of the application-related charts. Important APM charts in infrastructure monitoring do not have View query or Create alert options like the other infrastructure charts do. For more about using APM and infrastructure monitoring together, see APM data in infrastructure. Network tab The Network page provides real-time visibility into the health and performance of individual hosts, web servers, or other groups of resources across your network. Default charts show bandwidth metrics by packet, bandwidth by bytes, and errors per second. Details about individual interfaces can help you: Examine saturation levels across your network or for selected filter sets. Compare load balances between specific resources. Identify unexpected differences in capacity patterns between similar hosts. Evaluate the top five network errors that New Relic automatically presents for the selected time period. This real-time network data can then help you determine whether to resolve errors by reconfiguring your network, rebalancing the loads, or taking other preventative maintenance actions before needing to make a purchase decision. From the Network tab you can view bandwidth and error data about your network interfaces. The Network page includes an Events heatmap, which provides a snapshot of the events occurring within the same time range as the displayed metrics. For a technical explanation of the attributes used to populate the Network page chart, see NetworkSample attributes. Network tab functions Here are some of the things you can do from the Network tab: If you want to... Do this... Filter and group Use filter sets to show only hosts matching certain criteria, or use Group by to aggregate the results. Select a time range Use the time picker to change the range of time selected. You can also click and drag on the chart to select a custom time range. When you select a time range, it carries over when you go from one infrastructure page to another. Change metrics displayed in chart Use the sorting dropdown to switch what metric the chart is displaying for the chosen process groupings, including: Received Bytes Received Dropped Received Errors Received Packets Transmitted Bytes Transmitted Dropped Transmitted Errors Transmitted Packets Search and filter the list Type in the Search interfaces search bar to filter the list to only those items containing the text you've typed. You can also filter the list by simply selecting the list item or user name you want to filter for. The chosen filters are displayed beside the filter icon above the chart. Add items to chart The chart, by default, displays the top five results. Use the Chart shows dropdown to display more results. To remove an item from a chart, select its name below the chart. Set an alert condition for a metric Mouse over a chart, select and then Create alert. (Not available on APM charts.) View host's alert threshold violation Select the host's Critical icon or Warning icon. Processes tab Important By default, the infrastructure agent doesn't send data about the operating system's processes. To enable the sending of process data set enable_process_metrics to true. To fine-tune which processes you want to monitor, configure include_matching_metrics. Use the Processes tab to get information about processes running on your hosts, and to set alerts on process metrics. The Processes tab shows data such as CPU percentage, I/O bytes, and memory usage for individual processes or groupings of processes. The page also includes an events heatmap, which provides a snapshot of the events occurring within the same time range as the displayed metrics. Use this information to: Pinpoint processes that are causing performance issues. Create alerts for conditions such as CPU percentage and memory usage. On the Processes page, CPU percent is scoped to individual processes, rather than hosts. Because of this, the CPU percent metric does not take into account the resources of the entire system. Instead, it shows how much of a single CPU core each process is taking. Example Here's an example of how to pinpoint an issue and set an alert: You notice on the Hosts page that a cluster has a CPU percentage much higher than normal. You go to the Processes page and filter down to that cluster's processes. You notice that several instances of the same process have excessive CPU percentage. After fixing the issue, you decide to create an alert condition that triggers when the CPU percentage for that process type exceeds a certain threshold. For a technical explanation of the attributes used to populate the Processes page chart, see ProcessSample attributes. Tip You cannot start, stop, or restart processes from the UI. Instead, follow standard procedures to start, stop, check, or restart the infrastructure agent manually. Processes tab functions Here are some of the things you can do from the Processes tab: If you want to... Do this... Only show hosts matching certain criteria Use filter sets. Aggregate results or group by host attributes Use Group by to change how the processes are grouped in the chart and the list. The dropdown contains host-related attributes such as hostID and entityName. If you are monitoring AWS EC2 instances, EC2-related attributes such as awsRegion will be available. Select a time range Use either of these options: Select any of the time picker options at the top of the page. Click and drag on the chart to select a custom time range. After you select a time range, it carries over from one infrastructure page to another. View Docker metrics To view process usage by Docker containers, see Docker instrumentation. Change charts Select the dropdown beside the chart's name to switch what metric the chart displays. Choices include: Memory: Resident or virtual size CPU percentage Disk I/O: Read or write Search and filter the list Use either of these options: Type in the Search processes search bar. Select the list item or user name you want to filter for. The selected filters appear beside the filter icon above the chart, where you can select and remove them as needed. Set an alert condition for a metric Mouse over a chart. Select and then Create alert. (Not available on APM charts.) View host's alert threshold violation Select the host's Critical icon or Warning icon. Storage tab The Storage page allows you to monitor your resources' capacity and efficiency, including your devices' overall utilization, disk usage, or I/O operations. This can help you to: Examine unexpected patterns; for example, a cluster of mirrored machines that do not process I/O tasks uniformly. Monitor usage levels before disk space completely runs out. Set alert conditions to notify you about problems with one or more hosts; for example, long processing times for read or write operations, disk availability or utilization based on percentage or bytes, etc. Make informed decisions about where to redistribute hosts with higher or lower than normal processing requests. Use data to help plan for additions or changes to your infrastructure budget before an emergency arises. The Storage page includes an Events heatmap, which provides a snapshot of the events occurring within the same time range as the displayed metrics. For a technical explanation of the attributes used to populate the Storage page chart, see StorageSample attributes. Storage tab functions Here are some of the things you can do from the Storage tab: If you want to... Do this... Filter and group Use filter sets to show only hosts matching certain criteria, or use Group by to aggregate the results. Select a time range Use the time picker on the upper right to change the range of time selected. You can also click and drag on the chart to select a custom time range. When you select a time range, it carries over when you go from one infrastructure page to another. Change metrics displayed in chart Use the sorting dropdown to switch what metric the chart is displaying for the chosen process groupings. Choices include: Total Utilization % Read Utilization % Write Utilization % Disk Used Bytes Disk Free Bytes I/O Read Operations I/O Write Operations Search and filter the list Type in the Search devices search bar to filter the list. You can also filter the list by simply selecting the list item or user name you want to filter for. The chosen filters are displayed beside the filter icon above the chart. Add/remove chart items The chart, by default, displays the top five results. Use the Chart shows dropdown to display more results. To remove an item, select its name below the chart. Set an alert condition for a metric Mouse over a chart. Select and then Create alert. (Not available on APM charts.) View host's alert threshold violation Select the host's Critical icon or Warning icon. Docker containers tab Use the Docker containers tab to get information about the containers running on your hosts, and to set alerts on container metrics. The Docker containers tab shows data such as CPU percentage, I/O bytes, and memory usage for individual containers or groupings of containers. The page also includes an events heatmap, which provides a snapshot of the events occurring within the same time range as the displayed metrics. Use this information to: Identify containers that are experiencing performance issues. Create alerts for conditions such as CPU percentage and memory usage. Docker containers tab functions Here are some of the things you can do from the Docker containers tab: If you want to... Do this... Only show hosts matching certain criteria Use filter sets. Aggregate results or group by host attributes Use Group by to change how the processes are grouped in the chart and the list. The dropdown contains host-related attributes such as image and operatingSystem. Select a time range Use either of these options: Select any of the time picker options at the top of the page. Click and drag on the chart to select a custom time range. After you select a time range, it carries over from one infrastructure page to another. View Docker integration dashboard To open the Docker integration dashboard, click the Dashboard link above the data table. Change charts Select the dropdown beside the chart's name to switch what metric the chart displays. Choices include: CPU: Used cores, kernel percentage Memory: Size limit, cache bytes I/O: Write count per second, total bytes Network: Errors per second, packets Process: Process count, restart count Search and filter the list Use either of these options: Type in the Search processes search bar. Select the list item or user name you want to filter for. The selected filters appear beside the filter icon above the chart, where you can select and remove them as needed. Set an alert condition for a metric Mouse over a chart. Select and then Create alert. View host's alert threshold violation Select the host's Critical icon or Warning icon.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.80087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>APM</em> <em>and</em> infrastructure data",
        "body": " by simply selecting the list item or user name you want to filter for. The chosen filters are displayed beside the filter icon above the <em>chart</em>. <em>Add</em> items to <em>chart</em> The <em>chart</em>, by default, displays the top five results. Use the <em>Chart</em> shows dropdown to display more results. To remove an item from"
      },
      "id": "60440a6d196a675f6c960f58"
    }
  ],
  "/build-apps/ab-test/pie-charts": [
    {
      "sections": [
        "Add and customize NRQL charts",
        "Important",
        "Add NRQL charts to dashboard",
        "Customize NRQL charts"
      ],
      "title": "Add and customize NRQL charts",
      "type": "docs",
      "tags": [
        "Insights",
        "Use Insights UI",
        "Manage dashboards"
      ],
      "external_id": "680a20b0b37c8cf8e8d9366b5394aa528748dcef",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/manage-dashboards/add-customize-nrql-charts/",
      "published_at": "2021-04-16T15:06:44Z",
      "updated_at": "2021-03-30T09:55:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. Using NRQL, you can create NRQL charts to visualize your data in billboards, pie charts, histograms, and other formats. NRQL charts have some different display and customization options than metric charts. Add NRQL charts to dashboard Whenever you run a NRQL query, you can add charts for that query to a dashboard. To add the resulting chart to the current dashboard, select Add to this dashboard. To add the chart to another dashboard, select Add to and select the target dashboard from the list. Customize NRQL charts To edit a chart, select Edit chart from the chart menu . Customization options include: Change the underlying NRQL query to change things like the time window, returned data, the type of chart, etc. Change or add the title. Add notes to a chart in the Notes field to remind yourself of what data a widget displays, or to share information with teammates. Link to another dashboard. Copy to another dashboard. Expand the chart. Embed it in a webpage. Each instance of a chart is unique. Editing a chart will not affect any other copies of that chart, in the same dashboard or in a different dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.11999,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Add</em> and customize NRQL <em>charts</em>",
        "sections": "<em>Add</em> and customize NRQL <em>charts</em>",
        "body": " our Explorers Hub post. Using NRQL, you can create NRQL <em>charts</em> to visualize your data in billboards, <em>pie</em> <em>charts</em>, histograms, and other formats. NRQL <em>charts</em> have some different display and customization options than metric <em>charts</em>. <em>Add</em> NRQL <em>charts</em> to dashboard Whenever you run a NRQL query, you can"
      },
      "id": "6043ed4828ccbc61cd2c60c5"
    },
    {
      "sections": [
        "Troubleshoot pie chart with uniqueCount over 100%",
        "Problem",
        "Important",
        "Solution",
        "Cause"
      ],
      "title": "Troubleshoot pie chart with uniqueCount over 100%",
      "type": "docs",
      "tags": [
        "Insights",
        "Use Insights UI",
        "Manage dashboards"
      ],
      "external_id": "398ea7b71860441fb1fef1c3d16d65de81e3fd21",
      "image": "https://docs.newrelic.com/static/79854b1975631f48f5484641417b12ad/8c557/crop-pie-chart-uniquecount.png",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/manage-dashboards/troubleshoot-pie-chart-uniquecount-over-100/",
      "published_at": "2021-04-16T17:38:38Z",
      "updated_at": "2021-03-30T09:56:47Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. When using a pie chart with the uniqueCount aggregator function, the percentages add up to more than 100%. Solution Using a bar chart or table may provide a more accurate visualization of uniqueCount data. Cause The attributes being uniquely counted may be present in multiple facets. This overlap may result in the facet percentages adding up to more than 100%. For example, in the query SELECT uniqueCount(user) FROM PageView FACET appName, a single unique user may use multiple applications. Each of these users will be included in the unique value for each of the appropriate facets (applications), but the total number of unique users will not change. insights.newrelic.com > Query > (query using uniqueCount): Pie charts using uniqueCount can produce percentages that add up to more than 100%. In this example, you have 200 unique users. Of those, 198 of those users (99% of 200 unique users) have accessed your \"Account\" app, and 196 users (98% of 200 unique users) have accessed your \"Store\" app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.787125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot <em>pie</em> <em>chart</em> with uniqueCount over 100%",
        "sections": "Troubleshoot <em>pie</em> <em>chart</em> with uniqueCount over 100%",
        "body": " for this transition, see our Explorers Hub post. When using a <em>pie</em> <em>chart</em> with the uniqueCount aggregator function, the percentages <em>add</em> up to more than 100%. Solution Using a bar <em>chart</em> or table may provide a more accurate visualization of uniqueCount data. Cause The attributes being uniquely counted may be present"
      },
      "id": "6043ee56196a679eb6960f19"
    },
    {
      "sections": [
        "Use your charts",
        "Change the appearance of your chart",
        "Customize your charts",
        "Tip",
        "Format date and time",
        "Customize the Y axis",
        "Enable or disable the legend",
        "Remove the Other groups facet",
        "Chart share and view options"
      ],
      "title": "Use  your charts ",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Use charts"
      ],
      "external_id": "947a92d0243924f412fedb47bcb95dc40ec953fb",
      "image": "https://docs.newrelic.com/static/9bd74f30a31df0cb0ab112a325296b92/59415/crop-cb-chart-menu-tooltip_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/use-charts/use-your-charts/",
      "published_at": "2021-04-17T03:45:47Z",
      "updated_at": "2021-03-16T02:54:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Once created, you can customize the appearance of your chart to best present the data. You can share a chart in different formats and add a chart to a new or existing dashboard. Change the appearance of your chart When you run your query in advanced (NRQL) mode or view your chart while using basic mode to specify data, the query builder analyzes your data and applies a chart type that fits your data. You can select another chart type that you prefer — your chart should tell the story that you want to communicate. Some chart types may not be available due to the nature of the data you specified. To change the appearance of your chart, use the Chart type menu to the right of the current chart. Each type in the list has a tooltip with information about using that type. Example of the Chart type menu, showing a tooltip. Customize your charts While we try our best to optimize how we display your data, sometimes you may have other needs. To this end, you can customize charts to display information at your convenience. Tip Customizations are available depending on the chart type. Format date and time Tip For table and billboard charts. Customize the date and time format for tables and billboards: for each type of data, you can select if you want to leave it as it is, or modify the format as Numeric or Date. If data is a timestamp, you can choose how to represent the date and time: For numbers, select if you want us to auto-format them, or chose the number of decimals you want to see. Customize the Y axis Tip For line and area charts. On line charts and area charts you can adjust the Y axis to display the data within certain values by setting a minimum and maximum value for the axis. If no customization option is selected, dashboards automatically displays the full Y axis from 0 to the top value plus a margin. Enable or disable the legend Tip For line and area charts, and histograms. For line charts, area charts, and histograms, you can disable or enable the legend. Remove the Other groups facet Tip For bar and pie charts, and tables. When faceting on bar charts, pie charts, or tables, and if the number of faceting on queries is larger than 2,000, the Other groups facet aggregates the rest of facets. With this customization you can select whether to see Other groups, or remove it. Chart share and view options Most charts have various options, including a chart-embed option, getting a chart as an image, and adding a chart to a dashboard. To read about general chart options, see Basic UI features.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.767265,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use  your <em>charts</em> ",
        "sections": "Use your <em>charts</em>",
        "tags": "Use <em>charts</em>",
        "body": "Once created, you can customize the appearance of your <em>chart</em> to best present the data. You can share a <em>chart</em> in different formats and <em>add</em> a <em>chart</em> to a new or existing dashboard. Change the appearance of your <em>chart</em> When you run your query in advanced (NRQL) mode or view your <em>chart</em> while using basic"
      },
      "id": "603ec29a196a67ef5da83d82"
    },
    {
      "sections": [
        "Chart types",
        "Important",
        "Chart types for events",
        "Area chart",
        "Attribute sheet",
        "Bar chart",
        "Billboard",
        "Tip",
        "Bullet chart",
        "Event",
        "Funnel",
        "Gauge",
        "Heat map",
        "Histogram",
        "JSON",
        "Line",
        "List",
        "Pie chart",
        "Table",
        "Chart types for metric data"
      ],
      "title": "Chart types",
      "type": "docs",
      "tags": [
        "Insights",
        "Use Insights UI",
        "Manage dashboards"
      ],
      "external_id": "fdac9748f273b0e6a7ebe46bcc239edab903999d",
      "image": "https://docs.newrelic.com/static/a6a69d150667030e6382f24d82f62370/c1b63/crop-insights-attribute-sheet-chart.png",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/manage-dashboards/chart-types/",
      "published_at": "2021-04-16T11:57:15Z",
      "updated_at": "2021-03-29T18:22:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. New Relic One supports a variety of visualizations to present your data in whatever format works best for your needs. A chart's refresh rate is calculated based on the query's timeframe. Chart types for events You can browse your data using several options in New Relic One, including: Data explorer Basic or advanced (NRQL) queries Advanced PromQL-style mode When you create a chart in the New Relic One query builder, you can select any of the chart types appropriate for that query. Depending on the data specified in your query, some chart types may be unavailable (grayed out). A small table shows the availability status of a chart type for Insights and New Relic One. Area chart Basic mode Advanced (NRQL) mode Insights An area chart shows a time series for a single attribute. The area chart type shows a time series for a single attribute. To enable an area chart, add a FACET to your query. Important You can add only one facet in basic mode. If you're using advanced (NRQL) mode you can use facet to add up to five attributes, separated by commas. Use the TIMESERIES function when you use a FACET in an NRQL query. Use Area chart when you want to View the measurement of a single attribute over a period of time that you specify. Avoid Area chart when you want to View a chart that contains more than a single attribute. The line chart type is a good option; you can view multiple attributes over a time range that you specify. The bar chart type gives you a comparison view between the attributes; it uses a total of each attribute for the time range you choose. Attribute sheet Basic mode Advanced (NRQL) mode Insights An attribute sheet is a list of values for a single set of selected attributes. It is similar to the table chart type but is an option only when you are not using a FACET clause. The attribute sheet shows the single value from the query results. Use attribute street when you want to View a list of attributes for a set of single-value attributes. Avoid attribute street when you want to View data when you have used FACET function in your query. The table chart type is an option when your query uses FACET or when you have multiple values for each attribute. Bar chart Basic mode Advanced (NRQL) mode Insights The bar chart shows comparisons among the categories returned in the query results. The bar chart compares a related set of values. To enable a bar chart, add a FACET clause to the query. Important You can add only one facet in basic mode. You can use FACET with up to 5 different attributes, separated by commas. Use bar chart when you want to Create a chart that reports the total count of the data for a category over the specified time range. With the bar chart format, you can easily see the differences between each category. Avoid bar chart when you want to Include measurements over a period of time. This chart type is not available when using a TIMESERIES clause. The line chart type is a good option for this visualization. Billboard Basic mode Advanced (NRQL) mode Insights The billboard chart type presents results as a single, highly-visible value. It's an option when your query returns a single number, such as from this query: SELECT uniqueCount(session) FROM PageView since 1 day ago Copy A billboard chart is useful for single-stat queries like the Apdex function. Use billboards to monitor values at a glance. Billboards can also be used to compare a single value across states. For instance, use the COMPARE WITH clause to compare the same attribute across two different time frames. The billboard chart displays a single value in a large, easy to read font. To enable the data for a billboard chart, search for a single value. You can view multiple values by adding a facet from the dropdown. You can set Warning and Critical thresholds on billboards, which will highlight a chart in yellow or red. The threshold fields are on the right side of the chart edit pane, highlighted in yellow and red respectively. If you want to highlight a chart when a value falls below a given value rather than above it, set the Warning threshold higher than the Critical threshold. Tip Threshold fields will only be available for dashboards that present a single value. For instance, the use of a COMPARE WITH clause will disable the threshold settings in the edit pane. Use billboard when you want to Monitor values, including thresholds for Critical and Warning states, in a large, easy-to-read font. Avoid billboard chart type when You want to view data over a period of time. The line chart type is a better option for viewing data by time. Bullet chart Basic mode Advanced (NRQL) mode Insights Use the bullet chart type to represent progress to a target or goal, called the limit. To use this chart type, run a query that returns a single number, such as: SELECT uniqueCount(session) FROM PageView SINCE 1 day ago Copy The bullet chart displays a value compared against a limit. Bullet defaults to a limit that is twice the resulting query value. To adjust the limit, use the Limit field to enter another number. The bullet will adjust accordingly. Tip The bullet chart type can only be used for charts that present a single value. For example, a query using COMPARE WITH will not list bullet as an option. Use bullet when you want to View a chart uses a large, easy-to-read font that helps you view the value quickly. Avoid bullet when you want to View data that has more than a single value. Bar and line chart types may be better choices in this instance. The bullet chart type is not supported in Insights; use the gauge chart type instead. Event [check icon] Basic mode [check icon] Advanced (NRQL) mode Insights * * * * The event chart type lists the data in a text format. Use event when you want to Create a text file that contains the attribute name and its value. The file can be shared and the content easily embedded into a report or spreadsheet, for example. Avoid event when you want to Present the data in a graphic, which can be helpful when monitoring the event on a dashboard. The billboard chart type is a good option for single-value data visualization. Funnel Basic mode Advanced (NRQL) mode Insights Use funnels to evaluate a series of related events that are the steps toward a specified goal. A funnel allows you to ask, “Of the people that did (A), how many also did (B), and of the people that did (A) and (B), how many also completed (C)?” Sample funnel chart for a shopping site. In this example, you want to determine that of all the visitors that viewed the landing page, how many of them: Browsed the products. Then added one or more products to a shopping cart. And finally, purchased the item(s) in the shopping cart. Unlike other queries, you must use a SELECT funnel() statement in your query; the funnel chart type is not selectable from any other type of query. Additionally, the funnel chart type is only available for queries with eight steps or fewer. A funnel query that includes more than eight steps will only return the results as JSON. SELECT funnel(session, WHERE pageUrl like '%/index.html' AS 'Landing', WHERE pageUrl LIKE '%/browse/phones' AS 'Browse ', WHERE pageUrl LIKE '%/shoppingcart' AS 'Cart', WHERE pageUrl LIKE '%/checkout' AS 'Purchased') FROM PageView where appName = 'WebPortal' AND duration < 1 SINCE 1 week ago Copy Use funnel when you want to You want to visually evaluate the paths that visitors take after they hit a page that you designate as a landing page. Avoid funnel when you want to You only want counts for the attributes in the WHERE clause. You will not be able to choose funnel unless you use SELECT funnel in your query. Gauge Basic mode Advanced (NRQL) mode Insights Use the gauge chart type to represent progress to a target or goal, called the limit. To use this chart type, run a query that returns a single number, such as SELECT count(*) FROM PageView SINCE 1 hour ago Copy The gauge chart type displays a single value compared against a limit. The gauge defaults to a limit that is twice the resulting query value. To adjust the limit, select in the Limit field and enter another number; the gauge will adjust accordingly. When the value returned by the query exceeds the limit value, the gauge shows the limit value in blue, and the overage in purple. Use gauge when you want to View a large and easy-to-read comparison a value compared against a limit that you set. Avoid gauge when you want to Create a query that uses COMPARE WITH, as gauge will not be listed as an option. Gauge is not supported in New Relic One; use the bullet chart type instead. Heat map Basic mode Advanced (NRQL) mode> ** * * **Insights** * * ** The heat map displays data in a tabular format using color gradations to show frequency in specific time buckets. The heat map is a faceted distribution of values where color density represents the values displayed. To enable a heat map, use the Histogram() function with a numeric attribute and use FACET to add up to five attributes, separated by commas. See Histograms: View data distribution for more detailed information about histogram-based charts. Use heat map when you want to View tabular data for multiple attributes over a period of time, with gradated colors instead of numerals. Avoid heat map when you want to View the exact data for multiple attributes over a period of time. A line or bar chart may be an option. Histogram Basic mode ** Advanced (NRQL) mode * * ** Insights * * * * * * A histogram charts frequency across a series of value ranges. Use histograms to show the distribution of data across time buckets. See Histograms: View data distribution for more detailed information about histogram-based charts. Use histogram when you want to Chart frequency of data over a series of values. Avoid histogram when you want to View the same data as heat map or to view the data without the time buckets. JSON Basic mode Advanced (NRQL) mode Insights Use the returned JSON to review the raw data returned and to help develop integrations with New Relic. To implement integrations, use remote queries to return raw JSON as a service. Tip If you are using Insights, copy the JSON using the Copy JSON button. If you are using New Relic One query builder, use the Share menu to select Copy JSON. Example NRQL query: SELECT uniqueCount(name) FROM Transaction WHERE httpResponseCode = '200' TIMESERIES FACET appName LIMIT 10 SINCE 24 hours ago Copy Example JSOON response: { \"metadata\": { \"contents\": { \"messages\": [], \"timeSeries\": { \"messages\": [], \"contents\": [ { \"function\": \"uniquecount\", \"attribute\": \"name\", \"simple\": true } ] }, \"bucketSizeMillis\": 1800000 }, \"eventTypes\": [ \"Transaction\" ], \"eventType\": \"Transaction\", \"openEnded\": true, \"messages\": [], \"beginTimeMillis\": 1556226069396, \"endTimeMillis\": 1556312469396, \"beginTime\": \"2019-04-25T21:01:09Z\", \"endTime\": \"2019-04-26T21:01:09Z\", \"guid\": \"5238a2c6-328d-a5ff-9185-7f3f04c42d1e\", \"routerGuid\": \"1aea2ec5-0be8-3a60-7554-851e1b016eb0\", \"rawSince\": \"24 HOURS AGO\", \"rawUntil\": \"NOW\", \"rawCompareWith\": \"\", \"facet\": \"appName\", \"offset\": 0, \"limit\": 10 }, \"facets\": [ { \"name\": \"RPM Combined Production\", \"beginTimeSeconds\": 0, \"endTimeSeconds\": 0, \"timeSeries\": [ { \"results\": [ { \"uniqueCount\": 415 } ], \"beginTimeSeconds\": 1556226069, \"endTimeSeconds\": 1556227869, \"inspectedCount\": 4589471 }, [ { \"uniqueCount\": 1714 } ], \"beginTimeSeconds\": 1556310669, \"endTimeSeconds\": 1556312469, \"inspectedCount\": 53341469 } ], \"total\": { \"results\": [ { \"uniqueCount\": 2651 } ], \"beginTimeSeconds\": 0, \"endTimeSeconds\": 0, \"inspectedCount\": 5053841114 } }, \"performanceStats\": { \"inspectedCount\": 6088068932, \"responseTime\": 8077 } } ... Copy Line Basic mode Advanced (NRQL) mode Insights A line chart is useful for spotting trends over time. The line chart chart type plots a timeseries for an attribute. When working in basic mode in New Relic One, select a single attribute you can plot over time. When working with an NRQL query, either in Insights or advanced (NRQL) mode in New Relic One, SELECT one or more attributes you can plot over time and then use the TIMESERIES function. Use line chart when you want to Create a chart that lets you easily view trends over a specified time frame. Avoid line chart when you want to View your data using one or more attributes and see the values associated with each attribute. A bar or table chart is an option. List Basic mode Advanced (NRQL) mode< Insights The list chart type lists unique values for a given attribute. It is an option when the uniques( ) function is used in the select method. The list chart type shows the set of unique values for a given attribute. Use list when you want to Create a list of the value associated with each attribute. This list can be shared and easily added to reports and spreadsheets, for example. Avoid list when you want to When the data you want to view has multiple values for each attribute. The event chart type may be an option for New Relic One users. Pie chart Basic mode Advanced (NRQL) mode Insights A pie chart is the graphic representation of the table. It appears as an option for some functions when the FACET clause is used. To use this chart type, run a query that returns one value for each of a set of attributes. The pie chart chart type maps a set of values as a portion of a whole. To enable pie chart, add a FACET from the dropdown. You can add only one FACET in basic mode. If you're using Insights or advanced (NRQL) mode, you can use FACET to add up to 5 attributes, separated by commas, and also include the TIMESERIES function. Pie charts are unavailable for the following aggregator functions: average, apdex, min, max, percentage, and percentile. For uniqueCount, percentages may add up to more than 100%. Use pie chart when you want to Create a chart that that graphically presents a set of values as they relate to a whole. A pie chart is effective for displaying values for a time period, for example. Avoid pie chart when you want to Present data that does not use values as they related to a whole, such as with line charts. Table Basic mode< Advanced (NRQL) mode Insights A table is the standard view for a set of values related to a specific attribute (for example, the count of all page views by user agent name). By default, all tables are sortable by any one column. If you are using the FACET clause, the results will normally be returned as a table. You can use a table as a shortcut to other dashboards. If a table is faceted by attribute, selecting an entry will take you to an existing dashboard that is filtered by that attribute. If you have multiple dashboards filtered by that attribute, Insights selects the first one created. The table chart type, with its tabular format, works well for dashboards, as well as sharing the data for use in reports, for example. Use table when you want to Create a text-compatible table consisting of your data. This table can be shared and used in reports or imported into spreadsheets, for example. Avoid table when you want to View your data in a graphical format. Chart types for metric data Metric chart are unique from other event-based charts. You can view aggregated metric data reported to New Relic from your agent. To add and customize metric charts on your Insights dashboard, use the Metric Explorer. The metric explorer is not yet supported in New Relic One. However, once you have added a metric chart to dashboard, you can use the query builder in advanced (NRQL) mode to edit the query. To use advanced (NRQL) mode in New Relic One: Go to one.newrelic.com. Click the query data icon. If the query builder opens in basic mode, click Advanced (NRQL) in the top right corner of the basic mode container. Use the My recent queries dropdown in advanced (NRQL) mode to select the query associated with the metric chart on the Insights dashboard. When you open the query builder, you will see the last query mode you used, either basic mode or advanced (NRQL) mode. The My recent queries dropdown in advanced (NRQL) mode will display all of your New Relic queries, for both Insights and New Relic One, for both basic and advanced (NRQL) modes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.08601,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Chart</em> types",
        "sections": "<em>Pie</em> <em>chart</em>",
        "body": " use FACET to <em>add</em> up to 5 attributes, separated by commas, and also include the TIMESERIES function. <em>Pie</em> <em>charts</em> are unavailable for the following aggregator functions: average, apdex, min, max, percentage, and percentile. For uniqueCount, percentages may <em>add</em> up to more than 100%. Use <em>pie</em> <em>chart</em> when"
      },
      "id": "6043f0b1196a67bd76960f21"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/allwidgets1-1024x662.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/steal-this-dashboard",
      "sections": [
        "Build the All Chart Types dashboard",
        "Share your dashboard with the community, and win!",
        "Something for everyone who shares"
      ],
      "published_at": "2021-04-16T01:52:22Z",
      "title": "Steal this Dashboard! Every Insights Chart Type in One Dashboard",
      "updated_at": "2021-04-14T02:03:45Z",
      "type": "",
      "external_id": "dd4f8c007a04342a7d0cd0fcb9c328d8a12363c0",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Steal this Dashboard! Every Insights Chart Type in One Dashboard Nov 19, 2018 • 6 min read By Jimmy Wilcox Your modern software team moves fast. To help keep up the momentum, you’re likely gathering all kinds of data about the performance of your team and its deliverables. One of the best ways to visualize that data is to use New Relic Insights dashboards. Dashboards tell visual stories about your team’s work. They offer an instant view into the health of your systems, and they help you identify areas that need attention before problems arise. You need to set these views to match your workflows, and that’s why we give you so many ways to visualize the data you capture in New Relic. From billboards to histograms to gauges—you choose the visualizations that best help your team to understand what’s really happening. To illustrate the capabilities of New Relic Insights dashboards, we’ve built one that includes every possible way to visualize your APM data and pageview data—what we call the All Chart Types dashboard. These visualizations, or charts, come in a variety of formats, or widgets, and they are built using New Relic Query Language (NRQL) queries. Re-create this dashboard in your own environment to learn how each widget works. It’s a simple process: We supply all the necessary queries, and you should have it up and running in minutes. Whether you’ve created dozens of dashboards or you're just getting started, or even if you have never once looked at Insights, this is a dashboard you’re going to want to steal. Build the All Chart Types dashboard To reproduce the All Chart Types dashboard, you’ll need New Relic APM, New Relic Browser, and New Relic Infrastructure accounts. The dashboard works with the standard New Relic data models and does not require any custom attributes or events. The result will look something like the following screenshots:     To get started, you need to create a new dashboard in Insights: Navigate to newrelic.com, and select the green plus (+) icon next to All dashboards. Name your dashboard. On the dashboard, click Edit and then click the gear icon Filter enabled. Configure the following settings: Select Enable filter For Event types select PageView For Attributes set countryCode To add a widget and chart to your dashboard, run a NRQL query to populate the relevant data you want to visualize. For our All Chart Types dashboard, we’ve provided the relevant queries and an explanation of what each one does. Cut and paste them into your Insights query bar. Chart Type Definition NRQL query Comparison billboard Compare the number of pageviews this week with last week. SELECT count(*) FROM PageView SINCE 1 hour ago COMPARE WITH 1 week ago Attribute sheet Display the total number of pageviews, unique sessions, and the maximum page-load duration from the past hour. SELECT count(*), uniqueCount(session), max(duration) FROM PageView SINCE 1 hour ago Total page views billboard Display the total pageviews in the last hour. SELECT count(*) FROM PageView SINCE 1 hour ago Page load duration (per location) histogram Display a histogram of the page-load duration for a specific location (in this example, California). SELECT histogram(duration) FROM PageView where countryCode IN ('CA', 'US') SINCE YESTERDAY Unique sessions facet pie chart Display a pie chart, which can be faceted, showing the number of unique sessions per country. SELECT uniqueCount(session), average(duration) FROM PageView FACET countryCode LIMIT 10 SINCE YESTERDAY Total pageviews bar chart Display a bar chart, which can be faceted, showing the total number of pageviews per country. SELECT count(*) from PageView facet countryCode Pageload duration heatmap Display a heatmap of page-load durations, faceted by page URL. SELECT histogram(duration) from PageView facet pageUrl Pageview gauge Display the total number of pageviews. SELECT count(*) from PageView Related-events funnel Display a funnel that evaluates a series of related events that are the steps toward a specified goal. SELECT funnel(user, where name = 'Controller/applications/index' as 'App Index', where name = 'Controller/applications/show' as 'App Detail', where name = 'Controller/traced_errors/index' as 'Errors') from PageView Duration line-chart comparison Compare yesterday’s duration times with duration times from today. SELECT average(duration) FROM PageView SINCE yesterday TIMESERIES auto COMPARE WITH 1 day ago Timeseries-view area chart Show a timeseries view of today’s average page-load durations. SELECT average(duration) FROM PageView SINCE yesterday TIMESERIES auto Page-load line chart Display average duration and percentiles from today’s page loads. SELECT average(duration), percentile(duration, 50, 90) FROM PageView SINCE yesterday TIMESERIES auto Uniques list Display a stacked chart of the total number of pageviews faceted by country. SELECT uniques(pageUrl) FROM PageView Pageviews stacked chart Display a stacked chart of the total number of pageviews faceted by country. SELECT count(*) FROM PageView FACET countryCode TIMESERIES auto since yesterday Single pageview attributes chart Display the available attributes for a single pageview event. SELECT * FROM PageView limit 1 Number of sessions and average duration facetable table Display a facetable table showing the unique number of sessions and average duration per country. SELECT uniqueCount(session), average(duration) FROM PageView FACET countryCode LIMIT 10 SINCE YESTERDAY Number of sessions and average duration multi-facetable table Display a facetable table showing the unique number of sessions and average duration per country and city. SELECT uniqueCount(session), average(duration) FROM PageView FACET countryCode, city LIMIT 10 SINCE YESTERDAY Pageview event table Display a table of the most recent events captured by PageView. SELECT * FROM PageView limit 10 Maximum page load for a specified time period Display the maximum page-load duration captured for the default time period. SELECT max(duration) from PageView Event feed Display events in a feed. SELECT * FROM InfrastructureEvent Raw JSON Display an event in its raw JSON format. SELECT * FROM PageAction (Refer to the Insights chart types documentation for more about each chart type.) Share your dashboard with the community, and win! On November 26th, 2018, New Relic will kick off our Shared Dashboards contest. You’ll have two weeks to enter by sharing your most useful queries, Insights charts, and dashboards in the Explorers Hub. Something for everyone who shares There are two chances to win a New Relic branded Apple Watch, but everyone gets something for sharing: One Apple Watch winner will be selected by you via a community vote. A second Apple Watch winner will be selected by the New Relic team. Everyone who shares a dashboard will earn a New Relic Developer Program t-shirt and a contest badge. To help get you started and provide more inspiration, our dashboard experts will be sharing a Dashboard of the Day, complete with the NRQL queries that you can use to create these same dashboards in your own environments. Get ready to tell your story and share your dashboards. You could win big! By Jimmy Wilcox Jimmy began his career at New Relic on the Global Technical Support team, specializing in Account Management, New Relic Browser, and New Relic Insights. He now works on the Digital Platform Services team as an Associate Solutions Architect, helping to drive customer enablement. When he isn't working, Jimmy can be found knitting on a couch or out hiking the beautiful trails of the Pacific Northwest. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.34842,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Steal this Dashboard! Every Insights <em>Chart</em> Type in One Dashboard",
        "sections": "Build the All <em>Chart</em> Types dashboard",
        "body": " to understand what’s really happening. To illustrate the capabilities of New Relic Insights dashboards, we’ve built one that includes every possible way to visualize your APM data and pageview data—what we call the All <em>Chart</em> Types dashboard. These visualizations, or <em>charts</em>, come in a variety of formats"
      },
      "id": "60764d81196a67181164a78d"
    }
  ],
  "/build-apps/ab-test/demo-setup": [
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/sean-winters-1.jpg?h=bb00930c&itok=NUV55qE9",
      "url": "https://newrelic.com/blog/best-practices/best-practices-aws-lambda",
      "sections": [
        "Don’t reinvent the wheel if you don’t have to",
        "Understand there is still an underlying infrastructure",
        "Don’t leave your function out in the cold",
        "Eliminate recursion and embrace concurrency",
        "Know your limits",
        "Take advantage of complementary services",
        "You (probably) don’t need to use serverless functions for everything",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:23:43Z",
      "title": "Tips and Practical Guidance for Getting Started with AWS Lambda",
      "updated_at": "2021-04-14T00:32:53Z",
      "type": "",
      "external_id": "a58e2de9ff8db1d234d4e9df31045042fef66c1f",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Cloud Tips and Practical Guidance for Getting Started with AWS Lambda Nov 13, 2018 • 11 min read By Sean Winters Contrary to popular opinion, the term “serverless” is not entirely synonymous with AWS Lambda. In fact, the rise of Lambda seems to have inspired widespread adoption—and possible misuse—of the term “serverless.” Serverless is a general term that includes all cloud services that don’t require an administrator to spin up a server to run them (think Amazon DynamoDB or Amazon S3). Amazon Web Services has been promoting serverless computing for some time, and AWS Lambda is their functions as a service (FaaS) platform. The key feature of AWS Lambda is that you can upload and run application code with basically no administrative oversight. AWS takes care of your app’s scale and delivers high availability, and your code runs only when triggered via API calls. These lightweight, hands-off serverless functions are changing developer workflows. I’ve been experimenting with AWS Lambda since it launched, and in my spare time, I’ve built some fun projects using functions and New Relic's AWS Lambda monitoring integration. I’ve found that Lambda generates a lot to think about, from behavior to cost considerations. To that end, I’ve put together this collection of tips and practical advice for getting started with AWS Lambda. (Note: Other major cloud providers like Microsoft Azure and Google Cloud Platform have launched their own serverless, FaaS platforms, but this post focuses on AWS Lambda.) Don’t reinvent the wheel if you don’t have to When you create a new AWS Lambda function, you’re given the option of starting a new function from scratch, choosing a preconfigured template (or “blueprint”) as a starting point, or using an existing function that another user has uploaded to the AWS Serverless Application Repository. If you’re looking to create a common service or application, there’s a good chance you’ll find an implementation to import or borrow from. Applications in the Serverless Application Repository and blueprints adhere to the serverless application model (SAM) template. The AWS serverless application model is an extension of the CloudFormation template—used to define an AWS cloud stack—that defines how your serverless applications connect to other AWS resources. In some cases, shipping an app that uses AWS Lambda functions may be as simple as deploying the template and changing a few environment variables and parameters. Understand there is still an underlying infrastructure Spoiler alert: Underneath it all, your AWS Lambda functions run on containers in AWS' backend. One of the main advantages of using serverless functions is that you’re not supposed to worry about managing the backend. However, if your AWS Lambda function uses a lot of the container’s memory or CPU, or if it uses the host’s underlying file system (for example, to write temporary files), it’s crucial that you specify resources accordingly. It’s also interesting to note that FaaS providers have started rolling out service level agreements (SLAs). AWS has recently released its own, guaranteeing 99.95% availability for each AWS region. This is a good sign of Amazon’s commitment to this service, as well as a likely indicator that more and more enterprises are adopting AWS Lambda functions in their development practices and workflows. Don’t leave your function out in the cold When you trigger an AWS Lambda function for the first time, it needs some time to initialize: to load your code and any dependencies into the assigned container, and then to start the execution of your code. This initial runtime is known as a “cold start.” Subsequent, timely runs with that container won’t require a cold start and thus will be faster. If you leave the function (and therefore the container) inactive, AWS will eventually shut it down, and the function will have a cold start the next time you run it. There’s no definitive measure of how long AWS allows a function to idle—one engineer did enough research to hypothesize that 60% of cold starts happen after 45 minutes of inactivity—but it does seem dependent on factors like function size and the needs of other functions running in the shared cloud. There are ways to minimize the effects of cold starts. First, think about building your AWS Lambda functions as small as possible and minimizing bundled dependencies. According to our 2017 State of Serverles Report, “The total code size of AWS Lambda functions—how much disk space the code and the dependencies of a function consume—tends to be small by modern software standards. Nearly half of the monitored functions could almost fit on a 3½-inch floppy disk. Java functions were notable outliers. Their average code size was more than 20MB, indicating significantly larger function deployment sizes than Node.js or Python functions.” In other words, loading a 5 MB Python function into a new container on a cold start requires significantly less time than it takes to load a 20+ MB Java function. Another way to mitigate cold starts is to use a “keep warm” solution to keep your AWS Lambda functions container safe from termination. There are plenty of tools designed for this purpose, such as the Serverless WarmUP Plugin, which you can use to schedule a “warm up” event to run your functions every few minutes, at minimal cost. Of course, if your AWS Lambda function accepts concurrent requests, it will need to spin up concurrent containers so your function can serve requests as quickly as possible. In this case, cold starts may be unavoidable if the volume of requests is ever increasing, and AWS must start new containers. (Check out our post \"Understanding AWS Lambda Performance—How Much Do Cold Starts Really Matter?\" for more information on cold start optimizations.) Eliminate recursion and embrace concurrency The FaaS model has the potential to radically change how we deploy software applications, but it also requires us to change how we think about writing software to adapt to this new model. Specifically we need to change how we think about recursion and concurrency. It’s important to understand that AWS Lambda uses concurrency to scale your functions. In traditional applications, engineers could have to plug functions into an async framework to get requests running in parallel. With AWS Lambda, concurrency is handled by AWS; if there isn’t a “warm” container available to fulfill a request triggered by event sources like the Amazon API Gateway or Amazon S3, AWS Lambda will spin up a new container. Essentially, AWS removes a layer of abstraction and does the work of concurrency, so you don’t have to worry about it. But automatic concurrency means you have to be careful handling processes like recursion. Some of the most elegantly engineered functions employ a bit of recursion or include carefully crafted recursive implementations of an algorithm. However, in AWS Lambda functions, you don’t want an outer function to call itself. If this happens, AWS will spin up more concurrent instances of the function, and these concurrent instances, coupled with cold starts, will cost you compute time and money (inseparable concepts in this paradigm). Know your limits Function limits For each AWS Lambda function request, AWS sets limits on memory allocation, disk capacity, and execution time. In early November 2018, memory allocation starts at 128 MB and is capped at 3008 MB; disk capacity (/tmp directory storage) is limited to 512 MB; and the maximum duration of an AWS Lambda function is 900 seconds. If your function requires more memory or lasts longer than that, consider refactoring the function to make it more efficient, or break it down into smaller AWS Lambda functions. If you’re hitting disk capacity limits, use Amazon S3 for storage. Concurrency limits As mentioned, AWS Lambda uses concurrency to scale your functions. AWS sets the default limit at 1,000 concurrent executions, per region. Expect some throttling if you exceed this limit. If you have a single function that exceeds your limits, consider adjusting your concurrent execution limit at the function level. Deployment limits If you work with a language that favors large deployment packages, you may hit deployment package limits. Currently, AWS sets deployment limits at 50 MB for zipped packages and 256 MB for unzipped packages. You’ll want to be vigilant about removing unneeded libraries and otherwise keeping your functions as small as possible. If you have a group of specialized AWS Lambda functions (in other words, functions that perform only one task), consider logically combining them into one function to avoid having to deploy the same shared library across the AWS Lambda environment. Monitor your limits with the New Relic AWS Lambda integration Use New Relic's AWS Lambda monitoring integration for New Relic Infrastructure to report data such as invocation counts, error counts, function timers, concurrency, and other metrics and inventory data. You can view your AWS Lambda data in pre-built dashboards and also create custom queries and charts in New Relic Insights. Take advantage of complementary services Bring your team together with Cloud 9 Cloud 9 is a browser-based integrated development environment (IDE) you can use in the AWS console. By bundling necessary plug-ins, libraries, and SDKs, AWS has made it easy to engineer and deploy Lambda functions from Cloud 9. You can run your full Lamba development environment on one EC2 instance, and share real-time access with your team. Perform local development and iteration with SAM CLI If you want to integrate AWS Lambda function development into your local workflow, try the open source AWS SAM CLI. The AWS SAM CLI lets you use the serverless application model (SAM) to locally develop, test, and iterate on your functions before you deploy them into production. Take advantage of open source, including the Serverless Framework The Serverless Framework is an open source, provider-agnostic CLI that allows you to develop and test functions locally and deploy them when you’re ready. It also boasts a great developer community that has come up with an extensive list of plugins for building out your functions. Turn your AWS Lambda functions into a state machine with AWS Step Functions Eventually you may have several AWS Lambda functions—or several AWS Lambda functions and services running in containers or on Amazon Elastic Compute Cloud (EC2) instances—performing different tasks in your application. It can be challenging to coordinate, debug, and visualize what’s going on in your backend. This is where AWS Step Functions help. Think of Step Functions as workflows in which you define your application as a series of steps that must be executed in a particular order. It eventually resembles a state machine enforcing a programmatic flow within your serverless application. You (probably) don’t need to use serverless functions for everything As cutting-edge technology paradigms make their way into the mainstream, eager users will naturally want to apply the new tech to solve old problems. With serverless technologies, we should strive to avoid false dichotomies: It’s not about serverless vs. monoliths, or serverless vs. containers. Instead, let’s work toward definitions for how serverless functions and services, in combination with everything else, fits into our modern architectures. In fact, some cloud users are using serverless in conjunction with traditional servers and containers in their hybrid cloud environments. After all, some applications are a perfect fit for serverless frameworks, and others not so much. If you are considering going full serverless, we recommend that you do your research and calculate whether a serverless architecture would be less expensive or more viable for your needs. You can perform your own comparisons, use an AWS calculator, or have fun trying out third-party estimators. The debate over whether or not serverless functions are ready for the big time will continue for a while, so be sure to check in with both sides, as we did in \"The Great Serverless Debate\" podcast. Related Topics Cloud By Sean Winters Sean Winters is a Technical Support Engineer in New Relic's Dublin office. When not helping customers harness the power of New Relic, he's doing everything it takes to win his fantasy football league. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.50009,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Take advantage of complementary <em>services</em>",
        "body": ". In fact, the rise of Lambda seems to have inspired widespread adoption—and possible misuse—of the term “serverless.” Serverless is a general term that includes all cloud <em>services</em> that don’t require an administrator to <em>spin</em> <em>up</em> a server to run them (think Amazon DynamoDB or Amazon S3). Amazon Web"
      },
      "id": "6076383564441ffda49d859c"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/6-Snowflake-new-orders-received.png",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-snowflake-integration",
      "sections": [
        "Detect and resolve warehouse performance issues",
        "Optimize costs, credits used",
        "Detect potential security issues and failed logins",
        "Monitoring and alerting custom Snowflake data",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:23:43Z",
      "title": "New Relic Snowflake Integration Boosts Observability",
      "updated_at": "2021-04-13T23:25:02Z",
      "type": "",
      "external_id": "03e7785a57d3c95f9665eb6cb43c0b27760405e9",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Integrations New Relic Snowflake Integration Boosts Observability Jan 12, 2021 • 6 min read By Daniel Fitzgerald Snowflake, a data platform company that provides a scalable infrastructure in the cloud, can meet a diverse set of needs, from building a data lake to data warehousing, reporting, and analytics. This versatility, plus the benefits of running in the cloud, such as low maintenance and access to massive scale, means that more and more companies are turning to Snowflake. Like any piece of critical infrastructure, once Snowflake starts to play a key role in delivering value to a company or set of users, it’s critically important to make sure it’s secure, performant, and delivers the data you need in a timely fashion. That sounds like a job for New Relic. We are introducing our Snowflake integration, which gives you a broad view of how Snowflake is working across the following areas: costs, performance, security, and availability. In this post, we’ll walk through some key use cases to help you: Detect and resolve warehouse performance issues Optimize costs—whether that’s expensive queries, users running many queries, or warehouses that contribute the most to your bill Detect potential security issues and failed logins Monitor and alert on custom Snowflake data Detect and resolve warehouse performance issues In Snowflake, a virtual warehouse is a massively parallel processing (MPP) cluster, which you can spin up on-demand to execute user queries. Virtual warehouses can be different sizes for different workloads. If a warehouse doesn’t have enough capacity to run the queries in-memory, it will spill some bytes to the disk or remote storage. When this happens, there is a significant impact on query performance. Keep an eye on these metrics, consider setting up alerts to see when these cases happen, and think about increasing the size of virtual warehouses that experience these symptoms. Warehouse size also impacts the number of queries that you can process at any one time. A sign that a cluster needs to be resized is when you see disk spillage (bytes spilled to local or remote storage) or queries being queued. Here are two queries you can use to detect each of these scenarios: SELECT average(BYTES_SPILLED_TO_LOCAL_STORAGE_AVERAGE)FROM SnowflakeVirtualWarehouse WHERE metric_type = 'snowflake.query_performance' SELECT average(QUEUED_LOAD_AVERAGE) FROM SnowflakeVirtualWarehouse WHERE metric_type = 'snowflake.warehouse_performance' You can use New Relic Alerts to tell you when a warehouse is queueing queries and should be resized. If an alert triggers, you can resize the warehouse or increase the maximum number of clusters if you have the multi-cluster warehouses setting enabled. A key area for performance improvements is pinpointing inefficient or poorly written queries. In the chart below, we can detect when Snowflake is spending long periods compiling and executing queries. If you detect a spike in these times, you can dive in further to pinpoint which queries are causing the impact and optimize them to be more efficient. Optimize costs, credits used One of Snowflake’s key benefits is its consumption-based pricing model that allows you to spin up new capacity instantly. Of course, with great power comes great responsibility. Like any consumption-based system, it’s easy to spend more than you mean to; that’s why it’s important to keep an eye on costs and alert when spend goes over an acceptable level. Using a linear prediction function, you can predict when a warehouse spend is likely to reach a certain level in the future based on historical data. You can also alert when a particular warehouse spend goes over a certain amount using NRQL alerts, which can help you get an instant notification if a spend goes above a certain threshold, preventing an unexpected bill due to user error or misconfiguration. Detect potential security issues and failed logins Maintain the security of your Snowflake account by looking at who is logging in. You can track the number of logins, whether they are successful or failed logins, and the  method used, such as an ODBC Connector, via the UI or using a programmatic interface such as the Python driver. A rise in the number of failed logins can indicate that someone is trying to gain unauthorized access to the account or an application or integration that has been misconfigured and could suggest an issue with an application. Monitoring and alerting custom Snowflake data Out of the box, the Snowflake integration collects a wide range of performance-related data. What’s more, the integration enables you to ingest any data stored in Snowflake. If you want to keep an eye on orders, revenue, or customer interactions in real time, you can. All you need to do is add a new query to the integration .yml file, and our agent will store the result of that query in New Relic, running at an interval you choose. Check the GitHub repository for further instructions. It’s easy to export custom data from Snowflake. Here we see tracking sales orders in real time, alongside the valuable performance data. Snowflake is becoming ever more popular, but to ensure that its adoption goes smoothly within your organization, you must have a level of observability across different aspects such as performance, costs, and security. With the New Relic Snowflake integration, this is easily achievable. Sign up for a free New Relic account today and start monitoring your Snowflake account. Related Topics Integrations By Daniel Fitzgerald Daniel Fitzgerald is a senior solutions consultant for New Relic, based in London, UK. He helps some of the New Relic's largest European clients develop their monitoring and observability strategy. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.57683,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ") cluster, which you can <em>spin</em> <em>up</em> on-demand to execute user queries. Virtual warehouses can be different sizes for different workloads. If a warehouse doesn’t have enough capacity to run the queries in-memory, it will spill some bytes to the disk or remote storage. When this happens"
      },
      "id": "6076284e28ccbc11b651c174"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/docker-chart-2-1.jpg",
      "url": "https://newrelic.com/blog/best-practices/docker-usage-dockercon-devops",
      "sections": [
        "Crunching the Docker numbers",
        "Docker use cases, from VM replacements to ephemeral computicles",
        "Docker is changing how code gets written",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:24:24Z",
      "title": "Exclusive: How Docker Containers Are Being Used Right Now",
      "updated_at": "2021-04-14T00:22:55Z",
      "type": "",
      "external_id": "650a66c6c573214be3d1940492d5a8b905b10743",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Cloud Exclusive: How Docker Containers Are Being Used Right Now Apr 18, 2017 • 7 min read By Adam Larson By now you’re probably familiar with Docker, and how its container technology aims to improve the way you do DevOps—and even how you architect your applications. By encapsulating your compute environments into scripted, lightweight black boxes rather than manually defined and cumbersome-to-maintain virtual machines, Docker has helped light up a whole host of new and faster workflows in Continuous Integration/Continuous Deployment (CI/CD) and microservice communication. Docker is a technology that New Relic has embraced for years and it now accounts for a majority of our internal production workloads—heck, our lead site reliability engineer even wrote a book on the topic! (See Docker: Up & Running: Shipping Reliable Containers in Production, by Sean Kane and Karl Matthias). Crunching the Docker numbers So as we approached the two-year anniversary of New Relic’s original release of support for Docker monitoring, we figured it was time to move beyond the anecdotal evidence to show Docker’s growth, impact, and usage by doing what we do best: crunching some numbers. The following data is based on the hundreds of millions of containers customers have sent through our system and speaks to trends in Docker usage across different industries, company sizes, and use cases. First, let’s do the fun glamor stats! In the last two years, New Relic has monitored more than 418 million containers (so many that we had to rewrite our analysis tools to accommodate the massive scale of data). In a typical day, we see more than 1.5 million containers, and an average customer has more than 800 containers running at any given moment. Our top ten customers by Docker container usage actually spin up more than 92,000 containers a day. Docker use cases, from VM replacements to ephemeral computicles So yeah, Docker seems to have officially transcended the realm of “fun new DevOps toy” to become a full-blown production workhorse. But 92,000 containers a day still sounds crazy, right? Well, as we’ve discussed in the past, some people use Docker as a replacement for their VM infrastructure, but others use it for lightweight, ephemeral compute tasks that spin up, do something, and then disappear (think AWS Lambda). To drive home how prevalent this use case is, we thought we’d share some interesting trends in the lifespan of these containers. Docker container lifespan by hours, under 24 hours: The chart above shows that if we analyze only the containers that run for less than 24 hours, the drop-off in usage is stark over time. Literally orders of magnitude more containers run for less than an hour than for several hours (so much so that you can’t even see the long tail on the graph). Docker container lifespan by minutes, under one hour: Going even further, the chart above shows just the containers that have run for less than one hour, ranked by number of minutes they ran. We can see that most of these containers last only a few minutes. I’m doubtful that’s a traditional CRM application running in those containers. Docker container lifespan by hour, from 2 hours to 24 hours: Above, looking at just the containers that live from 2-24 hours, we can see that things start to get a little more spread out, but the trend toward “shorter is better” remains consistent. Docker container lifespan by hour, shown on a Log10 scale: Finally, examining this data via a log scale (since you wouldn’t even be able to see most of the data using a non-log scale) gives a better sense of how container usage is so heavily stacked toward short run and ephemeral. Docker is changing how code gets written Whether it’s quick computicle executions like Lambda or the more constant CI/CD of traditional applications, it’s clear that Docker is impacting the way the industry is writing code—for better or for worse. What do you think these trends mean? Tweet at us @newrelic using hashtag #DockerTrends. Interested in why so many folks choose New Relic to monitor their Dockerized infrastructure? for more details on how we tie containers to what really matters—the applications they support—visit our Docker page or check out New Relic Infrastructure.   Related Topics Cloud By Adam Larson Adam Larson is a senior technical marketing engineer at New Relic. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.906296,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " you do DevOps—and even how you architect <em>your</em> applications. By encapsulating <em>your</em> compute environments into scripted, lightweight black boxes rather than manually defined and cumbersome-to-maintain virtual machines, Docker has helped light <em>up</em> a whole host of new and faster workflows in Continuous"
      },
      "id": "607635e064441f97ad9d8539"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/KeepCalmandCloudOn-min.jpg",
      "url": "https://newrelic.com/blog/best-practices/devops-serverless",
      "sections": [
        "What “serverless” really means",
        "A new role for ops in a serverless world",
        "Six priorities ops should focus on",
        "1. Automation",
        "2. Cost optimization",
        "3. Disaster recovery",
        "4. Monitoring",
        "5. Security",
        "6. Troubleshooting",
        "No rest for the weary ops team",
        "Your turn",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:33:44Z",
      "title": "6 Priorities for Ops in a ‘Serverless’ World",
      "updated_at": "2021-04-14T00:26:38Z",
      "type": "",
      "external_id": "c064ee3e1a66ca1844573730ca1030b89b3ab75d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit DevOps 6 Priorities for Ops in a ‘Serverless’ World Mar 6, 2018 • 9 min read By Kevin Downs The server as we know it is dying [mic drop]. To many, this may not come as a complete surprise. But if for some reason you haven’t been paying attention, the long, slow death of the server began in 2014, when Amazon Web Services (AWS) introduced AWS Lambda. For reference, here is a description of Lambda from AWS: “With Lambda, you can run code for virtually any type of application or backend service—all with zero administration. Just upload your code and Lambda takes care of everything required to run and scale your code with high availability. You can set up your code to automatically trigger from other AWS services or call it directly from any web or mobile app.” What “serverless” really means AWS Lambda is sometimes incorrectly referred to by the generic name “serverless.” However, serverless is a more general term that includes all cloud services that don’t require you, the administrator, to spin up a server to run it. Lambda is just one such cloud service. Another example of a serverless service is notification. AWS has a service called Amazon Simple Notification Service (SNS). You don’t spin up a server and install SNS on it—you consume SNS. There are many other examples of serverless services, so when I refer to serverless, I’m talking about any and all cloud services that don’t require (or allow) you to administer a server. Still, although various serverless services have been around for a while now, it was AWS Lambda that dealt the first real death blow for servers as we’ve known and used them. Since then, both Microsoft Azure and Google Cloud Platform have come out with their own answers to Lambda called Functions. I’ll use the generic term “functions” to refer to this type of serverless service. A new role for ops in a serverless world Lambda’s debut in 2014 prompted me to ponder where operations (the ops part of DevOps) should focus its priorities in a world where developers (the dev part of DevOps) have the ability to spin up, scale up, scale out, consume, repurpose, scale down, scale in, shut down, and retire infrastructure on their own. The fact that developers can now do all of this without looking over the wall for operations support represents a huge shift in workflow. I have total respect for developers, but after two decades on the technical support and monitoring side of the business, sometimes I feel like they’ve made off with the keys to the cloud candy store—and that’s a good thing! So where is all this brave new serverless stuff going to take operations? Should operations staff start polishing their resumes or think about switching careers? Basically, should operations be worried their role is in jeopardy? The answer is no, not by a long shot. Developers are not going to take over operations’ job responsibilities. Robots are not going to invade our domain and mock our pocket protectors. In other words ... Six priorities ops should focus on Of course, that doesn’t mean that nothing is going to change. The rise of serverless and functions and the empowerment of developers will indeed affect how ops teams work. Given that, I have six suggestions (in alphabetical order) for where ops folks should focus their priorities in a DevOps serverless world: 1. Automation As developers increasingly employ powerful scripted architecture services, operations will need to make sure they are one step (if not many steps) ahead. That means everything from checking to see if all the components are running correctly to making sure developers are cleaning up after themselves (“Are you done with that container?”). Operations folks must get good at automating their daily tasks, fast! Remember, developers are using that same automation to create infrastructure and functions as fast as they can, too. My recommendation: Study up on DevOps deployment orchestration tools such as AWS CloudFormation and similar services from other cloud vendors. 2. Cost optimization This issue has been ramping up for a while. Once upon a time, IT budgets were authorized, projects were approved, and infrastructure was purchased. Both developers and operations didn’t really care about costs because that was all handled at the project-approval level. After that, developers were the consumers of infrastructure and operations was there to support that infrastructure, keeping the lights on. Now, operations has a large role to play in understanding where and how to balance cloud-computing’s three-legged stool: availability, performance, and cost. Ops is uniquely positioned to answer such questions as, Are oversized instances being used? Is the autoscaler properly configured to scale down? Are storage and database resources properly being consumed? This becomes essential as developers gain a seemingly unfettered ability to create infrastructure and code functions. In this new environment, operations is the first line of defense against unexpected cloud bills. My recommendation: Become familiar with how cloud vendors charge for their services and shine a light into that dark, scary place (see “Monitoring” below). 3. Disaster recovery We all know things fail, even cloud services. Operations will always need to think about worst-case scenarios and make sure the environments being created are properly configured for failover. We have come a long way from offsite tape-backup repositories, but the same theories apply: what happens if this part of the architecture fails? Operations needs to make sure that as developers script infrastructure and code functions, failover strategies are in place. My recommendation: Break things on purpose (in development environments, of course) to learn how to create fault-tolerant, multi-region architectures ... then try to break those. 4. Monitoring This one can’t be overemphasized: monitor everything you can! If you don’t monitor it, you can’t know if it’s working (or was working) correctly or at all. In a cloud world, monitoring becomes more important as services that were running one minute can be decommissioned in the blink of an eye. Operations needs to monitor serverless services to make sure they are performing (or did perform) as expected. Monitoring cloud services gives operations essential information to improve future cloud service usage. My recommendation: Incorporate the cloud vendor’s built-in monitoring where appropriate. However, do you fully trust the fox to guard the hen house? Look to third-party monitoring solutions to gain an unbiased view. Critically, a third-party monitoring solution is essential to fully instrument and understand complex multi-cloud as well as hybrid (cloud and on-premise) architectures. Only then will you be able to understand the complete picture, an end-to-end monitoring view that shows your applications and their relationships to the cloud services they rely upon. 5. Security Cloud-based security can actually be more secure than the on-premise variety. Yet, “with great power comes great responsibility.” Operations still needs to manage, control, and maintain proper access rights to applications and systems to minimize vulnerability to breaches and avoid improperly exposing private data. With the rise of scripted infrastructure and functions, ops must offer the required cloud services to devs while making sure that those services are secured properly. My recommendation: Establish best-practice security processes as recommended by your cloud vendors and incorporate a cloud security expert into your cloud journey (either an internal stakeholder or an external resource). 6. Troubleshooting Always an essential skill for operations, troubleshooting is pretty much what ops does. That’s not likely to change—operations will always need to figure out what went wrong. With cloud services, though, troubleshooting can become even more complex as operations stretches to take into account things like decoupled applications, scripted infrastructure, and functions. Recommendation: Keep doing what you’re doing. You wouldn’t be in operations if you didn’t have an inner Sherlock Holmes lurking around in there somewhere. No rest for the weary ops team You may be thinking, “We just got here. We just moved to the cloud. We moved our physical servers to instances. We moved our databases as well. Even though we lost a little visibility into the underpinning infrastructure, we gained some cool new features and abilities (I’m looking at you AWS CloudFormation). Now, they go ahead and pull the rug out from under us with this whole functions serverless thing. Can’t we just pause for a little bit?” No, that’s not going to happen. The world is moving rapidly toward serverless as the default option. Of course, not everything currently lends itself well to serverless and/or functions, so it may take a few years for the avalanche to show itself, but, ready or not, it’s coming! Fortunately, operations teams are uniquely suited to support our organizations during this next phase of the cloud journey. We may need to learn a few new tools and tricks, but that’s always been part of the operations job description, right? Your turn You’ve read my thoughts. Where do you think operations should focus its priorities in a DevOps world where “serverless” is becoming the norm rather than the exception? Let us know on Twitter @NewRelic using hashtag #ServerlessOps.   Related Topics DevOps By Kevin Downs As Solutions Strategy Director at New Relic, Kevin has deep knowledge of IT Opps, the cloud industry, and works with customers and partners to assist in their cloud adoption journeys. He’s been in the enterprise software industry for over 20 years, and has spent 12 years as a customer facing solutions architect, selling enterprise software solutions to all verticals. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.043945,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Your</em> turn",
        "body": " with zero administration. Just upload <em>your</em> code and Lambda takes care of everything required to run and scale <em>your</em> code with high availability. You can set <em>up</em> <em>your</em> code to automatically trigger from other AWS <em>services</em> or call it directly from any web or mobile app.” What “serverless” really means AWS Lambda"
      },
      "id": "607636be28ccbcda9651c137"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/health-map-screenshot-1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/health-map-application-infrastructure-visualization",
      "sections": [
        "The importance of tracking application to infrastructure dependencies",
        "Enter Health Map: Transforming your Network Operating Center wallboard",
        "Try Health Map now!"
      ],
      "published_at": "2021-04-16T00:38:54Z",
      "title": "Introducing Health Map: Innovative Visualization Integrates Our Application and Infrastructure Monitoring Data",
      "updated_at": "2021-04-13T23:50:38Z",
      "type": "",
      "external_id": "48a71cc6dcafbf8fc194398575e094abebcb140a",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Nerdlog Introducing Health Map: Innovative Visualization Integrates Our Application and Infrastructure Monitoring Data May 24, 2017 • 6 min read By Ravi Tharisayi New Relic is pleased to announce general availability of Health Map, our innovative visualization that integrates our industry-leading application and infrastructure monitoring data to help operations teams understand and troubleshoot their applications. As organizations shift towards microservices on ephemeral systems, ops and DevOps teams often find it increasingly difficult to fully understand all the dependencies for their applications. Health Map is a high-density, color-coded view that shows the health of all your applications as well as the health of the infrastructure hosts where those applications are deployed. The importance of tracking application to infrastructure dependencies The performance of modern applications is increasingly tied to understanding the infrastructure hosts that the application relies upon. In modern architectures, a web application is often replicated and dependent upon multiple dynamic infrastructure resources. Every time a customer touches your web application, a load balancer directs traffic to one of those application instances that in turn rely on highly dynamic infrastructure. Keeping track of the relationships between one application and its ever-changing hosts can be hard, and many operations teams are charged with tracking hundreds of applications across a complex network of hundreds of hosts. When a performance issue arises, it can be exceedingly difficult to determine whether the source of the issue lies in the code or with one of the infrastructure hosts. What’s needed is a straightforward way to see the big picture of the applications you’re maintaining and also be able to confidently drill down into the infrastructure supporting them to troubleshoot issues. Enter Health Map: Transforming your Network Operating Center wallboard With Health Map you get one integrated, prioritized view of your applications. While many ops teams must look in separate views or even separate tools to see application and infrastructure health, Health Map delivers one combined view of all of your applications and the infrastructure hosts that the applications depends on. Better still, Health Map detects these relationships automatically—no configuration required! health map dashboard example Each card provides a color-coded visualization of both application and infrastructure health, along with basic metrics such as Apdex (application performance index), error rate, and throughput for applications and CPU%, memory%, and load average for hosts. The data points and color coding are generated seamlessly based on data and alerting policies that have been set up in New Relic APM and New Relic Infrastructure. When troubleshooting an issue, you can use filters that help quickly find applications or hosts that you’re particularly interested in based on the labels that you’ve set up. You can then mouse over any particular unhealthy application or host to see the open alert violations. Once an area of analysis has been identified, you can click on the application or hosts to go deeper into the issue within New Relic APM or Infrastructure. And all of these powerful insights are available on the go in your New Relic mobile app.   Watch the short demo video below to see how much more effective you can be in pinpointing errors within your applications with New Relic Health Map: Try Health Map now! If you’re a New Relic APM and New Relic Infrastructure customer, find the “Maps” link in your New Relic navigation and give Health Map a spin. Make your Health Map more even more powerful by defining useful alert conditions for your applications and hosts. And if you’re an APM customer who hasn’t yet taken the plunge with Infrastructure, now is a great time to get started. With a 30-day free trial, you can see your application and infrastructure health more clearly through Health Map. For more information: Health Map documentation New Relic Alerts documentation New Relic Infrastructure information and sign-up New Relic APM information and sign-up   By Ravi Tharisayi Ravi Tharisayi is a Senior Product Marketing Manager, APM. He has 15 years of experience in the IT industry, starting as a Java web developer before a 10-year stint at IBM in consulting and marketing roles. Having first-hand experience with the frustrations of the waterfall software development methodology, Ravi is passionate about DevOps and development on the cloud. He’s also a proud Boston native and cheered for the Patriots even when they had Steve Grogan. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 66.17568,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Enter Health Map: Transforming <em>your</em> Network Operating Center wallboard",
        "body": " deeper into the issue within New Relic APM or Infrastructure. And all of these powerful insights are available on the go in <em>your</em> New Relic mobile app.   Watch the short <em>demo</em> video below to see how much more effective you can be in pinpointing errors within <em>your</em> applications with New Relic Health Map"
      },
      "id": "60762e4e28ccbccd5b51c153"
    }
  ],
  "/build-apps/ab-test/platform-state-context": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Security1.png",
      "url": "https://newrelic.com/blog/how-to-relic/new-relic-one-security-team-dashboards",
      "sections": [
        "Escaping our “black box”",
        "From dashboard to app",
        "Step 1: Store search parameter values in the state",
        "Step 2: Craft NRQL queries on the fly",
        "Step 3: Craft the final NRQL queries and set some temporary values for the text fields",
        "Step 4: Render the filter functionality",
        "Step 5: Render the charts using our finalized queries",
        "What’s next?"
      ],
      "published_at": "2021-04-16T00:17:37Z",
      "title": "How Our Security Team Uses New Relic One for Prevention",
      "updated_at": "2021-04-14T00:03:23Z",
      "type": "",
      "external_id": "5eea1bf9b3c298f54f9468d89e766a82bdc198b9",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic How Our Security Team Uses New Relic One for Prevention Aug 14, 2020 • 8 min read By Scott Cutler Way back in 2016, the New Relic Security team discussed how we used New Relic Insights to monitor for potential threats and security events. Four years later, we introduced some major changes to the New Relic platform, so we've decided to make our security dashboards more user-friendly and flexible by converting them to Nerdlets using the New Relic One SDK. That’s exactly what we’ll explain in this post.  We documented our process and have made the source code available, so you can try it, too. Escaping our “black box” Until recently, we were using an early version of the Network Telemetry Integration. The integration sends sFlow and IPFIX data to New Relic, where we used the data in several dashboards built from long, complex NRQL queries. The dashboards showed metrics like traffic over time, anomalous traffic types, and sources by location. We even successfully used them to identify and troubleshoot at least one security incident. The dashboard and underlying queries survived multiple iterations of team members until it became a “black box”—we knew it worked but weren’t sure how. With an ever-changing infrastructure, our queries became obsolete and our dashboard unusable. We realized if we wanted to continue tracking anomalous data, we needed a revamp. From dashboard to app In our previous iteration, we had a set of static queries we used to create each dashboard. To replace the static queries, we wrote a Nerdlet from scratch that lets us filter and create our own queries. It’s important to note that our Nerdlet relies on New Relic Database data produced from the Network Telemetry Integration. This is what we came up with: In this instance, we’re able to use the text fields at the top row to add filter values—such as removing a specific IP address or protocol number. We can also remove the filters by pressing the X next to each filter value at the top. And each time we press the + or X, the rest of the Nerdlet is re-rendered with the correct results. Once we have a “filter set” that we like, we can copy and paste the NRQL query at the bottom and use it in an alert or dashboard. In this case, our next step is to start creating alerts focused on bandwidth usage for specific protocols we know aren’t used very often, and for network segments that shouldn’t be generating large amounts of traffic. Now, let’s take a look at how we created this Nerdlet. We broke it down into five steps, and if you want to try something similar, you can grab the code from this gist. Step 1: Store search parameter values in the state In our state object, we store several arrays, one for each filter type on the top row: Step 2: Craft NRQL queries on the fly Once we have the values in the arrays, we can start building NRQL queries with simple string concatenation tricks. In the example of IP Protocol numbers, we add WHERE protocolIdentifier = <number> when we want to filter for a specific protocol number. You may also notice that this method will introduce several WHERE clauses. Thankfully NRQL interprets this behavior as multiple AND clauses. Step 3: Craft the final NRQL queries and set some temporary values for the text fields In the beginning of our render function we set up two main things: our tempTextBoxValues object, which will hold the user-inputted values, and the final NRQL queries. Step 4: Render the filter functionality We created a few helper functions to render our filter bar at the top. The key was taking advantage of the fact that JavaScript will pass JSON objects by reference rather than value, allowing the onChange lambda to modify the tempTextBoxValues from step three. In our render portion of the code, we called it with one line: { this.populateTopToolbarStack(tempTextBoxValues) } Step 5: Render the charts using our finalized queries In our render block, we can now create grid items with chart objects that mirror the NR1 workshop examples but reference our finishedNrqlQueries object. When the user clicks a filter button, the autoSetFilters() function is called and will update the state object and trigger React to re-render the page. What’s next? What we really want is for the New Relic One platform to become our own security information and event management (SIEM), but we’re not quite there yet. For now, we plan to add pre-processing logic on logs before sending them to New Relic. This pre-processing could serve as our implementation for correlation and look for logs that occur across different event types. It seems like this may be possible in a New Relic One application, but we are still working on the idea of processing data outside the context of a browser session. If you’re looking for ways to get more out of New Relic One, check out our catalog of available apps and accompanying blog post series. By Scott Cutler Scott Cutler is a Senior Application Security Engineer at New Relic. He has been interested in security since he went to his first DefCon conference in 2004. He graduated with an Information and Computer Science degree from UC Irvine in 2009, took his first security job in 2012, and now works on the New Relic Threat Detection team. While engaging with the larger security community is fun (RainSec, OWASP, Twitter, CTFs), he also enjoys hiking, photography, and video games (DoTA 2 and Satisfactory are currently his go-tos). He has been living in North Portland for about four years and will always appreciate a food or drink recommendation for anywhere around Portland! Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.89981,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Step 1: Store search parameter values in the <em>state</em>",
        "body": ", the autoSetFilters() function is called and will update the <em>state</em> object and trigger React to re-render the page. What’s next? What we really want is for the New Relic One <em>platform</em> to become our own security information and event management (SIEM), but we’re not quite there yet. For now, we plan to <em>add</em> pre"
      },
      "id": "6076314be7b9d2ad1da5c64b"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/kubernetes_logs.png",
      "url": "https://newrelic.com/blog/how-to-relic/logs-in-context-java-app-kubernetes",
      "sections": [
        "Step 1: Install the New Relic Kubernetes integration",
        "Step 2: Capture Kubernetes logs",
        "Step 3: Enable logs in context for your Java app",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:17:06Z",
      "title": "How To Set Up Logs In Context For A Java Application Running In Kubernetes",
      "updated_at": "2021-04-13T23:42:27Z",
      "type": "",
      "external_id": "ddc33b08541ad6c81c1c1eaae3a071613e89b0f1",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Log Management How To Set Up Logs In Context For A Java Application Running In Kubernetes Feb 12, 2020 • 7 min read By Alec Isaacson For software developers, DevOps engineers, and IT professionals, log data is a valuable and often irreplaceable source of troubleshooting data. Today teams are swamped with more log data, from more sources, than ever before. In addition, as the volume of log data scales, so do the challenges associated with collecting, managing, and analyzing this data. New Relic Logs simplifies that with log management that is fast, reliable, and highly scalable, while also giving developers and operations teams deeper visibility into application and infrastructure performance data, such as events and errors. This reduces mean time to resolution (MTTR), and allows IT to quickly troubleshoot production incidents, and connect their log data with the rest of their telemetry data, like metrics, events, and traces. New Relic makes it simple to gather and visualize your log data by using plugins that integrate with some of the most common open source logging tools, like Fluentd, Fluent Bit, Logstash, and Amazon CloudWatch (among others). With New Relic logs in context, you can bring contextual data to the logging experience and correlate log data with other telemetry to reveal meaningful patterns and trends in your applications and infrastructure. So, what is logs in context? Logs in context adds metadata that links your log data with related data, like error or trace information in New Relic APM. By bringing all of this data together in a single solution, you’ll more quickly get to the root cause of issues—narrowing down from all of your logs, to the exact log lines that you need to identify and resolve a problem. For example, you can correlate log messages to a related error trace or distributed trace for a Java application. In this blog post, I’ll explain how to set up logs in context for a Java application running in a Kubernetes cluster. We’ll achieve this in three steps: Install the New Relic Kubernetes integration Configure Kubernetes logging for New Relic Enable logs in context for your Java app Step 1: Install the New Relic Kubernetes integration New Relic’s Kubernetes integration gives you in-depth information about your cluster’s performance, and reports on data and metadata about the nodes, namespaces, deployments, ReplicaSets, pods, clusters, and containers, so you can easily determine the source, scope, and impact of any problems. In this example, my Kubernetes  environment is stand-alone, but we also support several cloud-based Kubernetes platforms, including  Amazon Elastic Kubernetes Service (EKS), Google Kubernetes Engine (GKE), and Red Hat OpenShift. So, let’s get started: New Relic uses kube-state-metrics—a simple service that listens to the Kubernetes API server and generates metrics—to gather information about the state of Kubernetes objects. Use this command to  install kube-state-metrics in your cluster: curl -L -o kube-state-metrics-1.7.2.zip https://github.com/kubernetes/kube-state-metrics/archive/v1.7.2.zip && unzip kube-state-metrics-1.7.2.zip && kubectl apply -f kube-state-metrics-1.7.2/kubernetes Download the New Relic Kubernetes integration configuration file: curl -O https://download.newrelic.com/infrastructure_agent/integrations/kubernetes/newrelic-infrastructure-k8s-latest.yaml In the env: section of the configuration file, add your New Relic license key and a cluster name to identify your Kubernetes cluster. Both values are required. env: - name: NRIA_LICENSE_KEY value: <YOUR_LICENSE_KEY> - name: CLUSTER_NAME value: <YOUR_CLUSTER_NAME> Load the daemon set onto your  cluster: kubectl create -f newrelic-infrastructure-k8s-latest.yaml Go to one.newrelic.com, and select the Kubernetes cluster explorer launcher. This will take you to the Kubernetes cluster explorer. If you haven’t worked with it before, take a few minutes and explore—it’ll be well worth it. The Kubernetes cluster explorer in New Relic One Tip: If you’re having problems or can’t see your cluster, check out the Kubernetes integration documentation. Step 2: Capture Kubernetes logs Now, we need to gather Kubernetes logs and send them to New Relic. Here, we are going to do this with FluentBit and a New Relic output plugin. Here’s how to set this up: Clone or download the New Relic kubernetes-logging project from GitHub. In the new-relic-fluent-plugin.yml, edit the env: section to replace the placeholder value <LICENSE_KEY> with your New Relic license key. - name:LICENSE_KEY value: <YOUR_LICENSE_KEY> Load the logging plugin into your Kubernetes environment: kubectl apply -f . Go to one.newrelic.com, and select the Logs launcher.  After a few moments you should see Kubernetes log entries start to appear. If you’ve already got log entries from other sources that might be getting in the way, add plugin source: “kubernetes” to the query field. This will show you entries from Kubernetes clusters only. (Congratulations, you’ve also just gained valuable experience working with New Relic Logs too.  Queries are simple and easy.  No waiting for results and no specialized query language to learn.) New Relic Logs collects log data from your clusters Tip:  If you’re having problems or can’t see  your logs, check out the full Kubernetes plugin for Logs documentation. Step 3: Enable logs in context for your Java app For this to work, New Relic’s instrumentation needs to inject some metadata that maps log entries to application activity. New Relic  leverages your existing application log framework to do that. While this step involves a configuration change, you won’t have to change any application code. In this example, my Java app uses the Log4j 2.x extension for logging, but New Relic supports other languages and logging frameworks as well. If you haven’t done so already, instrument your app with New Relic’s Java APM agent v 5.6.0 or higher, and enable distributed tracing. Add the New Relic logs in context extension to your project. My project uses Gradle, so I’ve added the compile stanza to the dependencies section, as shown: dependencies { compile(\"com.newrelic.logging:log4j2:1.0-rc2\") } Edit your logging configuration file (mine is called log4j2.xml) and add the packages statement to the <Configuration> tag. <Configuration xmlns=\"http://logging.apache.org/log4j/2.0/config\" packages=\"com.newrelic.logging.log4j2\"> Still in the logging configuration XML file, add a <NewRelicLayout/&gt; tag to one of your log appenders. In this case, we’ll use the console appender because that’s the default method for aggregating logs in Kubernetes: <Appenders> <Console name=\"STDOUT\" target=\"SYSTEM_OUT\"> <NewRelicLayout/> Set the log4j2.messageFactory system property to use the NewRelicMessageFactory.  I did this by adding a custom parameter to the Java command line: -Dlog4j2.messageFactory=com.newrelic.logging.log4j2.NewRelicMessageFactory Tip: To help you understand what you need to do in these steps, check out my example Build.Gradle and log4j2.xml files. Redeploy the app into your Kubernetes environment. Wait a few minutes and then look for log entries that have a span.id or trace.id attribute. For example, in the query field, add has span.id. Tip: If you’re not seeing any traffic, run the app. If you have log entries with those attributes, you’ll be able to drill down from application traces into logs. Using span.ids to examine logs in context for a Java application in New Relic Here's how it looks when you drill down from application traces into logs: Want to learn more about how to stay on top of your Kubernetes environment with the cluster explorer? Check out A Complete Introduction to Monitoring Kubernetes with New Relic. Related Topics Log Management By Alec Isaacson Alec Isaacson is a Solution Architect at New Relic with more than 15 years of experience in enterprise IT. He specializes in application and infrastructure monitoring with a sideline in migrations to cloud and microservices technologies. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.10029,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How <em>To</em> Set Up Logs In <em>Context</em> For A Java Application Running In Kubernetes",
        "sections": "Step 3: Enable logs in <em>context</em> for <em>your</em> Java app",
        "body": " Java APM agent v 5.6.0 or higher, and enable distributed tracing. <em>Add</em> the New Relic logs in <em>context</em> extension to <em>your</em> project. My project uses Gradle, so I’ve added the compile stanza to the dependencies section, as shown: dependencies { compile(&quot;com.newrelic.logging:log4j2:1.0-rc2&quot;) } Edit <em>your</em>"
      },
      "id": "60762c63e7b9d24e30a5c686"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/openshift4_1.png",
      "url": "https://newrelic.com/blog/how-to-relic/red-hat-openshift-monitor",
      "sections": [
        "Installing New Relic on OpenShift",
        "Starting the New Relic Kubernetes integration",
        "Examining your OpenShift Kubernetes cluster",
        "Examine APM data about the applications running in your OpenShift clusters."
      ],
      "published_at": "2021-04-16T01:56:01Z",
      "title": "Monitor Applications and Infrastructure In Red Hat OpenShift with New Relic",
      "updated_at": "2021-04-14T01:39:58Z",
      "type": "",
      "external_id": "4de28c62c9d634a77c6b396f9506e18db78fc575",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Monitor Applications and Infrastructure In Red Hat OpenShift with New Relic Jul 22, 2019 • 6 min read By Stijn Polfliet Red Hat OpenShift is a managed Kubernetes platform that allows you to build and deploy container-based applications rapidly while alleviating the time-consuming process of managing clusters. OpenShift provides a host of services for managing Kubernetes clusters, including an integrated container registry and a container host and runtime built on Red Hat Enterprise Linux CoreOS. While OpenShift makes it easier to launch and run Kubernetes, the ephemeral nature of Kubernetes-based workflows means you need advanced monitoring at the cluster, node, pod, container, and application levels. The New Relic Kubernetes integration gives you these infrastructure-centric and application-centric views into your clusters. The Kubernetes integration reports on data and metadata about the nodes, namespaces, deployments, ReplicaSets, pods, clusters, and containers running in OpenShift, so you can fully monitor the frontend and backend applications and hosts running in your cluster. Monitoring OpenShift with New Relic provides total visibility, alerting, and dashboards for all Kubernetes entities that live among your applications. Installing New Relic on OpenShift As an officially certified OpenShift partner,New Relic Infrastructure is available through the Red Hat Container Catalog. Once you have an OpenShift cluster running, follow these steps to install the New Relic Kubernetes integration: Edit your OpenShift security context constraints and add the newrelic service account: oc adm policy add-scc-to-user privileged \\ system:serviceaccount:<YOUR NAMESPACE>:newrelic Note: Be sure to update <YOUR NAMESPACE> with the correct value. New Relic uses kube-state-metrics—a simple service that listens to the Kubernetes API server and generates metrics—to gather information about the state of Kubernetes objects. Install kube-state-metrics in your cluster: curl -o kube-state-metrics-1.5.zip https://codeload.github.com/kubernetes/kube-state-metrics/zip/release-1.5 && unzip kube-state-metrics-1.5.zip && oc apply -f kube-state-metrics-release-1.5/kubernetes Download the Kubernetes integration configuration file: curl -O https://download.newrelic.com/infrastructure_agent/integrations/kubernetes/newrelic-infrastructure-k8s-latest.yaml In the configuration file, add your New Relic license key and a cluster name to identify your Kubernetes cluster. Both values are required. Be sure to update <YOUR_LICENSE_KEY> with your license key and <YOUR_CLUSTER_NAME> with the name of your cluster. env: - name: NRIA_LICENSE_KEY value: <YOUR_LICENSE_KEY> - name: CLUSTER_NAME value: <YOUR_CLUSTER_NAME> Still in the configuration file, in the securityContext: section, add a privileged: true setting to be run and deployed in the default namespace: spec: serviceAccountName: newrelic containers: - name: newrelic-infra image: newrelic/infrastructure-k8s:1.0.0 securityContext: privileged: true resources: limits: memory: 100Mi Information about additional installation settings can be found in New Relic’s OpenShift  and Kubernetes integration documentation. Starting the New Relic Kubernetes integration The New Relic Infrastructure agent is installed as a Kubernetes DaemonSet, which ensures that the New Relic Kubernetes integration is automatically running on each node in your OpenShift cluster. To create the DaemonSet: oc create -f newrelic-infrastructure-k8s-latest.yaml Check that the DaemonSet is running: oc get daemonsets The result should report that newrelic-infra is ready, up-to-date, and available. Check that kube-state-metrics is running: oc get pods --all-namespaces | grep kube-state-metrics The results should report that kube-system is running. Examining your OpenShift Kubernetes cluster After you ensure kube-state-metrics is running, you’re ready to examine your cluster. Navigate to New Relic Infrastructure, and in the menu bar, click Kubernetes. This opens the New Relic Kubernetes cluster explorer, which shows all the pods, namespaces, deployments, and nodes in your OpenShift environment: Tip: For more information about the cluster explorer, check out Kubernetes Cluster Explorer: Multidimensional Monitoring for Running Kubernetes at Scale Kubernetes. If you’re a cluster operator, platform engineer, or application developer, you can use the New Relic Kubernetes cluster explorer to: Locate and drill down to the pods you care about most. The cluster explorer allows you to filter by namespace, deployment, node, and cluster. Track resource requests and resource limits. Use data gathered in New Relic to accurately plan your capacity and understand which teams are consuming the most resources in your cluster. Track essential cluster resources with the cluster explorer.   Alert on high resource consumption. The Kubernetes integration sets up a default alert policy for your cluster, so you can be notified if pods are reaching resource consumption limits. For example, if any pods in your cluster are reaching 90% of their memory limit, depending on the alert conditions you set, they will be highlighted in yellow or red. To see the default alert policies, navigate to alerts.newrelic.com, click Alert policies, and search for Kubernetes default alert policy. Pods in the cluster explorer showing alert conditions. See the Kubernetes integration documentation for more information about the data and metadata about nodes, namespaces, deployments, clusters, pods, and containers the integration reports to New Relic. Examine APM data about the applications running in your OpenShift clusters. At this point, you’ll want to correlate the performance of your applications with your OpenShift infrastructure, by linking your New Relic APM data with your OpenShift data (learn how in the documentation). This step provides deep application performance monitoring (with code instrumentation and distributed tracing) for the applications running in your cluster. After you’ve linked your applications, click any of the hexagons in the cluster explorer—which represent pods in your cluster—to open the pod details view from where you can analyze the performance of applications running in that pod. Examine New Relic APM data about the applications running in your OpenShift clusters. From the pod details, click APM overview to get a detailed view of the application running in that pod, which you can use to investigate transaction traces and errors from the applications in your OpenShift environment. Or click Distributed tracing to inspect the distributed traces captured for the application running in that pod. If you click on an individual span in a distributed trace, you can quickly see the relevant Kubernetes attributes for that application; for example you can find out which pod, cluster, and deployment an individual span belongs to. Get distributing tracing data from the applications running in your OpenShift cluster. The New Relic Kubernetes integration is available to all New Relic Infrastructure customers at the Pro level. Learn more in our Kubernetes integration documentation and our OpenShift-specific documentation. If you don’t have a New Relic account yet, sign up for a 30-day free trial, and get started monitoring your OpeShift cluster in less than five minutes. By Stijn Polfliet Stijn Polfliet is a Principal Technical Evangelist at New Relic. Stijn was co-founder and CEO of CoScale, a provider of full stack monitoring for containers and microservices, acquired by New Relic in 2018. He holds a Ph.D. in Computer Science from Ghent University in Belgium. His interests focus on cloud technologies like Docker and Kubernetes and their performance-related aspects. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.503876,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Examining <em>your</em> OpenShift Kubernetes cluster",
        "body": " Container Catalog. Once you have an OpenShift cluster running, follow these steps to install the New Relic Kubernetes integration: Edit <em>your</em> OpenShift security <em>context</em> constraints and <em>add</em> the newrelic service account: oc adm policy <em>add</em>-scc-to-user privileged \\ system:serviceaccount:&lt;<em>YOUR</em> NAMESPACE&gt;:newrelic"
      },
      "id": "607647eee7b9d2e295a5c65a"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/nr-distributed-tracing-2.png",
      "url": "https://newrelic.com/blog/best-practices/simplify-distributed-application-complexity-with-dapr",
      "sections": [
        "What is Dapr?",
        "How does Dapr observability work?",
        "Configuring Dapr for tracing",
        "Using Dapr with New Relic One",
        "Next steps"
      ],
      "published_at": "2021-04-15T23:24:56Z",
      "title": "Simplify Distributed Application Complexity with Dapr",
      "updated_at": "2021-04-13T23:30:52Z",
      "type": "",
      "external_id": "039fad5f77a9e05ca5b902b90753aefec64c688c",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Best Practices Simplify Distributed Application Complexity with Dapr Feb 18, 2021 • 6 min read By Ori Zohar When planning to build a distributed application, developers often find a lot to think about beyond the application’s business logic. For instance, how to ensure multiple microservices communicate with each other, integrate with external systems, and, if the microservices are stateful, how to save their state in a resilient way that allows them to recover from potential failures. There are, of course, multiple patterns that address these issues and both open source or cloud-provider-specific technologies that help you implement them. Examples of intra-service communication methods include service-to-service invocation via HTTP or gRPC and pub/sub using message brokers such as Kafka or RabbitMQ. State stores are a good way to keep the state of an app decoupled, and common ones include in-memory stores such as Redis and databases such as MongoDB. Add to that securing connection strings and certificates in secret stores such as HashiCorp Vault and the specifics of cloud provider services that offer similar solutions on Azure, AWS, and GCP, and it is clear that there is a lot to do even before you get to the specific logic of what you are trying to build. On top of having to choose, ramp up, and integrate various SDKs into the code, you also need to keep in mind that your application may need to be deployed to different environments (e.g., local dev box, on-prem, multi-cloud), so you may need to replace some of these solutions on deployment, depending on the hosting infrastructure. Last and arguably most important, you and your development team need to build these distributed applications securely (e.g., encrypt communication, implement access control) and instrument them so they can be observed. Here, specific cloud infrastructure details add to the complexity. What is Dapr? The Distributed Application Runtime (Dapr) open source project aims to help developers solve the challenges that come with building distributed applications. Dapr defines a set of building blocks that map to specific capabilities, such as service-to-service method invocation, state management, secret stores, and pub/sub messaging. These building blocks offer APIs that abstract the specific implementations (called components) and save you the need to add SDKs and/or libraries to your code, or even know the specifics of the technology implementing the capability. The Dapr runtime uses the sidecar pattern and runs as a separate process, so it is language agnostic and lets your app make all API calls via HTTP or gRPC (although specific language SDKs are available). With the release of Dapr v1.0, Dapr is now production-ready, and several large and small companies are already using it to build business-critical applications. You can try Dapr yourself with this getting started guide.   Some of the benefits of using Dapr in a distributed application include: Simpler code: You no longer need to integrate various SDKs or interact with the component directly in a custom way (to create a client, manage a connection, etc.), nor do you need to account for cases where a different implementation is used if the same code is deployed elsewhere. Language agnostic: The Dapr API uses HTTP / gRPC, so an application written in any language can use it with no dependency. Dapr does offer SDKs for .NET, Java, Go, Python, Javascript, and more if you wish to use them. High portability: There is no dependency in the code on the underlying hosting technology. When you switch cloud providers or move to environments that may use different state stores, secret stores, message brokers, or bindings, you don’t need to change the code, only the component files that configure Dapr. Security: Dapr offers secured communication between sidecars via mTLS authentication and includes namespaces and scopes to allow access control for secrets, service invocation, and pub/sub subscription topics. Observability: The Dapr sidecar can be configured to send tracing data, so just by using Dapr, you’re already instrumenting your application. How does Dapr observability work? Many Dapr users find the observability capabilities it provides to be a real game-changer. Using the Dapr API for all of your service-to-service calls and pub/sub messaging, you get automatic application-aware instrumentation. The Dapr sidecar takes care of tracing based on a configuration file, so instrumentation doesn’t require any additional code. Because Dapr conforms to standards such as W3C trace context and OpenTelemetry and uses the Zipkin protocol to emit tracing, it can integrate with any tooling that supports it. Alternatively, you can use the OpenTelemetry Collector to integrate it with any other monitoring tools. With its W3C trace context compatibility, Dapr gives you flexibility in trace context management; you can let Dapr generate and propagate the trace context automatically or do either generation or propagation yourself. This allows you to use a trace context that was generated outside your application or propagate it in additional custom flows. Configuring Dapr for tracing Dapr configuration is defined using YAML configuration files that set the tracing sample rate (Dapr uses probabilistic sampling) and endpoint URL for tracing collection: apiVersion: dapr.io/v1alpha1 kind: Configuration metadata: name: myconfig namespace: default spec: tracing: samplingRate: \"1\" zipkin: endpointAddress: \"http://...\" When you deploy a Dapr application, it will use the above configuration. For example, on a Kubernetes deployment, the Dapr annotation dapr.io/config defines the configuration to be associated with the application (learn more about deploying Dapr applications to Kubernetes). Using Dapr with New Relic One Because New Relic One supports Zipkin, you can use it as an endpoint for tracing in a Dapr application with no need to add anything in the code. This makes it extremely easy to use New Relic One as a backend for tracing and take full advantage of trace visualization, insights, and more. All you need to do is set the endpoint in the configuration file to point to the New Relic Tracing API: apiVersion: dapr.io/v1alpha1 kind: Configuration metadata: name: appconfig namespace: default spec: tracing: samplingRate: \"1\" zipkin: endpointAddress: \"https://trace-api.newrelic.com/trace/v1?Api-Key=<NR-INSIGHTS-INSERT-API-KEY>&Data-Format=zipkin&Data-Format-Version=2\" Note that you’ll need to include your API key here. Additionally, the URL includes an argument that defines the data format to Zipkin (since that is the protocol Dapr will be using). Next steps Sign up for New Relic’s free tier and explore how to configure it to work with Dapr. By Ori Zohar Ori Zohar is a Senior Program Manager in the Azure Incubations team at Microsoft and is currently working on the Distributed Application Runtime, Dapr. Ori has years of experience in building embedded and cloud solutions in various roles including engineering, evangelism and product marketing. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.34095,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " or RabbitMQ. <em>State</em> stores are a good way to keep the <em>state</em> of an app decoupled, and common ones include in-memory stores such as Redis and databases such as MongoDB. <em>Add</em> to that securing connection strings and certificates in secret stores such as HashiCorp Vault and the specifics of cloud provider services"
      },
      "id": "607629ac28ccbcdc8051c18a"
    },
    {
      "sections": [
        "Get started with Incident Intelligence",
        "Tip",
        "How it works",
        "Set up Incident Intelligence",
        "1. Configure your environment (one-time)",
        "2. Configure sources",
        "Alerts",
        "Anomalies",
        "PagerDuty",
        "Splunk",
        "Important",
        "Splunk metadata",
        "Prometheus Alertmanager",
        "Grafana",
        "AWS",
        "REST API",
        "3. Configure destinations",
        "Configure ServiceNow (example)",
        "Send data to ServiceNow",
        "Custom notification message",
        "Other destinations",
        "Send data to PagerDuty",
        "Send data via webhook",
        "4. Configure pathways",
        "Visual timeline",
        "Related activity",
        "Issue summary",
        "Root cause analysis",
        "Use decisions",
        "Use suggested responders",
        "EU and US datacenter and Incident Intelligence data"
      ],
      "title": "Get started with Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "8c4a5a914ca01cb42250908d2fb1a12ccc697e25",
      "image": "https://docs.newrelic.com/static/6e37cc77304398121e1a0080a57e47bb/8c557/screenshot_incident_intelligence_timeline_event_detail.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence/",
      "published_at": "2021-04-16T14:29:07Z",
      "updated_at": "2021-04-16T14:29:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As part of Applied Intelligence, Incident Intelligence helps you correlate your incidents and reduce noise in your environment. It gives you an overview of all your incidents, their sources, and related events. Tip To use Incident Intelligence and Applied Intelligence, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. How it works After you set up Incident Intelligence, our system will begin finding issues from your data sources. In the issue feed, you can find an overview of all your issues, along with helpful information about them. You can also click any individual issue for more detail, including its analysis summary, event log, and details about correlated issues. This screenshot shows an example issue feed, which describes your issues' statuses, correlations, and more. What's the difference between an issue, incident, and event? In short, these terms are like building blocks. Events are raw data from your sources. Incidents are made up of one or more events. Issues are composed of one or more incidents. In more detail: Events indicate a state change or trigger defined by your monitoring systems. An event contains information about the affected entity, and they are almost always triggered automatically by the system. Incidents are groups of events that describe the \"symptoms\" of your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. Issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. Set up Incident Intelligence To enable Incident Intelligence, follow these four steps. Afterwards, issues should start to appear in your issue feed. 1. Configure your environment (one-time). 2. Configure sources. 3. Configure destinations. 4. Configure pathways. 1. Configure your environment (one-time) To set up an environment in Incident Intelligence, you need an administrator to select a New Relic account for it. This account should be the one your team is using. Who sets the environment? Only administrators, and only for accounts where they have admin privileges. Can administrators set more than one environment? They can set one environment per master account and its sub-accounts. More than one can be set if an administrator has privileges for more than one master account. Need to change the environment's associated account? Reach out to your account executive or our support team for help. Tip Incident Intelligence is a cross-account product. This means you can send in data from any New Relic account or external source to correlate events. 2. Configure sources After setting up your environment, determine your incident sources. These are your data inputs. You can get data from any of the following sources: Alerts By integrating Incident Intelligence with your alerts violations, you can get context and correlations from what you're monitoring. To get data from alerts: From one.newrelic.com, click Alerts. On the left under Incident Intelligence, click Sources and then click Alerts. Select the policies you want to connect to Applied Intelligence, and click Connect. You can add additional alerts policies or remove policies you've already connected in Sources > New Relic Alerts. Tip Adding alerts as a source will not affect your current configuration or notifications. Anomalies By integrating Incident Intelligence with your New Relic Proactive Detection anomalies, you can get context and correlations from what you're monitoring. To get data from New Relic Proactive Detection anomalies: From one.newrelic.com, click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Anomalies. Select the configurations you want to connect to Applied Intelligence by toggling to on (green). To add or remove alert policies, from Alerts & AI, click Sources, then Alerts. Tip Adding anomalies as a source won't affect your current Proactive Detection configurations or notifications. PagerDuty You can integrate Incident Intelligence directly with your PagerDuty services to ingest, process, and enhance all of your PagerDuty incidents. To get data from PagerDuty: Make sure your PagerDuty API key has write access. From one.newrelic.com, click Alerts & AI. On the left under Incident Intelligence, click Sources and then click PagerDuty. Enter your PagerDuty API key. The key should be either a personal or general access key with write access. If it's created by a user, the user should be an admin. Select the PagerDuty services you want to connect to Applied Intelligence, and click Connect. You can add additional services or remove services you've already connected in Sources > PagerDuty. Tip Connecting PagerDuty services to Applied Intelligence will not affect your current services or notifications. Splunk By integrating Incident Intelligence with your Splunk log monitoring, you can: Use your environment's log data for searches and key term reports. Correlate alerts and search reports with your other metrics and incidents. Important Applied Intelligence supports Splunk Light, Splunk Cloud, and Splunk Enterprise version 6.3 and higher. To get data from Splunk: In your Splunk console, start a search for the relevant events. Save your search as an alert, configure your alert conditions, and then choose the webhook as the delivery method. Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Splunk. Copy the collector URL, and paste it into the webhook endpoint in the Splunk console. Optional: Use Splunk tokens to enrich alert data with Splunk metadata. Splunk metadata To enrich alerts data with your Splunk metadata, use Splunk tokens. This helps you leverage your search data, which includes metadata and values from the first row of search results. If you want to... Do this... Access search data Use the format $<fieldname>$. For example, use $app$ for the app context for the search. Access field values To access field values from the first result row that a search returns, use the format $result.<fieldname>$. For example, use $result.host$ for the host value and $result.sourcetype$ for the source type. Use variables You can leverage any of the Selected fields in the Splunk search and add any unique fields to the Selected fields to make the data available as a variable. The following fields will automatically provide hints to the correlation engine: app: parsed as APPLICATION_NAME application:parsed as APPLICATION_NAME application_name: parsed as APPLICATION_NAME cluster: parsed as CLUSTER_NAME computer: parsed as HOST_NAME Dc: parsed as DATACENTER_NAME datacenter: parsed as DATACENTER_NAME host: parsed as HOST_NAME host_name: parsed as HOST_NAME hostname: parsed as HOST_NAME transaction: parsed as EVENT_ID Transaction_id: parsed as EVENT_ID user: parsed as USER_NAME Prometheus Alertmanager By integrating Incident Intelligence with Prometheus Alertmanager, you can receive and correlate your Prometheus alerts with events from other sources. To integrate Prometheus Alertmanager: Set up your Alertmanager configuration file by running: ./alertmanager -config.file=simple.yml Copy Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Prometheus Alertmanager. Copy the Prometheus Alertmanager URL, and paste it into the <webhook_config>/url section of your Alertmanager config file. Reload the Prometheus Alertmanager configuration with one of the two methods: Send a SIGHUP to the process. Send an HTTP POST request to the /-/reload endpoint. Grafana You can integrate Incident Intelligence with Grafana's notifications for insight into events across your applications and environment. Grafana's webhook notification is a simple way to send information over HTTP to a custom endpoint. To integrate Grafana as a new webhook: Log into your Grafana portal using Admin permissions, and choose Alerting. On the Grafana Notification Channels page, click New Channel > Webhook. Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources, and then click Grafana. Copy the URL, and paste it into your new Grafana webhook. AWS You can integrate Incident Intelligence with Amazon CloudWatch to provide incident management for all of your AWS services. To integrate Amazon CloudWatch: Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Amazon Web Services. Copy the URL. Create a new Amazon SNS topic. Set CloudWatch to forward all Alarms state changes to that topic: In the Amazon CloudWatch UI, click Events > Event Pattern. Select Service Name > CloudWatch. Select Event Type > CloudWatch Alarm State Change. Select Targets > SNS Topic, and select your new Amazon SNS topic. Create a new subscription: In the Amazon AWS UI, click Create a Subscription. Select your new Amazon SNS topic. Select Protocol > choose HTTPS. In Endpoint, paste the URL you previously copied from the Applied Intelligence Sources. REST API Incident Intelligence supports a dedicated REST API interface that lets you integrate with additional systems. The interface allows instrumentation of your code or other monitoring solutions to report any kind of metric or event. A metric can be a raw data point such as CPU, memory, disk utilization, or business KPI. An event can be a monitoring alert, deployment event, incident, exceptions or any other change in state that you want to describe. You can also send any type of data to Incident Intelligence straight from your own systems or applications. The REST API supports secure token-based authentication and accepts JSON content as input. For more information on authentication and the full API reference, see REST API for New Relic Applied Intelligence. 3. Configure destinations Now that you've set up your sources, you can configure your destinations. These are the data outputs where you view your incidents. Configure ServiceNow (example) Using ServiceNow as a destination enables you to push valuable violation data into new ServiceNow incident tickets. Send data to ServiceNow To configure Incident Intelligence to send data to ServiceNow: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click ServiceNow. Required: Enter a channel name. This is used internally in Applied Intelligence to identify the destination (for example, in Pathways). Required: Enter your ServiceNow credentials: Team domain (This must be unique. No two destinations can have the same domain). Username Password Follow the two-way integration on screen instructions: Open and download this XML file. In the ServiceNow sidebar menu, go to System Definition > Business Rule. Click the menu icon in one of the column headers, select Import XML, and upload the XML file you downloaded. The two way integration will allow the ServiceNow incident to be updated with changes to the Applied Intelligence issue. Closing a ServiceNow incident will close its corresponding New Relic issue. When a New Relic issue is resolved, the corresponding ServiceNow incident will be closed. Custom notification message Applied Intelligence uses a templating framework called Jinja2 in the customization section interface. The Value field must be in valid Jinja syntax. By default, the interface populates a set of default fields in ServiceNow. When you add a custom field, enter the ServiceNow field name you want to use. When you want to skip a selected field in an issue update, add the | skip_on_update string at the end of the value you've selected. Tip By default, ServiceNow adds u_ to the beginning of its custom values. When mapping to ServiceNow attributes, use the Column name value. Please note that the name needs to be lowercase separated by underscores. Go here to see the custom notification message attribute descriptions. Go here to see Jinja2 Useful Syntax. Other destinations You can also set PagerDuty as a destination, as well as any other destination compatible with webhook: Send data to PagerDuty Recommended: Create a new PagerDuty service to use as a destination. Because PagerDuty services can also be used as sources, this can help you distinguish your data input from your output. To create a PagerDuty destination: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click PagerDuty. Enter your PagerDuty API key. The key should be either a personal or general access key with write access. If it's created by a user, the user should be an admin. If you've configured a PagerDuty source with an API key, you can use the same key. Select the PagerDuty services you want to connect to Applied Intelligence, and click Connect. When you're ready, you can add policies for one or more PagerDuty destinations. You can also transfer the policies over from your existing services or leave them as sources if needed. From the Destinations > PagerDuty page, you can also: Review the permissions for your services. Click Authorize when you're done. Add or delete existing services from the PagerDuty destination. Edit permissions for any service. To configure your PagerDuty destinations, use the following settings: Configuration setting Description Trigger new incidents Required. Trigger correlated parent incidents so you can identify issues faster. Edit incident titles Required. Alter your incident titles to help you orient and understand issues. Add new integrations Required. Add integrations to enable incident creation for selected services. Add webhook extensions Add webhook extensions to sync user actions in PagerDuty to New Relic. This lets you update the correlated issue state. Auto-resolve correlated incidents When enabled, this will resolve and automatically close correlated parent/child incidents. Select a user to take actions in PagerDuty You need to select a user before you can enable deep integration with PagerDuty. Once you do, the user can: Add notes to incidents (required): Incident notes are used to enrich incidents with context. Acknowledge triggered incidents: When enabled, Applied Intelligence will acknowledge and correlate newly triggered incidents in PagerDuty before you're notified. Use the original escalation policy: When enabled, the escalation policy of the source service will be applied to each incident. Send data via webhook Incident Intelligence will send the event body in JSON format by HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). To configure Incident Intelligence to send data via webhook: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click Webhook. Required: Configure the unique webhook key, used in Applied Intelligence to refer to this webhook configuration and its specific settings. Required: Configure the destination endpoint where the webhook payload will be sent. Optional steps: Configure custom headers, which are key:value pairs of headers to be sent with the request. Example: \"Authentication\" \"Bearer\" <bearer token> Configure a custom payload template that can be used to map New Relic fields to match the destination tool's expected name and format. Configure priority mapping (critical, high, medium, or low), used to map New Relic's priorities to the priorities expected at the destination. Tip There’s a retry mechanism that is triggered a few times with exponential backoff for a couple of minutes once an error occurs. If we reach the retry limit, the Webhook will get auto-disabled. For examples of destination templates, webhook formats, and JSON schema, see the Incident Intelligence destination examples. 4. Configure pathways To control when and where you want to receive notifications from your incidents, you can configure pathways. To add a pathway: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Pathways, then click Add a pathway. In the query builder box, select an attribute, such as application/name. This can be from the list of all attributes available in PagerDuty incidents and New Relic alerts violations, or you can add your own attributes. Select a logical operator. For example, contains. Enter a specific value to complete the logical expression. To include all issues created by your sources, select Send everything. (Use this if you only use one PagerDuty service to manage all incidents.) To build more complex logic, use the AND/OR operators. Select one or more of your destinations. To edit or remove existing pathways, mouse over the pathway's name on the Pathways page. Visual timeline The visual timeline, as presented below, shows you a breakdown of: Incidents The trends taking place What incidents are active What incidents are resolved What is correlated to each other Various milestones at different issue levels In addition, you’ll see a grey line at the top of the timeline. In comparison to the visual timeline that shows the changes to each incident, the grey line represents changes to the issue. Mouse over the grey line to see details of the event. Finally, mouse over the incident to see information on the location, timing, and level of importance of a specific incident. This figure shows a particular incident populated on January 11th with a level of Critical. To view the issues in a text format, in the right hand corner, click Switch to issue log view. Related activity The related activity section aggregates a set of incidents into a single issue, according to a rule-based system. This section will show you the Last Update, the Source location, its State, the number of Related Events, and where it Originated. You can also copy the Payload or click on Analyze for more information. Issue summary The issue page is built to first provide the user with bottom line insights to understand the problem and minimize the time needed to resolve it. The following outlines each of the four sections on the issue page: The Analysis Summary: the analysis summary has two machine learning modules, the golden signals and the related components. The Suggested Responder: the suggested responder will tell you who to potentially reach out to on your team to solve a specific problem. The Impacted Entities: an entity is anything that has data you can monitor. Specifically, these are focused on incidents from New Relic sources, extracting the entities and providing a summary. Each entity is unique. The Label Sets: label sets are focused on incidents that come from 3rd party sources, such as PagerDuty, AWS Cloudwatch, REST APIs, etc., as well as for NRQL queries. They come in the form of key:value pairs. All four of these sections can show up together for each issue or separately. It will vary based on the data in the issue. In addition to these four sections, you can also take a look at anomaly overview and entity overview directly from the issue feed. If you hover over an impacted entity application, you’ll notice both call to actions: anomaly overview and entity overview. Anomaly overview will open the application's anomalies page. This is only available for applications that are set up for Proactive Detection. Finally, the issue page contains deployment events. APM’s Deployment page lists recent deployments and their impact on your end user and app server's Apdex scores, response times, throughput, and errors. This section will only show up if New Relic has identified applications under the Impacted Entities that have deployments. There are two types of deployment events: deployments and related deployments. Click “Show all deployments”, to see all your deployment events when they arrive. Click a specific deployment to see its APM deployments page. Root cause analysis Root cause analysis automatically finds potential causes for an issue and its impacted entities. It shows you why open issues occurred, which deployments contributed, and relevant error logs and attributes. With this, you can investigate the problem and reduce your mean time to resolution (MTTR). Tip Note that root cause analysis is dependent on other New Relic data sources and features. This is why root cause analysis information may not always be present for every issue. When you select an issue, you may see Root cause analysis information. Root cause analysis includes three main UI sections: Deployment events: When you set up deployments, we provide the deployment nearest to the issue creation. Changes, such as deployments, account for a high percentage of the root causes of incidents and having that information at hand can help diagnose and resolve issues. Error logs: You can explore millions of log messages with a single click and use manual querying to help you find anomalous patterns and hard-to-find problems. Attributes to investigate: We scan the distribution of attributes and surface possible causes by finding significant changes in the distribution. For example, for every single transaction event, we can scan to see if an individual user starts to take up an anomalous share of the requests sent to your app. You can also query interesting attributes. Use decisions To further reduce noise or get improved incident correlation, you can change or customize your decisions. Decisions determine how Incident Intelligence groups incidents together. To get started, see Decisions. Use suggested responders If you’re using PagerDuty or New Relic alerts violations as your incident notification tools, Incident Intelligence suggests relevant team members that can help resolve your issues. Incident Intelligence learns from your PagerDuty and alerts violations data to provide suggestions for each new incident. Once you receive a suggestion, you can contact the responder or search for relevant documentation that person may have written. To get started, enable PagerDuty or alerts violations as a source for Incident Intelligence. Afterwards, you can view the suggestions in two places: The issue feed, where you can also provide feedback on the suggestions. Directly within PagerDuty (both UI and API.) If you’re also using PagerDuty as a destination, the suggestions will appear in your issue notifications payload. Important This feature doesn't account for on-call availability at the time of incident. Tip In order to train the model, we use the information PagerDuty provides about individuals. We ingest incident information only, not users’ contact details. EU and US datacenter and Incident Intelligence data New Relic's Incident Intelligence service is performed solely in the United States. By using New Relic Incident Intelligence, you agree that New Relic may move your data to, and process your data in, the US region. This applies whether you store your data in New Relic's US region data center or in our EU region data center. If you elect to use the Suggested Responder feature and manage EU-based individuals, you may need to confirm that an appropriate data processing agreement is in place.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.80289,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "1. Configure <em>your</em> environment (one-time)",
        "body": " observability <em>platform</em>, join the New Relic family! Sign up to create <em>your</em> free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. How it works After you set up Incident Intelligence, our system will begin finding issues from <em>your</em> data sources. In the issue"
      },
      "id": "603ea62e64441f119f4e883f"
    }
  ],
  "/build-apps/ab-test/grid": [
    {
      "image": "https://newrelic.com/themes/custom/curio/assets/images/metadata/NROG_Image.png",
      "url": "https://newrelic.com/press-releases/20100112",
      "sections": [
        "New Relic Teams with GoGrid to Deliver Superior-Performing Web Apps in the Cloud, on Dedicated Servers, or in Hybrid Environments",
        "About GoGrid",
        "About New Relic",
        "Media Contact",
        "Investor Contact"
      ],
      "published_at": "2021-04-11T14:38:40Z",
      "title": "New Relic Teams with GoGrid to Deliver Superior-Performing Web Apps in the Cloud, on Dedicated Servers, or in Hybrid Environments | New Relic",
      "updated_at": "2021-04-11T14:38:39Z",
      "type": "",
      "external_id": "92ae31c589c4c8f059255625c0827f74ca9e7e9a",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Newsroom Press Release New Relic Teams with GoGrid to Deliver Superior-Performing Web Apps in the Cloud, on Dedicated Servers, or in Hybrid Environments Customers taking advantage of GoGrid’s robust cloud infrastructure can use RPM to monitor, troubleshoot and tune Java and Ruby web applications Share on Facebook Share on Twitter Share on LinkedIn San Francisco - January 12, 2010 New Relic, Inc., the leading software-as-a-service provider of application performance management solutions, and GoGrid, the Cloud Infrastructure Hosting service from ServePath Dedicated Hosting, today announced that New Relic RPM supports monitoring, troubleshooting and tuning of Java and Ruby web application deployed on GoGrid’s leading platform. Additionally, the companies announced that customers who select New Relic RPM to manage their GoGrid-hosted applications are eligible for preferential pricing. With more than ten years of experience in enterprise-level data center hosting, GoGrid applies a unique understanding of uptime, security, and service level agreements to its public cloud offering. GoGrid goes beyond existing public cloud offerings by providing Hybrid hosting solutions that privately connect cloud front-ends with dedicated back-end infrastructures, as well as the ability to create and store customer images (MyGSIs). New Relic RPM is a leading on-demand application performance management that operates seamlessly in both cloud and dedicated server environments, making it uniquely suited to monitor, troubleshoot and tune web applications deployed on GoGrid’s cloud or hybrid infrastructures. \"Organizations taking advantage of GoGrid’s multi-tier cloud-computing platform have high expectations for performance and reliability,\" said John Keagy, Co-Founder and CEO of GoGrid. \"Working with New Relic to add application performance management as a complement to our robust infrastructure provides our customers with the very best combined solution for deploying and managing applications that successfully meet business needs.\" \"As more and more companies deploy their applications with GoGrid, it’s especially important that they have a single performance management solution that they can use on-premise, in the cloud, and in hybrid environments,\" said Bill Lapcevic, New Relic’s vice president of business development. \"New Relic RPM is the only enterprise-class application management tool delivered as a service, and that automatically offers the same monitoring and troubleshooting capabilities for web applications deployed on both virtual and dedicated servers. Its a perfect fit for GoGrid’s customers.\" As part of the partnership between GoGrid and New Relic, GoGrid customers are eligible for a preferred partner discount on RPM pricing and a complementary trial of RPM Gold premium service. To take advantage of preferred pricing, GoGrid customers can visit New Relic’s GoGrid partner page, select a subscription level, then sign up for RPM. Discounts will be applied automatically. About GoGrid GoGrid is a leading Cloud Infrastructure Hosting provider that delivers true \"Control in the Cloud™\". GoGrid enables sysadmins, developers, IT professionals and SaaS vendors to create, deploy, and control free f5 load balanced cloud servers and complex hosted virtual server networks with full root access and administrative server control which includes personal server images (known as MyGSIs). GoGrid server instances maintain the industry standard specifications with no requirement to learn and adapt to proprietary standards. Bringing up servers and server networks takes minutes via a unique, award winning web control panel or GoGrid’s API. GoGrid delivers portal controlled servers for Windows Server 2008, Windows Server 2003, SQL Server, and ASP.NET, as well as multiple Linux server operating systems like RHEL and CentOS. GoGrid gives users the control of a familiar datacenter environment with the flexibility and immediate scalability of the cloud, a \"cloudcenter.\" To learn more, visit www.gogrid.com. Back to press releases About New Relic The world’s best engineering teams rely on New Relic to visualize, analyze and troubleshoot their software. New Relic One is the most powerful cloud-based observability platform built to help companies create more perfect software. Learn why customers trust New Relic for improved uptime and performance, greater scale and efficiency, and accelerated time to market at newrelic.com. New Relic is a registered trademark of New Relic, Inc. All product and company names herein may be trademarks of their registered owners. New Relic on Facebook New Relic on Twitter New Relic on LinkedIn New Relic on YouTube Media Contact New Relic, Inc. PR@newrelic.com Investor Contact Peter Goldmacher 503-336-9280 IR@newrelic.com Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.57433,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic Teams with GoGrid to Deliver Superior-Performing Web <em>Apps</em> in the Cloud, on Dedicated Servers, or in Hybrid Environments | New Relic",
        "sections": "New Relic Teams with GoGrid to Deliver Superior-Performing Web <em>Apps</em> in the Cloud, on Dedicated Servers, or in Hybrid Environments",
        "body": "-Founder and CEO of Go<em>Grid</em>. &quot;Working with New Relic to <em>add</em> application performance management as a complement to our robust infrastructure provides our customers with the very best combined solution for deploying and managing applications that successfully meet business needs.&quot; &quot;As more and more"
      },
      "id": "575f8b668e9c0f699329e537"
    },
    {
      "image": "https://newrelic.com/themes/custom/curio/assets/images/metadata/NROG_Image.png",
      "url": "https://newrelic.com/press-releases/20100623",
      "sections": [
        "New Relic Teams with GridGain to Deliver Superior-Performing Java Applications in the Cloud",
        "About GridGain® Systems",
        "About New Relic RPM",
        "About New Relic",
        "Media Contact",
        "Investor Contact"
      ],
      "published_at": "2021-04-05T03:35:39Z",
      "title": "New Relic Teams with GridGain to Deliver Superior-Performing Java Applications in the Cloud | New Relic",
      "updated_at": "2021-03-29T14:33:54Z",
      "type": "",
      "external_id": "9bec54d4ce2b07ac3ad2a85b62133054a23027c5",
      "popularity": 1,
      "body": "Skip to main content New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Newsroom Press Release New Relic Teams with GridGain to Deliver Superior-Performing Java Applications in the Cloud Customers taking advantage of GridGain’s robust Cloud Development Platform can use RPM to monitor, troubleshoot and tune their business-critical Java applications. Share on Facebook Share on Twitter Share on LinkedIn San Francisco - June 23, 2010 New Relic, Inc., the leading software-as-a-service provider of application performance management (APM) solutions, and GridGain, a leading cloud development platform provider, today announced that New Relic RPM supports monitoring, troubleshooting and tuning of applications developed on GridGain’s leading Java-based Cloud Development Platform and that GridGain customers are eligible for preferential pricing for paid RPM subscriptions. GridGain’s Cloud Development Platform enables developers to write any custom grid-enabled Java, Groovy or Scala application or grid enable an existing application and seamlessly deploy and run it on any managed infrastructure such as internal grids, external or hybrid clouds. This platform allows development teams to take full advantage of such concepts like MapReduce, data grids, affinity load balancing, zero deployment, and peer-to-peer class loading among many others. GridGain’s SPI architecture is ideally suited for hybrid cloud deployment, allowing teams to develop an entire application locally and then seamlessly deploy and run it on a virtualized cloud without any changes to business logic, the code or how it was developed. New Relic RPM is a leading on-demand application performance management solution that operates seamlessly in both cloud and dedicated server environments, making it uniquely suited to monitor, troubleshoot and tune applications deployed using GridGain’s Cloud Development Platform. Development and deployment teams using GridGain can now use RPM to gain comprehensive visibility into production application health and availability. “GridGain is committed to delivering a powerful cloud development platform that is simple to use, affordable for projects of any size and focused on enterprise application development,” said Nikita Ivanov, CEO at GridGain. “Offering RPM’s deep, 24x7 visibility into production applications to our customers advances this philosophy because it’s an effective, easy-to-use solution for managing the performance of Java applications deployed in any managed infrastructure.” “As more and more organizations build and deploy their mission-critical applications on GridGain’s platform, it’s important that they have 24x7 visibility into application health and availability,” said Bill Lapcevic, New Relic’s vice president of business development. “RPM’s on-demand capabilities for monitoring, troubleshooting and optimizing production Java applications are a perfect fit for GridGain’s cloud customers. We are pleased to be partnering with GridGain and look forward to helping their customers deliver superior-performing web applications.” GridGain customers can take advantage of RPM right away by visiting https://newrelic.com/lite/ to sign up for RPM Lite, which is available free for an unlimited time. After the two-minute signup and implementation process, customers have immediate access to a rich set of performance data for their production web applications. To choose a premium paid subscription, select the “Change Subscription” option in Account Settings. About GridGain® Systems GridGain Systems develops Cloud Development Platform — a unique software middleware that combines computational and data grids technology with auto-scaling on any managed infrastructure allowing developers to build Java, Groovy or Scala-based native cloud applications. GridGain’s software starts every 20 seconds around the globe — to learn more, visit www.gridgain.com. About New Relic RPM New Relic RPM is an on-demand performance management solution for web applications developed in Ruby, Java or JRuby. New Relic RPM is fully implemented in minutes and provides deep, 24x7 visibility and code-level diagnostics for web applications deployed on traditional, dedicated infrastructures, private and public clouds, or any combination thereof. RPM’s real-time metrics enable application owners, developers and operations teams to quickly and cost effectively monitor, troubleshoot, and tune application performance. Learn more about RPM and subscribe. Back to press releases About New Relic The world’s best engineering teams rely on New Relic to visualize, analyze and troubleshoot their software. New Relic One is the most powerful cloud-based observability platform built to help companies create more perfect software. Learn why customers trust New Relic for improved uptime and performance, greater scale and efficiency, and accelerated time to market at newrelic.com. New Relic is a registered trademark of New Relic, Inc. All product and company names herein may be trademarks of their registered owners. New Relic on Facebook New Relic on Twitter New Relic on LinkedIn New Relic on YouTube Media Contact New Relic, Inc. PR@newrelic.com Investor Contact Peter Goldmacher 503-336-9280 IR@newrelic.com Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.36154,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic Teams with <em>GridGain</em> to Deliver Superior-Performing Java <em>Applications</em> in the Cloud | New Relic",
        "sections": "New Relic Teams with <em>GridGain</em> to Deliver Superior-Performing Java <em>Applications</em> in the Cloud",
        "body": " Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Newsroom Press Release New Relic Teams with <em>Grid</em>Gain to Deliver Superior-Performing Java"
      },
      "id": "575f8b7d0cc37f76f8aad577"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/Javier-sanchez-marin.jpg?h=dd5474d1&itok=xjbWOHn4",
      "url": "https://newrelic.com/blog/best-practices/best-practices-shared-ui-libraries",
      "sections": [
        "CSS best practices",
        "JavaScript best practices",
        "Packaging and distribution best practices",
        "Set up your library for success"
      ],
      "published_at": "2021-04-16T03:37:29Z",
      "title": "16 Best Practices for Shared UI Libraries",
      "updated_at": "2021-04-14T06:36:55Z",
      "type": "",
      "external_id": "00cf06916be24962b09bcd34d1f435e51c0f8c84",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Best Practices 16 Best Practices for Shared UI Libraries Mar 15, 2018 • 8 min read By Javier Sánchez-Marín Recently, the New Relic Core UI team moved to React v16.0. In support of this move, we’ve had to upgrade a handful of shared UI libraries owned by teams across the company. As most of us know, upgrading cross-company dependencies can be quite the challenge, and it takes a lot of time. Often, during such work, we find that UI libraries are not always in the best shape for sharing. To that end, I’ve put together this list of some best practices and recommendations for building shareable UI libraries. For clarity, I’ve grouped the recommendations in three critical categories: CSS, JavaScript, and packaging and distribution. CSS best practices While many of the following practices are already addressed by some CSS-in-JS libraries, it’s still helpful to keep them in mind when using plain CSS or a pre-processor like Sass. #1: Use namespaced selectors It’s easy to mistakenly pick a name for a class that’s already in use by one or more of the consumers. So instead of using a class name like .MyComponent, it’s better to use a namespace; for example: .mylib-MyComponent. A lengthy class name might not be so appealing, but it’s worth it to be sure the name won’t ever conflict with your consumer’s CSS. #2: Don’t use global selectors A global selector selects all available elements and styles them accordingly. But with global selectors, something as simple as li { padding: 20px; } in your library’s CSS will visually break any consumer application. Instead, scope all the styles of your library with CSS class selectors that you own. For example, the following selector would be much safer: .mylib-MyComponent li { padding: 20px; } #3: Don’t apply a global reset/normalization When you start a new project, it’s quite common to include a reset.css or normalize.css file to reset the default styles from the browser. But for shared libraries, this can be quite dangerous. Once the consumer imports your library’s CSS, it will visually break their application unless your reset file and theirs are exactly the same, which is highly unlikely. Instead, you can do a reset at the component level. For example: .mylib-MyComponent { margin: 0; padding: 0; font: inherit; ... } Keep in mind that consumers of your shared UI library will probably have global CSS and CSS resets in place. So it’s a good idea to add a robust reset file in your components CSS. In this case, the more robust the reset is, the less likely it is that you’ll run into problems. #4: Provide one main entrypoint Consumers using your shared library will be pleased if you provide one entrypoint CSS file that includes all the CSS required to use your library. So for the following CSS files: @import './components/Icon/styles'; @import './components/Button/styles'; @import './components/Link/styles'; @import './components/Logo/styles'; ... Your consumer can do a single import to use the CSS of your library: import '@my-scope/my-library/dist/styles.css' JavaScript best practices The following best practices can help streamline the use of JavaScript in your libraries. #1: Think twice before adding a new dependency We all know that dependencies take up space, and most of the time they also depend on other dependencies. Before you know it, dependencies can totally bloat your production bundles. When adding a new dependency, always review its package.json file to see how many dependencies that project uses. You can use tools like bundlephobia or package-size to inspect their sizes. #2: Use selective imports where possible If your library uses just a couple of items from a giant library, you should consider importing only the items you’ll use. This way only the things your library really needs will end up in the consumer’s production bundle. For example, instead of: import { debounce } from 'lodash'; import { Grid } from 'react-virtualized'; Try: import debounce from 'lodash/debounce'; import Grid from 'react-virtualized/commonjs/Grid'; /code> This practice will 1) help keep your library size small, and 2) keep you from relying on your consumers having tree shaking enabled in their builds to get rid of the unused code. #3: Provide one main entrypoint Similar to providing one main entrypoint for your library’s CSS, it’s a good practice to provide a main index.js entrypoint from where you export all the public modules from your library. For example, for the following modules: export { default as Select } from './components/Select'; export { default as Input } from './components/Input'; export { default as SearchInput } from './components/SearchInput'; export { default as Checkbox } from './components/Checkbox'; Your consumers can do a single import to use whatever they need from your library: import { Select, Input } from '@my-scope/my-library'; #4: Consider using peer dependencies If your library depends on React or any other large library that is frequently used by your consumers, consider adding the dependency as a peer dependency. With peer dependencies you can specify ranges of versions to give more flexibility to your consumers instead of forcing them to use the version fixed in your library. For example: \"peerDependencies\": { \"d3\": \"3.x\", \"react\": \"^15.5.0 || ^16.0.0\" } #5: Eliminate development-only code from production Sometimes your libraries contain code that should run only in development and not in production. This pattern is frequently used for warnings (React.propTypes) and devtools (Redux DevTools). To wrap code blocks that can be eliminated in production, use process.env.NODE_ENV. For example, you add the following to your code: if (process.env.NODE_ENV !== “production”) { // This code will only run in development } When the consumer of your library builds the project with webpack's DefinePlugin and sets NODE_ENV to production, the previous code block will be transformed to: if (\"production\" !== “production”) { // This code will only run in development } If the consumer uses UglifyJS, it will be converted to: if (false) { // This code will only run in development } And will later be stripped away completely by UglifyJS’s dead-code elimination feature. Packaging and distribution best practices Once you have your library working and ready for use by the rest of the world, you need to package and distribute it. This is where a lot of libraries fail. The following best practices are designed to help avoid that fate. #1: Don’t distribute bundles in npm packages While it’s easy to create a bundle of your library with webpack, there are some consequences to consider. When you bundle your library with webpack, all its dependencies that are not webpack externals will end up in the bundle as well. All of your dependencies will be static code in a giant bundle. If all your dependencies are static, consumers won’t get automatic minor or patch updates. Also, static dependencies cannot be deduped with dependencies of the consuming application. Instead, use a one-to-one transpilation, where each file is transpiled individually, instead of transpiling all files and bundling them together into a single file. The easiest way to do this in JavaScript is to compile with Babel: babel src/ --out-dir build/ Or you can  compile with Sass: node-sass src/ -o build/ #2: Provide CommonJS and ES modules in your library CommonJS modules can be used with any build tool and don’t require extra configuration. It’s not as common to provide libraries as ECMAScript (ES) modules, but they are needed to enable tree shaking. When you package your library with Babel, you can set different configurations with the BABEL_ENV variable. A basic .babelrc configuration for CommonJS and ES modules would look like this: { \"env\": { \"commonjs\": { \"plugins\": [ \"transform-runtime\", [\"transform-react-remove-prop-types\", { \"mode\": \"wrap\" }] ], \"presets\": [ \"env\", \"react\" ] }, \"esmodules\": { \"plugins\": [ \"transform-runtime\", [\"transform-react-remove-prop-types\", { \"mode\": \"wrap\" }] ], \"presets\": [ [\"env\", { modules: false }], \"react\", ] } } } Note that the example sets [\"env\", { modules: false }] for the esmodules environment. This disables the transformation of ES modules (import/export) to CommonJS modules (require/exports), which is the main requirement for getting tree shaking to work. Given the example .babelrc config, you could generate both versions of your library by running these two commands: $ BABEL_ENV=commonjs babel src/ --out-dir build/commonjs $ BABEL_ENV=esmodules babel src/ --out-dir build/es #3: Point the npm package main attribute to the transpiled CommonJs version of your library The package.json#main attribute indicates the path of your library’s main JavaScript entrypoint. It’s important that package.json#main points to the transpiled CommonJs version of your library, so users can use it without extra tooling or configuration. Given the following package.json: { name: “@my-scope/my-library”, main: “build/commonjs/index.js” } When the consumers of your library import it like this: import myLibrary from '@my-scope/my-library'; @my-scope/my-library resolves to the path you specified in the package.json#main attribute. Consumers won’t need to perform additional configuration. #4: Use the npm package module attribute to enable tree shaking The package.json#module field is not an npm official attribute, but it is the first field webpack checks for resolving a module’s main entrypoint. If you don’t set the module attribute, webpack will default to the main attribute. Pointing the module attribute to the ES modules version of your library will enable tree shaking out of the box for consumers using webpack: { name: “@my-scope/my-library”, main: “build/commonjs/index.js”, module: “build/es/index.js” } #5: Use .npmignore and the npm package file attribute in published packages Published packages should contain only the files required to use the library. Jenkins scripts, tests, documentation, and other items should not be included in the package. Use .npmignore to keep files out of your package. Or use the package.jsonfiles attribute to explicitly include files in your package. #6: Remove React propTypes React propTypes are only for development and are not intended for use in production. To remove propTypes in production bundles, use babel-plugin-transform-react-remove-prop-types. This plugin lets you wrap propTypes into conditional statements, so they can be removed in production. Consider the following example component: class MyComponent extends React.Component { static propTypes = { className: PropTypes.string, items: PropTypes.array, onClick: PropTypes.func, } render() { return <div>...</div>; } } When you enable the remove propTypes plugin, the propTypes will be wrapped in a conditional ternary like this: MyComponent.propTypes = process.env.NODE_ENV !== \"production\" ? { className: PropTypes.string, items: PropTypes.array, onClick: PropTypes.string } : {}; That code block, after being processed by UglifyJS will be converted to: MyComponent.propTypes = {}; #7: Use the Babel Runtime transform This transform will help you avoid Babel helper duplication in your library’s output. You can also use this transform to create a sandboxed environment for experimenting with your code. Set up your library for success This is just a small sample of best practices for composing shareable UI libraries. These tips offer a good way to start proactively reducing the friction that can arise in large, cross-team projects where you share your code.   By Javier Sánchez-Marín Javier Sánchez-Marín is a lead software engineer for New Relic in Barcelona, Spain. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 66.12539,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Packaging <em>and</em> distribution best practices",
        "body": " that consumers of your shared UI library will probably have global CSS and CSS resets in place. So it’s a good idea to <em>add</em> a robust reset file in your components CSS. In this case, the more robust the reset is, the less likely it is that you’ll run into problems. #4: Provide one main entrypoint Consumers"
      },
      "id": "60768d8828ccbca82451c192"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/article-templates/landing-page-template/",
      "sections": [
        "Landing page template",
        "Important",
        "Front matter",
        "Tip",
        "Introduction section",
        "Tiles",
        "Button for viewing all docs in the category",
        "Code sample"
      ],
      "published_at": "2021-04-16T01:35:17Z",
      "title": "Landing page template",
      "updated_at": "2021-04-12T11:25:05Z",
      "type": "docs",
      "external_id": "c40093f49b3daaa82483e1f82228c53a3b12ad6c",
      "document_type": "page",
      "popularity": 1,
      "body": "Landing pages are a specialized type of page that serve as the starting pages for various New Relic products. For example, you'll see landing pages for Application monitoring (APM) and Browser monitoring. Important This landing page information does not apply to the docs home page. If you need to create a new landing page, you can either copy an existing landing page, or you can modify the sample landing page shown at the bottom. The next sections look at what you need to include for each landing page. Front matter When you insert the front matter, be sure to designate the type as landingPage. Here's an example: --- title: New Relic APM type: landingPage --- Copy Tip In the front matter, the following are optional: tags, translate, and redirects. So, you can leave them out if they don't have any values. Introduction section Following the front matter, the first content section is a two-column introduction (also called the hero section). This includes the following: A <LandingPageHero> component wrapping all the introductory content. A <HeroContent> component wrapping the text portion of the introduction (the content in the left column). An image or video (appears in the right column). A caption (optional), which is wrapped by the <figcaption> component. Here's an example of the hero section that shows you where to insert your content: <LandingPageHero> <HeroContent> INSERT_PARAGRAPHS_FOR_YOUR_INTRODUCTION </HeroContent> ![INSERT_ALT-TEXT_HERE](./images/INSERT_IMAGE_FILE_NAME.png \"INSERT_THE_IMAGE_TITLE_HERE\") <figcaption> INSERT_OPTIONAL_CAPTION_USING_SAME_INDENTATION_AS_IMAGE </figcaption> </LandingPageHero> Copy Tiles Tiles are a series of boxes after the introduction. They contain the main subject areas for your product. You should just list these in order you want them to appear, and the cascading style sheet will render them across the page. Here's an example of a tile: <LandingPageTileGrid> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE.\" href=\"/docs/INSERT_THE_DIRECTORY_PATH_TO_THE_TARGET_LANDING_PAGE_INDEX.HTML\" icon=\"fe-INSERT_THE_ICON_NAME\" > INSERT_TILE_CONTENT_HERE... </LandingPageTile> ... Copy For each tile, do the following: Insert a value for title that explains the purpose of the category. Insert a value for href that links to the target landing page. If the target landing page is index.html, you can just include the directory path with no filename since index.html is the default (it doesn't cause any problems if you include index.html). Insert a value for icon by prefixing the icon name with fe- (Feather icons), logo- (third-party logos), or nr- (New Relic logos). For example, here is the format for a feather icon: fe-alert-triangle). Tip For more details about icons, see Embed images. Between the LandingPageTile tags, insert text, such as a bullet list with links to product documentation. Button for viewing all docs in the category After your tiles, you should have a single button that offers to take users to all the documentation for that category. The table of contents page that gets linked here is always at the same path as the landing page, but with /table-of-contents appended to it. These table of contents pages get built automatically for every landing page. For example, if this landing page was located at /docs/apm, this link should be /docs/apm/table-of-contents. Here's an example: <ButtonLink role=\"button\" to=\"INSERT_LINK_TO_DIRECTORY_WITH_ALL_THESE_DOCS/table-of-contents\" variant=\"normal\" > View all INSERT_YOUR_CATEGORY_HERE docs </ButtonLink> Copy Code sample Here's a sample landing page you could modify to suit your needs: --- title: INSERT_YOUR_TITLE_HERE type: landingPage --- <LandingPageHero> <HeroContent> INSERT_PARAGRAPHS_FOR_YOUR_INTRODUCTION </HeroContent> ![INSERT_ALT-TEXT_HERE](./images/INSERT_IMAGE_FILE_NAME.png \"INSERT_THE_IMAGE_TITLE_HERE\") <figcaption> INSERT_OPTIONAL_CAPTION_USING_SAME_INDENTATION_AS_IMAGE </figcaption> </LandingPageHero> <LandingPageTileGrid> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * [INSERT_LINK_NAME](INSERT_LINK_URL) Aliquam auctor mattis nisl ut iaculis. * [INSERT_LINK_NAME](INSERT_LINK_URL) Suspendisse pharetra elit sit amet risus euismod, a consectetur tortor vulputate. </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) to lectus diam, ornare vitae dui suscipit, laoreet ultrices lacus. * Mauris tempor massa ac augue mattis, nec pharetra quam mollis [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) rhoncus tortor vitae libero laoreet feugiat. * Donec dui elit, fermentum vel faucibus sed, rhoncus in felis [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) uspendisse pharetra elit sit amet risus euismod. * Pellentesque finibus magna vitae hendrerit gravida [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) Etiam imperdiet felis eu ipsum consequat tristique. * Etiam imperdiet felis eu ipsum consequat tristique [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) Quisque hendrerit, dolor sed sodales aliquet. * Vestibulum varius lectus ac velit euismod [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> </LandingPageTileGrid> <ButtonLink role=\"button\" to=\"INSERT_LINK_TO_DIRECTORY_WITH_ALL_THESE_DOCS/table-of-contents\" variant=\"normal\" > View all INSERT_YOUR_CATEGORY_HERE docs </ButtonLink> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 64.0388,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Button for viewing <em>all</em> docs in the category",
        "body": " them to appear, and the cascading style sheet will render them across the page. Here&#x27;s an example of a tile: &lt;LandingPageTile<em>Grid</em>&gt; &lt;LandingPageTile title=&quot;INSERT_YOUR_BOX_TITLE_HERE.&quot; href=&quot;&#x2F;docs&#x2F;INSERT_THE_DIRECTORY_PATH_TO_THE_TARGET_LANDING_PAGE_INDEX.HTML&quot; icon=&quot;fe-INSERT_THE_ICON_NAME"
      },
      "id": "6042212a28ccbc283feba79d"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Delayed-Jobs-New-Relic-1024x837.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/monitoring-delayedjob",
      "sections": [
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "Monitoring DelayedJob",
      "updated_at": "2021-04-14T00:06:04Z",
      "type": "",
      "external_id": "2e9c1f784c773aa1fa509a112bcd338cac37c70e",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit APM Monitoring DelayedJob Sep 12, 2012 • 6 min read By Bill Kayser Like many Ruby shops we use the DelayedJob job runner to run many of our background tasks. The New Relic agent has had some basic DelayedJob instrumentation for a while now but until recently you were limited to a few metrics which could only be viewed using the somewhat limited and unwieldy custom charts. But no longer! In the latest release of the Ruby Agent we are sending much richer, useful metrics for DelayedJob workers, and the recently released Custom Dashboards allows you to to build a truly useful view for monitoring and troubleshooting your jobs. Here's what it looks like: This is a Custom Dashboard we built for our DelayedJobs workers running in production. Below, I'll show you the steps to create this in your own New Relic account. But first let me explain what we are looking at. There are four graphs with data reported by the agent running in the DelayedJob worker. Job Queue Length shows the number of jobs waiting to be executed at any given time, based on one minute samples. We break out these numbers by priority since we manage separate workers in three different priority levels. In the graph above, you can see that our highest priority worker maintains a pretty healthy queue while we get a few spikes in our low priority worker every now and then, since the jobs in the low priority queue tend to run a little longer. In our configuration, we destroy jobs when they've run successfully and leave the failed ones. The agent polls the failed jobs and reports the count which we graph in the Failed Jobs chart. We pay particular attention to this chart during a deploy to look for any jump in failing jobs caused by a regression. Locked Jobs is particularly interesting. Jobs are locked while executing, so the number of jobs locked at any given time should not exceed the number of workers. With idle workers, the count will be low. With workers fully utilized, the number will approach the total number of workers. We find you do have to be careful as some jobs occasionally fail without clearing their lock, so you have to manually clear those out. But you can use the Locked Jobs graph as a gauge of your overall worker utilization. The Average Job Execution time graph is simply a graph of the average response time of the DelayedJob transactions. Creating a Custom Dashboard for DelayedJobs Let's walk through the steps to get this set up in a typical account. The first thing you need is the current version of the Ruby Agent gem. You must be running at least version 3.4.2. Then follow these steps in the New Relic application: 1) Select the application where DelayedJob is running. In our case it's \"Background Jobs\". 2) From the Custom Dashboards menu choose Create custom dashboard. Enter the title and \"Grid\" chart type. 3) Choose Add chart to add the first chart to your dashboard.  Fill in the basic properties, including the titles and chart type, which is \"Stacked Area.\" 4) Select the DelayedJob queue lengths for the graph. Start typing in Workers/. Initially it will say the metric doesn't exist, but when you enter the slash it will display the list of available metrics in the Workers namespace. Keep typing Workers/DelayedJob/queue_length/priority/*.  The metrics will auto-complete as you enter each segment. The asterisk at the end indicates that you want to break down the graph by priority. If you don't use priorities you can chart a single line for the queue length using the metric name Workers/DelayedJob/queue_length/all. 5. That's generally good enough to display the chart, but there are a couple of other properties you can customize. In our case, we removed the limit on the number of different priorities it will show, added \"jobs\" to the y-axis labels, and fixed the application to \"RPM Background\" where the DelayedJob agent reports to. Here's what it looks like: 6. Add the Failed Jobs chart. Repeat steps 3 - 5 but enter the metric for tracking failed jobs: Workers/DelayedJob/failed_jobs. 7. Add the Locked Jobs chart. Repeat steps 3 - 5 but enter the metric for tracking locked jobs: Workers/DelayedJob/locked_jobs. 8. Add the Job Execution Time chart. Repeat steps 3 - 5 but enter the metric for the response time of delayed jobs:  OtherTransaction/DelayedJob/all. We show execution time in milliseconds so we chose To Milliseconds for the Number Format and \"ms\" as the y-axis unit label. We also hide the legend. That's enough to get you started with a good dashboard for monitoring your DelayedJob workers. But you don't have to stop there. You can add a table showing you the summary metrics for each job or a breakdown chart of all the jobs. In addition to showing the response time of jobs, you could chart the throughput. We combine our staging and production servers onto one dashboard by duplicating the charts and picking a different application. Custom Dashboards now makes it easy to configure the charts for the exact data you want to display. If you haven't already, try New Relic today to see how you can improve the performance of your Ruby applications. And as always, we welcome your feedback on this post. Let us know what you think of Custom Dashboards and how you're using them to monitor your applications. Related Topics APM By Bill Kayser Bill has been with New Relic from the beginning as both a developer and a data scientist. Having worked in application performance management for nearly two decades, his role now entails discovering new ways of exploring and interpreting data as well as prototyping innovative new features. Follow the author Bill Kayser on Twitter Bill Kayser on GitHub Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 63.896706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " in the New Relic application: 1) Select the application where DelayedJob is running. In our case it&#x27;s &quot;Background Jobs&quot;. 2) From the Custom Dashboards menu choose Create custom dashboard. Enter the title and &quot;<em>Grid</em>&quot; chart type. 3) Choose <em>Add</em> chart to <em>add</em> the first chart to your dashboard.  Fill"
      },
      "id": "607631ece7b9d201aea5c63a"
    }
  ],
  "/build-apps/ab-test/nrql-customizations": [
    {
      "sections": [
        "NRQL: Group results across time",
        "Facet your NRQL query time range",
        "Group results by month",
        "Other grouping examples with FACET clause"
      ],
      "title": "NRQL: Group results across time",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "90fa8030ed670866a9d8154e8b8f16fc04ba0abf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nrql-group-results-across-time/",
      "published_at": "2021-04-17T02:08:27Z",
      "updated_at": "2021-04-17T02:08:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NRQL, you can create queries that group results across time. For example, you can group results together based on timestamps by separating them into buckets that cover a specified range of dates and times. When using time functions in NRQL queries, the results are returned in UTC. To adjust the results to your time zone, include the WITH TIMEZONE clause in your query. Facet your NRQL query time range To create your NRQL query, use a FACET clause with a bucket function that works with a timestamp attribute. Run a standard FACET query, but instead of faceting by an attribute, facet by time. For example: SELECT count(*) FROM PageView SINCE 1 day ago FACET monthOf(account_created) Copy To perform multiple functions within the same query, use NRQL's multi-facet capability: SELECT count(*) FROM PageView SINCE 1 day ago FACET dateOf(account_created), monthOf(account_created) Copy Time-based functions Description yearOf(attr) Returns the year of a timestamp. quarterOf(attr) Returns the quarter of the year. The returned value includes both the quarter and the year. Example: Q1 2014 monthOf(attr) Returns the month and year of the timestamp. Example: July 2014 weekOf(attr) Returns the week the timestamp occurred by naming the month and day of that week's Monday. Example: Week of January 15. weekdayOf(attr) Returns the day of the week of the timestamp. The returned value loops back at the end of the week, allowing you to look at trends by weekday over time. dateOf(attr) Returns the date of the timestamp. The returned value includes month, day and year. Example: July 15, 2014 dayOfMonthOf(attr) Returns the numeric date within a single month of the timestamp, a value from 1 to 31. The returned value does not include the month. hourOf(attr) Returns the hour of the timestamp. The returned value does not include a prepended 0 for hours between 1am and 9am. This differs from functions and clauses such as SINCE, which accept these hours with a 0 at the start. Examples: 6:00, 12:00, 18:00 Group results by month To group all results based on the month, use the monthOf function. In this example, the NRQL query includes a function (count(*)), a data type (PageView), a time frame (SINCE 1 day ago), and a time facet (monthOf(attribute)). SELECT count(*) FROM PageView SINCE 1 day ago FACET monthOf(account_created) Copy Running the query returns a table of results by month. Other grouping examples with FACET clause You can run NRQL queries to group your data in other ways, not just time. For additional examples, see the NRQL FACET documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.61388,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em>: Group results across time",
        "sections": "<em>NRQL</em>: Group results across time",
        "tags": "Query your <em>data</em>",
        "body": ". In this example, the <em>NRQL</em> query includes a function (count(*)), a <em>data</em> type (PageView), a time frame (SINCE 1 day ago), and a time facet (monthOf(attribute)). SELECT count(*) FROM PageView SINCE 1 day ago FACET monthOf(account_created) Copy Running the query returns a table of results by month"
      },
      "id": "60445a61196a671ddf960f19"
    },
    {
      "sections": [
        "NRQL syntax, clauses, and functions",
        "Syntax",
        "Query components",
        "Required clauses",
        "Required: SELECT statement",
        "Avg response time since last week",
        "Required: FROM clause",
        "Query one data type",
        "Query multiple data types",
        "Optional clauses",
        "AS clause",
        "Query using math function and AS",
        "Query using funnel and AS",
        "COMPARE WITH clause",
        "EXTRAPOLATE clause",
        "Important",
        "Example of extrapolating throughput",
        "Example of extrapolating throughput as a time series",
        "FACET clause",
        "Faceted query using count()",
        "Faceted query using uniqueCount()",
        "Grouping results across time",
        "FACET ... AS clause",
        "FACET CASES clause",
        "Basic usage with WHERE",
        "Group based on multiple attributes",
        "Label groups with AS",
        "FACET ... ORDER BY clause",
        "Tip",
        "LIMIT clause",
        "Query using LIMIT",
        "OFFSET clause",
        "ORDER BY clause",
        "SHOW EVENT TYPES clause",
        "Data types in the last day",
        "SINCE clause",
        "SLIDE BY clause",
        "Use SLIDE BY with MAX or AUTO interval",
        "TIMESERIES clause",
        "Use a set interval",
        "Use an automatically set interval",
        "Use MAX interval",
        "UNTIL clause",
        "WHERE clause",
        "Example query with three conditions",
        "WITH METRIC_FORMAT clause",
        "WITH TIMEZONE clause",
        "Query metric data",
        "Aggregator functions",
        "aggregationendtime()",
        "apdex(attribute, t: )",
        "Get Apdex for specific customers",
        "Get Apdex for specific transaction",
        "Get overall Apdex for your app",
        "average(attribute)",
        "buckets(attribute, ceiling [,number of buckets])",
        "bucketPercentile(attribute)",
        "cardinality(attribute)",
        "count(*)",
        "derivative(attribute [,time interval])",
        "dimensions(include: {attributes}, exclude: {attributes})",
        "earliest(attribute)",
        "Get earliest country per user agent from PageView",
        "eventType()",
        "Use eventType() in filter() function",
        "Use eventType() with FACET",
        "filter(function(attribute), WHERE condition)",
        "Analyze purchases that used offer codes",
        "funnel(attribute, steps)",
        "getField(attribute, field)",
        "histogram(attribute, ceiling [,number of buckets])",
        "Histogram of response times from PageView events",
        "Prometheus histogram buckets",
        "New Relic distribution metric",
        "Histogram with a FACET clause",
        "keyset()",
        "See all attributes for a data type",
        "latest(attribute)",
        "Get most recent country per user agent from PageView",
        "latestrate(attribute, time interval)",
        "Get the most recent rate of change of PageView Duration",
        "max(attribute)",
        "median(attribute)",
        "Median query",
        "min(attribute)",
        "minuteOf(attribute)",
        "mod(attribute, divisor)",
        "mod() within a WHERE clause condition",
        "mod() within a FACET clause",
        "percentage(function(attribute), WHERE condition)",
        "percentile(attribute [, percentile [, ...]])",
        "Basic percentile query",
        "predictLinear(attribute, [,time interval])",
        "rate(function(attribute) [,time interval])",
        "Basic rate query",
        "round(attribute)",
        "stddev(attribute)",
        "stdvar(attribute)",
        "sum(attribute)",
        "uniqueCount(attribute)",
        "uniques(attribute [,limit])",
        "Using tuple",
        "Type conversion"
      ],
      "title": "NRQL syntax, clauses, and functions",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "97c38ce7950d354d9f1d9efa5f432326f9bb4b00",
      "image": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/images/screen-apdex-function.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/",
      "published_at": "2021-04-16T19:26:15Z",
      "updated_at": "2021-04-12T09:29:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NRQL is a query language you can use to query the New Relic database. This document explains NRQL syntax, clauses, components, and functions. Syntax This document is a reference for the functions and clauses used in a NRQL query. Other resources for understanding NRQL: Intro to NRQL: explains what NRQL is used for, what data you can query with it, and basic NRQL syntax Examine NRQL queries used to build New Relic charts Learn how to query the Metric data type Simulate SQL JOIN functions Use funnels to evaluate a series of related data Format NRQL for querying with the Event API Query components Every NRQL query will begin with a SELECT statement or a FROM clause. All other clauses are optional. The clause definitions below also contain example NRQL queries. Required clauses Required: SELECT statement SELECT attribute ... Copy SELECT function(attribute) ... Copy The SELECT specifies what portion of a data type you want to query by specifying an attribute or a function. It's followed by one or more arguments separated by commas. In each argument you can: Get the values of all available attributes by using * as a wildcard. For example: SELECT * from Transaction. Get values associated with a specified attribute or multiple attributes specified in a comma separated list. Get aggregated values from specified attributes by selecting an aggregator function. Label the results returned in each argument with the AS clause. You can also use SELECT with basic math functions. Avg response time since last week This query returns the average response time since last week. SELECT average(duration) FROM PageView SINCE 1 week ago Copy Required: FROM clause SELECT ... FROM data type ... Copy Use the FROM clause to specify the data type you wish to query. You can start your query with FROM or with SELECT. You can merge values for the same attributes across multiple data types in a comma separated list. Query one data type This query returns the count of all APM transactions over the last three days: SELECT count(*) FROM Transaction SINCE 3 days ago Copy Query multiple data types This query returns the count of all APM transactions and Browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Optional clauses AS clause SELECT ... AS 'label' ... Copy Use the AS clause to label an attribute, aggregator, step in a funnel, or the result of a math function with a string delimited by single quotes. The label is used in the resulting chart. Query using math function and AS This query returns the number of page views per session: SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session' FROM PageView Copy Query using funnel and AS This query returns a count of people who have visited both the main page and the careers page of a site over the past week: SELECT funnel(SESSION, WHERE name='Controller/about/main' AS 'Step 1', WHERE name = 'Controller/about/careers' AS 'Step 2') FROM PageView SINCE 1 week ago Copy COMPARE WITH clause SELECT ... (SINCE or UNTIL) (integer units) AGO COMPARE WITH (integer units) AGO ... Copy Use the COMPARE WITH clause to compare the values for two different time ranges. COMPARE WITH requires a SINCE or UNTIL statement. The time specified by COMPARE WITH is relative to the time specified by SINCE or UNTIL. For example, SINCE 1 day ago COMPARE WITH 1 day ago compares yesterday with the day before. The time range for theCOMPARE WITH value is always the same as that specified by SINCE or UNTIL. For example, SINCE 2 hours ago COMPARE WITH 4 hours ago might compare 3:00pm through 5:00pm against 11:00am through 1:00pm. COMPARE WITH can be formatted as either a line chart or a billboard: With TIMESERIES, COMPARE WITH creates a line chart with the comparison mapped over time. Without TIMESERIES, COMPARE WITH generates a billboard with the current value and the percent change from the COMPARE WITH value. Example: This query returns data as a line chart showing the 95th percentile for the past hour compared to the same range one week ago. First as a single value, then as a line chart. SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO Copy EXTRAPOLATE clause You can use this clause with these data types: Transaction TransactionError Custom events reported via APM agent APIs The purpose of EXTRAPOLATE is to mathematically compensate for the effects of APM agent sampling of event data so that query results more closely represent the total activity in your system. This clause will be useful when a New Relic APM agent reports so many events that it often passes its harvest cycle reporting limits. When that occurs, the agent begins to sample events. When EXTRAPOLATE is used in a NRQL query that supports its use, the ratio between the reported events and the total events is used to extrapolate a close approximation of the total unsampled data. When it is used in a NRQL query that doesn’t support its use or that hasn’t used sampled data, it has no effect. Important Note that EXTRAPOLATE is most useful for homogenous data (like throughput or error rate). It's not effective when attempting to extrapolate a count of distinct things (like uniqueCount() or uniques()). This clause works only with NRQL queries that use one of the following aggregator functions: apdex average count histogram sum percentage (if function it takes as an argument supports EXTRAPOLATE) rate (if function it takes as an argument supports EXTRAPOLATE) stddev Example of extrapolating throughput A query that will show the extrapolated throughput of a service named interestingApplication. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE Copy Example of extrapolating throughput as a time series A query that will show the extrapolated throughput of a service named interestingApplication by transaction name, displayed as a time series. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE Copy FACET clause SELECT ... FACET attribute ... Copy Use FACET to separate and group your results by attribute values. For example, you could FACET your PageView data by deviceType to figure out what percentage of your traffic comes from mobile, tablet, and desktop devices. Use the LIMIT clause to specify how many facets appear (default is 10). For more complex grouping, use FACET CASES. FACET clauses support up to five attributes, separated by commas. The facets are sorted in descending order by the first field you provide in the SELECT clause. If you are faceting on attributes with more than 2,000 unique values, a subset of facet values is selected and sorted according to the query type. When selecting min(), max(), or count(), FACET uses those functions to determine how facets are picked and sorted. When selecting any other function, FACET uses the frequency of the attribute you are faceting on to determine how facets are picked and sorted. For more on faceting on multiple attributes, with some real-world examples, see this New Relic blog post. Faceted query using count() This query shows cities with the highest pageview counts. This query uses the total number of pageviews per city to determine how facets are picked and ordered. SELECT count(*) FROM PageView FACET city Copy Faceted query using uniqueCount() This query shows the cities that access the highest number of unique URLs. This query uses the total number of times a particular city appears in the results to determine how facets are picked and ordered. SELECT uniqueCount(pageUrl) FROM PageView FACET city Copy Grouping results across time Advanced segmentation and cohort analysis allow you to facet on bucket functions to more effectively break out your data. Cohort analysis is a way to group results together based on timestamps. You can separate them into buckets that cover a specified range of dates and times. FACET ... AS clause Use FACET ... AS to name facets using the AS keyword in queries. This clause is helpful for adding clearer or simplified names for facets in your results. It can also be used to rename facets in nested aggregation queries. FACET ... AS queries will change the facet names in results (when they appear as headers in tables, for example), but not the actual facet names themselves. FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type' Copy FACET CASES clause SELECT ... FACET CASES ( WHERE attribute operator value, WHERE attribute operator value, ... ) ... Copy Use FACET CASES to break out your data by more complex conditions than possible with FACET. Separate multiple conditions with a comma ,. For example, you could query your PageView data and FACET CASES into categories like less than 1 second, from 1 to 10 seconds, and greater than 10 seconds. You can combine multiple attributes within your cases, and label the cases with the AS selector. Data points will be added to at most one facet case, the first facet case that they match. You may also use a time function with your attribute. Basic usage with WHERE SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10) Copy Group based on multiple attributes This example groups results into one bucket where the transaction name contains login, and another where the URL contains login and a custom attribute indicates that the user was a paid user: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') Copy Label groups with AS This example uses the AS selector to give your results a human-readable name: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users') Copy FACET ... ORDER BY clause In NRQL, the default is for the first aggregation in the SELECT clause to guide the selection of facets in a query. FACET ... ORDER BY allows you to override this default behavior by adding an aggregate function with the ORDER BY modifier to specify how facets are selected. Specifically, the clause will override the priority by which facets are chosen to be in the final result before being limited by the LIMIT clause. This clause can be used in querying but not for alerts or streaming. This example shows how to use FACET ... ORDER BY to find the average durations of app transactions, showing the top 10 (default limit) highest durations by apps which have the highest response size. In this case, if FACET ... ORDER BY is not used, the query results will instead show the top 10 by highest durations, with response size being irrelevant to the app selection. FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize) Copy Tip Because the operations are performed before the LIMIT clause is applied, FACET ... ORDER BY does not impact the sort of the final query results, which will be particularly noticeable in the results for non-timeseries queries. Important The ORDER BY modifier in this case works differently than the ORDER BY clause. When parsing queries that follow the format FACET attribute1 ORDER BY attribute2, New Relic will read these as FACET ... ORDER BY queries, but only if ORDER BY appears immediately after FACET. Otherwise ORDER BY will be interpreted by New Relic as a clause. LIMIT clause SELECT ... LIMIT count ... Copy Use the LIMIT clause to control the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. This clause takes a single integer value as an argument. If the LIMIT clause is not specified, or no value is provided, the limit defaults to 10 for FACET queries and 100 in the case of SELECT * queries. The maximum allowed value for the LIMIT clause is 2,000. Query using LIMIT This query shows the top 20 countries by session count and provides 95th percentile of response time for each country for Windows users only. SELECT uniqueCount(session), percentile(duration, 95) FROM PageView WHERE userAgentOS = 'Windows' FACET countryCode LIMIT 20 SINCE YESTERDAY Copy OFFSET clause SELECT ... LIMIT count OFFSET count ... Copy Use the OFFSET clause with LIMIT to control the portion of rows returned by SELECT * or SELECT column queries. Like the LIMIT clause, OFFSET takes a single integer value as an argument. OFFSET sets the number of rows to be skipped before the selected rows of your query are returned. This is constrained by LIMIT. OFFSET rows are skipped starting from the most recent record. For example, the query SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1 returns the last 5 values from Minute_Report except for the most recent one. ORDER BY clause The ORDER BY clause allows you to specify how you want to sort your query results in queries that select event attributes by row. This query orders transactions by duration. FROM Transaction SELECT appName, duration ORDER BY duration Copy The default sort order is ascending, but this can be changed by adding the ASC or DESC modifiers. SHOW EVENT TYPES clause SHOW EVENT TYPES... Copy SHOW EVENT TYPES will return a list of all the data types present in your account for a specific time range. It is used as the first clause in a query instead of SELECT. Important In this context, \"event types\" refers to the data types you can access with a NRQL query. Data types in the last day This query will return all the data types present over the past day: SHOW EVENT TYPES SINCE 1 day ago Copy SINCE clause SELECT ... SINCE [numerical units AGO | phrase] ... Copy The default value is 1 hour ago. Use the SINCE clause to define the beginning of a time range for the returned data. When using NRQL, you can set a UTC timestamp or relative time range. You can specify a timezone for the query but not for the results. NRQL results are based on your system time. See Set time range on dashboards and charts for detailed information and examples. SLIDE BY clause The SLIDE BY clause supports a feature known as sliding windows. With sliding windows,SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. To use SLIDE BY, place it in a query after the TIMESERIES clause. For example, this query pulls data in 5-minute windows with a 1-minute SLIDE BY interval, meaning that each window lasts 5 minutes, but window 1 starts at 0 minutes, window 2 starts at 1 minute, window 3 starts at 2 minutes, and so on. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy To learn more about how and when you can use SLIDE BY, see Create smoother charts with sliding windows. Use SLIDE BY with MAX or AUTO interval You can use sliding windows in combination with MAX or AUTO. However, MAX or AUTO may not be placed between TIMESERIES and SLIDE BY. This query will automatically decide a SLIDE BY window interval. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy This query will set the SLIDE BY window to the maximum interval granularity. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy Important The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which can cause gaps and unexpected results. TIMESERIES clause SELECT ... TIMESERIES integer units ... Copy Use the TIMESERIES clause to return data as a time series broken out by a specified period of time. Since TIMESERIES is used to trigger certain charts, there is no default value. To indicate the time range, use integer units. For example: TIMESERIES 1 minute TIMESERIES 30 minutes TIMESERIES 1 hour TIMESERIES 30 seconds TIMESERIES can be combined with arguments such as MAX, AUTO, and SLIDE BY to further tailor query results, as shown in the examples below. Important For functions such as average( ) or percentile( ), a large aggregation window can have a significant smoothing effect on outliers. This is true whether or not the query makes use of sliding windows. Use a set interval The value provided indicates the units used to break out the graph. For example, to present a one-day graph showing 30 minute increments: SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes Copy Use an automatically set interval TIMESERIES can also be set to AUTO, which will divide your graph into a reasonable number of divisions. For example, a daily chart will be divided into 30 minute intervals and a weekly chart will be divided into 6 hour intervals. This query returns data as a line chart showing the 50th and 90th percentile of client-side transaction time for one week with a data point every 6 hours. SELECT average(duration), percentile(duration, 50, 90) FROM PageView SINCE 1 week AGO TIMESERIES AUTO Copy Use MAX interval You can set TIMESERIES to MAX, which will automatically adjust your time window to the maximum number of intervals allowed for a given time period. This allows you to update your time windows without having to manually update your TIMESERIES buckets and ensures your time window is being split into the peak number of intervals allowed. The maximum number of TIMESERIES buckets that will be returned is 366. For example, the following query creates 4-minute intervals, which is the ceiling for a daily chart. SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX Copy UNTIL clause SELECT ... UNTIL integer units AGO ... Copy The default value is NOW. Only use UNTIL to specify an end point other than the default. Use the UNTIL clause to define the end of a time range across which to return data. Once a time range has been specified, the data will be preserved and can be reviewed after the time range has ended. You can specify a UTC timestamp or relative time range. You can specify a time zone for the query but not for the results. The returned results are based on your system time. See Set time range on dashboards and charts for detailed information and examples. WHERE clause Use the WHERE clause to filter results. NRQL returns the results that fulfill the condition(s) you specify in the clause. SELECT function(attribute) ... WHERE attribute [operator 'value' | IN ('value' [, 'value]) | IS [NOT] NULL ] [AND|OR ...] ... Copy If you specify more than one condition, separate the conditions by the operators AND or OR. If you want to simulate a SQL join, use custom attributes in a WHERE or FACET clause. Operators that the WHERE clause accepts Description =, !=, <, <=, >, >= NRQL accepts standard comparison operators. Example: state = 'WA' AND Used to define an intersection of two conditions. OR Used to define a union of two conditions. IS NULL Determines if an attribute has a null value. IS NOT NULL Determines if an attribute does not have a null value. IN Determines if the string value of an attribute is in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Example: animalType IN ('cat', 'dog', 'fish') NOT IN Determines if the string value of an attribute is not in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Values must be in parentheses, separated by commas. For example: SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA') Copy LIKE Determines if an attribute contains a specified sub-string. The string argument for the LIKE operator accepts the percent sign (%) as a wildcard anywhere in the string. If the substring does not begin or end the string you are matching against, the wildcard must begin or end the string. Examples: userAgentName LIKE 'IE%' IE IE Mobile userAgentName LIKE 'o%a%' Opera Opera Mini userAgentName LIKE 'o%a' Opera userAgentName LIKE '%o%a%' Opera Opera Mini Mozilla Gecko NOT LIKE Determines if an attribute does not contain a specified sub-string. RLIKE Determines if an attribute contains a specified Regex sub-string. Uses RE2 syntax. Examples: appName RLIKE 'z.*|q.*'' z-app q-app hostname RLIKE 'ip-10-351-[0-2]?[0-9]-.*' ip-10-351-19-237 ip-10-351-2-41 ip-10-351-24-238 ip-10-351-14-15 Important Note: Slashes must be escaped in the Regex pattern. For example, \\d must be \\\\d. Regex defaults to full-string matching, therefore ^ and $ are implicit and you do not need to add them. If the Regex pattern contains a capture group, the group will be ignored. That is, the group will not be captured for use later in the query. NOT RLIKE Determines if an attribute does not contain a specified Regex sub-string. Uses RE2 syntax. Example query with three conditions This query returns the browser response time for pages with checkout in the URL for Safari users in the United States and Canada over the past 24 hours. SELECT histogram(duration, 50, 20) FROM PageView WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%' SINCE 1 day ago Copy WITH METRIC_FORMAT clause For information on querying metric data, see Query metrics. WITH TIMEZONE clause SELECT ... WITH TIMEZONE (selected zone) ... Copy By default, query results are displayed in the timezone of the browser you're using. Use the WITH TIMEZONE clause to select a time zone for a date or time in the query that hasn't already had a time zone specified for it. For example, the query clause SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York' will return data recorded from Monday at midnight, Eastern Standard Time, until midnight Tuesday, Eastern Standard Time. Available Time Zone Selections Africa/Abidjan Africa/Addis_Ababa Africa/Algiers Africa/Blantyre Africa/Cairo Africa/Windhoek America/Adak America/Anchorage America/Araguaina America/Argentina/Buenos_Aires America/Belize America/Bogota America/Campo_Grande America/Cancun America/Caracas America/Chicago America/Chihuahua America/Dawson_Creek America/Denver America/Ensenada America/Glace_Bay America/Godthab America/Goose_Bay America/Havana America/La_Paz America/Los_Angeles America/Miquelon America/Montevideo America/New_York America/Noronha America/Santiago America/Sao_Paulo America/St_Johns Asia/Anadyr Asia/Bangkok Asia/Beirut Asia/Damascus Asia/Dhaka Asia/Dubai Asia/Gaza Asia/Hong_Kong Asia/Irkutsk Asia/Jerusalem Asia/Kabul Asia/Katmandu Asia/Kolkata Asia/Krasnoyarsk Asia/Magadan Asia/Novosibirsk Asia/Rangoon Asia/Seoul Asia/Tashkent Asia/Tehran Asia/Tokyo Asia/Vladivostok Asia/Yakutsk Asia/Yekaterinburg Asia/Yerevan Atlantic/Azores Atlantic/Cape_Verde Atlantic/Stanley Australia/Adelaide Australia/Brisbane Australia/Darwin Australia/Eucla Australia/Hobart Australia/Lord_Howe Australia/Perth Chile/EasterIsland Etc/GMT+10 Etc/GMT+8 Etc/GMT-11 Etc/GMT-12 Europe/Amsterdam Europe/Belfast Europe/Belgrade Europe/Brussels Europe/Dublin Europe/Lisbon Europe/London Europe/Minsk Europe/Moscow Pacific/Auckland Pacific/Chatham Pacific/Gambier Pacific/Kiritimati Pacific/Marquesas Pacific/Midway Pacific/Norfolk Pacific/Tongatapu UTC See Set time range on dashboards and charts for detailed information and examples. Query metric data Metric data is more complex than other types of data. There are specific tips for querying it well. We have two types of metric data, each with their own query guidelines: Query dimensional metrics, which are reported by our Metric API and by some of our tools that use that API, like our Telemetry SDKs and our open-source telemetry integrations (OpenTelemetry, Kamon, Micrometer, more). Query metric timeslice data, which is our original metric data type reported by our APM, mobile monitoring, and browser monitoring. For more on understanding these data types, see Metric data types. Aggregator functions Use aggregator functions to filter and aggregate data in a NRQL query. Some helpful information about using aggregator functions: See the New Relic University tutorials for Filter queries, Apdex queries, and Percentile queries. Or, go to the full online course Writing NRQL queries. Data type \"coercion\" is not supported. Read about available type conversion functions. Cohort analysis functions appear on the New Relic Insights Cohort analysis page. The cohort functions aggregate transactions into time segments. Here are the available aggregator functions. The definitions below contain example NRQL queries. Examples: SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy aggregationendtime() Use the aggregationendtime() function to return the time of the relevant aggregation. More specifically, for a given aggregate, the aggregationendtime() function provides the timestamp of the end of the time period of that aggregation. For example, in a timeseries query, for a data point that encompasses an hour’s worth of data, the function would return the timestamp of the end of that hour period. apdex(attribute, t: ) Use the apdex function to return an Apdex score for a single transaction or for all your transactions. The attribute can be any attribute based on response time, such as duration or backendDuration. The t: argument defines an Apdex T threshold in seconds. The Apdex score returned by the apdex( ) function is based only on execution time. It does not account for APM errors. If a transaction includes an error but completes in Apdex T or less, that transaction will be rated satisfying by the apdex ( ) function. Get Apdex for specific customers If you have defined custom attributes, you can filter based on those attributes. For example, you could monitor the Apdex for a particularly important customer: SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago Copy Get Apdex for specific transaction Use the name attribute to return a score for a specific transaction, or return an overall Apdex by omitting name. This query returns an Apdex score for the Controller/notes/index transaction over the last hour: SELECT apdex(duration, t: 0.5) from Transaction WHERE name='Controller/notes/index' SINCE 1 hour ago Copy The apdex function returns an Apdex score that measures user satisfaction with your site. Arguments are a response time attribute and an Apdex T threshold in seconds. Get overall Apdex for your app This example query returns an overall Apdex for the application over the last three weeks: SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago Copy average(attribute) Use the average( ) function to return the average value for an attribute. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. buckets(attribute, ceiling [,number of buckets]) Use the buckets() function to aggregate data split up by a FACET clause into buckets based on ranges. You can bucket by any attribute that is stored as a numerical value in the New Relic database. It takes three arguments: Attribute name Maximum value of the sample range. Any outliers will appear in the final bucket. Total number of buckets For more information and examples, see Split your data into buckets. bucketPercentile(attribute) The bucketPercentile( ) function is the NRQL equivalent of the histogram_quantile function in Prometheus. It is intended to be used with dimensional metric data. Instead of the quantile, New Relic returns the percentile, which is the quantile * 100. Use the bucketPercentile( ) function to calculate the quantile from the histogram data in a Prometheus format. It takes the bucket name as an argument and reports percentiles along the bucket's boundaries: SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago Copy Optionally, you can add percentile specifications as an argument: SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago Copy Because multiple metrics are used to make up Prometheus histogram data, you must query for specific Prometheus metrics in terms of the associated <basename>. For example, to compute percentiles from a Prometheus histogram, with the <basename> prometheus_http_request_duration_seconds using NRQL, use bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50). Note how _ bucket is added to the end of the <basename> as a suffix. See the Prometheus.io documentation for more information. cardinality(attribute) Use the cardinality( ) function to obtain the number of combinations of all the dimensions (attributes) on a metric. It takes three arguments, all optional: Metric name: if present, cardinality( ) only computes the metric specified. Include: if present, the include list restricts the cardinality computation to those attributes. Exclude: if present, the exclude list causes those attributes to be ignored in the cardinality computation. SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list}) Copy count(*) Use the count( ) function to return a count of available records. It takes a single argument; either *, an attribute, or a constant value. Currently, it follows typical SQL behavior and counts all records that have values for its argument. Since count(*) does not name a specific attribute, the results will be formatted in the default \"humanize\" format. derivative(attribute [,time interval]) derivative() finds the rate of change for a given dataset. The rate of change is calculated using a linear least-squares regression to approximate the derivative. Since this calculation requires comparing more than one datapoint, if only one datapoint is included in the evaluation range, the calculation is indeterminate and won't work, resulting in a null value. The time interval is the period for which the rate of change is calculated. For example, derivative(attributeName, 1 minute) will return the rate of change per minute. dimensions(include: {attributes}, exclude: {attributes}) Use the dimensions( ) function to return all the dimensional values on a data type. You can explicitly include or exclude specific attributes using the optional arguments: Include: if present, the include list limits dimensions( ) to those attributes. Exclude: if present, the dimensions( ) calculation ignores those attributes. FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions() Copy When used with a FACET clause, dimensions( ) produces a unique timeseries for all facets available on the event type, similar to how Prometheus behaves with non-aggregated queries. earliest(attribute) Use the earliest( ) function to return the earliest value for an attribute over the specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get earliest country per user agent from PageView This query returns the earliest country code per each user agent from the PageView event. SELECT earliest(countryCode) FROM PageView FACET userAgentName Copy eventType() ...WHERE eventType() = 'EventNameHere'... ...FACET eventType()... Copy Use the eventType() function in a FACET clause to break out results by the selected data type or in a WHERE clause to filter results to a specific data type. This is particularly useful for targeting specific data types with the filter() and percentage() functions. Important In this context, \"event type\" refers to the types of data you can access with a NRQL query. Use eventType() in filter() function This query returns the percentage of total TransactionError results out of the total Transaction results. You can use the eventType() function to target specific types of data with the filter() function. SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago Copy Use eventType() with FACET This query displays a count of how many records each data type (Transaction and TransactionError) returns. SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES Copy filter(function(attribute), WHERE condition) Use the filter() function to limit the results for one of the aggregator functions in your SELECT statement. You can use filter() in conjunction with FACET or TIMESERIES. Filter is only useful when selecting multiple different aggregations such as SELECT filter(sum(x), WHERE attribute='a') AS 'A', filter(sum(x), WHERE attribute='b') AS 'B' .... Otherwise, it's better to just use the standard WHERE clause. Analyze purchases that used offer codes You could use filter() to compare the items bought in a set of transactions for those using an offer code versus those who aren't: Use the filter( ) function to limit the results for one of the aggregator functions in your SELECT statement. funnel(attribute, steps) Use the funnel() function to generate a funnel chart. It takes an attribute as its first argument. You then specify steps as WHERE clauses (with optional AS clauses for labels) separated by commas. For details and examples, see the funnels documentation. getField(attribute, field) Use the getField() function to extract a field from complex metrics. It takes the following arguments: Metric type Supported fields summary count, total, max, min gauge count, total, max, min, latest distribution count, total, max, min counter count Examples: SELECT max(getField(mySummary, count)) from Metric Copy SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10 Copy histogram(attribute, ceiling [,number of buckets]) Use the histogram( ) function to generate histograms. It takes three arguments: Attribute name Maximum value of the sample range Total number of buckets (between 1 and 500, inclusive) Histogram of response times from PageView events This query results in a histogram of response times ranging up to 10 seconds over 20 buckets. SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy Prometheus histogram buckets histogram( ) accepts Prometheus histogram buckets: SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago Copy New Relic distribution metric histogram( ) accepts Distribution metric as an input: SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago Copy Histogram with a FACET clause Use histogram( ) with a FACET clause to generate a heatmap chart: SELECT histogram(duration) FROM PageView FACET appName SINCE 1 week ago Copy keyset() Using keyset() will allow you to see all of the attributes for a given data type over a given time range. It takes no arguments. It returns a JSON structure containing groups of string-typed keys, numeric-typed keys, boolean-typed keys, and all keys. See all attributes for a data type This query returns the attributes found for PageView events from the last day: SELECT keyset() FROM PageView SINCE 1 day ago Copy latest(attribute) Use the latest( ) function to return the most recent value for an attribute over a specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get most recent country per user agent from PageView This query returns the most recent country code per each user agent from the PageView event. SELECT latest(countryCode) FROM PageView FACET userAgentName Copy latestrate(attribute, time interval) Use the latestrate( ) function to return the rate of change of a value based on the last 2 data points. It takes the attribute in question as the first argument and the unit of time for the resulting rate as the second argument. The function returns a result in units of change in attribute/time interval. This function can be useful to provide the most recent rate of change for an attribute in order to see leading-edge trends. Get the most recent rate of change of PageView Duration This query returns the rate of change of duration based on the last 2 data points. It will be returned in units of duration/second because of the 1 SECOND argument. SELECT latestrate(duration, 1 SECOND) FROM PageView Copy max(attribute) Use the max( ) function to return the maximum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. median(attribute) Use the median( ) function to return an attribute's median, or 50th percentile. For more information about percentile queries, see percentile(). Tip The median( ) query is only available when using the query builder. Median query This query will generate a line chart for the median value. SELECT median(duration) FROM PageView TIMESERIES AUTO Copy min(attribute) Use the min( ) function to return the minimum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. minuteOf(attribute) Use the minuteOf() function to extract only the minute portion (i.e. 0-59) of an attribute holding a valid timestamp value. mod(attribute, divisor) Use the mod( ) function to return the floor modulus after dividing the value of the provided numeric attribute (the first argument, or dividend) by a numeric value (the second argument, or divisor). This modulo operation can be used within a WHERE clause condition to filter to an arbitrary subset of results or within a FACET clause as a way to subdivide the result set. mod() within a WHERE clause condition FROM Transaction SELECT * WHERE mod(port, 2) = 1 Copy mod() within a FACET clause FROM NrDailyUsage SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10) Copy percentage(function(attribute), WHERE condition) Use the percentage( ) function to return the percentage of a target data set that matches some condition. The first argument requires an aggregator function against the desired attribute. Use exactly two arguments (arguments after the first two will be ignored). If the attribute is not numeric, this function returns a value of 100%. percentile(attribute [, percentile [, ...]]) Use the percentile( ) function to return an attribute's approximate value at a given percentile. It requires an attribute and can take any number of arguments representing percentile points. The percentile() function enables percentiles to displays with up to three digits after the decimal point, providing greater precision. Percentile thresholds may be specified as decimal values, but be aware that for most data sets, percentiles closer than 0.1 from each other will not be resolved. Percentile display examples Use TIMESERIES to generate a line chart with percentiles mapped over time. Omit TIMESERIES to generate a billboard and attribute sheet showing aggregate values for the percentiles. If no percentiles are listed, the default is the 95th percentile. To return only the 50th percentile value, the median, you can also use median(). Basic percentile query This query will generate a line chart with lines for the 5th, 50th, and 95th percentile. SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO Copy predictLinear(attribute, [,time interval]) predictLinear() is an extension of the derivative() function. It uses a similar method of least-squares linear regression to predict the future values for a dataset. The time interval is how far the query will look into the future. For example, predictLinear(attributeName, 1 hour) is a linear prediction 1 hour into the future of the query time window. Generally, predictLinear() is helpful for continuously growing values like disk space, or predictions on large trends. Since predictLinear() is a linear regression, familiarity with the dataset being queried helps to ensure accurate long-term predictions. Any dataset which grows exponentially, logarithmically, or by other nonlinear means will likely only be successful in very short-term predictions. New Relic recommends against using predictLinear in TIMESERIES queries. This is because each bucket will be making an individual prediction based on its relative timeframe within the query, meaning that such queries will not show predictions from the end of the timeseries forward. rate(function(attribute) [,time interval]) Use the rate( ) function to visualize the frequency or rate of a given query per time interval. For example, you might want to know the number of pageviews per minute over an hour-long period or the count of unique sessions on your site per hour over a day-long period. Use TIMESERIES to generate a line chart with rates mapped over time. Omit TIMESERIES to generate a billboard showing a single rate value averaged over time. Basic rate query This query will generate a line chart showing the rate of throughput for APM transactions per 10 minutes over the past 6 hours. SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago TIMESERIES Copy round(attribute) Use the round( ) function to return the rounded value of an attribute. Optionally round( ) can take a second argument, to_nearest, to round the first argument to the closest multiple of the second one. to_nearest can be fractional. SELECT round(n [, to_nearest]) Copy stddev(attribute) Use the stddev( ) function to return one standard deviation for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. stdvar(attribute) Use the stdvar( ) function to return the standard variance for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. sum(attribute) Use the sum( ) function to return the sum recorded values of a numeric attribute over the time range specified. It takes a single argument. Arguments after the first will be ignored. If the attribute is not numeric, it will return a value of zero. uniqueCount(attribute) Use the uniqueCount( ) function to return the number of unique values recorded for an attribute over the time range specified. Tip To optimize query performance, this function returns approximate results for queries that inspect more than 256 unique values. uniques(attribute [,limit]) Use the uniques( ) function to return a list of unique values recorded for an attribute over the time range specified. When used along with the facet clause, a list of unique attribute values will be returned per each facet value. The limit parameter is optional. When it is not provided, the default limit of 1,000 unique attribute values per facet is applied. You may specify a different limit value, up to a maximum of 10,000. The uniques( ) function will return the first set of unique attribute values discovered, until the limit is reached. Therefore, if you have 5,000 unique attribute values in your data set, and the limit is set to 1,000, the operator will return the first 1,000 unique values that it discovers, regardless of their frequency. The maximum number of values that can be returned in a query result is the product of the uniques( ) limit times the facet limit. In the following query, the theoretical maximum number of values that can be returned is 5 million (5,000 x 1,000). Depending on the data set being queried, and the complexity of the query, memory protection limits may prevent a very large query from being executed. From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000 Copy Using tuple If you'd like to know the unique combinations of a handful of attributes, you can structure a query in the format SELECT unique(tuple(x, y, ... z)) ...` to get all the unique tuples of values, to maintain their relationship. In the following query, tuple is used on index and cellName together to find uniques where those two values occur in combination. FROM NodeStatus SELECT uniques(tuple(index, cellName), 5) Copy Type conversion NRQL does not support \"coercion.\" This means that a float stored as a string is treated as a string and cannot be operated on by functions expecting float values. You can convert a string with a numeric value or a boolean with a string value to their numeric and boolean types with these functions: Use the numeric() function to convert a number with a string format to a numeric function. The function can be built into a query that uses math functions on query results or NRQL aggregator functions, such as average(). Use the boolean() function to convert a string value of \"true\" or \"false\" to the corresponding boolean value.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.43859,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> syntax, clauses, and functions",
        "sections": "<em>NRQL</em> syntax, clauses, and functions",
        "tags": "Query your <em>data</em>",
        "body": " <em>NRQL</em> is used for, what <em>data</em> you can query with it, and basic <em>NRQL</em> syntax Examine <em>NRQL</em> queries used to build New Relic charts Learn how to query the Metric <em>data</em> type Simulate SQL JOIN functions Use funnels to evaluate a series of related <em>data</em> Format <em>NRQL</em> for querying with the Event API Query"
      },
      "id": "604456c1196a678db8960f41"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/server-overview-dashboard.png",
      "url": "https://newrelic.com/blog/how-to-relic/server-overview-dashboard",
      "sections": [
        "Building a Server Overview dashboard",
        "Creating custom dashboards is easy"
      ],
      "published_at": "2021-04-16T04:25:53Z",
      "title": "How to Create a Server Overview Dashboard in New Relic Insights",
      "updated_at": "2021-04-14T02:02:40Z",
      "type": "",
      "external_id": "a682a93ac23e587fc70b52a65c2440851f9214aa",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic How to Create a Server Overview Dashboard in New Relic Insights Aug 10, 2017 • 7 min read By Phil Weber New Relic Infrastructure gives you real-time, searchable, filterable visibility across your entire infrastructure. But what if you want to view key metrics about a server on a single dashboard? Thanks to New Relic Insights, you can! Because Infrastructure stores its data in the New Relic Database (NRDB, the same data store used by Insights), it’s easy to create a Server Overview dashboard. In this post I’d like to walk you through how it’s done. Building a Server Overview dashboard First, log into your New Relic account and navigate to Infrastructure’s Compute page: If you look closely above each chart, you’ll notice a small icon that resembles a chart on an easel: Click this icon to open the chart’s underlying NRQL query in Insights: From here, you can customize the query, give the chart a title, and add it to a dashboard. The NRQL AS clause allows you to customize the label of a query attribute. Let’s add some AS clauses to make the chart legend easier to read. Change the NRQL query to SELECT average(cpuSystemPercent) AS 'CPU System %', average(cpuIOWaitPercent) AS 'CPU I/O Wait %', average(cpuUserPercent)   AS 'CPU User %', average(cpuStealPercent) AS 'CPU Steal %' FROM SystemSample SINCE 60 minutes ago TIMESERIES Click the Run button to execute the query. Give the resulting chart a title, such as “CPU Usage,” and click Add to a Dashboard. In the Add to a Dashboard dialog, select Add to a new dashboard and give your new dashboard a name, such as “Server Overview.” Now go back to Infrastructure and repeat the process for the Load and Memory charts. Infrastructure draws a custom chart to display Used and Available memory as a stacked-area chart. Unfortunately, it is not possible to replicate this chart in Insights. Instead, change the NRQL query to SELECT average(memoryUsedBytes / memoryTotalBytes * 100) AS 'Percent Used', 100 AS 'Max' FROM SystemSample SINCE 60 minutes ago TIMESERIES The SELECT...100 AS 'Max' clause forces the Y-axis to a scale of 0 to 100, allowing us to display the memory used as an easy-to-read percentage. From Infrastructure’s Storage page, change the chart to display Total Utilization %, view the query in Insights, and change it to SELECT average(totalUtilizationPercent) FROM StorageSample FACET entityAndMountPoint SINCE 60 minutes ago TIMESERIES To display network throughput, use the following query: SELECT average(transmitBytesPerSecond / 1024) AS 'Transmitted', average(receiveBytesPerSecond / 1024) AS 'Received' FROM NetworkSample SINCE 60 minutes ago TIMESERIES It can be helpful to see which processes are running on a server, in case one of them is consuming a large amount of CPU or memory, for example. You can use the following query to display a list of running processes, the name of the user who started each process, and how much CPU and memory each process is using: SELECT uniqueCount(processId), latest(userName),   average(cpuPercent) AS 'CPU Percent', average(memoryResidentSizeBytes) / 1024 AS 'Memory (MB)' FROM ProcessSample FACET processDisplayName SINCE 1 hour ago New Relic Infrastructure captures information about system events, such as user logins, package deployments, etc. Let’s add a widget to our dashboard to display recent events: SELECT * FROM InfrastructureEvent SINCE 1 day ago Finally, we need a way to select an individual host, so we can see an overview of a single server. Let’s add a table based on the following query: SELECT average(cpuPercent) AS 'CPU %', average(memoryUsedBytes / memoryTotalBytes) * 100 AS 'Memory Used %' FROM SystemSample FACET hostname SINCE 5 minutes ago LIMIT 10 That query displays the Top 10 host names reporting to your account, in order of CPU usage. After adding the above table to your dashboard, click the ellipsis icon in the upper-right corner of the chart widget and select Edit link: In the resulting Link to dashboard dialog, link the widget to the Current dashboard and save your changes. Now you can select a host name from the table to filter the dashboard to that host: To view the information for a host that’s not included in the Top 10, click in the Search hostname field at the top of the page and select the desired hostname. Creating custom dashboards is easy Pulling key server metrics into a single dashboard takes just a few minutes; now you can easily see the status of an individual server at a glance. Because New Relic Infrastructure stores its data in NRDB, it’s easy to export and customize charts from Infrastructure to Insights, and create custom dashboards that display whatever information you want to see. For more information on using New Relic Insights to share and view Infrastructure data, check out the documentation.   By Phil Weber Phil Weber is a Senior Technical Training Specialist with New Relic University. He worked as a software developer for over 15 years, and has been a technical trainer since 2005. As a consultant, he worked for such clients as Intel and Kaiser Permanente. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.408905,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Creating <em>custom</em> dashboards is easy",
        "body": " minutes; now you can easily see the status of an individual server at a glance. Because New Relic Infrastructure stores its <em>data</em> in NRDB, it’s easy to export and <em>customize</em> charts from Infrastructure to Insights, and create <em>custom</em> dashboards that display whatever information you want to see. For more"
      },
      "id": "60764d40196a67ef7f64a7c0"
    },
    {
      "sections": [
        "NRQLの構文、句、関数",
        "構文",
        "クエリの構成要素",
        "必要な句",
        "必須：SELECT文",
        "直近1週間の平均レスポンスタイム",
        "必須：FROM句",
        "ひとつのデータタイプのクエリ",
        "複数のデータタイプのクエリ",
        "オプションの句",
        "AS句",
        "数学関数とASを使用したクエリ",
        "ファネルとASを使用したクエリ",
        "COMPARE WITH句",
        "EXTRAPOLATE句",
        "重要",
        "スループットの推定の例",
        "時系列としてのスループットの推定の例",
        "FACET句",
        "count()を使用したファセットクエリ",
        "uniqueCount()を使用したファセットクエリ",
        "時間範囲で結果をグループ化",
        "FACET ... AS句",
        "FACET CASES句",
        "WHEREの基本的な使い方",
        "複数の属性に基づくグループ化",
        "ASを使用したグループのラベル付け",
        "FACET ... ORDER BY 句",
        "ヒント",
        "LIMIT句",
        "LIMITを使用したクエリ",
        "OFFSET 句",
        "ORDER BY 句",
        "SHOW EVENT TYPES句",
        "直近1日間のデータタイプ",
        "SINCE句",
        "SLIDE BY句",
        "SLIDE BYをMAXまたはAUTO間隔と一緒に使用する",
        "TIMESERIES句",
        "設定した間隔を使用する",
        "自動設定した間隔を使用する",
        "MAXインターバルを使用する",
        "UNTIL句",
        "WHERE句",
        "3つの条件を使ったクエリの例",
        "WITH METRIC_FORMAT 句",
        "WITH TIMEZONE句",
        "メトリックデータのクエリを行う",
        "集計関数",
        "aggregationendtime()",
        "apdex(attribute, t: )",
        "特定の顧客の Apdexを取得する",
        "特定のトランザクションのApdexを取得する",
        "アプリ全体のApdexを取得する",
        "average(attribute)",
        "buckets(attribute, ceiling \\[,number of buckets])",
        "bucketPercentile(attribute)",
        "cardinality(attribute)",
        "count(\\*)",
        "derivative(attribute \\[,time interval])",
        "dimensions(include: {attributes}, exclude: {attributes})",
        "earliest(attribute)",
        "PageView からユーザーエージェントごとに最も古い国を取得",
        "eventType()",
        "filter()関数でeventType()を使用する",
        "FACETでeventType()を使用する",
        "filter(function(attribute), WHERE condition)",
        "オファーコードを使用した購入を分析する",
        "funnel(attribute, steps)",
        "getField(attribute, field)",
        "histogram(attribute, ceiling \\[,number of buckets])",
        "PageViewイベントからのレスポンスタイムのヒストグラム",
        "Prometheusヒストグラムバケット",
        "New Relicディストリビューションメトリック",
        "keyset()",
        "データタイプのすべての属性を表示",
        "latest(attribute)",
        "PageView からユーザーエージェントごとに最新の国を取得",
        "latestrate(attribute, time interval)",
        "PageView期間の最新の変化率を取得する",
        "max(attribute)",
        "median(attribute)",
        "中央値クエリ",
        "min(attribute)",
        "minuteOf(attribute)",
        "mod(attribute, divisor)",
        "WHERE句条件内のmod()",
        "FACET句内のmod()",
        "percentage(function(attribute), WHERE condition)",
        "percentile(attribute \\[, percentile \\[, ...]])",
        "基本的なパーセンタイルのクエリ",
        "predictLinear(attribute, \\[,time interval])",
        "rate(function(attribute) \\[,time interval])",
        "基本的な評価クエリ",
        "round(attribute)",
        "stddev(attribute)",
        "stdvar(attribute)",
        "sum(attribute)",
        "uniqueCount(attribute)",
        "uniques(attribute \\[,limit])",
        "タプルの使用",
        "データ型変換",
        "その他のヘルプ"
      ],
      "title": "NRQLの構文、句、関数",
      "type": "docs-jp",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "86a104da11c2a96cd4c395682c86dc9205a32327",
      "image": "https://docs.newrelic.com/jp/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/images/screen-apdex-function.png",
      "url": "https://docs.newrelic.com/jp/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/",
      "published_at": "2021-04-16T19:26:14Z",
      "updated_at": "2021-04-06T00:25:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NRQLは、New Relicデータベースのクエリに使用可能なクエリ言語です。このドキュメントではNRQLの構文、句、構成要素、関数について説明します。 構文 このドキュメントは、NRQLクエリにおいて使用される関数と句の参考資料です。NRQLを理解するためのその他のリソース： NRQLの紹介：どのようなNRQLが使用されるのか、それによってどのようなデータをクエリできるのか、そして基本的なNRQL構文について説明しています。 New Relicチャートの作成に使用するNRQLクエリを検証する SQL JOIN関数をシミュレーション ファネルを使用して一連の関連データを評価する Event APIでクエリを行うためのNRQLをフォーマットする クエリの構成要素 すべてのNRQLクエリはSELECT文または FROM句で始まります。その他すべての句は任意です。以下の句の定義には、NRQLクエリの例も含まれます。 必要な句 必須：SELECT文 SELECT属性... コピー SELECT関数（属性）... コピー SELECTは、属性または関数を指定することによってどの部分のデータタイプをクエリしたいかを指定します。その後、カンマ区切りの1つ以上の引数が続きます。各引数では、以下を実行できます。 ワイルドカードとして*を使用することにより、利用可能なすべての属性の値を取得できます。例えば：SELECT * from Transaction。 指定した属性、または カンマ区切りのリストで指定した複数の属性に関連する値を取得できます。 集約関数を選択することで、指定した属性から集約値を取得できます。 AS句を使って、各引数で返された結果にラベルを付けます。 基本的な数学関数とともにSELECTを使用することもできます。 直近1週間の平均レスポンスタイム このクエリは、直近1週間の平均応答時間を返します。 SELECT average(duration) FROM PageView SINCE 1 week ago コピー 必須：FROM句 SELECT ... FROM data type ... コピー FROM句を使用して、クエリしたいデータタイプを指定します。クエリはFROMまたはSELECTから開始することができます。カンマ区切りのリストを使って、複数のデータタイプにまたがる同じ属性の値をマージすることができます。 ひとつのデータタイプのクエリ このクエリは、直近3日間の APMトランザクション の全件数を返します。 SELECT count(*) FROM Transaction SINCE 3 days ago コピー 複数のデータタイプのクエリ このクエリは、直近3日間の APM トランザクション と Browserイベント の全カウント数を返します。 SELECT count(*) FROM Transaction, PageView SINCE 3 days ago コピー オプションの句 AS句 SELECT ... AS 'label' ... コピー AS句を使用して、シングルクォート区切りの文字列で属性、集計、ファネル内のステップ、または数学関数の結果にラベルを付けます。このラベルは結果のチャートで使用されます。 数学関数とASを使用したクエリ このクエリはセッションごとのページ数を返します。 SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session' FROM PageView コピー ファネルとASを使用したクエリ このクエリは、過去1週間でサイトのメインページと採用情報ページの両方を訪れた人の数を返します。 SELECT funnel(SESSION, WHERE name='Controller/about/main' AS 'Step 1', WHERE name = 'Controller/about/careers' AS 'Step 2') FROM PageView SINCE 1 week ago コピー COMPARE WITH句 SELECT ... (SINCE or UNTIL) (integer units) AGO COMPARE WITH (integer units) AGO ... コピー COMPARE WITH句を使用して、2つの異なる時間範囲の値を比較します。 COMPARE WITHでは、SINCEまたはUNTIL文が必要になります。COMPARE WITHで指定された時間は、SINCEまたはUNTILで指定した時間に相対します。たとえば、SINCE 1 day ago COMPARE WITH 1 day agoは、昨日とその前日を比較します。 COMPARE WITH値の時間範囲は、常にSINCEまたはUNTILで指定されたものと同じになります。たとえば、SINCE 2 hours ago COMPARE WITH 4 hours agoは、午後3時から午後5時の範囲と午後1時から午後3時の範囲を比較します。 COMPARE WITHは、折れ線グラフまたはビルボードのいずれかの形式にすることができます： TIMESERIESを使うと、COMPARE WITHは時系列でマッピングされた比較で折れ線グラフを作成します。 TIMESERIESがない場合、COMPARE WITHは現在値とCOMPARE WITH値からの増減率でビルボードを生成します。 例: このクエリは、過去1時間の95パーセンタイルを1週間前の同じ時間範囲と比較した折れ線グラフでデータを返します。一つ目は単一の値、その次は折れ線グラフです。 SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO コピー EXTRAPOLATE句 この句は以下のデータタイプで使用可能です： Transaction TransactionError APMエージェントのAPIを通じて報告されたカスタムイベント EXTRAPOLATEの目的は、クエリ結果がシステム内のアクティビティ全体をより厳密に表現できるよう、イベントデータのAPMエージェントサンプリングの影響を数学的に補うことです。 この節は、New Relic APMエージェントが余りにも多くのイベントを報告することで、収穫サイクルの報告上限を超過しがちになる際に便利です。その場合、エージェントはイベントのサンプリングを開始します。 EXTRAPOLATEに対応したNRQLクエリでこれを使用した場合、報告されたイベントと合計イベントの比率を基に、合計未サンプルデータの近似を推定します。この句に未対応であるか、サンプルデータを使用していないNRQLでこれを使用した場合、結果に影響を与えません。 重要 EXTRAPOLATEは、（スループットやエラー率など）同種データについて最も有用なことに注意してください。（uniqueCount() や uniques()など）特徴的なことの数を外挿しようとする際には有効ではありません。 この句は、以下のいずれかの集約関数を利用したNRQLクエリでのみ機能します： apdex average count histogram sum percentage （引数として取る関数がEXTRAPOLATEに対応している場合） rate （引数として取る関数がEXTRAPOLATEに対応している場合） stddev スループットの推定の例 interestingApplicationという名前のサービスの推定スループットを示すクエリ。 SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE コピー 時系列としてのスループットの推定の例 トランザクション名ごとに、時系列として表示するinterestingApplicationという名前のサービスの推定スループットを示すクエリ。 SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE コピー FACET句 SELECT ... FACET attribute ... コピー FACETを使用すると、結果を属性値で分割してグループ化できます。例えば、PageViewデータでdeviceType別にFACETを行い、トラフィックの何割が携帯電話、タブレット、およびデスクトップデバイスから発生しているかを把握することができます。 LIMIT句を使用して、表示するファセットの数を指定します（デフォルトは10）。複雑なグループ化には、FACET CASESを使用してください。FACET句は、カンマで区切られた最大5つの属性をサポートします。 ファセットは、SELECT句で指定した最初のフィールドによって降順でソートされます。2,000件以上のユニーク値を持つ属性をファセットに指定した場合、ファセット値のサブセットを選択し、それらをクエリタイプに従って並べ替えます。 min()、max()、またはcount()を選択すると、FACETはこれらの関数を使用してファセットの選択方法とソート方法を決定します。その他の関数を選択すると、FACETはファセット対象の属性の発生頻度に基づいて、ファセットの選択方法とソート方法を決定します。 実際の例を使った複数の属性に対するファセットについては、こちらの New Relicのブログ記事をご覧ください。 count()を使用したファセットクエリ このクエリは、ページビュー数が最も多い都市を表示します。このクエリは、都市ごとのページビューの合計数を使用してファセットの選択方法と並べ替え方法を決定します。 SELECT count(*) FROM PageView FACET city コピー uniqueCount()を使用したファセットクエリ このクエリは、最も多数のユニークURLにアクセスしている都市を表示します。このクエリは、特定の都市が結果に表れる合計回数を使用して、ファセットの選択方法と並べ替え方法を決定します。 SELECT uniqueCount(pageUrl) FROM PageView FACET city コピー 時間範囲で結果をグループ化 高度なセグメンテーションやコホート分析では、バケット機能でファセットすることでデータをより効率的に分割することができます。 コホート分析は、タイムスタンプに基づいて結果をグループ化する方法です。指定範囲日時に対応するバケットに結果を分割することができます。 FACET ... AS句 FACET ... AS 句では、クエリで AS キーワードを使用してファセットに名前を付けます。この句は、結果のファセットに明確な名前または簡略化された名前を追加するのに役立ちます。ネスト構造の集計クエリで、ファセットの名前を変更するためにも使用できます。 FACET ... AS クエリでは、結果のファセット名が変更されますが（たとえば、テーブルのヘッダーとして表示される場合）、実際のファセット名自体は変更されません。 FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type' コピー FACET CASES句 SELECT ... FACET CASES ( WHERE attribute operator value, WHERE attribute operator value, ... ) ... コピー FACET CASESを使用して、FACETで可能な範囲を超えた複雑な条件別にデータを取り出します。複数の条件はカンマ,で区切ります。たとえば、PageViewデータをクエリして、1秒未満、1秒から10秒、10秒を上回るといったカテゴリにFACET CASESを行うことができます。ケース内の複数の属性を組み合わせたり、ASセレクタを使ってケースにラベルを付けることができます。データ点は、最大で1つのファセットケースに追加されます。つまり、一致する最初のファセットになります。 属性とともに時間関数も使用できます。 WHEREの基本的な使い方 SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10) コピー 複数の属性に基づくグループ化 この例は、トランザクション名にloginが含まれる1つのバケットと、URLにloginが含まれ、かつカスタム属性がユーザーが有料ユーザーであったことを示すもう1つのバケットに結果をグループ化します： SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') コピー ASを使用したグループのラベル付け この例は、結果に目視可能な名前をつけるためにASセレクタを使います： SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users') コピー FACET ... ORDER BY 句 NRQL では、デフォルトは SELECT 句の最初の集計で、クエリ内のファセットの選択をガイドします。FACET ... ORDER BY 句では、ORDER BY 修飾子を使用して集計関数を追加し、ファセットの選択方法を指定することで、このデフォルトの動作をオーバーライドできます。具体的には、LIMIT句によって制限される前に、最終結果に含めるファセットの優先度をオーバーライドします。この句はクエリで使用できますが、アラートやストリーミングには使用できません。 この例では、FACET ... ORDER BY を使用してアプリ トランザクションの平均期間を見つける方法を示し、応答サイズが最大のアプリによる上位10（デフォルトの制限）の最大期間を示しています。この場合、FACET ... ORDER BY が使用されていない場合、クエリ結果には、アプリの選択とは関係のない応答サイズで、期間が最も長い上位10件が代わりに表示されます。 FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize) コピー ヒント LIMIT 句が適用される前に操作が実行されるため、FACET ... ORDER BYは、最終的なクエリ結果の種類に影響を与えません。これは、非時系列クエリの結果で特に顕著になります。 重要 この場合の ORDER BY 修飾子は、ORDER BY 句とは機能が異なります。FACET attribute1 ORDER BY attribute2 の形式に従うクエリを解析する場合、NewRelic はこれらのクエリを FACET ... ORDER BY クエリとして読み取りますが、ORDER BY が FACET の直後に表示される場合に限定されます。それ以外の場合、ORDER BY は New Relic によって句として解釈されます。 LIMIT句 SELECT ... LIMIT count ... コピー LIMIT句を使用して、FACETクエリで返されるファセット値の最大数あるいはSELECT *クエリで返される項目の最大数を管理します。この句は、単一の整数値を引数に取ります。LIMIT句が指定されないか、値が提供されなかった場合、リミットのデフォルト設定はFACETクエリの場合は10に、SELECT *クエリの場合は100となります。 LIMIT句で許容される最大値は2,000です。 LIMITを使用したクエリ このクエリはセッション数上位20カ国を表示し、各国のWindowsユーザー限定でレスポンスタイムの95 パーセンタイルを提供します。 SELECT uniqueCount(session), percentile(duration, 95) FROM PageView WHERE userAgentOS = 'Windows' FACET countryCode LIMIT 20 SINCE YESTERDAY コピー OFFSET 句 SELECT ... LIMIT count OFFSET count ... コピー OFFSET句とLIMIT句を使用して、SELECT *またはSELECTの列クエリによって返される行の一部を制御します。 LIMIT 句と同様に、 OFFSET は引数として単一の整数値を取ります。 OFFSET は、クエリで選択された行が返される前に、スキップされる行数を設定します。これは LIMIT によって制約されます。 OFFSET 行はスキップされ、直近のレコードから開始されます。 たとえば、SELECT InterestingValue FROM Minute_Report LIMIT 5 OFFSET 1 のクエリは、 Minute_Report から、直近の値を除いて最後の5つの値を返します。 ORDER BY 句 ORDER BY 句を使用すると、行でイベント属性を選択するクエリで結果を並べ替える方法を指定できます。 このクエリは、期間順にトランザクションを並べ替えます。 FROM Transaction SELECT appName, duration ORDER BY duration コピー デフォルトの並べ替え順序は昇順ですが、 ASC または DESC の修飾子を追加することで変更できます。 SHOW EVENT TYPES句 SHOW EVENT TYPES... コピー SHOW EVENT TYPESは、特定の時間範囲内にアカウントに存在するすべてのデータタイプのリストを返します。これは、SELECTの代わりにクエリの最初の句として使用されます。 重要 この文脈において、「イベントタイプ」はNRQLクエリでアクセス可能なデータタイプを指します。 直近1日間のデータタイプ このクエリは、直近1日のすべてのデータタイプを返します。 SHOW EVENT TYPES SINCE 1 day ago コピー SINCE句 SELECT ... SINCE [numerical units AGO | phrase] ... コピー デフォルト 値は 1 時間前です。 SINCE句を使用して、返されたデータに対する時間範囲の開始時点を定義します。NRQLを使用する場合、UTCタイムスタンプまたは相対時間範囲を設定できます。タイムゾーンは結果ではなく、クエリに対して指定できます。NRQLの結果はシステム時間に基づきます。 詳細な情報と例については、ダッシュボードとチャートで時間範囲を設定するをご覧ください。 SLIDE BY句 SLIDE BY 句は、スライディングウィンドウと呼ばれる機能をサポートしています。スライディングウィンドウを使用すると、SLIDE BYデータは、互いに重複する時間の「ウィンドウ」に収集されます。これらのウィンドウは、移動集計（移動平均など）が狭い時間枠からの集計よりも重要である場合に、変動の多い折れ線グラフを滑らかにするのに役立ちます。 SLIDE BYを使用するには、TIMESERIES句の後のクエリにこの句を配置します。たとえば、このクエリは1分のSLIDE BY間隔で5分間のウィンドウにデータをプルします。つまり、各ウィンドウは5分間続きますが、ウィンドウ1は0分後に開始し、ウィンドウ2は1分後に開始し、ウィンドウ3は2分後に開始します。 SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute コピー SLIDE BYをいつ、どのように使用できるかについて詳しくは、スライディングウィンドウを使用してよりスムーズなグラフを作成するをご覧ください。 SLIDE BYをMAXまたはAUTO間隔と一緒に使用する スライディングウィンドウは、MAXまたはAUTOと組み合わせて使用できます。ただし、MAXまたはAUTOをTIMESERIES とSLIDE BYの間に配置することはできません。 このクエリは、SLIDE BYウィンドウ間隔を自動的に決定します。 SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO コピー このクエリは、SLIDEBYウィンドウを最大間隔に設定します。 SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX コピー 重要 AUTOまたはMAXによって決定されるSLIDE BY値は、ウィンドウ サイズよりも大きいステップ間隔を生成する可能性があり、ギャップや予期しない結果を引き起こす可能性があります。 TIMESERIES句 SELECT ... TIMESERIES integer units ... コピー TIMESERIES句を使用して、指定期間単位の時系列としてデータを返します。TIMESERIESは特定のチャートをトリガするために使用されることから、デフォルト値はありません。 時間範囲を指定するには、integer unitsを使用します。例えば： TIMESERIES 1 minute TIMESERIES 30 minutes TIMESERIES 1 hour TIMESERIES 30 seconds 以下の例に示すように、TIMESERIESをMAX、AUTO、SLIDE BYなどの引数と組み合わせると、クエリ結果をさらに調整できます。 重要 average( )またはpercentile( )などの関数では、集計ウィンドウを大きく設定することで、外れ値に対して大幅なスムージング効果が得られます。これは、クエリがスライディングウィンドウを使用するかどうかに関係なく当てはまります。 設定した間隔を使用する 指定された値は、グラフを分割する単位を示します。たとえば、以下のようにして1日のグラフを30分刻みで表示します。 SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes コピー 自動設定した間隔を使用する TIMESERIESはAUTOに設定することもでき、これによってグラフが適切な数の区分に分割されます。たとえば、1日のチャートは30分間隔で分割され、1週間のチャートは6時間間隔で分割されます。 このクエリは、6時間間隔のデータ点で、1週間のクライアントサイドのトランザクションタイムの50パーセントタイルと90パーセンタイルを示す折れ線グラフを返します。 SELECT average(duration), percentile(duration, 50, 90) FROM PageView SINCE 1 week AGO TIMESERIES AUTO コピー MAXインターバルを使用する TIMESERIESをMAXに設定することで時間枠が自動的に調整され、指定された期間で許可された間隔数を最大にすることができます。これによって、TIMESERIESバケットを手動で更新することなく時間枠を更新でき、認められた最大インターバル数に時間枠を分割できます。返されるTIMESERIESバケットの最大数は366です。 例えば、以下のクエリでは4分間の間隔を作成していますが、これは1日のチャートの上限となります。 SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX コピー UNTIL句 SELECT ... UNTIL integer units AGO ... コピー デフォルト 値は NOWです。UNTILは、デフォルト以外の終了点を指定するためのみに使用してください。 UNTIL句はデータを返す時間範囲の終了時点を定義します。時間範囲を指定するとデータが保存されるようになり、時間範囲が終了した後に確認することができます。時間は UTC タイムスタンプ または相対時間範囲を指定できます。タイムゾーンは結果ではなく、クエリに対して指定できます。返される結果はシステム時間に基づきます。 詳細な情報と例については、ダッシュボードとチャートで時間範囲を設定するをご覧ください。 WHERE句 WHERE句を使用して、結果をフィルタリングします。NRQLは、句で指定した条件を満たす結果を返します。 SELECT function(attribute) ... WHERE attribute [operator 'value' | IN ('value' [, 'value]) | IS [NOT] NULL ] [AND|OR ...] ... コピー 複数の条件を指定する場合は、条件を演算子ANDまたはORで区切ります。 SQLのjoinをシミュレートしたい場合は、WHEREまたはFACET句でカスタム属性を使用します。 WHERE句が受け付ける演算子 説明 =, !=, <, <=, >, >= NRQLは標準的な比較演算子を受け付けます。 例: state = 'WA' AND 2つの条件の論理積を定義するために使用します。 OR 2つの条件の論理和を定義するために使用します。 IS NULL 属性がnull値を持つかどうかを判定します。 IS NOT NULL 属性がnull値を持たないかどうかを判定します。 IN 属性の文字列値が指定したセットに存在するかどうかを判断します。この方法を使うと、複数のWHERE句を組み合わせた場合よりもパフォーマンスが向上します。 例: animalType IN （'cat', 'dog', 'fish'） NOT IN 属性の文字列値が指定したセットに存在しないかどうかを判断します。この方法を使うと、複数のWHERE句を組み合わせた場合よりもパフォーマンスが向上します。 値は括弧で囲み、カンマで区切る必要があります。例えば： SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA') コピー LIKE 属性に指定の部分文字列が含まれるかどうかを判断します。 LIKE演算子の文字列引数は、文字列内の任意の位置にワイルドカードとしてパーセント記号（%）を受け付けます。部分文字列が一致対象の文字列で開始（先頭に一致）または終了（末尾に一致）しない場合、ワールドカードを文字列の先頭または末尾に指定する必要があります。 例： userAgentName LIKE 'IE%' IE IE Mobile userAgentName LIKE 'o%a%' Opera Opera Mini userAgentName LIKE 'o%a' Opera userAgentName LIKE '%o%a%' Opera Opera Mini Mozilla Gecko NOT LIKE 属性に指定の部分文字列が含まれないかどうかを判定します。 RLIKE 属性に特定のRegex 部分文字列が含まれるかどうかを判断します。RE2 構文を使用します。 例： appName RLIKE 'z.*|q.*'' z-app q-app hostname RLIKE 'ip-10-351-[0-2]?[0-9]-.*' ip-10-351-19-237 ip-10-351-2-41 ip-10-351-24-238 ip-10-351-14-15 重要 注: Regexパターンではスラッシュをエスケープする必要があります。たとえば、\\dは\\\\dとする必要があります。 Regexではデフォルトで文字列全体マッチとなっているため、^と$は暗黙となり、追加する必要はありません。 Regexパターンにキャプチャグループが含まれる場合、そのグループは無視されます。つまり、クエリで後で使用するためにグループはキャプチャされません。 NOT RLIKE 属性に指定のRegex部分文字列が含まれないかどうかを判定します。RE2 構文を使用します。 3つの条件を使ったクエリの例 このクエリは、過去24時間、米国およびカナダ国内のSafariユーザーについて、URLにcheckoutが含まれるページのブラウザレスポンスタイムを返します。 SELECT histogram(duration, 50, 20) FROM PageView WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%' SINCE 1 day ago コピー WITH METRIC_FORMAT 句 メトリックデータのクエリに関する情報については、メトリックスのクエリを行うをご覧ください。 WITH TIMEZONE句 SELECT ... WITH TIMEZONE (selected zone) ... コピー デフォルトで、クエリ結果は、現在使用中のブラウザのタイムゾーンで表示されます。 WITH TIMEZONE句を使用して、タイムゾーンが未指定のクエリで日付や時刻のタイムゾーンを選択します。 たとえば、SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York'というクエリ句は、東部標準時の月曜日午前12時から東部標準時の火曜日午前12時までに記録されたデータを返します。 利用可能なタイムゾーンの選択 アフリカ/アビジャン アフリカ/アディスアベバ アフリカ/アルジェ アフリカ/ブランタイヤ アフリカ/カイロ アフリカ/ウィントフック 米州/アダック 米州/アンカレッジ 米州/アラグアイナ 米州/アルゼンチン/ブエノスアイレス 米州/ベリーズ 米州/ボゴタ 米州/カンポグランデ 米州/カンクン 米州/カラカス 米州/シカゴ 米州/チワワ 米州/ドーソンクリーク 米州/デンバー 米州/エンセナーダ 米州/グリーンベイ 米州/ゴットホープ 米州/グースベイ 米州/ハバナ 米州/ラパス 米州/ロサンゼルス 米州/ミクロン 米州/モンテビデオ 米州/ニューヨーク 米州/モローニャ 米州/サンティアゴ 米州/サンパウロ 米州/セントジョンズ アジア/アナディル アジア/バンコク アジア/ベイルート アジア/ダマスカス アジア/ダッカ アジア/ドバイ アジア/ガザ アジア/香港 アジア/イルクーツク アジア/エルサレム アジア/カブール アジア/カトマンズ アジア/コルカタ アジア/クラスノヤルスク アジア/マガダン アジア/ノボシビルスク アジア/ヤンゴン アジア/ソウル アジア/タシケント アジア/テヘラン アジア/東京 アジア/ウラジオストク アジア/ヤクーツク アジア/エカテリンブルク アジア/エレバン 大西洋/アゾレス 大西洋/カーポベルデ 大西洋/スタンリー オーストラリア/アデレード オーストラリア/ブリスベン オーストラリア/ダーウィン オーストラリア/ユークラ オーストラリア/ホバート オーストラリア/ロードハウ オーストラリア/パース チリ/イースター島 その他/GMT+10 その他/GMT+8 その他/GMT-11 その他/GMT-12 ヨーロッパ/アムステルダム ヨーロッパ/ベルファスト ヨーロッパ/ベオグラード ヨーロッパ/ブリュッセル ヨーロッパ/ダブリン ヨーロッパ/リスボン ヨーロッパ/ロンドン ヨーロッパ/ミンスク ヨーロッパ/モスクワ 太平洋/オークランド 太平洋/チャタム 太平洋/ガンビエ 太平洋/キリバス 太平洋/マルケサス 太平洋/ミッドウェイ 太平洋/ノーフォーク 太平洋/トンガタプ UTC 詳細な情報と例については、ダッシュボードとチャートで時間範囲を設定するをご覧ください。 メトリックデータのクエリを行う NRQLを使用してメトリックデータのクエリを行うには、次のいくつかの方法があります： メトリックタイムスライスデータをクエリ（New Relic APM、Browser、Mobileによりレポートされます） Metricデータタイプをクエリ（一部のインテグレーションおよびテレメトリーSDKによりレポートされます） New Relicでのメトリックスの理解の詳細については、メトリックデータのタイプをご覧ください。 集計関数 集約関数を使用して、NRQLクエリのデータを絞り込み、集約できます。以下に、集約関数の利用に関する便利な情報を提供します： New Relic UniversityのFilter Queries、Apdex Queries、およびPercentile Queriesのチュートリアル。または、完全なWriting NRQL クエリのオンラインコースにアクセスしてください。 データタイプ「型強制」には対応していません。利用可能なデータ型変換関数の詳細を参照してください。 New Relic Insights の コホート分析 ページでは、コホート分析の関数が表示されます。コホート関数は、時間別にトランザクションを集計します。 以下は、利用可能な集約関数になります。以下の定義には、NRQLクエリの例が含まれます。 例： SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago コピー aggregationendtime() aggregationendtime()関数を使用して、関連する集計の時刻を返します。より具体的には、aggregationendtime()関数は、特定の集計に対して集計の期間終了のタイムスタンプを提供します。たとえば、時系列クエリでは、1時間分のデータを含むデータポイントの場合、関数はその時間の終わりのタイムスタンプを返します。 apdex(attribute, t: ) apdex関数を使用して、単一のトランザクションまたはすべてのトランザクションに対してApdexスコアを返します。属性は、durationやbackendDurationなどのレスポンスタイムに基づいて、任意の属性に指定できます。t: 引数は Apdex T の閾値を秒単位で定義します。 apdex（ ）関数が返すApdexスコアは、実行時間のみに基づくものです。APMエラーは考慮していません。エラーが含まれているにもかかわらず、トランザクションがApdex T以下で完了する場合、そのトランザクションはapdex （ ）関数によって満足と評価されます。 特定の顧客の Apdexを取得する もし 定義済みのカスタム属性 がある場合は、それらの属性に基づいて絞り込むことができます。たとえば、特に重要な顧客のApdexを監視することができます。 SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago コピー 特定のトランザクションのApdexを取得する name属性を使用して特定のトランザクションのスコアを返す、またはnameを省略して総合的なApdexを返します。このクエリは、直近1時間の Controller/notes/index トランザクションのApdexスコアを返します。 SELECT apdex(duration, t: 0.5) from Transaction WHERE name='Controller/notes/index' SINCE 1 hour ago コピー apdex関数は、サイトに対するユーザーの満足度を測定するApdexスコアを返します。引数は、秒単位のレスポンスタイムの属性とApdex Tの閾値です。 アプリ全体のApdexを取得する このクエリの例では、直近3週間のアプリケーション全体のApdexを返します。 SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago コピー average(attribute) average( )関数を使用して、属性の平均値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数字の値が返されない場合、nullの値を返します。 buckets(attribute, ceiling \\[,number of buckets]) buckets()関数を使用して、FACET句ごとに分割されたデータを、範囲に基づきバケットに集約します。New Relicデータベースの数値として保存される属性ごとにバケットにまとめることができます。 この関数は 3 つの引数を取ります。 属性名 サンプル範囲の最大値。外れ値は最終バケットに表示されます。 バケットの合計数 詳細と例については、データをバケットに分割をご覧ください。 bucketPercentile(attribute) bucketPercentile( )関数は、Prometheusのhistogram_quantile関数のNRQL版です。ディメンションメトリックデータとともに使用します。分位数の代わりにNew Relicパーセンタイルを返します。これは分位数 * 100です。 bucketPercentile( )関数を使用して、Prometheus形式のヒストグラムデータから分位数を計算します。 バケット名を引数として取得し、バケットの境界とともにパーセンタイルをレポートします： SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago コピー オプションで、引数としてパーセンタイル指定を追加できます： SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago コピー 複数のメトリックスを使用してPrometheusヒストグラムデータを構成しているため、関連する<basename>に関して特定のPrometheusメトリックスのクエリを行う必要があります。 たとえば、PrometheusヒストグラムからNRQLを使用して<basename> prometheus_http_request_duration_secondsによりパーセンタイルの計算を行うには、bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50)を使用します。 _ bucketがサフィックスとして<basename>の最後に追加されていることに注意してください。 詳しくは、Prometheus.ioドキュメントを参照してください。 cardinality(attribute) cardinality( )関数を使用して、メトリック上のすべてのディメンション（属性）の組み合わせの数を取得します。 次の3つの引数を取りますが、すべてオプションです： Metric name: ある場合、cardinality( )は指定したメトリックのみを計算します。 Include: ある場合、Includeリストは、濃度計算をこの属性に制限します。 Exclude: ある場合、Excludeリストにより、この属性は濃度計算で使用されなくなります。 SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list}) コピー count(\\*) count（ ）関数を使用して、利用可能なレコード数を返します。これは単一の引数を受け入れます (*、属性、または一定値のいずれか)。現在、一般的なSQL動作に従って、その引数に対する値を持つすべてのレコードを計上します。 count（*）は特定の属性を示すものではないため、結果はデフォルトの「humanize」形式でフォーマットされます。 derivative(attribute \\[,time interval]) derivative()は、所定のデータセットの変化率を検索します。線形最小二乗回帰を使用して変化率を計算し、微分係数を近似します。この計算では複数のデータポイントの比較が必要であるため、評価範囲にデータポイントが1つしかない場合、解が求められず、結果はnull値になります。 時間間隔は、変化率を計算する期間です。たとえば、derivative(attributeName, 1 minute)は、1分あたりの変化率を返します。 dimensions(include: {attributes}, exclude: {attributes}) dimensions( )関数を使用して、データタイプのすべてのディメンション値を返します。 オプションの引数を使用して、特定の属性を明示的に含めたり除外したりすることができます： Include: ある場合、includeリストは、dimensions( )をそれらの属性に限定します。 Exclude: ある場合、dimensions( )の計算ではそれらの属性を使用しません。 FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions() コピー FACET句とともに使用する場合、dimensions( )は、未集計クエリでのPrometheusの動作と同様に、イベントタイプで使用できるすべてのファセットについて一意の時系列を生成します。 earliest(attribute) latest（ ）関数を使用して、指定された時間範囲における属性の最も古い値を返します。 単一の引数を取ります。最初の引数以外は無視されます。 FACETと併用する場合、この関数は得られた各ファセットの属性の最新値を返します。 PageView からユーザーエージェントごとに最も古い国を取得 このクエリは、PageView イベントからユーザーエージェントごとに最も古い国コードを返します。 SELECT earliest(countryCode) FROM PageView FACET userAgentName コピー eventType() ...WHERE eventType() = 'EventNameHere'... ...FACET eventType()... コピー eventType()関数は、選択したデータタイプ別に結果を取り出すためにFACET句で使用、または特定のデータタイプに結果をフィルタリングするためにWHERE句で使用します。これは filter() や percentage() 関数で特定のデータタイプを対象とする際に特に便利です。 重要 この文脈において、「イベントタイプ」はNRQLクエリでアクセス可能なデータタイプを指します。 filter()関数でeventType()を使用する このクエリは、合計Transactionの結果あたりの合計TransactionErrorの結果の割合を返します。eventType()関数を使用して、filter()関数で特定のデータタイプをターゲットにすることができます。 SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago コピー FACETでeventType()を使用する このクエリは、各データタイプ（TransactionおよびTransactionError）が返すレコードの数を表示します。 SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES コピー filter(function(attribute), WHERE condition) filter（ ）関数を使用して、SELECT文内の集計関数の1つに結果を制限できます。filter()は、FACETまたはTIMESERIESと併用することができます。 オファーコードを使用した購入を分析する filter()は、一連のトランザクションで購入された商品の中で、オファーコードを使用して購入された商品と、オファーコードを使用せずに購入された商品を比較するために使用できます： filter（ ）関数を使用して、SELECT文内の集計関数の1つに結果を制限できます。 funnel(attribute, steps) funnel()関数を使用して、ファネルチャートを生成します。属性を最初に引数に取ります。その後、カンマで区切られた複数のWHERE句（オプションでラベル付け用にAS句を含める）をステップとして指定します。 詳細な情報と例については、 ファネルのドキュメントをご覧ください。 getField(attribute, field) getField()関数を使用して、複雑なメトリックスからフィールドを抽出します。 次の引数を取ります： メトリックのタイプ サポートされたフィールド summary count、total、max、min gauge count、total、max、min、latest distribution count、total、max、min counter count 例： SELECT max(getField(mySummary, count)) from Metric コピー SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10 コピー histogram(attribute, ceiling \\[,number of buckets]) histogram（ ）関数を使用して、ヒストグラムを生成します。この関数は 3 つの引数を取ります。 属性名 サンプル範囲の最大値 バケットの合計数 PageViewイベントからのレスポンスタイムのヒストグラム このクエリは 20 バケットにわたって 10 秒以内のレスポンスタイムのヒストグラムを生成します。 SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago コピー Prometheusヒストグラムバケット histogram( )では、Prometheusヒストグラムバケットを受け取ります: SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago コピー New Relicディストリビューションメトリック histogram( )ではディストリビューションメトリックを入力として受け取ります: SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago コピー keyset() keyset()を使用すると、所定の時間範囲における所定のデータタイプに対するすべての属性を表示できます。この関数は引数を取りません。文字列型キー、数値型キー、ブーリアン型キー、およびすべてのキーをグループ化した JSON 構造体を返します。 データタイプのすべての属性を表示 このクエリは、最後の日からのPageViewイベントで見つかった属性を返します： SELECT keyset() FROM PageView SINCE 1 day ago コピー latest(attribute) latest（ ）関数を使用して、指定された時間範囲における属性の最新値を返します。 単一の引数を取ります。最初の引数以外は無視されます。 FACETと併用する場合、この関数は得られた各ファセットの属性の最新値を返します。 PageView からユーザーエージェントごとに最新の国を取得 このクエリは、PageView イベントからユーザーエージェントごとに最新の国コードを返します。 SELECT latest(countryCode) FROM PageView FACET userAgentName コピー latestrate(attribute, time interval) latestrate( )関数を使用して、最後の2つのデータポイントに基づく値の変化率を返します。問題となる属性を最初の引数として受け取り、結果である変化率の時間の単位を2番目の引数として受け取ります。この関数は、属性の変化/時間間隔の単位で結果を返します。 この関数は、最先端の傾向を確認するために、属性の最新の変化率を提供するのに役立ちます。 PageView期間の最新の変化率を取得する このクエリは、最後の2つのデータポイントに基づいて期間の変化率を返します。 1 SECOND 引数があるため、期間/秒の単位で返されます。 SELECT latestrate(duration, 1 SECOND) FROM PageView コピー max(attribute) max（ ）関数を使用して、指定された時間範囲内に記録された数値属性の最大値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数字の値が返されない場合、nullの値を返します。 median(attribute) median( )関数を利用して、属性の中央値あるいは50パーセンタイルを返します。パーセンタイルクエリの詳細に関しては、percentile()を参照してください。 ヒント median( )クエリは、クエリビルダーを利用する場合にのみ利用できます。 中央値クエリ このクエリは、中央値に関する折れ線グラフを生成します。 SELECT median(duration) FROM PageView TIMESERIES AUTO コピー min(attribute) min（ ）関数を使用して、指定された時間範囲内に記録された数値属性の最小値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数字の値が返されない場合、nullの値を返します。 minuteOf(attribute) minuteOf()関数を使用して、有効なタイムスタンプ値を持つ属性の分の部分（0～59）のみを抽出します。 mod(attribute, divisor) 与えられた数値属性の値（最初の引数、すなわち被除数）を数値（2つ目の引数、すなわち除数）で割った後、mod( )関数を使用してfloor係数を返します。このモジュロ演算は、WHERE句の条件内で使用して結果の任意のサブセットにフィルターしたり、FACET句で結果セットをさらに分割したりする方法として使用できます。 WHERE句条件内のmod() FROM Transaction SELECT * WHERE mod(port, 2) = 1 コピー FACET句内のmod() FROM NrDailyUsage SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10) コピー percentage(function(attribute), WHERE condition) percentage（ ）関数を使用して、いくつかの条件に一致する目的のデータセットの割合を返します。 最初の引数には、目的の属性に対する集計関数が必要です。必ず2つの引数を使用してください（最初の 2 つ以外の引数は無視されます）。属性が数値でない場合、この関数は 100% を値として返します。 percentile(attribute \\[, percentile \\[, ...]]) percentile（ ）関数を使用して、所定の指定パーセンタイルでの属性の概算値を返します。この関数は属性が必須であり、パーセンタイル点を表す引数はいくつでも指定できます。percentile() 関数は、小数点以下3桁までの表示を可能にすることで、より厳密な内容を提供できます。パーセンタイルの閾値は小数点値として指定される場合があるものの、大半のデータセットにおいて、互いに0.1よりも近いパーセンタイルは解決されない点に注意してください。 パーセンタイルの表示例 TIMESERIESを使用して、時系列でマッピングされたパーセンタイルで折れ線グラフを生成します。 TIMESERIESを省略して、パーセンタイルの集計値を示すビルボードと属性シートを生成します。 パーセンタイルが指定されていない場合、デフォルトで 95 パーセンタイルとなります。50パーセンタイル値、つまり中央値のみを返すには、median()を使用することもできます。 基本的なパーセンタイルのクエリ このクエリは 5、50、95 パーセンタイルの折れ線を表示する折れ線グラフを生成します。 SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO コピー predictLinear(attribute, \\[,time interval]) predictLinear()は、derivative()関数の拡張です。同様の方法の最小2乗線形回帰を使用して、データセットの将来値を予測します。 時間間隔は、クエリでどの程度将来まで扱うかを表します。たとえば、predictLinear(attributeName, 1 hour)は、1時間の線形予想をクエリの時間枠の将来に当てはめます。 一般に、predictLinear()は、ディスクスペースのような増加が続く値や大きなトレンドの予想などで有用です。 predictLinear()は線形回帰のため、クエリを行っているデータセットに習熟していると、正確な長期的な予想を行えます。 指数的または対数的、その他の非線形的に増加するデータセットでは、非常に短期的な予想でのみ有効な可能性が高いと言えます。 New Relicでは、TIMESERIESクエリでpredictLinearを使用することを推奨していません。これは、各バケットがクエリ内の相対的な期間に基づき個別に予想を行う、つまり、そうしたクエリは時系列終了以後の予想は示さないためです。 rate(function(attribute) \\[,time interval]) rate ()関数を使用して、時間間隔ごとに所定のクエリの頻度またはレートを視覚化します。たとえば、1 時間の 1 分あたりのページビュー数や 1 日間の 1 時間あたりのサイトのユニークセッション数を把握したい場合があるかもしれません。 TIMESERIESを使用して、時系列でマッピングされたレートで折れ線グラフを生成します。 TIMESERIESを省略して、時系列で平均化された単一のレート値を示すビルボードを生成します。 基本的な評価クエリ このクエリは、過去 6 時間の 10 分あたりの APM トランザクションのスループット評価を示す折れ線グラフを生成します。 SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago TIMESERIES コピー round(attribute) round( )関数を使用して、属性の丸め値を返します。 オプションで、round( )は2番目の引数to_nearestを取り、最初の引数を2番目の引数の最も近い倍数に切り上げます。to_nearestは分数でも使用できます。 SELECT round(n [, to_nearest]) コピー stddev(attribute) stddev()関数を使用して、指定された時間範囲内に記録された数値属性の標準偏差値を返します。単一の引数を取ります。属性が数値でない場合は、ゼロを値として返します。 stdvar(attribute) stdvar()関数を使用して、指定された時間範囲内に記録された数値属性の標準分散を返します。 単一の引数を取ります。属性が数値でない場合は、ゼロを値として返します。 sum(attribute) sum（ ）関数を使用して、指定された時間範囲内に記録された数値属性の合計値を返します。 単一の引数を取ります。最初の引数以外は無視されます。属性が数値でない場合は、ゼロを値として返します。 uniqueCount(attribute) uniqueCount（ ）関数を使用して、指定された時間範囲内に記録された属性のユニーク値の数を返します。 ヒント クエリのパフォーマンスを最適化するため、この関数は256を超えるユニーク値を検査するクエリのおおよその結果を返します。 uniques(attribute \\[,limit]) uniques（ ）関数を使用して、指定された時間範囲内に記録された属性のユニーク値のリストを返します。facet句と共に使用すると、各ファセット値ごとに固有の属性値一覧が返されます。 limitパラメータは任意です。これが提供されない場合、ファセットあたり1,000の固有の属性値がデフォルトリミットとして適用されます。最大10,000までの、別のlimitを指定することもできます。uniques( )関数は、上限に達するまで、発見した固有の属性値の最初の一式を返します。このため、データセットに5,000の固有の属性値があり、上限が1,000に設定されている場合、演算子はその頻度に関わらず、発見した最初の1,000の固有の値を返します。 クエリ結果で返すことのできる最大数は、uniques( )上限とfacet上限を掛け合わせたものになります。以下のクエリでは、論理的に返すことの可能な最大値は500万になります（5,000 x 1,000）。 クエリしたデータセットのほか、クエリの複雑さ次第では、メモリ保護上限の影響で非常に大きなクエリの実行が阻止される可能性があります。 From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000 コピー タプルの使用 少数の属性の独自の組み合わせを知りたい場合、SELECT unique(tuple(x, y, ... z)) ...`形式でクエリを構築することで、値の独自のタプルをすべて取得して、それらの関係を維持することができます。以下のクエリでは、tupleがインデックスとcellName両方に対して使用され、これらの2つの値が組み合わせで発生する一意の要素を見つけます。 FROM NodeStatus SELECT uniques(tuple(index, cellName), 5) コピー データ型変換 NRQLは「型強制」をサポートしていません。つまり、文字列として保存された浮動小数点は文字列として取り扱われ、浮動小数点数を要求する関数に渡しても操作できません。 次に示す関数を用いることで、数値を伴う文字列、または文字列を伴うブーリアン値をそれぞれ数またはブーリアン値に変換できます。 numeric() 関数を用いて、文字列形式の数値を数値関数に変換します。この関数は、クエリ結果に数学関数を使用するクエリ、もしくはaverage()などのNRQL 集計関数に組み込むことができます。 boolean()関数を用いることで、「true」もしくは「false」の文字列値を対応するブーリアン値に変換できます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.547226,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em>の構文、句、関数",
        "sections": "<em>NRQL</em>の構文、句、関数",
        "tags": "Query your <em>data</em>",
        "body": "<em>NRQL</em>は、New Relicデータベースのクエリに使用可能なクエリ言語です。このドキュメントでは<em>NRQL</em>の構文、句、構成要素、関数について説明します。 構文 このドキュメントは、<em>NRQL</em>クエリにおいて使用される関数と句の参考資料です。<em>NRQL</em>を理解するためのその他のリソース： <em>NRQL</em>の紹介：どのような<em>NRQL</em>が使用されるのか、それによってどのようなデータをクエリできるのか、そして基本的な<em>NRQL</em>構文について説明しています。 New Relicチャートの作成に使用する<em>NRQL</em>クエリを検証する SQL JOIN関数をシミュレーション ファネルを使用して一連の関連データを評価する Event"
      },
      "id": "6053a66828ccbc48e1c2fd19"
    },
    {
      "sections": [
        "Rate limits for NRQL queries",
        "Limits on queried events",
        "NRQL query rate limits",
        "Limits on count of data types"
      ],
      "title": "Rate limits for NRQL queries",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "6dd3504c517c84fe20e0066c36482a001d0e2f3a",
      "image": "https://docs.newrelic.com/static/a67951798a5b60f8aca1b4aac861f61a/466da/insights-inspected-event-count-modal_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/rate-limits-nrql-queries/",
      "published_at": "2021-04-17T03:10:23Z",
      "updated_at": "2021-04-05T16:30:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's query language, NRQL, has rate limits in place to ensure a high level of availability and reliability for all users. To understand the places NRQL can be used, see Where is NRQL used?. You will rarely encounter rate limiting, especially if you follow these general guidelines: Limit the amount of requests with complex queries (for example, queries with FACET or TIMESERIES clauses, or queries of over a million events) that run at the same time. Limit the amount of requests run concurrently over extended periods of time to a maximum of 5, especially if they include complex queries. Limits on queried events When you run a NRQL query, it will display the number of events inspected, as shown below: In this context, \"events\" is used in a general sense to refer to all NRQL-available objects; this includes events, metrics, logs, and distributed tracing (span) data. Each New Relic account has limits on the total number of events that can be inspected. There are limits that apply over two different time frames: A rolling 30-minute time window A 24-hour period These limits are as follows: Time period Limit Rolling 30 minutes 300 billion events inspected (equivalent to a sustained rate of 10 billion events inspected per minute) 24 hours 7.2 trillion events inspected Once the limit has been reached for a given time period, limiting will be imposed and some queries may be impacted. After the time period has passed, if query volume drops below the limit, restrictions will be removed automatically. NRQL query rate limits The limit on NRQL queries is 50 queries per second, or 3000 queries per minute. Past this, New Relic cannot guarantee query performance, and you may be rate limited. Limits on count of data types The limit for total number of reported data types is 250 per account over a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. This limit applies to all NRQL-queryable data types. Because there aren't that many different data types reported by New Relic products and integrations, this will mainly be a limit on custom events.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.15061,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Rate limits for <em>NRQL</em> queries",
        "sections": "Rate limits for <em>NRQL</em> queries",
        "tags": "Query your <em>data</em>",
        "body": " account over a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop <em>data</em>. This limit applies to all <em>NRQL</em>-queryable <em>data</em> types. Because there aren&#x27;t that many different <em>data</em> types reported by New Relic products and integrations, this will mainly be a limit on <em>custom</em> events."
      },
      "id": "603e8e46e7b9d2143d2a07b0"
    }
  ],
  "/build-apps/ab-test/confirmation-modal": [
    {
      "sections": [
        "Test alert notification channels",
        "Request the test",
        "Troubleshoot the test results",
        "Tip"
      ],
      "title": "Test alert notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "c001fca5128a2fb8128ff655c44f9d51b6d5fa2a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/test-alert-notification-channels/",
      "published_at": "2021-04-16T14:39:15Z",
      "updated_at": "2021-03-16T06:45:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You must save a new notification channel or any changes to an existing notification channel before testing it. Alerts will then send a test message to your chosen destination. Request the test To test a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Follow standard procedures to add a new notification channel or to update an existing notification channel, and save it. Select a notification channel, and then click Send a test notification. Review the test confirmation message, and then click Got it. Troubleshoot the test results A confirmation message will automatically show up in the user interface that indicates where the test was sent (for example, email) and whether it was successful. Also, the test notification message itself includes detailed information, including: The person who requested the test Links to policies for the channel Links to all notification channels and policies for the account Tip When troubleshooting problems, review the test notification message, and verify the setup requirements for the type of notification channel you selected. If necessary, make additional changes to your notification channel, and test it again as needed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.511246,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Test</em> alert notification channels",
        "sections": "<em>Test</em> alert notification channels",
        "tags": "Alerts <em>and</em> Applied Intelligence",
        "body": " Notification channels. Follow standard procedures to add a new notification channel or to update an existing notification channel, and save it. Select a notification channel, and then click Send a <em>test</em> notification. Review the <em>test</em> <em>confirmation</em> message, and then click Got it. Troubleshoot the <em>test</em>"
      },
      "id": "603ec9ffe7b9d25b3d2a07a7"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/h97l6ifq7j4t/promo-image.1608575470.png",
      "url": "https://learn.newrelic.com/new-relic-alerts-fundamentals-1",
      "sections": [
        "In this engaging FREE 2 hour workshop is an introduction to understanding and working with Alerts in New Relic. It will enable you to set up a range of Alert policies, understand how different conditions operate, and learn how to work with incidents when issues arise.",
        "About this workshop",
        "New Relic Alerts Fundamentals"
      ],
      "published_at": "2021-04-20T01:39:15Z",
      "title": "[Webinar] New Relic Alerts Fundamentals",
      "updated_at": "2021-04-20T01:39:15Z",
      "type": "",
      "external_id": "abe6d2064ec19dc00ae4530f4b96f04b39395d96",
      "popularity": 1,
      "body": "Sign In [Webinar] New Relic Alerts Fundamentals In this engaging FREE 2 hour workshop is an introduction to understanding and working with Alerts in New Relic. It will enable you to set up a range of Alert policies, understand how different conditions operate, and learn how to work with incidents when issues arise. Register | FREE Already registered? Sign In About this workshop Alerts are an integral part of an observability platform.  New Relic Alerts lets you set up robust and customizable alert policies for anything that you can monitor. Get notifications for fluctuations in key performance metrics as data streams in from the different New Relic products, including APM, Infrastructure, Browser, and Synthetics. This hands-on workshop is a comprehensive introduction to understanding and working with Alerts in New Relic.  It will enable you to set up a range of effective Alert policies, understand how different conditions and settings operate, and learn how to work with incidents when issues arise, and conditions are violated.  Using a sandbox environment, you’ll get to create, test, and respond to a range of alert policies and conditions across the stack, and choose who gets notified and how.   Agenda and Labs Introduction to Alerts; Terminology and Workflows Creating Alert Policies  Lab: Create a Policy Entities, Conditions and Thresholds Lab: Alerting on backend conditions Lab: Alerting on front end conditions Lab: Alerting on variable performance: Dynamic Baseline Alerting Notifications: Consistent Notifications with Incident Preferences Notification Channels, Test Channels and Muting Rules Lab: Alerting on Synthetics Lab: Alerting on Infrastructure Alert Violations; Violation event attributes, closing Violations Incidents; Acknowledge Incidents and using Runbook URLs Lab: Responding to an Incident Knowledge Check and Takeaways New Relic Alerts Fundamentals Event Date Spaces left New Relic Alerts Fundamentals April 20, 2021, 10 a.m. - April 20, 2021, noon BST 107 New Relic Alerts Fundamentals May 6, 2021, 9 a.m. - May 6, 2021, 11 a.m. PDT 146 New Relic Alerts Fundamentals May 11, 2021, 10 a.m. - May 11, 2021, noon BST 149 New Relic Alerts Fundamentals June 8, 2021, 10 a.m. - June 8, 2021, noon BST 150 New Relic Alerts Fundamentals June 8, 2021, 9 a.m. - June 8, 2021, 11 a.m. PDT 149 About this workshop Alerts are an integral part of an observability platform.  New Relic Alerts lets you set up robust and customizable alert policies for anything that you can monitor. Get notifications for fluctuations in key performance metrics as data streams in from the different New Relic products, including APM, Infrastructure, Browser, and Synthetics. This hands-on workshop is a comprehensive introduction to understanding and working with Alerts in New Relic.  It will enable you to set up a range of effective Alert policies, understand how different conditions and settings operate, and learn how to work with incidents when issues arise, and conditions are violated.  Using a sandbox environment, you’ll get to create, test, and respond to a range of alert policies and conditions across the stack, and choose who gets notified and how.   Agenda and Labs Introduction to Alerts; Terminology and Workflows Creating Alert Policies  Lab: Create a Policy Entities, Conditions and Thresholds Lab: Alerting on backend conditions Lab: Alerting on front end conditions Lab: Alerting on variable performance: Dynamic Baseline Alerting Notifications: Consistent Notifications with Incident Preferences Notification Channels, Test Channels and Muting Rules Lab: Alerting on Synthetics Lab: Alerting on Infrastructure Alert Violations; Violation event attributes, closing Violations Incidents; Acknowledge Incidents and using Runbook URLs Lab: Responding to an Incident Knowledge Check and Takeaways Live events New Relic Alerts Fundamentals Event Date Spaces left New Relic Alerts Fundamentals April 20, 2021, 10 a.m. - April 20, 2021, noon BST 107 New Relic Alerts Fundamentals May 6, 2021, 9 a.m. - May 6, 2021, 11 a.m. PDT 146 New Relic Alerts Fundamentals May 11, 2021, 10 a.m. - May 11, 2021, noon BST 149 New Relic Alerts Fundamentals June 8, 2021, 10 a.m. - June 8, 2021, noon BST 150 New Relic Alerts Fundamentals June 8, 2021, 9 a.m. - June 8, 2021, 11 a.m. PDT 149 © 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.67941,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "In this engaging FREE 2 hour workshop is <em>an</em> introduction to understanding <em>and</em> working with Alerts in New Relic. It will enable you to set up a range of Alert policies, understand how different conditions operate, <em>and</em> learn how to work with incidents when issues arise.",
        "body": " Entities, Conditions and Thresholds Lab: Alerting on backend conditions Lab: Alerting on front <em>end</em> conditions Lab: Alerting on variable performance: Dynamic Baseline Alerting Notifications: Consistent Notifications with Incident Preferences Notification Channels, <em>Test</em> Channels and Muting Rules Lab"
      },
      "id": "5fe29f8664441fc05b2057a2"
    },
    {
      "sections": [
        "Add users to SAML accounts (original user model)",
        "Important",
        "Requirements",
        "Add and confirm users",
        "Caution",
        "Bypass email confirmation"
      ],
      "title": "Add users to SAML accounts (original user model)",
      "type": "docs",
      "tags": [
        "Accounts",
        "Original accounts and billing",
        "SAML SSO (original users)"
      ],
      "external_id": "1ab1cb53dc639014a77f74442c2a89c37b021cc0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts/saml-single-sign/add-users-saml-accounts/",
      "published_at": "2021-04-16T01:43:19Z",
      "updated_at": "2021-03-13T03:20:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important These docs are for setting up SSO for users on our original user model. For SSO for users on New Relic One user model, see Authentication domains. As an additional security measure for SAML single sign-on (SSO) accounts, users are not added until they complete the email confirmation that New Relic sends automatically. Users in the pending state (not yet confirmed) will not receive notifications, such as alerts. For accounts without SAML SSO integration, the account Owner and Admins can add new users without requiring confirmation. Requirements For requirements, including which New Relic users this feature applies to, see Requirements. Add and confirm users Follow this process to add and confirm users for New Relic accounts with SAML SSO: The account's Owner or an Administrator adds new users: Go to: account dropdown > Account settings > Account > Summary. On SAML-enabled accounts, New Relic flags the users as Pending and sends an email confirmation. (Pending users will not receive notifications associated with their user role, such as alert notifications.) Users select the link in the email to confirm their account, which directs them to the SAML provider's login URL. When users successfully sign into their SAML SSO end point (Auth0, Okta, OneLogin, Ping Identity, Salesforce, etc.), New Relic flags the users as Active. Caution If you disable SAML SSO, New Relic automatically flags all of your Pending users as Active. If you decide to re-enable SAML SSO later, New Relic automatically flags all users except the Owner as Pending, and they will need to confirm their account access by email. Admin user's API keys for all users that go into a pending state will be deleted. Bypass email confirmation Depending on your subscription level, you may have the option to claim the domain names that you own and bypass the SAML SSO confirmation process. When the account Owner or Administrators add new users and their email address has a domain that matches the account's domains, New Relic automatically adds them as Active users. Benefits of identifying domain ownership include: Adds a useful feature to your account. Claims domains as your own. Makes it easier for your employees to get started with New Relic, because they do not need to confirm their account access. Maintains security when adding users outside of your organization. To flag your account as owning one or more domain names, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.14518,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>and</em> <em>confirm</em> users",
        "tags": "Original accounts <em>and</em> billing",
        "body": " accounts, New Relic flags the users as Pending and sends an email <em>confirmation</em>. (Pending users will not receive notifications associated with their user role, such as alert notifications.) Users select the link in the email to <em>confirm</em> their account, which directs them to the SAML provider&#x27;s login URL"
      },
      "id": "6043f342e7b9d20ca55799fa"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/course_series/mel4oa9grtp7/promo-image.1532642657.jpg",
      "url": "https://learn.newrelic.com/series/certified-performance-pro",
      "sections": [
        "The New Relic Certified Performance Pro certification is being retired"
      ],
      "published_at": "2021-04-20T01:58:46Z",
      "title": "Certified Performance Pro",
      "updated_at": "2021-03-29T13:41:57Z",
      "type": "",
      "external_id": "74f98cf65cddc256a50869400318d579e939409c",
      "popularity": 1,
      "body": "Sign In Back to Catalog View Results Searching... Plans Courses Lessons Reset The New Relic Certified Performance Pro certification is being retired New Relic Certified Performance Pro is retired as of November 15th, 2019. You can now get certified through our new certification program New Relic Fundamentals. This new certification will help you build the foundation you need to become an expert on the New Relic Observability Platform. If you registered for the certification test between November 1st - 15th, 2019, you will have until February 15th, 2020 to complete the Certified Performance Pro Certification. Certification Test Ready to take the test? Pass the certification assessment and get an official New Relic Certified Performance Pro certification and badge to share on LinkedIn, and beyond. Not currently available Get CertifiedCertification Test [Self Paced] Data Exploration with Full-Stack Observability New Relic Explorer has been updated with new capabilities — New Relic Navigator & New Relic Lookout — to help you better visualize and analyze your entire environment in one place. FREE [Self Paced] Fundamentals This foundational course requires no pre-requisite knowledge. It walks through basic concepts of the modern web, the purpose and value of monitoring and observability, how monitoring and observability is carried out in modern applications, and how an observability platform like New Relic can drive business success. FREE New Relic FundamentalsFundamentals [Webinar] What’s New?: The Next Generation of AIOps with New Relic Applied Intelligence Detect, understand, and resolve incidents faster than ever with the easiest-to-use, most powerful AIOps capabilities that automatically detect anomalies, cut through alert noise and get you to root cause quickly. FREE New Relic APIs Learn how to use a variety of New Relic APIs, including the GraphQL API, the Insights Insert API, and the APM Agent API. FREE IntroductoryCustomize DataAdvancedTutorialGraphQL APIAPINew Relic APIs Navigating APM Learn how to navigate New Relic APM UI and interpret chart data so you can improve your application's performance and troubleshoot complex applications faster. FREE [Webinar] Go Deeper: Advanced Alerting & NRQL Alerts Delve deeper into Alerts and move beyond the basics to implement an effective alerting strategy in this FREE 2 hour workshop. With scenario based labs, you’ll create specific policies and conditions for typical use cases, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios. FREE New Relic Infrastructure Fundamentals In this course, you'll learn how New Relic Infrastructure provides deep visibility into cloud and on-premises environments. New Relic Infrastructure connects the health and performance of infrastructure to the richest metrics, events, logs, and traces to provide context for supporting our customers’ applications. FREE Performance Monitoring Fundamentals In this course, you’ll learn how you can use the New Relic Digital Intelligence Platform to get end-to-end visibility into the performance of your websites and apps, the customer experiences they deliver, and their effect on your business. FREE APMTutorialBrowserself-serveNew Relic InsightsNew Relic InfrastructureNew Relic FundamentalsPerformance Monitoring Fundamentals APM for Power Users Level up your digital intelligence and become an APM Power User. In this course, you learn to use advanced performance monitoring features. FREE Become a power userAPMPower UserAdvancedTutorialAPM for Power Users New Relic APM Fundamentals In this course, you'll learn how to use New Relic APM to see what's happening in your application, understand where the problems are, discover opportunities for optimizing your entire application ecosystem, and make sure you never miss an issue that needs attention. FREE New Relic APM Fundamentals New Relic Insights + APM Fundamentals In this course, you'll learn how to create an Insights dashboard in the UI and from a JSON template, add APM charts, and edit your Dashboard. This course culminates in a live virtual training where you'll learn how to analyze your APM data in Insights. FREE New Relic Insights + APM FundamentalsNew Relic APM Fundamentalsabracadabra New Relic Alerts Fundamentals (Legacy) Learn how to use the New Relic platform Alerts tool to monitor performance and know when leading performance indicators spike or drop so you can catch problems before they reach your end user. Enable team members to get the alerts they need faster and achieve lower response times. FREE New Relic Alerts Fundamentals [Self Paced] Get Ready for Next Gen AIOps We launched the next generation of Applied Intelligence within New Relic One which includes new innovations and features. Dive into this course to see how our new features can help you detect, understand and resolve problems faster than ever. FREE [Self Paced] New Relic One Overview New Relic One is the industry’s largest and most comprehensive cloud-based observability platform built to help customers create more perfect software. In the pursuit of our vision, we have enhanced New Relic One to provide a simplified and frictionless experience for customers. FREE Live Learncast: New Relic One Programmability Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. FREE GraphQL APIAPIUpcoming WebcastsNew Relic OneNew Relic APIs Get Started with APM Let's get started together. We're going to take you through the basics to manage your application and services. FREE Get StartedGet CertifiedIntroductoryAPMTutorialGetting-Startedself-serveGet Started with APMNew Relic APM [Webinar] Getting started with Dashboards & NRQL Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations. FREE [Webinar] New Relic Distributed Tracing: Tracking Across Your Application Stacks In this practical session you’ll find out about how New Relic Distributed Tracing can extend your transaction tracing capabilities for distributed systems, and understand how Distributed Tracing works and can be configured for different environments. FREE [Webinar] Maximizing Observability with New Relic Logs This workshop is a comprehensive introduction to understanding and working with Logs in New Relic. Get hands-on with your data. Practice importing logs and then parsing, filtering, dropping, and alerting on log data in New Relic One. FREE [Hands-on Lab] Hello, New Relic! Hello New Relic! is a series of hands-on labs, each consisting of a video walkthrough followed by written step-by-step instructions. FREE Getting Started with Synthetics Learn how to use Synthetics to test your app from different global locations, simulate user flows and interactions, check the performance of individual page components, and fix problems before they affect the end-user's experience. FREE Get StartedMonitor PerformancePower UserTutorialSyntheticsNew Relic Synthetics Getting Started with Insights Learn how to use New Relic Insights to analyze and present custom, real-time data visualizations. FREE Get StartedIntroductoryInsightsTutorialNew Relic Insights Getting Started with Infrastructure Learn New Relic Infrastructure fundamentals to get a precise picture of your dynamically changing systems. New Relic Infrastructure delivers real-time health metrics correlated with recent configuration changes, so you can quickly resolve issues, scale rapidly, and deploy intelligently. FREE Get StartedInfrastructureMonitor PerformancePower UserTutorialNew Relic Infrastructure [Webinar] New Relic Alerts Fundamentals In this engaging FREE 2 hour workshop is an introduction to understanding and working with Alerts in New Relic. It will enable you to set up a range of Alert policies, understand how different conditions operate, and learn how to work with incidents when issues arise. FREE Custom Data with Insights Learn how to take your application performance analysis to the next level. Add context and get more detailed results with custom attributes, or by importing additional datasets. This course will show you how to import JSON data to the Insights API endpoint, alongside default data captured natively. FREE Power UserInsightsCustomize DataAdvancedTutorialCustom Data with Insights Insights Dashboards and Data Apps Learn how to use Insights Dashboards and Data Apps to analyze any data type from across all New Relic products in real-time and present a variety of metrics and visualizations in a meeting or on the go, embed charts into your own application, or create self-service dashboards for other teams. FREE Get StartedMonitor PerformanceGet CertifiedPower UserInsightsTutorialInsights DashboardsDashboards and Data Apps Writing NRQL Queries Learn how to ask questions about your data using NRQL, New Relic's SQL-flavored query language, and create beautiful visualizations for analyzing your data in real-time. FREE Get StartedBecome a power userGet CertifiedIntroductoryInsightsTutorialCloud AdoptionApplication Baselineself-serveWriting NRQL Queries New Relic Alerts Learn how to use the New Relic platform Alerts tool to monitor performance and know when leading performance indicators spike or drop so you can catch problems before they reach your end user. Enable team members to get the alerts they need faster and achieve lower response times. FREE AlertsGet StartedIntroductoryAPMPower UserTutorialNew Relic Alerts Performance Monitoring with New Relic In this course, you’ll learn how you can use the New Relic Digital Intelligence Platform to get end-to-end visibility into the performance of your websites and apps, the customer experiences they deliver, and their effect on your business. FREE AlertsGet StartedInfrastructureIntroductoryAPMInsightsTutorialSyntheticsBrowserMobile monitoringself-servePerformance Monitoring with New Relic Part of: © 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.02202,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " how to use Synthetics to <em>test</em> your app from different global locations, simulate user flows and interactions, check the performance of individual page components, and fix problems before they affect the <em>end</em>-user&#x27;s experience. FREE Get StartedMonitor PerformancePower UserTutorialSyntheticsNew Relic"
      },
      "id": "5c2eb989c75d07657a11b4a6"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/sdet_1.png",
      "url": "https://newrelic.com/blog/best-practices/sdet-engineer-functional-testing",
      "sections": [
        "Finding room for improvement in testing",
        "A mission for our embedded SDET",
        "Seeing the benefits of the SDET"
      ],
      "published_at": "2021-04-16T02:11:33Z",
      "title": "Improve Your Team’s Testing Processes With an SDET Engineer",
      "updated_at": "2021-04-14T02:14:21Z",
      "type": "",
      "external_id": "329165b6a8a68e4e6d63e25596f48101ba9c9c40",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Best Practices Improve Your Team’s Testing Processes With an SDET Engineer Oct 7, 2019 • 8 min read By Judith Simpson As you’d expect, at New Relic, we’re experts at applying observability to the operational aspects of our systems. The Unified Data Streams (UDS) team takes great pride in our instrumentation and alerting practices. We have a keen focus on maintaining a reliable, highly available data platform. But beyond being highly available, our reliability practices must also ensure our platform provides accurate results at all times. Incorrect results, obviously, will only erode trust in the services we provide. If it’s incorrect, we might as well not produce any data at all. Building reliability into our data platform is a big topic, especially when we’re talking about data streams. In this post, though, I’ll explain a critical step we took toward improving the reliability of our testing practices. Finding room for improvement in testing In a nutshell, the UDS team is responsible for filtering and aggregating all incoming New Relic customer data so it can be sent to the teams that manage the various products in our platform at a volume they can handle.  When it comes to testing, our strategy for white box testing (in which the tester is fully aware of the design and implementation of the code) requires a high percentage of unit test coverage for all code written by the team. We use JaCoCo and JUnit to write tests for all our code, which we run on every build. For builds to pass, test coverage is typically set at 99%. Our black box test strategy (in which the tester has no knowledge of the design and implementation of the code) hasn’t been as strong as our white box testing. As we began to grow more rapidly and scale our services, it became clear that we needed to increase confidence in our reliability practices by catching problems in our platform before our customers could. To address this lack, we hired a software development engineer in test (SDET) to join the UDS team. SDETs have a rare blend of strong engineering skills and a passion for finding bugs in software. They play a critical role not only in writing, developing, and executing tests, but they’re also able to participate in the design and creation of the software they’ll ultimately test. The UDS SDET, however, would be responsible for building a functional test suite that would test the correctness of our systems from end to end. A mission for our embedded SDET In embedding on SDET on the team, my goal was simple: A dedicated test engineer who is less familiar with the internal workings of our service would bring a new perspective to testing on the UDS team— a perspective closer to how our customers think things work. For example, a customer looks at an API definition and makes certain assumptions about what it does based on its name, its parameters, and their personal experience with other APIs. Our developers, on the other hand, make assumptions about how well our customers will understand that API. An SDET’s job is to identify and eliminate the developer’s assumptions through testing. So, the UDS SDET’s mission would be two-fold: Set up an integration test environment in the public cloud to run tests on our streaming services platform. By using the public cloud, we wouldn’t be constrained by capacity in our data centers or by needing support from other New Relic teams. Build a functional test framework that includes an extensive suite of tests to validate the integrity of our customers' data. The SDET would create test data to replicate different accounts, so tests can catch and notify us when unexpected results are discovered. Functional tests are designed to test specific parts of service to ensure they’re functioning as intended. For the UDS team, our functional tests would need to cover parts of our code that: Create, read, update, and delete (CRUD) operations on internal APIs Appropriately throttle accounts that hit data limits Handle late and early arriving event data per agreed upon business rules Ensure API endpoints that integrate with GraphQL are functional Seeing the benefits of the SDET Having worked with the SDET and the functional test framework for some time now, the UDS team has enjoyed a number of benefits.  Specifically, we’ve: Reduced the scope and time it takes to run game days at the end of our feature development sprints, resulting in faster delivery of features to customers without compromising quality Improved our confidence in the software we ship thanks to increased coverage where it was formerly incomplete or missing Reduced the time to troubleshoot issues raised by customer support by using quick functional tests to reproduce the issue Resolved previously undetected problems, such as identifying and updating out-of-date software in our service that could have impacted customers Improved our deployment process, bringing it much closer to true CI/CD Isolated complexity by allowing the team to get the right data in the right place for feature testing when time was of the essence. And in the spirit of drinking our champagne, our SDET built a New Relic One dashboard, so the team can track the full set of functional tests and their most current results: New Relic One dashboard showing functional test results The end result of the SDET’s work is a sophisticated functional test framework, called “Sea Dragon,” that now plays a pivotal role in the team's build and deploy process. When a UDS team members starts a deployment in our deploy pipeline (called Grand Central), a test bot automatically kicks off the appropriate unit tests. If the deployment is successful, the bot then kicks off a series of smoke tests: Test bot kicks off smoke tests for successful deployments. Finally, an accompanying bot provides a handy Slack integration to keep the team up to date on deployments: A Slack integration sends notifications with test results. As a manager at New Relic, I’m responsible for making sure my team delivers new features for our platform while at the same maintaining operational excellence, even as the platform—and the company—continues to grow at a rapid pace. Hiring an SDET and building a functional test suite has greatly improved our team’s velocity and build process, reduced our bug count, and increased our confidence that our software is reliable and delivering the value we promise our users. Running a functional test framework will remain a central part of our reliability work going forward.     By Judith Simpson Originally from England, Judith has had a long, varied career as a software engineer and manager. Currently, she’s an Engineering Manager at New Relic. When she’s not working on New Relic's data platform, she enjoys CrossFit, hiking, paddle boarding, gardening, puzzling, and travel. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 71.80045,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Improve Your Team’s <em>Testing</em> Processes With <em>an</em> SDET Engineer",
        "sections": "Finding room for improvement in <em>testing</em>",
        "body": ", however, would be responsible for building a functional <em>test</em> suite that would <em>test</em> the correctness of our systems from <em>end</em> to <em>end</em>. A mission for our embedded SDET In embedding on SDET on the team, my goal was simple: A dedicated <em>test</em> engineer who is less familiar with the internal workings of our"
      },
      "id": "60764ffde7b9d2341da5c682"
    }
  ],
  "/build-apps/ab-test/install-nr1": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 294.37476,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> application",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> gives you a framework to build your own React JavaScript applications that: Reside on the <em>New</em> <em>Relic</em> <em>One</em> platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-16T22:12:16Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.07355,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use tags to define <em>the</em> workload content",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.06232,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.05768,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.05768,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/build-apps/ab-test/end-test": [
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-04-16T14:02:55Z",
      "updated_at": "2021-04-16T14:02:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The configuration options explained below refer only to the browser agent, and should not to be confused with the New Relic user roles and pricing tiers. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your agent: Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.2223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the browser monitoring <em>agent</em>",
        "sections": "Install the browser monitoring <em>agent</em>",
        "body": ", and then select <em>Add</em> more data. In the Back-<em>end</em>, front-<em>end</em>, and mobile applications <em>section</em>, select the New Relic Browser tile. When prompted to select the account you want to <em>add</em> this instrumentation to, choose <em>your</em> account, and click Continue. From the Get started with New Relic Browser page"
      },
      "id": "604429e628ccbcb80b2c60d0"
    },
    {
      "sections": [
        "Forward your logs using the infrastructure agent",
        "Tip",
        "Enable log forwarding using the infrastructure agent",
        "What you need",
        "Install the infrastructure agent",
        "Test log forwarding",
        "Configure the infrastructure agent",
        "Log forwarding parameters",
        "name",
        "attributes",
        "file",
        "Important",
        "systemd (Linux only)",
        "syslog (Linux only)",
        "tcp",
        "max_line_kb",
        "winlog",
        "pattern",
        "fluentbit",
        "Sample configuration file",
        "logging.d/sample.yaml",
        "View your log data",
        "Log attributes automatically inserted by the infrastructure agent",
        "Troubleshoot log forwarding",
        "No data appears when tailing a file",
        "Example: checking file access under Linux",
        "No data appears when capturing via a Syslog socket",
        "No data appears using infrastructure agent proxy",
        "Send the agent's logs to New Relic",
        "Caution",
        "Runtime error on Windows",
        "What's next?"
      ],
      "title": "Forward your logs using the infrastructure agent",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "dddab40697224ea7f816e70b05d18f8d75fb5084",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/enable-log-management-new-relic/enable-log-monitoring-new-relic/forward-your-logs-using-infrastructure-agent/",
      "published_at": "2021-04-16T21:14:05Z",
      "updated_at": "2021-04-16T21:14:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can forward your logs to New Relic using our infrastructure monitoring agent. This makes all of your logging data available in one location and provides deeper visibility into both your application and your platform performance data. Tip To use log management and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Enable log forwarding using the infrastructure agent To enable log forwarding through the infrastructure agent: Start by checking what you need. Install the infrastructure agent, version 1.11.4 or higher. Configure your log sources and other parameters in the logging.d directory. Generate some traffic and wait a few minutes, then check your account for data. Explore your log data in the Logs UI and benefit from the log attributes automatically inserted by the infrastructure agent. What you need The log forwarding feature is compatible with the following operating systems: Operating system Supported version Amazon Linux Amazon Linux 2 CentOS Version 7 or higher Debian Version 9 (\"Stretch\") or higher Red Hat Enterprise Linux (RHEL) Version 7 or higher SUSE Linux Enterprise Server (SLES) Version 12 Ubuntu Versions 16.04.x and 18.04.x (LTS versions) Windows Windows Server 2012, 2016, and 2019, and their service packs. Windows 10 To use the log forwarder of the infrastructure agent, make sure you meet the following requirements: Infrastructure agent version 1.11.4 or higher Windows: Install the Microsoft Visual C++ Redistributable: x64 or x86. The log forwarding feature is not supported on containerized agents. Install the infrastructure agent Starting with version 1.11.4, the infrastructure agent can forward logs to New Relic. To install and run the agent, use a package manager (Linux) or the MSI installer (Windows). To use the following links, make sure you are logged to your New Relic account. Amazon Linux CentOS Debian RHEL SLES Ubuntu Windows If you don't have a New Relic account yet, or prefer to follow the procedure manually, see our tutorial to install the package manager. Test log forwarding To quickly check that the log forwarding feature works, follow these steps. If you're running the infrastructure monitoring agent in privileged or non-privileged modes, make sure that the user executing nri-agent has read permissions for the data sources. Navigate to the logging forwarder configuration folder: Linux: /etc/newrelic-infra/logging.d/ Windows: C:\\Program Files\\New Relic\\newrelic-infra\\logging.d\\ Create a configuration file (for example, logs.yml) with this content: Linux example: # Remember to only use spaces for indentation logs: - name: \"test_log\" file: /var/log/test.log Copy Windows example: # Remember to only use spaces for indentation logs: - name: \"test_log\" file: 'C:\\ProgramData\\New Relic\\newrelic-infra\\newrelic-infra.log' Copy Run the following command to append a test log message to your log file: echo \"This is a test message.\" >> /PATH/TO/YOUR/LOG/FILE Copy For example: echo \"This is a test message.\" >> /var/log/test.log Copy Search New Relic Logs for test message. Configure the infrastructure agent Configuration files describe which log sources are forwarded. You can add as many config files as you want, and set as many sources as you need per config file. To add a new configuration file for the log forwarding feature: Navigate to the logging forwarder configuration folder: Linux: /etc/newrelic-infra/logging.d/ Windows: C:\\Program Files\\New Relic\\newrelic-infra\\logging.d\\ Create a configuration file with the parameters you need. Use our sample config file as reference. The agent automatically processes new configuration files without having to restart it. Log forwarding parameters The log forwarder config supports the following parameters (for examples, see the sample configuration). name Name of the log or logs. attributes List of custom attributes, as key-value pairs, that can be used to send additional data with the logs which you can then query. For example, you can enable built-in parsing rules by setting the logtype attribute. Example: ... - name: tcp-simple-test tcp: uri: tcp://0.0.0.0:1234 format: none separator: \\t attributes: # You can add custom attributes to any source of logs tcpFormat: none logtype: nginx # See https://docs.newrelic.com/docs/logs/log-management/ui-data/new-relic-logs-parsing-built-rules-custom-parsing someOtherAttribute: associatedValue Copy file Path to the log file or files. The agent tracks changes on the log files in a way similar to tail -f shell. Your file can point to a specific log file or multiple ones by using wildcards applied to names and extensions; for example, /logs/*.log Example: logs: - name: file-with-attributes file: /var/log/test.log # Path to a single file or pattern pattern: Error # Regular expression to filter log entries Copy Wildcards can also be used in place of directories in a file path, which can be used to tail files located in different directories. Example: logs: - name: docker-logs file: /var/lib/docker/containers/*/*.log # Path to multiple folders and files pattern: redis # Regular expression to filter log entries Copy Important Use of wildcards may significantly increase the number of file descriptors the Fluent Bit process keeps open, which can interfere with log collection if the host's file descriptor limit is reached. We recommend increasing the file descriptor limit on Linux hosts running Fluent Bit by adding the following to the host's /etc/security/limits.conf file: root soft nofile 65536 root hard nofile 65536 *soft nofile 65536 *hard nofile 65536 Copy Once you add these changes, reboot the host to ensure your changes are applied. systemd (Linux only) Service name. Once the systemd input is activated, log messages are collected from the journald daemon in Linux environments. This input type requires the agent to run in root mode. Example: logs: - name: systemd-example systemd: cupsd Copy syslog (Linux only) Syslog data source. Parameters: uri: Syslog socket. Format varies depending on the protocol: TCP/UDP network sockets: [tcp/udp]://LISTEN_ADDRESS:PORT Unix domain sockets: unix_[tcp/udp]:// + /socket/path parser: Syslog parser. Default is rfc3164. Use rfc5424 if your messages include fractional seconds. Note: rfc3164 currently does not work on SuSE. unix_permissions: default is 0644 for domain sockets; this limits entries to processes running as root. You can use 0666 to listen for non-root processes, at your own risk. When running the agent in privileged mode, ports and sockets must be available or owned by nri-agent, with 0666 file permissions, so that other processes can write logs to the sockets. logs: # TCP network socket - name: syslog-tcp-test syslog: uri: tcp://0.0.0.0:5140 # Use the tcp://LISTEN_ADDRESS:PORT format parser: rfc5424 # Default syslog parser is rfc3164 # UDP network socket - name: syslog-udp-test syslog: uri: udp://0.0.0.0:6140 # Use the udp://LISTEN_ADDRESS:PORT format max_line_kb: 35 # Unix TCP domain socket - name: syslog-unix-tcp-test syslog: uri: unix_tcp:///var/unix-tcp-socket-test unix_permissions: 0666 # Default is 0644. Change at your own risk # Unix UDP domain socket - name: syslog-unix-udp-test syslog: uri: unix_udp:///var/unix-udp-socket-test parser: rfc5424 Copy tcp Logs retrieved over TCP connections. Parameters: uri: TCP/IP socket to listen for incoming data. The URI format is tcp://LISTEN_ADDRESS:PORT format: format of the data. It can be json or none. separator: If format: none is used, you can define a separator string for splitting records (default: \\n). logs: - name: tcp-simple-test tcp: uri: tcp://0.0.0.0:1234 # Use the tcp://LISTEN_ADDRESS:PORT format format: none # Raw text - this is default for 'tcp' separator: \\t # String for separating raw text entries max_line_kb: 32 - name: tcp-json-test tcp: uri: tcp://0.0.0.0:2345 # Use the tcp://LISTEN_ADDRESS:PORT format format: json Copy max_line_kb Maximum size of log entries/lines in KB. If log entries exceed the limit, they are skipped. Default is 128. winlog Collect events from Windows log channels. Parameters: channel: name of the channel logs will be collected from. collect-eventids: a list of Windows Event IDs to be collected and forwarded to New Relic. Event ID ranges are supported. exclude-eventids: a list of Windows Event IDs to be excluded from collection. Event ID ranges are supported. All events are collected from the specified channel by default. Configure the collect-eventids and exclude-eventids sections to avoid sending unwanted logs to your New Relic account. Add event IDs or ranges to collect-eventids or exclude-eventids to forward or drop specific events. exclude-eventids takes precedence over collect-eventids if the same event ID is present in both sections. Example: logs: - name: windows-security winlog: channel: Security collect-eventids: - 4624 - 4265 - 4700-4800 exclude-eventids: - 4735 Copy pattern Regular expression for filtering records. Only supported for the tail, systemd, syslog, and tcp (only with format none) sources. This field works in a way similar to grep -E in Unix systems. For example, for a given file being captured, you can filter for records containing either WARN or ERROR using: - name: only-records-with-warn-and-error file: /var/log/logFile.log pattern: WARN|ERROR Copy No filtering is applied by default. fluentbit External Fluent Bit configuration and parser files. If defined, they are merged with the existing configuration and parser files generated by the Infrastructure agent. The infrastructure agent processes the configuration files located in the logging.d directory and will generate a run-time Fluent Bit configuration file that contains the appropriate [INPUT], [FILTER] and [OUTPUT] sections. Optionally, it will also declare an @INCLUDE in case you provided an external Fluent Bit configuration file via the fluentbit option. The runtime file does not define a [SERVICE] section, leaving all default Fluent Bit configuration values. You can still override Fluent Bit's default settings by defining your own [SERVICE] section in your external Fluent Bit configuration file and include it via the fluentbit option. Parameters: config_file: path to an existing Fluent Bit configuration file. Note that any overlapping source results in duplicate messages in New Relic Logs. parsers_file: path to an existing Fluent Bit parsers file. The following parser names are reserved: rfc3164, rfc3164-local and rfc5424. Sample configuration file Here is an example of a logging.d/ configuration file in YAML format. For more configuration examples, see the infrastructure agent repository. logging.d/sample.yaml # Remember to only use spaces for indentation logs: # Example of 'file' source - name: file-with-attributes file: /var/log/test.log # Path to a single file or pattern attributes: # You can use custom attributes to enrich your data logtype: nginx team: The A Team pattern: Error # Regular expression to filter log entries # Example of 'systemd' source (Linux only) - name: systemd-example systemd: cupsd # Examples of 'syslog' source, one per protocol # TCP network socket - name: syslog-tcp-test syslog: uri: tcp://0.0.0.0:5140 # Use the tcp://LISTEN_ADDRESS:PORT format parser: rfc5424 # Default syslog parser is rfc3164 # UDP network socket - name: syslog-udp-test syslog: uri: udp://0.0.0.0:6140 # Use the udp://LISTEN_ADDRESS:PORT format max_line_kb: 35 # Paths for Unix sockets are defined by combining protocol and path: # unix_udp:// + /path/socket - for example, unix_udp:///tmp/socket # Unix TCP domain socket - name: syslog-unix-tcp-test syslog: uri: unix_tcp:///var/unix-tcp-socket-test unix_permissions: 0666 # Default is 0644. Change at your own risk # Unix UDP domain socket - name: syslog-unix-udp-test syslog: uri: unix_udp:///var/unix-udp-socket-test parser: rfc5424 # Examples of 'tcp' source for formats 'none' and 'json' - name: tcp-simple-test tcp: uri: tcp://0.0.0.0:1234 # Use the tcp://LISTEN_ADDRESS:PORT format format: none # Raw text - this is default for 'tcp' separator: \\t # String for separating raw text entries attributes: # You can add custom attributes to any source of logs tcpFormat: none someOtherAttribute: associatedValue max_line_kb: 32 - name: tcp-json-test tcp: uri: tcp://0.0.0.0:2345 # Use the tcp://LISTEN_ADDRESS:PORT format format: json attributes: tcpFormat: json yetAnotherAttribute: 12345 # Example of Fluent Bit configuration import - name: fluentbit-import fluentbit: config_file: /path/to/fluentbit.config parsers_file: /path/to/fluentbit/parsers.conf Copy View your log data If everything is configured correctly and data is being collected, you should see data in both of these places: New Relic Logs UI New Relic tools for running NRQL queries; for example, you can execute a query like this: SELECT * FROM Log Copy Log attributes automatically inserted by the infrastructure agent The infrastructure agent automatically inserts log attributes for your convenience. Some of them are inserted for any log record, while other depend on the configuration parameters you used while setting up the Log Forwarder. Find a summary of these attributes in the following table: Attribute name Inserting conditions Description entity.guids Always inserted The infrastructure agent inserts the Entity GUID assigned by New Relic to identify the host where it's running. It is available in the entity.guids field. Note: If the captured logs belong to an application instrumented using APM, the entity.guids field contains both the Entity GUID of infrastructure as well as the GUID of APM, separated by a pipe ( | ) delimiter. fb.input Always inserted The underlying Fluent Bit input plugin type used to capture the logs. Currently, its values are tail, systemd, winlog, syslog, and tcp. filePath When using the file input type Absolute file path of the file being monitored. hostname Always inserted The hostname of the machine/VM/container executing the infrastructure agent. plugin.type Always inserted Indicates the utility used to capture the logs. In this case, it is the infrastructure agent itself, so this attribute always has the value nri-agent. Troubleshoot log forwarding If no data appears after you enable log management, follow standard troubleshooting procedures. No data appears when tailing a file The log forwarding feature requires the agent to have permission to read the data sources. When running the infrastructure agent in privileged or non-privileged modes, make sure that the log files you want to forward (and any intermediary directory in its path) are readable by the user running nri-agent. Example: checking file access under Linux Let's check whether the file /var/log/restrictedLogs/logFile.log can be monitored by the nri-agent user. In Linux, you can do a quick check with the namei command: sudo -u nri-agent namei -ml /var/log/restrictedLogs/logFile.log f: /var/log/restrictedLogs/logFile.log drwxr-xr-x root root / drwxr-xr-x root root var drwxrwxr-x root syslog log drwxr--r-- root root restrictedLogs logFile.log - No such file or directory Copy This command failed because the file is not visible to the nri-agent user. By inspecting the previous output, we can detect that the restrictedLogs directory is missing the execution flag for others\". We can fix this by executing: sudo chmod 755 /var/log/restrictedLogs Copy And then check for file access again: # sudo -u nri-agent namei -ml /var/log/restrictedLogs/logFile.log f: /var/log/restrictedLogs/logFile.log drwxr-xr-x root root / drwxr-xr-x root root var drwxrwxr-x root syslog log drwxr-xr-x root root restrictedLogs -rw-r----- vagrant vagrant logFile.log Copy The file is now visible to the nri-agent user. You must ensure that the file is also readable by the nri-agent user. To check this, use: # sudo -u nri-agent head /var/log/restrictedLogs/logFile.log head: cannot open '/var/log/restrictedLogs/logFile.log' for reading: Permission denied Copy In this example, the file is missing the read rights for the others group (users other than vagrant and the vagrant user group). You could fix this by granting read permissions to others, but the application could change these permissions upon restart. To avoid this, a better approach is to add the nri-agent user to the vagrant user group. No data appears when capturing via a Syslog socket The log forwarding feature requires that the agent has permission to read the data sources. When running the Infrastructure agent in privileged or non-privileged modes: If you're using Unix domain socket files, make sure that the nri-agent user can access these files (please refer to the previous section) and that they have read and write permissions (666) so that other users than nri-agent can write to them. If you're using IP sockets, ensure that the port that you are using is not a system reserved one (like port 80, for example). If no data appears after you enable log management, follow standard log management troubleshooting procedures. No data appears using infrastructure agent proxy As explained in the infrastructure agent configuration guidelines, the proxy parameter must use either HTTP or HTTPS and be in the form https://user:password@hostname:port. The agent can parse the parameter without the HTTP or HTTPS, but the log-forwarder cannot. You will see an error like the following in the agent verbose logs: [ERROR] building HTTP transport: parse \\\"hostname:port\\\":  first path segment in URL cannot contain colon Copy To solve this problem, check your newrelic-infra.yml file, and ensure the proxy parameter adheres to this form. Send the agent's logs to New Relic The infrastructure agent can be configured to send its own logs to New Relic. This can be useful for troubleshooting issues with log forwarding, the agent, or when contacting support. To forward the infrastructure agent logs to New Relic: Edit your newrelic-infra.yml file. Enable agent logging in troubleshooting mode by adding verbose: 3 Important On Windows and systems that don't use systemd or where journald is inaccessible, verbose:3 causes the agent to write the logs on the disk. Revert to verbose:0 to prevent this. (Recommended): Enable agent logging in JSON format to log_format: json. Restart the agent so that the new settings can be loaded. This configuration sets up the agent in troubleshooting mode, but the log forwarder (based on Fluent Bit) will continue in a non-verbose mode. Sometimes you can have issues with the log forwarder itself. For example, there may be problems accessing a specific channel when shipping Windows log events or when accessing a particular log file. In these situations, you can also enable the verbose mode for the log forwarder: Set verbose to a value other than 0. Add the following configuration option: trace: [\"log.fw\"]. Caution Check whether you are using the fluentbit option. When setting verbose: 3 and trace: [\"log.fw\"], ensure that you don't define any [OUTPUT] section pointing to stdout in an external Fluent Bit configuration file, Runtime error on Windows One of the following error messages may appear when enabling log forwarding on Windows: The code execution cannot proceed because VCRUNTIME140.dll was not found. Copy OR error=\"exit status 3221225781\" process=log-forwarder Copy This is caused by a missing DLL. To solve the issue, install the Microsoft Visual C++ Redistributable: x64 or x86. What's next? Now that you've enabled Logs, here are some potential next steps: Explore your data using the Logs UI. Configure your agent to see contextual log data, such as distributed tracing, stack traces, application logs, and more. Query your data and create custom dashboards or alerts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.19958,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Forward <em>your</em> logs using the infrastructure <em>agent</em>",
        "sections": "Forward <em>your</em> logs using the infrastructure <em>agent</em>",
        "body": " to <em>your</em> log file: echo &quot;This is a <em>test</em> message.&quot; &gt;&gt; &#x2F;PATH&#x2F;TO&#x2F;<em>YOUR</em>&#x2F;LOG&#x2F;FILE Copy For example: echo &quot;This is a <em>test</em> message.&quot; &gt;&gt; &#x2F;var&#x2F;log&#x2F;<em>test</em>.log Copy Search New Relic Logs for <em>test</em> message. Configure the infrastructure agent Configuration files describe which log sources are forwarded. You can <em>add</em>"
      },
      "id": "603e9df164441f6b6f4e8843"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/800w/public/2021-04/select%20locations-sythetic%20monitoring.png?itok=rBpAR1AB",
      "url": "https://newrelic.com/blog/how-to-relic/better-synthetic-monitoring",
      "sections": [
        "Better Synthetic Monitoring: No Code Required",
        "What’s new with synthetic monitoring?",
        "Create monitors easily with the step monitor",
        "Don’t start from scratch—use a template",
        "Spot performance changes across monitors in Lookout",
        "An improved way to create synthetic monitors",
        "How to set up your first step monitor",
        "Next Steps",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:12:02Z",
      "title": "Better Synthetic Monitoring: No Code Required | New Relic",
      "updated_at": "2021-04-15T23:12:02Z",
      "type": "",
      "external_id": "0ac34f051d273eea55cc032fd532ddfed749af52",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Digital Experience Monitoring Better Synthetic Monitoring: No Code Required Apr 15, 2021 • 8 min read By Scott Sugimoto Imagine it’s late Sunday evening and you’re sitting at your Red Bull-strewn desk. After days of troubleshooting your deployment, you’re elated because your team has just pushed a major update to your e-commerce website a day before the company’s big sale. But soon worry starts to creep in. What if your update broke a critical workflow and customers can’t make purchases? How can you know for sure every use case was covered by testing? Not every broken process registers as an error, so you might not learn about an issue until a customer complains. Here’s where synthetic monitoring comes in. Synthetic monitors are vital to ensuring your website is working properly with minimal impact on customers. These monitors continually test business-critical processes and proactively alert you when they’re broken. If IT downtime costs a company thousands of dollars per minute, imagine the cost of having an e-commerce site that’s running, but on which no one can make a purchase because the checkout button is missing.  However, as useful as synthetic monitors are, they can be tedious to set up. That’s why the New Relic team invested a lot of effort to make the synthetic experience as easy to set up and deploy as possible. What’s new with synthetic monitoring? These updates to synthetic monitoring help you set up and deploy monitors quickly: New monitor type: step monitor. This monitor type allows you to set up a monitor without code, broadening the number of business users who can set up monitors.  Quickstarts Synthetic Monitoring library. This page includes pre-built scripts for synthetics so you don’t have to start from scratch.  Visualize monitors in Lookout. This enhancement to New Relic Lookout make it easy to visualize the state of your website in one place. The next sections go into detail about these updates. If you are eager to set up your first step monitor, jump right to the \"How to set up your first step monitor\" section. Create monitors easily with the step monitor The step monitor provides a no-code way to set up synthetic monitors. You simply add “steps” and enter the actions you want the monitor to perform. You can verify that specific text or elements (like buttons and images) are on the page, verify functionality by clicking on elements, and even log in to a site by entering text. Don’t start from scratch—use a template Not sure where to start? Check out our Quickstarts Synthetic Monitoring library for commonly used monitors to get you started faster. This constantly expanding list is community-driven and includes scripts that help you authenticate against Azure, get a Google Lighthouse Audit report, and more. Spot performance changes across monitors in Lookout Synthetics are now integrated with Lookout to provide a quick view into how your websites are performing and whether there are any critical errors. See all of your synthetic monitors in a single view with highlights indicating which monitors are finding abnormal performance changes and where to focus your attention. An improved way to create synthetic monitors In addition to launching the new step monitor, we also updated the experience. If you’re still seeing the previous experience, you might need to select Show new view. The following example shows the previous experience for creating monitors, but you can select Show new view to see the new, streamlined view: Note that you can only create step monitors in the new view, so make sure you have Show new view selected. The new view separates the different monitor types into cards and guides you through the setup process, depending on the monitor you select: How to set up your first step monitor Follow this step-by-step guide to set up a step monitor for your website. 1. Select the Synthetics tab and click Create monitor in the top right corner: 2. Make sure Show new view is selected. Then select the User step execution option (also called a step monitor): 3. Configure the monitor. Enter a descriptive name for your monitor, how often you want the monitor to check your site, and whether you want it to take a screenshot when an error is detected (under Advanced options): 4. Select locations for the monitor. Set up your monitor to test from one of New Relic’s worldwide locations. It monitors how your users from all over the world are able to access your page with high performance: 5. Enter the steps for your monitor. Now the fun begins. Start by entering the URL for the site you want to monitor: For each subsequent step, click one of the Add Step buttons at the bottom of the screen: Assert Text: Test that specific text appears or doesn’t appear on the screen. Assert Element: Test that a specific element (e.g., buttons, divs, images, etc.) are on the page or are visible. Click Element: Interact with elements on the page, like buttons. Type Text: Enter text on the page. Secure Credential: Use a password in a monitor without exposing it to everyone in New Relic. To locate elements in the monitor, you have several options. You can locate by: CSS Class Example: #stylized-button The locator is “#stylized-button” HTML ID Example: <div id = “button”></div> The locator is “button” Link Text Example: <a href=\"http://example.com>Link text</a> The locator is is “Link text” and the text is also “Link text” XPath Example: <input placeholder=“search-query-field”> The locator is “//input[@placeholder = 'search-query-field']” 6. Test your monitor. You always want to test your monitor before deploying, so we’ve made it easy. Under Build steps, select Test and click Run Test. If there’s an error or an element isn’t found, the monitor automatically highlights the broken step and details about the error, so you can troubleshoot. 7. Sit back and watch. After the monitor is saved, the New Relic One UI generates a Selenium IDE script so you can do direct script editing for more advanced tests. For example, you could edit the script directly to use a regex instead of simple matching for string tests. To view a summary of the performance of your user flow, simply select the monitor name. Then you can see request/response times, error response codes, duration, metadata, and tags: To learn more and see a detailed walkthrough, watch the Nerdlog episode “Test Complex User Flows With No Code”: Next Steps There’s a lot more to learn about step monitors and New Relic Synthetic Monitoring. Read our documentation, request a demo or free trial today. Related Topics Digital Experience Monitoring By Scott Sugimoto Scott Sugimoto is a Senior Product Marketing Manager at New Relic focused on front-end application monitoring. He is passionate about helping companies provide great customer experiences. Previously, Scott worked as a product marketer at Salesforce and as a technology consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn In this article Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.30156,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>An</em> improved way <em>to</em> create synthetic monitors",
        "body": " right to the &quot;How to set up <em>your</em> first step monitor&quot; <em>section</em>. Create monitors easily with the step monitor The step monitor provides a no-code way to set up synthetic monitors. You simply <em>add</em> “steps” and enter the actions you want the monitor to perform. You can verify that specific text"
      },
      "id": "6078c842196a674a5e64a78b"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/sean.jpg?h=6e93dd64&itok=t5YBHvDp",
      "url": "https://newrelic.com/blog/best-practices/ansible-auditing-tool",
      "sections": [
        "First, defining our requirements for Ansible as a hardware auditing tool",
        "Creating an Ansible playbook role to run our audits",
        "Example individual audit task",
        "Example multi-step audit tasks",
        "How the multi-step task works",
        "Generating the audit report",
        "Proactive > Reactive"
      ],
      "published_at": "2021-04-16T01:44:43Z",
      "title": "Using Ansible as a Hardware Auditing Tool",
      "updated_at": "2021-04-14T01:16:22Z",
      "type": "",
      "external_id": "894ef4c4c53000961b7d668aca8f55a6f594c791",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Best Practices Using Ansible as a Hardware Auditing Tool Jan 31, 2018 • 9 min read By Sean P. Kane The Container Fabric team runs New Relic’s in-house container orchestration and runtime platform. One of the team’s critical functions is to confirm that we have healthy hardware with consistent settings and versions deployed across our container clusters. Simple mismatches in settings among hosts inside Container Fabric can lead to inconsistent performance and behavior that then impacts higher-level services and complicates troubleshooting. When we started building the platform, we were using Ansible for basic configuration management on our CoreOS Container Linux hosts, and we made the early decision to extend that functionality so that we could also use Ansible to perform some non-intrusive auditing of our systems. This post will cover how we utilized Ansible as a basic auditing tool to ensure that hosts met expected requirements regarding configuration, health, and security. In the early phases of the Container Fabric project, Ansible helped us keep the number of tools we needed down to a minimum, while helping us ensure that all the important aspects of our hardware were configured as expected. Our hardware configuration tests checked a broad range of things, including BIOS settings and RAID configuration. Hopefully, this post will give you some ideas for using Ansible to run audit checks in your infrastructure. (Note: This post assumes a working knowledge of Ansible and task execution.) First, defining our requirements for Ansible as a hardware auditing tool Before we started building our auditing solution, we defined our requirements. The solution had to be able to detect and report any non-conformant configuration that we identified as important. These checks should be for things we didn’t already permanently enforce with Terraform or Ansible configuration management runs. Container Fabric is built on a diverse set of hosts in diverse data centers, so our solution had to be able to detect the underlying platform and apply the correct checks. Every run had to complete without hard errors and produce a report of the results. The solution had to be completely non-invasive and could be allowed to pull and launch a support container only when absolutely required to properly query the host. The solution had to be useful to both humans and automated provisioning processes. Creating an Ansible playbook role to run our audits Since the Container Fabric team already heavily leveraged Ansible playbook roles, we added two new roles to our codebase: validate_barebones, which we designed to run on newly provisioned hosts as soon as we received them (although it could safely run at any time) and validate_postansible, which built upon validate_barebones and was intended to be run on a system that had already undergone configuration management. So the first thing we needed was to create a simple playbook for our new role. --- - include: bootstrap_ansible.yaml when: no_includes is not defined - hosts: '{{ target_hosts }}' become: yes become_method: sudo gather_facts: True roles: - validate_barebones The no_includes variable is a trick we used to more quickly test our playbooks in development without needing to run the whole Ansible workflow. We assigned hosts to the {{target_hosts}} variable so that anything launching Ansible must define the hosts targeted in the run, instead of defaulting to the typical—and dangerous—all. When we ran this playbook, Ansible executed the validate_barebones role. This role consisted of three files: a task YAML file (tasks/main.yaml), a handler YAML file (handlers/main.yaml), and a single Jinja 2 template (templates/barebones_report.j2), which we used when generating reports. The tasks/main.yaml file is where we defined the tasks for the audit runs, but before we ran the audit tasks, we ran a few tasks to determine which platform the host was running on. - name: 'Detect AWS Instance' shell: \"grep -qi amazon /sys/devices/virtual/dmi/id/bios_version\" register: in_aws ignore_errors: True changed_when: False failed_when: False - name: 'Detect Dell Server' shell: \"grep -qi PowerEdge /sys/devices/virtual/dmi/id/product_name\" register: dell_hardware ignore_errors: True changed_when: False failed_when: False - name: 'Check for Unknown Platform' # This check should actually fail the run, if it is True shell: \"echo\" failed_when: in_aws|failed and dell_hardware|failed In the first two stanzas, we checked if the host was running in Amazon or if it was a Dell PowerEdge server, and then registered the variables for in_aws and dell_hardware with the results of those checks. If a host was neither in AWS or deployed on Dell hardware, we exited the run, as described in the final stanza. (We never really expect that to happen though.) Example individual audit task Once we’ve determined the platform our host was running on, it was time to start running audit checks. The following check ensures that Docker is running on the host: # Docker - name: 'Docker daemon is running' # This check should actually fail the run, since a lot depends on it. shell: 'docker -H unix:///var/run/docker.sock ps' register: docker_running changed_when: False Container Fabric runs on CoreOS Container Linux, so must rely on containers to run most software, including the tools required to query important details about the Dell hardware. Because of this, we make sure this check will fail the whole run if Docker is not running (by registering the docker_running variable). The line changed_when:False tells Ansible that this command didn’t make any changes to the system that we want to track. Example multi-step audit tasks Besides running simple individual audits, we have more complicated checks. Dell EMC OpenManage Server Administrator (OMSA) is the name of the Dell tool that is required to query most of the Dell specific settings. The following check determined if the OMSA container was already running, launched it if not, and then verified that our host BIOS power profile was configured correctly. We accomplished this check by running a few tasks with a single handler. The task looks like this: - name: 'Is OMSA running' shell: 'curl -s --no-buffer -XGET --unix-socket /var/run/docker.sock http://localhost/containers/json?all=true | grep -q /omsa' register: omsa_local changed_when: False ignore_errors: True when: dell_hardware|success failed_when: False args: warn: False # Launch Openmanage Container (with sleep to allow processes to start up) - name: 'Launch openmanage container' # This check should actually fail the run, since a lot depends on it. shell: \"docker -H unix:///var/run/docker.sock run --privileged -d -p 1311:1311 -p 161:161/udp --restart=always -v /lib/modules/`uname -r`:/lib/modules/`uname -r` --name=omsa registry.example.net/dell-openmanage84:latest && sleep 40\" when: (omsa_local|failed and dell_hardware|success) register: launch_omsa changed_when: launch_omsa|success notify: remove omsa # Hardware BIOS - name: 'Power profile should be PerfOptimized' # NOT PerfPerWattOptimizedDapc shell: 'docker -H unix:///var/run/docker.sock exec omsa omreport chassis biossetup display=shortnames -fmt ssv | grep SysProfile' ignore_errors: True when: dell_hardware|success failed_when: False register: bios_power changed_when: (\"PerfOptimized\" not in bios_power.stdout) These tasks demonstrate where we get a little creative with Ansible’s abilities. Let me explain. We wanted these checks to generate a comprehensive report, so we never wanted the Ansible runs to fail. To ensure they never fail, we define failed_when: False in each task. We also wanted the report to tell us more than whether or not a system was compliant; we wanted to understand in what way a system was out of compliance. How the multi-step task works The first stanza determines if the Dell OpenManage (OMSA) container is already running on the host. If it is, we use the existing container and refrain from uninstalling it at the end of the run. (The args: warn: False option disables a warning that Ansible gives us about using curl via the shell, instead of relying on Ansible’s underlying library functions.) The second stanza launched the Dell OpenManage container if it wasn’t already running (when: omsa_local|failed) and the system is on Dell hardware (when: dell_hardware|success). If we launch the container, we also register a handler to run at the end with notify: remove omsa. This way we only remove the container if we launched it. The third stanza executes a check utilizing the Dell OpenManage container. A shell command determines the Dell BIOS power profile setting, which creates a value for register: bios_power. The output for register: bios_power (bios_power.stdout) will often look something like this: { \"changed\": false, \"cmd\": \"docker -H unix:///var/run/docker.sock exec omsa omreport chassis biossetup display=shortnames -fmt ssv | grep SysProfile\", \"delta\": \"0:00:00.153451\", \"end\": \"2017-02-16 18:55:53.583467\", \"failed\": false, \"failed_when_result\": false, \"rc\": 0, \"start\": \"2017-02-16 18:55:53.430016\", \"stderr\": \"\", \"stdout\": \"SysProfile;PerfOptimized\", \"stdout_lines\": [\"SysProfile;PerfOptimized\"], \"warnings\": [] } We then detect any divergence with the changed_when: (\"PerfOptimized\" not in bios_power.stdout) statement, used in the third stanza. We also add this output to our larger report later. After the audit run completed, the last step in the task is for Ansible to trigger any registered handlers (handlers/main.yaml), including the one to remove the Dell OpenManage container: - name: remove omsa shell: \"docker -H unix:///var/run/docker.sock rm -f omsa\" Generating the audit report The final task in our playbook role is a local action that only runs once and generates our report. # Report Results - name: Generate report become: no local_action: template src=barebones_report.j2 dest=/tmp/barebones_report.txt run_once: True changed_when: False The following is a representative portion of the Jinga 2 template file (templates/barebones_report.j2) that we use to create the final report: {{'\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"' | format(\"Barebones Section\", \"Test Name\" \"Changed\", \"Hostname\", \"Data\") }} {% set section = 'platform' %} {% set test = 'type' %} {% for i in play_hosts %} {% if hostvars[i]['in_aws'] is defined and hostvars[i]['in_aws']['rc'] == 0 %} {{'\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"' | format(section, test, \"False\", i, \"AWS instance\") }} {% elif hostvars[i]['dell_hardware'] is defined and hostvars[i]['dell_hardware']['rc'] == 0 %} {{'\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"' | format(section, test, \"False\", i, \"Dell hardware\") }} {% else %} {{'\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"' | format(section, test, \"True\", i, \"UNKNOWN/UNREACHABLE\") }} {% endif %} {% endfor %} {% set section = 'bios' %} {% set test = 'Power Mode' %} {% for i in play_hosts | sort %} {% if hostvars[i]['bios_power'] is defined and \"skipped\" not hostvars[i]['bios_power'] %} {{'\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"' | format(section, test, hostvars[i]['bios_power']['changed'], i, hostvars[i]['bios_power']['stdout'].strip(' \\t\\n\\r')) }} {% endif %} {% endfor %} And finally, here is a partial report (in a comma-separated values (CSV) format) that we ran against two hosts: \"Barebones Section\", \"Test Name\", \"Changed\", \"Hostname\", \"Data\" \"platform\", \"type\", \"False\", \"agent-10.example.net\", \"Dell hardware\" \"platform\", \"type\", \"False\", \"agent-11.example.net\", \"Dell hardware\" \"bios\", \"Power Mode\", \"False\", \"agent-10.example.net\", \"SysProfile;PerfOptimized\" \"bios\", \"Power Mode\", \"False\", \"agent-11.example.net\", \"SysProfile;PerfOptimized\" \"network\", \"bond0 - Bonding Mode\", \"False\", \"agent-11.example.net\", 2 \"network\", \"bond0 - Bonding Mode\", \"True\", \"agent-11.example.net\", 1 The first line is a table header for the rest of the report. The last entry that has a True value in the Changed column indicates a divergence we needed to address. We then used this data to create tickets and schedule any required remediation work. Proactive > Reactive Although we always want to believe that hardware is delivered to us in an expected state, it is important to follow the “trust but verify” model to ensure that nothing important has “slipped through the cracks” during earlier testing performed outside our control. Before the team implemented these checks, much of this discovery process would have been triggered by real-world incidents, and we wouldn’t know there was a problem until we had one. This Ansible-based audit workflow helped us identify problems ahead of time, and also helped us keep track of previously discovered issues so that we didn’t hit them again. Designing and extending these audit playbooks was very easy for everyone on the team, and by regularly running them across our initial infrastructure, we learned a lot about the critical settings that we needed to track and correct. Using this knowledge we were able to move forward and implement a much more robust testing solution for our production launch using the Python-based TestInfra tool.   By Sean P. Kane Sean is a Lead Site Reliability Engineer at New Relic. He is a long-time system administrator and operations engineer who has lived in places ranging from Alaska to Pakistan. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.53964,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Using <em>Ansible</em> <em>as</em> <em>a</em> Hardware <em>Auditing</em> <em>Tool</em>",
        "sections": "First, defining our requirements for <em>Ansible</em> <em>as</em> <em>a</em> hardware <em>auditing</em> <em>tool</em>",
        "body": " report: {{&#x27;&quot;%s&quot;, &quot;%s&quot;, &quot;%s&quot;, &quot;%s&quot;, &quot;%s&quot;&#x27; | format(&quot;Barebones <em>Section</em>&quot;, &quot;<em>Test</em> Name&quot; &quot;Changed&quot;, &quot;Hostname&quot;, &quot;Data&quot;) }} {% set <em>section</em> = &#x27;platform&#x27; %} {% set <em>test</em> = &#x27;type&#x27; %} {% for i in play_hosts %} {% if hostvars[i][&#x27;in_aws&#x27;] is defined and hostvars[i][&#x27;in_aws&#x27;][&#x27;rc&#x27;] == 0 %} {{&#x27;&quot;%s&quot;, &quot;%s&quot;, &quot;%s"
      },
      "id": "60764266e7b9d2de4ca5c679"
    },
    {
      "sections": [
        "Third party instrumentation",
        "Contents",
        "Finding third-party extensions",
        "Extensions as gems",
        "Starting transactions",
        "add_transaction_tracer",
        "perform_action_with_newrelic_trace",
        "Nodes in transaction traces",
        "add_method_tracer",
        "Custom Datastores",
        "NewRelic::Agent::Datastores.trace",
        "NewRelic::Agent::Datastores.wrap",
        "NewRelic::Agent::Datastores.notice_sql",
        "Caution",
        "NewRelic::Agent::Datastores.notice_statement",
        "Testing your extension",
        "NewRelic::Agent.require_test_helper",
        "assert_metrics_recorded",
        "in_web_transaction/in_background_transaction",
        "with_config",
        "Tip",
        "Multiverse: Test against multiple gem versions"
      ],
      "title": "Third party instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "API guides"
      ],
      "external_id": "57bcc0d905afa6233b74207ec38808fdf5cc97ef",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/api-guides/third-party-instrumentation/",
      "published_at": "2021-04-16T10:52:17Z",
      "updated_at": "2021-03-11T08:12:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document details how to instrument third-party gems with the Ruby agent, as well as some best practices for interacting with the agent. This is useful if you are using a gem that the Ruby agent does not instrument by default, or if you are a gem author who wants to add instrumentation for your library. Contents Finding third-party extensions Anyone can write a gem that builds on top of the Ruby agent. New Relic maintains a repository called extends_newrelic_rpm to track these extensions and to provide links to other gems that build the Ruby agent. These extensions are not supported by New Relic. New Relic gathers these links as a service to our customers. Issues with those gems should be reported to the respective projects on GitHub. Extensions as gems New Relic encourages third-party extensions to be maintained as gems, with one gem per instrumented library. For example, newrelic-redis provides instrumentation for the redis gem. Starting transactions If your library provides code which should be represented as a full transaction in New Relic (for example: a web request or background job that isn't instrumented by the Ruby agent), then use one of these mechanisms for starting a transaction. add_transaction_tracer The simplest way to get a transaction started is to call add_transaction_tracer on the method. This assumes that NewRelic::Agent::Instrumentation::ControllerInstrumentation is included in your class. class CustomBackgroundJob include NewRelic::Agent::Instrumentation::ControllerInstrumentation def transaction # execute a transaction end add_transaction_tracer :transaction end Copy perform_action_with_newrelic_trace Sometimes you need slightly more control over the transaction that New Relic generates. When that happens, you can use perform_action_with_newrelic_trace. Some of the parameters you can override include the transaction name and category (whether it's a web transaction or a background transaction). class CustomBackgroundJob include NewRelic::Agent::Instrumentation::ControllerInstrumentation def transaction perform_action_with_newrelic_trace(:name => \"custom_name\", :category => :task) do # your work here... end end end Copy See the full documentation of perform_action_with_newrelic_trace for further information on parameters and usage. Nodes in transaction traces You may want to add timing information to New Relic about calls to a method, but it does not represent a full transaction. New Relic recommends adding a method tracer to accomplish this. add_method_tracer require 'new_relic/agent/method_tracer' class Foo include ::NewRelic::Agent::MethodTracer def generate_image # ... end add_method_tracer :generate_image, 'Custom/generate_image' end Copy The above example results in metrics being recorded for the name 'Custom/generate_image', as well as an entry in transaction traces that includes the method call. Custom Datastores The Ruby agent provides special functionality for recording calls to Datastores. These are intended to support both SQL and NoSQL databases, and provide a consistent interface for use by third-party gems. Metrics recorded via the NewRelic::Agent::Datastores module functions will show up in the Databases UI in New Relic. NewRelic::Agent::Datastores.trace trace is the simplest way to record Datastore for a method. class FauxDB def find # FauxDB lookup end NewRelic::Agent::Datastores.trace self, :find, \"FauxDB\" end Copy The first parameter is the class to instrument, the second the method to find, the third the datastore product name. An optional operation name can be included as the final parameter, otherwise the method name is used to represent the operation in metrics. Note that Datastore metrics recorded with this interface do not allow for adding a collection/table name. For that, see the wrap method below. NewRelic::Agent::Datastores.wrap wrap allows for recording Datastore metrics with additional collection/table information in the metric names. It also provides a callback for operations such as noticing slow statements. class FauxDB def find(table) NewRelic::Agent::Datastores.wrap(\"FauxDB\", \"find\", table) do # FauxDB lookup end end end Copy If you want to record additional information about your datastore call, you can use the optional callback parameter on wrap: class FauxDB def find(query) callback = Proc.new do |result, scoped_metric, elapsed| NewRelic::Agent::Datastores.notice_sql(query, scoped_metric, elapsed) end NewRelic::Agent::Datastores.wrap(\"FauxDB\", \"find\", \"items\", callback) do # execute query end end end Copy NewRelic::Agent::Datastores.notice_sql This helper method records slow SQL queries for presentation in transaction traces and slow SQL pages. SQL is filtered and obfuscated based on the user's settings. NewRelic::Agent::Datastores.notice_sql(query, scoped_metric, elapsed) Copy Non-SQL queries should never be sent through notice_sql.Use notice_statement instead. Caution New Relic's Transaction Tracing and Slow SQL features will attempt to apply obfuscation to the passed queries, but it is possible for a query format to be unsupported and result in exposing user information embedded within captured queries. NewRelic::Agent::Datastores.notice_statement This helper method records statements for slow datastore calls to transaction traces. These are not obfuscated. NewRelic::Agent::Datastores.notice_statement(statement, elapsed) Copy SQL queries should never be sent through notice_statement. Use notice_sql instead. Caution This method will properly ignore statements when the user has turned off capturing queries, but it is not able to obfuscate arbitrary data! Ensure all data passed to this method is safe to transmit to New Relic in order to prevent exposing user information embedded in captured queries. Testing your extension You can write automated tests when you author a gem that extends New Relic. The test helpers used by the agent itself are available to simplify some common testing tasks. NewRelic::Agent.require_test_helper The test methods documented in this section can be accessed by calling this from your test code (most commonly a test_helper.rb file) NewRelic::Agent.require_test_helper Copy assert_metrics_recorded This method is the primary way to ensure your expected metrics are recorded by the Ruby agent. refute_metrics_recorded is also available. In the simplest form, assert_metrics_recorded can be called like this: assert_metrics_recorded([\"MetricA\", \"MetricB\"]) Copy Metrics with specific values can be asserted via this syntax: assert_metrics_recorded('MetricA' => { :call_count => 1, :total_call_time => 1.0 }) Copy in_web_transaction/in_background_transaction These methods simulate running in web or background transaction. in_web_transaction do # Perform work to test behavior in transaction end Copy with_config Configuration of the agent can be changed for testing via with_config. It takes a hash which is applied to the other configuration values in agent. with_config(:enabled => false) do # Check what happens when agent's disabled end Copy Tip This method doesn't help for testing installation of instrumentation, as those config values are typically checked when instrumentation happens on require, and isn't influenced by the setting change in a test. Multiverse: Test against multiple gem versions If you need to test your extension against multiple gem versions, you can use Multiverse, a part of the Ruby agent's own testing code. For examples of Multiverse testing, see the suites directory in the agent files. To configure Multiverse for your own gem: Require tasks/multiverse in Rakefile. To enable the rake test:multiverse command, add the following to your Rakefile: require \"tasks/multiverse\" Copy Create the Multiverse test directory. Multiverse tests require a specific file layout. Create a directory named test/multiverse/YOUR_PROJECT with the following file locations: test/multiverse/YOUR_PROJECT test/multiverse/YOUR_PROJECT/Envfile test/multiverse/YOUR_PROJECT/config/newrelic.yml test/multiverse/YOUR_PROJECT/FILE_WITH_A_TEST.rb Copy Configure your Envfile. Use the Envfile to declare sets of gem dependencies for your Multiverse tests. For example, your Envfile might look like this: gemfile <-RB gem 'your-project', '~> 1.0.0' gem 'rack' gem 'newrelic_rpm' gem 'newrelic_your-project', path: '../../..' RB gemfile <-RB gem 'your-project', '~> 2.1.0' gem 'rack' gem 'newrelic_rpm' gem 'newrelic_your-project', path: '../../..' RB Copy Tip Include the gem lines for newrelic_rpm and rack to ensure your Multiverse tests work. Detect dependencies. If necessary, ensure your extension's instrumentation is loaded by running an additional dependency detection from your Multiverse tests: require 'newrelic/your-project' DependencyDetection.detect! class YourProjectTest > Minitest::Test end Copy To run your Multiverse tests against the gem dependencies in your Envfile: After setting up Multiverse for your gem, run rake test:multiverse to execute the tests in your directory.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.99617,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>add_transaction_tracer</em>",
        "tags": "<em>Agents</em>",
        "body": "(:name =&gt; &quot;custom_name&quot;, :category =&gt; :task) do # <em>your</em> work here... <em>end</em> <em>end</em> <em>end</em> Copy See the full documentation of perform_action_with_newrelic_trace for further information on parameters and usage. Nodes in transaction traces You may want to <em>add</em> timing information to New Relic about calls"
      },
      "id": "604403e0e7b9d23d64579a05"
    }
  ],
  "/build-apps/ab-test/table-charts": [
    {
      "sections": [
        "Integrations and custom roles",
        "Recommended role",
        "Optional role",
        "Important",
        "List of permissions",
        "Common permissions",
        "Service-specific permissions",
        "Permissions to link projects through the UI"
      ],
      "title": "Integrations and custom roles",
      "type": "docs",
      "tags": [
        "Integrations",
        "Google Cloud Platform integrations",
        "Get started"
      ],
      "external_id": "d4f60e2d8413ddde9a342980d75a0e216af9baa4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/google-cloud-platform-integrations/get-started/integrations-custom-roles/",
      "published_at": "2021-04-16T16:37:10Z",
      "updated_at": "2021-04-16T16:37:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To read the relevant data from your Google Cloud Platform (GCP) account, New Relic uses the Google Stackdriver API and also other specific services APIs. To access these APIs in your Google Cloud project, the New Relic authorized account needs to be granted a certain set of permissions; GCP uses roles to grant these permissions. Recommended role By default we highly recommend using the GCP primitive role Project Viewer, which grants \"permissions for read-only actions that do not affect your cloud infrastructure state, such as viewing (but not modifying) existing resources or data.\" This role is automatically managed by Google and updated when new Google Cloud services are released or modified. Optional role Alternatively, you can create your own custom role based on the list of permissions, which specifies the minimum set of permissions required to fetch data from each GCP integration. This will allow you to have more control over the permissions set for the New Relic authorized account. Important New Relic has no way of identifying problems related to custom permissions. If you choose to create a custom role, it is your responsibility to maintain it and ensure proper data is being collected. To customize your role you need to: Create a Google Cloud IAM Custom Role in each one of the GCP projects you want to monitor with New Relic. In each custom role, add the permissions that are specifically required for the cloud services you want to monitor according to the following list. Assign the custom role(s) to the New Relic authorized account. List of permissions Common permissions All integrations need the following permission: monitoring.timeSeries.list service.usage.use Service-specific permissions For some GCP integrations, New Relic will also need the following permissions, mainly to collect labels and inventory attributes. Integration Permissions Google AppEngine n/a; Google App Engine does not require additional permissions. Google BigQuery bigquery.datasets.get bigquery.tables.get bigquery.tables.list Google Cloud Functions cloudfunctions.locations.list Google Cloud Load Balancing n/a; Google Cloud Load Balancing does not require additional permissions. Google Cloud Pub/Sub pubsub.subscriptions.get pubsub.subscriptions.list pubsub.topics.get pubsub.topics.list Google Cloud Spanner spanner.instances.list spanner.databases.list spanner.databases.getDdl Google Cloud SQL cloudsql.instances.list Google Cloud Storage storage.buckets.list Google Compute Engine compute.instances.list compute.disks.get compute.disks.list Google Kubernetes Engine container.clusters.list Permissions to link projects through the UI To be able to see the list of projects that you can link to New Relic through the UI, your New Relic authorized service account needs the following permissions: resourcemanager.projects.get monitoring.monitoredResourceDescriptors.list If you do not want to grant New Relic authorized account the permissions that are needed for the linking process through the UI, you have the following options: Assign the Project Viewer or Monitoring Viewer role initially to the authorized account to link Google Cloud projects to New Relic through the UI. After the projects are linked, assign a Google Cloud custom role to the authorized account. Use New Relic NerdGraph to link Google Cloud projects to New Relic. This does not involve listing the viewable projects. However, you must know the id of the project you want to monitor. For more information, see the NerdGraph GraphiQL cloud integrations API tutorial.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.78006,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is being collected. To customize your role you need to: Create a Google Cloud IAM Custom Role in each one of the GCP projects you want to monitor with New Relic. In each custom role, <em>add</em> the permissions that are specifically required for the cloud services you want to monitor according to the following"
      },
      "id": "603ebb3564441f34b64e8874"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/mysql3.png",
      "url": "https://newrelic.com/blog/how-to-relic/how-to-monitor-mysql",
      "sections": [
        "Key MySQL Metrics to Monitor",
        "Uptime",
        "Connections",
        "Memory usage",
        "Storage speed",
        "Query speed",
        "Query optimization metrics",
        "Temporary Files and Tables",
        "Locks",
        "Missing indexes",
        "Monitoring MySQL with New Relic",
        "Install the agent and integration on an Ubuntu server",
        "Configure the MySQL integration",
        "View MySQL data in New Relic",
        "From integration to observability"
      ],
      "published_at": "2021-04-16T04:25:17Z",
      "title": "Monitoring MySQL Database Performance with New Relic",
      "updated_at": "2021-04-14T00:08:57Z",
      "type": "",
      "external_id": "3094a8de9f54b579f4a2c39828a89388637abf35",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Monitoring MySQL Database Performance with New Relic Aug 24, 2020 • 11 min read By Tomas Fernandez Zavalia MySQL is an open source relational database system that, like Linux, started its history as a personal side project. Over its 25 years of history, MySQL has gained significant traction, and today a broad range of companies, such as Sony and Uber, use it to run their multi-petabyte mission-critical databases. In a way, MySQL has been a victim of its own success. It’s easy enough to run that developers may take it for granted and assume it doesn’t need supervision. In reality, MySQL is a complex system with a delicate balance you must monitor closely. It exposes a lot of useful metrics you can’t afford to miss because they highlight where bottlenecks are, when it’s time to upgrade, and what queries you should optimize. Like most relational databases, MySQL organizes data using databases (also called schemas) and tables. However, MySQL has a unique modular architecture that lets you choose the best low-level storage engine for the job. MySQL exposes its inner workings in all these levels through dozens of metrics. MySQL is also extremely flexible. You can run it as a single instance, as a primary-secondary cluster, thank to replication, or in multi-master mode. And third-party solutions like Vitess allow you to create horizontally-scaled clusters. Key MySQL Metrics to Monitor Let's start by reviewing some of the most important metrics to monitor in any MySQL instance. To view all available metrics, check out our MySQL integration docs (which we’ll walk through setting up below). Uptime It may sound self-evident, but many teams set alerts for server downtime while forgetting to monitor the MySQL process itself. When the database is down, you want to get notified immediately. Connections MySQL sets a hard limit on the number of simultaneous connections. When you reach it, new connections are blocked until someone disconnects. MySQL allows 151 connections by default. Changing the limit is simple: SET GLOBAL max_connections = 200; Bear in mind that each connection needs at least 3MB, so always try to keep the number of connections as small as possible. To determine the optimum number of connections to set, monitor three metrics: net.maxUsedConnections: The maximum number of connections recorded since the database started. Use this value as a reference to set max_connections. net.threadsConnected: The current number of active connections. net.connectionErrorsMaxConnectionsPerSecond: The number of connections failed per second due to the max_connections limit being reached. If the value is higher than zero, you need to either raise the limit, set up connection pools for your applications, or consider installing a load balancer like ProxySQL. Network issues and buggy clients can also affect MySQL connections. Watch net.abortedClientsPerSecond to detect applications not closing connections properly. A high rate usually indicates problems in the network. Memory usage Databases need a lot of memory to work well, so monitoring memory is vital to keep your MySQL in top shape. First, set up monitoring for the server to ensure it has enough RAM: memoryFreeByes memoryUsedBytes memoryTotalByes Then, on the MySQL side, monitor these metrics: db.innodb.bufferPoolPagesTotal: The number of pages in-memory holding data. You want this number to be as high as possible to reduce disk activity and increase performance. db.innodb.bufferPoolReadsPerSecond: The number of pages not found in-memory that need to be retrieved from disk. If the value is more than 5-15% of db.innodb.bufferPoolPagesTotal, the database needs more memory. In that case, check the server RAM and increase the db.innodb_buffer_pool_size setting on MySQL. db.innodb.logWaitsPerSecond: If this value is consistently high, it means that the log buffer is set too low. In that case, increase innodb_log_buffer_size until the problem goes away. Storage speed After memory, disk I/O speed is the most crucial factor for database performance. Even if the system has enough RAM to allocate the complete database, it’ll still need disk I/O to ensure transaction consistency. The main database workload shapes disk activity. For Online Transaction Processing (OLTP) systems (e.g., systems used for online purchase processing), the following metrics should be smooth and steady. Peaks indicate possible bottlenecks and latency for your users. On the other hand, for Online Analytical Processing (OLAP) systems (e.g., systems used for budgeting and forecasting), uneven activity is a lot more common and should be expected. To keep an eye on workload, monitor the following: db.innodb.dataReadsPerSecond: The number of reads per second. db.innodb.dataWritesPerSecond: The number of writes per second. db.innodb.osLogWrittenBytesPerSecond: The transaction log throughput. This value is proportional to how much the data changes over time. Query speed Watch these metrics to monitor query speed and capture a baseline for your database: query.questionsPerSecond: The number of queries sent by clients. query.queriesPerSecond: The total number of queries per second (QPS), including administrative commands and stored procedures. It measures the raw capacity of the database. query.maxExecutionTimeExceededPerSecond: The number of SELECT statements timed out per second. For OLTP workloads, you never want this value to exceed zero. If you find that your queries are timing out, optimize them. Query optimization metrics Query optimization is where you can make the most significant impact on MySQL performance. To identify long-running queries, activate the MySQL slow query log: SET GLOBAL slow_query_log = 1; SET GLOBAL slow_query_log_file = '/var/log/mysql/mysql-slow.log'; Then set a reasonable query time to capture the worst-behaving queries on a first pass: // 3 seconds threshold SET GLOBAL long_query_time = 3; As performance improves, you can reduce the query time and repeat the process. Once the feature is active, monitor query.slowQueriesPerSecond, analyze the log, and use an EXPLAIN statement to find which queries do worse. Depending on the case, you may need to rewrite them, add or modify indexes, or restructure your tables. Here are some additional metrics to monitor while optimizing queries. Temporary Files and Tables MySQL creates temporary files and tables on disk for operations such as GROUP BY, ORDER BY, or UNION that don’t fit in-memory. Since these can cause excessive disk I/O, keep a close watch on these metrics: db.createdTmpDiskTablesPerSecond measures tables. db.createdTmpFilesPerSecond measures temporary files. While it’s not always possible to reduce these values to zero, you can minimize temporary disk activity by adjusting sort_buffer_size and join_buffer_size, and rewriting queries. Locks MySQL uses table- and row-level locks to ensure data consistency. Poorly written queries and some administrative tasks can lead to long-running locks that block other clients. The main metrics for lock activity are db.tablesLocksWaitedPerSecond for tables, and db.innodb.rowLockTimeAvg and db.innodb.rowLockWaitsPerSecond for rows. Missing indexes MySQL uses indexes for filtering, sorting, and joining tables. When queries and table structures don’t line up, MySQL is forced to scan the whole table. This situation uses up a lot of extra memory and causes heavy disk I/O. Monitor these metrics for details: db.selectFullJoinPerSecond and db.selectFullJoinRangePerSecond indicate whether your tables need additional indexes. db.innodb.bufferPoolReadAheadRndPerSecond helps detect inefficient table-level reads. Monitoring MySQL with New Relic Our MySQL integration uses the New Relic Infrastructure agent to collect and send performance metrics from your MySQL database to our platform.  You can see  your database server’s health and analyze metric data so that you can easily find the source of any problems The integration is compatible with MySQL version 5.6 or higher. In the following example, we’ll show you how to set up Infrastructure Monitoring for an  Ubuntu server running MySQL. If you have a different host OS, check the agent documentation for alternative instructions. Note: You can also monitor MySQL as a service running in Kubernetes or ECS. Install the agent and integration on an Ubuntu server From New Relic One, navigate to your account drop-down (in the top-right corner) and select Add more data. Select your operating system (in this case Ubuntu), and follow the prompts to get your license key and select your Ubuntu version. To deploy the Infrastructure agent and the MySQL integration, run the following commands on your server: Import Infrastructure agent GPG Key. curl -s https://download.newrelic.com/infrastructure_agent/gpg/newrelic-infra.gpg | sudo apt-key add - Add the New Relic repository (view all distributions here). printf \"deb [arch=amd64] https://download.newrelic.com/infrastructure_agent/linux/apt bionic main\" | sudo tee -a /etc/apt/sources.list.d/newrelic-infra.list Install the infrastructure agent (newrelic-infra) and MySQL integration (nri-mysql). sudo apt-get update && sudo apt-get install -y newrelic-infra nri-mysql Configure the MySQL integration Add a monitoring user in MySQL. mysql -e \"CREATE USER 'newrelic'@'localhost' IDENTIFIED BY 'MONITOR_USER_PASSWORD';\" mysql -e \"GRANT REPLICATION CLIENT ON *.* TO 'newrelic'@'localhost';\" Configure the MySQL integration. cd /etc/newrelic-infra/integrations.d sudo cp mysql-config.yml.sample mysql-config.yml sudo nano mysql-config.yml Fill in the password.hostname: hostname: localhost port: 3306 username: newrelic password: MONITOR_USER_PASSWORD Set remote_monitoring to true. Capture extended_metrics and extended_innodb_metrics. extended_metrics: 1 extended_innodb_metrics: 1 If you have MyISAM tables, also set extended_myisam_metrics: extended_myisam_metrics: 1 Restart the infrastructure agent to complete the setup.systemctl restart newrelic-infra A full list of configuration options is available in our MySQL integration documentation. View MySQL data in New Relic From New Relic One, navigate to Infrastructure to see the incoming data about your servers. To start monitoring your MySQL databases, navigate to Infrastructure > Third-party Services > MySQL Dashboard. Here are a few example charts created based on our integration’s configuration: A QPS graph measures the raw efficiency of your database The Slow Queries chart lets you know when it’s time to optimize your database Use the Max Connections graph to fine tune max_connections Use the I/O activity for the network and disk to find bottlenecks in your system To create more advanced charts and custom dashboards, check out the data explorer. From integration to observability If data is the application’s lifeblood, then the database is its heart. Reliable database performance is vital in any business. By monitoring a few key metrics, you can better understand how your MySQL servers are functioning. The MySQL integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. Make our MySQL integration an essential part of your observability stack. Check out our full list of on-host integrations for more. If you are ready to take control of your databases, sign up for 100GB of ingest per month and one Full-Stack Observability user license—free forever!   By Tomas Fernandez Zavalia Tomas started his career as a PHP developer. After graduating, he worked at British Telecom as head of the Web Services department in Argentina. After that, he went to IBM, where he wore many technical hats: DBA, Sysadmin, and DevOps. He's now an independent consultant and writer. He loves to learn and to teach about technology. In his free time, he likes reading, sailing, and board gaming. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.24545,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Temporary Files and <em>Tables</em>",
        "body": ", <em>add</em> or modify indexes, or restructure your <em>tables</em>. Here are some additional metrics to monitor while optimizing queries. Temporary Files and <em>Tables</em> MySQL creates temporary files and <em>tables</em> on disk for operations such as GROUP BY, ORDER BY, or UNION that don’t fit in-memory. Since these can cause"
      },
      "id": "6076329a196a67a65164a773"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/1621DA95-52CD-41D0-B213-21D85D116ED8_1_201_a.jpeg?h=99bb2061&itok=AHnzfGKB",
      "url": "https://newrelic.com/blog/nerd-life/observy-mcobservface-episode-3-bobby-tables",
      "sections": [
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:29:41Z",
      "title": "Observy McObservface Episode 3 - Firefighting and DevOps: The Platypus Incident",
      "updated_at": "2021-04-13T23:25:47Z",
      "type": "",
      "external_id": "8b9ec69b18904641bab8bb353bff9dabb8200f57",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Culture Observy McObservface Episode 3 - Firefighting and DevOps: The Platypus Incident Aug 5, 2020 • 22 min read By Jonan Scheffler This week we were joined by Bobby Tables of Firehydrant.io, a world-renowned purveyor of artisanal, handcrafted incident response services that are, in fact, the opposite of that; perfectly replicable and entirely automated. Bobby talks us through some of the motivation behind the path he and his co-founders walked (sprinted?) when starting their company and the market circumstances that have created a demand for automated incident response. We also touch on the distinction between DevOps and SRE, the pros and cons of microservices, and one particularly memorable incident involving a platypus and a fire hydrant. Should you find a burning need to share your thoughts or rants about the show, please spray them at devrel@newrelic.com. While you’re going to all the trouble of shipping us some bytes, please consider taking a moment to let us know what you’d like to hear on the show in the future. Despite the all-caps flaming you will receive in response, please know that we are sincerely interested in your feedback; we aim to appease. Enjoy the show! Jonan: I'm joined today by my guest, Bobby Tables. How are you today, Bobby? Bobby Tables: I am doing super well, man. How are you? Jonan: I'm doing great. I'm excited to talk to you about some FireHydrant.io stuff, and specifically incident response. I'm really curious about incident response because I'm not a DevOps professional, and I never really have been. Also, before we get into that, I want to hear about you. Tell me who you are and how you ended up here. Bobby Tables: My name is Bobby Tables. People call me that after the xkcd comic, after a mom names her child a SQL injection attack. My real name is Robert Ross. Previous to starting FireHydrant with two of my friends—we were all in the DevOps space—but I worked at Namely HR, where I was building a lot of developer tools. I was on the SRE team. Before Namely, I was at DigitalOcean and before that, I was at Thunderbolt Labs doing a lot of really cool things with that consultancy. So a lot of developer tools in my life, and it had been a really fun time to build it for myself and for others. Jonan: I remember Thunderbolt. How long ago was Thunderbolt? Bobby Tables: I think I was at Thunderbolt Labs, I want to say, six years ago. Jonan: You worked with Bryan Lyles, maybe? Bobby Tables: I did. Jonan: I remember Thunderbolt Labs because you had great stickers. You've always been on point with the branding. At Thunderbolt, you had really good branding and you also have lovely branding at FireHydrant. In fact, I remember an episode recently where there was a Twitter exchange that ended up with quite an interesting logo on your homepage. I wonder if you want to share a story about that. Bobby Tables: So, we somehow ended up engaging with Corey Quinn on Twitter and we posted to Corey on Twitter, from our corporate FireHydrant account, we said, “If you draw a logo for FireHydrant, we'll make it our logo for the rest of the day on our website.” And there was a little bit of exchange. He said, “Don't say things if you won’t actually do it.” And we said, “We're serious.” And Corey recently posted the exchange that happened in their Slack.org, and it basically said, “I need you to draw the duckbill logo peeing on a fire hydrant.” So we get this logo back, I want to say, 30 minutes later, something like that. And I went into our WordPress and uploaded the logo and... Jonan: You had you a duckbill platypus peeing on a fire hydrant... Bobby Tables: We did. Jonan: ... as your logo for the rest of the day? Bobby Tables: We did, yeah. Jonan: It's amazing. Bobby Tables: It got a good laugh. It was pretty funny. And we hold that moment near and dear to our hearts and in the company. Jonan: So you're drinking an old-fashioned? Bobby Tables: I am. Jonan: I'm having some scotch. This is my Operation Shamrock class that I got at New Relic back in the day, when they went and opened an office in Dublin—which I think was their first office overseas. They called it Operation Shamrock. Bobby Tables: That's great. Jonan: So the company that you've started now, FireHydrant, how long ago did you start up? Bobby Tables: The first commit for FireHydrant was in September of 2017. And FireHydrant started as a video series where I wanted to record building an application from scratch. It was a Ruby on Rails application. So I recorded every second of FireHydrant being built for the first 40 hours. And then I had a friend say, \"Hey, what you're building is way more valuable.\" So FireHydrant was a project to basically help with incident response. That was always its intention—to be that, but then I just kind of stopped recording after 40 hours, and then I had a couple of friends join in the fun. And then in December of 2018 is when we raised a seed, and we started the project full-time as a team. So here we are—we have some great clients, and we’re helping incident response. Jonan: How many people are you up to now? You're growing quickly. Bobby Tables: We've grown pretty well. We have 16 people now. Jonan: Wow! And so it was about a year and a half ago? Bobby Tables: A little over a year and a half ago. Jonan: That's awesome. What is it like to raise funding for an idea you have? I have a lot of friends who do these startup things. It seems to be kind of a path for a software engineer of your experience level. I just don't understand the process. Do you just announce on Twitter, \"Hey, someone give me $1 million.\" Where do you go? Bobby Tables: A couple of investors in New York City reached out to us, and I feel bad even telling this story, because there's so many founders that say they had to talk to 50 investors before they were able to get a term sheet. I really feel so lucky being able to say that we had a great idea, we had some really enthusiastic investors, and honestly, that's how we raised it. We were able to tap into our network that had raised a little bit of capital in the past as well, and we had some advice there. We were guided through the whole process, read a lot of books—a lot of books—we definitely tried to read as much as we could before signing anything. But we're really lucky. We have some of the best investors we probably could have ever asked for. So Work-Bench was our first investor, and then our Series A, which closed earlier this year, is Menlo Ventures, which is a really well-established firm. They have investments in Uber, Roku, Warby Parker. So we feel really lucky and we're solving some really cool problems—we just keep the vision moving us forward. Jonan: So I looked at some of your blog posts. What I think your product does is that when you have an incident at your company, FireHydrant.io will be initiated by someone or even automatically initiated when some threshold metric is reached, and it manages the entire incident lifecycle. So suddenly, people start to get the right Slack messages to let the right people know that systems are down and what steps to take next. It presents to them playbooks and resources to walk through, fix the problem; try rebooting this, try rebooting that, set up this new instance of this application. And then in the end, it wraps it all up into a tidy report that you can then use for your retrospective analysis of the incident. How'd I do? Bobby Tables: That was great. Do you want a marketing role? Jonan: I've been at New Relic now for three weeks. Bobby Tables: You just joined New Relic. That's probably not a question yeah... That was a great description of FireHydrant. So we think of FireHydrant—as it really is baked into the name—the tool that helps you put out a fire. So with a lot of the alerting tools that are out there, they kind of receive a signal and they'll wake you up. And that's really what these alerting tools are kind of built to do, and they do it very well. One of the pains that I felt and my team felt was that once I get woken up, what now? So FireHydrant was kind of born with that idea in mind. You have a smoke detector, your smoke detector is going to wake you up when it smells smoke, but it's not going to help you at that point. It's just going to get you out of the house to call someone else to fix the problem for you. Bobby Tables: When you think about a fire hydrant on the street, it's not directly responsible for putting out the fire. Firefighters are responsible for putting out the fire, and the fire hydrant is just an essential tool. So we help you organize the right people as fast as possible. We'll create a Slack channel for your incident. We'll create a Zoom bridge. We can even do things like post a run book for the services that are impacted: Here's how you do a rollback, here's how you send a USR2 signal to reload config. You can store all of that, and FireHydrant makes it really, really easily accessible. If something's broken, New Relic is telling you, \"Hey, your APM is way above threshold.\" It can cause a sense of panic, and you might forget your process. Engineers, they really just want to do the right thing. No engineer is ever going to do anything in an incident response process that's going to intentionally make something worse. But what happens is that they might go into cognitive tunneling where they forget to create a Slack room or update a status page I/O or update our status page product. That's common. So FireHydrant was kind of built around the idea of how we could make it so you have the same process every single time, and we'll do it for you in a few seconds so you can do what you're really good at as an engineer, which is solve the problem. Jonan: Which makes it a brilliant product, I will reiterate. Having been in the position many times where I get a PagerDuty alert for some application that is technically in my sphere of responsibility but I haven't worked with very often or maybe I'm new to the company—even if I am one of the more experienced engineers on my team—when I get that alert, I go into an application that I haven't coded on in a few months. I don't remember all of the things. I just start poking about it at random. It's so valuable to have these run books, which is, from my perspective, a relatively recent innovation. I'm sure that there were people doing this 10 years ago, but I feel like when I first came into the industry about that time, it wasn't a common practice, certainly. And since then, we've gone all in on this DevOps perspective, a term that arose from trying to bridge the gap between developers and IT or systems folk that, really, are the same thing: We're all working toward the same goals, and we're all writing code, and we're all trying to build things in ways that are replicable using tools like FireHydrant. So what is the distinction in your mind? Bobby Tables: Yeah, the question is one that I've had many discussions over beers at many bars. So I think that one of the things you hear, or you can just Google—start typing in “DevOps,” one thing you'll see pop up in Google is “DevOps versus SRE.” And I think it's important to make a distinction here first. So DevOps has a lot of different ideas. It's certain practices around CI/CD. It's certain practices around building tooling for maybe rolling back to employees or to alert, and the process is kind of around that. It's just that. It's just a bunch of ideas. And that's where SRE kind of comes into play, and it's a framework of those ideas. So if you think about an object oriented-language, Google has a really great presentation about this. SRE implements DevOps. SRE inherits from DevOps. And that's a nice way to kind of separate the idea of DevOps versus SRE, I think. Jonan: So, site reliability engineering is an implementation of DevOps principles—DevOps is a collection of ideas, and SRE is the actual implementation? Bobby Tables: Yes. Jonan: So from outside of that world, I started seeing people use the term SRE about the time I started hearing about DevOps—but presumably, those two didn't happen in tandem, did they? So there was a foundational book about DevOps. There was a book that maybe had “unicorn” in the title? Bobby Tables: Yeah. The Unicorn Project: A Novel about Developers, Digital Disruption, and Thriving in the Age of Data, by Gene Kim came out more recently. I think The Phoenix Project by Gene Kim was the one that talked a little bit more directly—in a fictional sense—about DevOps. It’s a really good book. It talks about almost a scary realistic world of DevOps and kind of moving toward it from a non-DevOps world. I haven't read the new one that you're mentioning, The Unicorn Project. Jonan: I was misremembering because I started going to DevOps meetups. Just in the last year or so, I really took an interest in this kind of stuff. It's fascinating to me to look at systems architecture, the way that I would build an application that I'm designing components for. I'm still kind of a fan of microservices now, the bitty, tiny microservices. There is a threshold where you reach and... Bobby Tables: Nano services? Jonan: Nano services, yeah. I think people over-complicated the message there, but I'm still a fan of having apps that approximately have a responsibility. This is where the users live. And architecting a system that way. I use CRC cards sometimes, and I'll do these mind maps when I'm getting ready to set up an application. I feel like systems architecture was very similar, but today, the pieces on the playing field, the number of Legos you have available to you when you're designing a system is huge. If you look at that CNCF page that describes the applications that are under the Cloud Native Computing Foundation, I think there must be 50 logos on that page. And I feel like it's just seeing this explosive growth. If you use the Kubernetes ecosystem, it's just a barometer for the growth of this type of cloud architecture, I guess. It's exploding. And by next year, we may have twice as many. So you've got all of these Legos that you're trying to keep track of and to me—from the outside, because it's not my full-time job, as it is yours—it just looks so hard to keep up with. I would rather try to keep up with JavaScript's ecosystem. Bobby Tables: That's such a good way to compare that. It's interesting that you said Legos, because I talk about this a lot—where if you go to Legoland and you stand very far away, it looks like these sculptures that they're making with Legos have a curvature to them. But if you get close enough, it's still jagged lines. If you put your hand on it, it's still pretty uncomfortable. You still wouldn't want to step on that sculpture. With these Legos, you're able to make these extremely elaborate systems with all these pieces now. But the problem is you're just making it an extremely complex system. And if you don't have a framework or mindset to really manage that system—if you're not really setting up your team for success to manage that system—you're almost doomed. I think a lot of the Kubernetes architecture and all of the other projects around the CNCF; service meshes are becoming a huge thing, right? I just had another layer of complexity, and how do you even graph how a request gets to a process anymore? It's becoming insane as compared to 16 years ago, where I have Apache and I have a little PHP thing listening on port 5,000, whatever it was. It's just so different. Jonan: Back in the day, I used to have to sew together a request myself using a request ID. I would find the app at the front where the user logged in and get the request ID, if we had a request ID and I hoped we did, so I'm not correlating timestamps across microservices. And I'm still searching logs for that request ID and sewing it. And that's all gone now. And we just keep building abstractions that make everything easier. Bobby Tables: And I can speak from experience with FireHydrant. You almost have to build these things from the start now. You kind of have to have this architecture that is going to have a request ID at the load balancing glare that's going to propagate all the way down into pub/sub. Diagnosing these problems is becoming very, very hard. And that's why service-oriented architecture, while it is good for a lot of companies, it's probably not a good idea to really start with. We started with a model. I came from a microservice architecture for my last two companies, and we said, \"Nope, we're going to do a monolith,\" because if something breaks, guess what? You can only break in one place. So, we're going to go there. Jonan: Service-oriented architecture is designed to address pain. And if you don't have the pain yet, then you don't know correctly which pieces to extract. Bobby Tables: Right. And I think that one of the interesting things about architecture that's not talked about enough is that it should follow a lot of the same principles used in good, object-oriented programming. We have solid principles. We have domain-driven design, single responsibility principle. You talk about open-close, dependency inversion. But we don't talk about those same concepts in architecture, which is totally realistic to do. Why can't we have a system that is open-close where we can add a service that extends the functionality of the system? Why can't we do a Liskov substitution where—because we have such a well-defined API for this service—we need to make it a little faster so we swap it with go app, but because it has the same API signature, consumers don't care. We don't talk about architecture and design enough. I think we just throw services at the problem and we redesign the endpoint every time differently—every single time—and we end up with these spaghetti monsters. Uber is even talking about this right now. They have a new blog post about that. I think it was some crazy style, one service to three engineers, and Uber has thousands—thousands—of engineers. Could you imagine doing that? Jonan: I cannot imagine what it's like to be on an engineering team inside that company. I think it has to do with the very, very rapid growth that they experienced. They exploded overnight. They're producing a lot of interesting technology. They have one of the more popular backends for Prometheus. So Prometheus is an application that pulls your applications. So rather than me, when I process a payment for customer Bobby Tables, rather than me calling out to some metrics endpoint and saying, \"Hey, Bobby just paid us $10,\" I just kind of write that locally to some temporary store, and Prometheus comes along every minute or so and pulls an endpoint on my payments application. It gets all of the data of all of the metrics that I've recorded, and it stores them. But Prometheus is not designed as a project to hold that data long-term. It takes it and puts it into a backend store. And Uber M3, I think, is the name of it. Does that sound right? Bobby Tables: Yeah. M3 does sound right. Jonan: That's one of the backends for this. So then Prometheus will use Uber's M3 open source project to store that data longer term. Those kinds of technologies—if you look at the number of time series backends that are available for Prometheus, there's 100 right now. The products that I know of that do the thing you're doing, there's one unified product for handling incident response. So my actual question is not, \"Hey, name all your competitors,\" but why is that not more at the forefront of people's minds? Because it's a thing everyone deals with, right? Every SRE I've ever worked with had the run books and the systems, but it was all hand-rolled. They all had customized artisanal processes. And you're handing a company a whole process in a box. Why isn't that more common? Bobby Tables: That's a great question. I think that FireHydrant can exist today because we've standardized so many other things. Yes, things have gotten more complex, and Kubernetes has started to definitely dominate the way that a lot of modern application architectures are built. I think every major Fortune 100 right now said that they're experimenting with Kubernetes. I remember some article about that, some insane stat. And I'm talking about that because I think it's the same way that FireHydrant can exist today. We started standardizing on so many things in the last 10 to 15 years. Containers exist because we were able to standardize on a format. Docker created this standardized, portable format. Without that standardization, what would Kubernetes do? Because all these abstractions with really well-defined interfaces started to exist, Kubernetes was able to come in and bundle those things together. FireHydrant's the same thing. We had DevOps, and then SRE started to become prominent in the space. I think a lot of organizations are thinking about reliability in a more structured sense. And then we also had people standardized on a chat tool. A lot of the world has moved to Slack. Jonan: I agree with you 1,000%. I know that you are a fellow Rubyist, so I want to take a minute to appreciate what value comes to a community by having an opinion. I think Rails did an amazing thing in getting a lot of programmers to swim in the same direction at the same time. There is definitely something to be said for standardization, the open telemetry change that has come recently where we now have one way to report metrics. I worked with New Relics’ proprietary format back in the day. I would much rather have a metrics format that everyone can use, that we can all interoperate with, right? I feel like we're reaching a point with the DevOps ecosystem and the SRE ecosystem, that we are now learning the value of standardizing how we build these things and how we respond to these things. So if I were to ask you to make some predictions for the future, what's it going to be like in your space in a year? So in a year, I can call you up to be on the podcast and we'll tell you how wrong you were. Bobby Tables: Yeah. I'd love that, set a reminder. I have two predictions that I'm actually not making up on the spot. I've been thinking about this a lot. One of them is that we're going to hit a point where service-oriented architectures are becoming incredibly cumbersome and super complex to the point where we're going to need to get away from Google Sheets as the de facto way of listing the services we're running and who owns them. So I think that we're actually going to see a lot of tools come into play for cataloging the services we're running in production. Because there are a lot of challenges that come with running multiple services that are not just around engineering operations. It's a question of, “How do you make this compliant?” For SOC compliance, you have to log when you deploy a lot of the time. You have to have a deploy log. And when you have 100 services deploying multiple times a day, where does that information go? What is the service? And then people are going multi-region, multi-cloud, even—how do we know where the services are running? That's a challenge that needs to be solved. A lot of companies just have YAML and a GitHub repository to represent that catalog, and that's not going to be sufficient as the year progresses. Jonan: I think it's particularly relevant to what you do in incident response. If there's an incident, what I want to know right away is what things have changed in the last 24 hours, or one hour, or 10 minutes. What things in the system changed? Because I know enough about computers to know that if you don't poke the bear, it just keeps sleeping. Don't change anything ever, right? So you've got to find those changes. And I think service discovery and those kinds of things are really important to doing that. So your prediction for the next year is that we will have some popular player in the ecosystem or some project that does that service discovery well. And, in an opinionated way, that starts to dominate as the standard? Bobby Tables: Yeah. Startups and venture capital—as annoying as it might be— are really good indicators of what's happening. If you look at the last six months, a lot of service catalog startups have been coming out where it is their sole responsibility to list the services you're running and the changes that they've recently had. So, it's happening. The challenge is becoming, “How do we define even what a service is?” We're going to start seeing that challenge. And I'm hoping that the CNCF or some governing body creates a definition of what a service is. Is a load balancer that we don't run a service? If you ask me, that is a service, because your customers don't care that it's on Amazon's ELB, but it's a service that you run. I think that we're going to need a well-defined version of what a service is and have a spec for it, an actual RFC of what a service is. I think what's going to come with that—or hope so—we need a generalized labeling standard. The labels are all over the place. Every major cloud provider, every major metrics consumer—New Relic being one of them—every single one of these services has a way to tag and annotate things. But there is no definition that says what the keys should be and what the value should be for a service. So I really hope that happens. We're going to have someone define a standard set of labels. You could call it “CNCF Labeling Project,” for all I care, that says the name of the service, the purpose of the service, the component that it powers, the team that owns it, and other key value pairs along those lines. And if you think about the value that provides—if I say I have this key value system that I can then add to my ELB in Amazon, because Amazon supports tags, and then I have my deployment reference in Kubernetes that has annotations, and I have a metric that comes out and that has a key value pair—if I have a way to slice down all of those keys across the entire request cycle from ELB to deployment to metric, that enables a crazy amount of observability that we don't have today. It's cobbled together. So I think that we're going to see a service catalog come out. And I think to make that a reality, we're going to have to see a labeling standard come out. That will actually be a really interesting turning point for observability and linking that to the services that we've run in a standardized way. Jonan: I think that's a wise prediction, and I think it’s the most likely to happen so far in the brief history of Observy McObservface. This now being our third episode, that's quite an honor. We've had many predictions already, but you win the prediction game for now. Bobby Tables: Maybe I'll write it now to prove a point and say, \"Yes, it happened.\" Jonan: That should be a blog post. While we're on the subject, you made a blog post about how to make an old-fashioned, is that right? Bobby Tables: I did. Jonan: And was there fire in it? Did you use... you burned your... Bobby Tables: I did, from the back of an orange. I forget the name of the technique, but you can slice off what's called a “coin” on an orange and apply some flames to it as you squeeze and extract some of the oils from the orange and that kind of inserts it into the drink. So that gives it a nice orangy tone. Jonan: I appreciate this very much. I feel like the old-fashioned has become a developer drink somehow, but everyone has an opinion about that. I know software developers who craft their own bitters from scratch. I'm from Portland, and we just do that kind of stuff up here, but still very into the artisanal handcrafted. But I don't think people should be into our artisanal handcrafted incident response, and I'm really glad your company exists. I will repeat my prediction for the episode, which is that you're going to get bought out in a year and a half maximum, and you're going to stop taking my calls. But I really appreciate you taking this one and being on this podcast with me. It's been a real pleasure having you, Bobby. Thank you so much for joining us. Bobby Tables: No, the pleasure is mine. Thanks for reaching out, and I'm always happy to talk to the community. And the real goal for us is to just make developers happier with our tool, so if we're able to keep doing that forever, that's a win for me. Jonan: I am all about developer happiness. That's what I want to do with the rest of my life. Tell us where we can find you on the internet? Bobby Tables: I don't say too much, but you could find me on Twitter, @bobbytables. I'm also on github.com/bobbytables, happy to chat with anyone, if anything I said sounded interesting. Jonan: Awesome. Thank you so much. I'll see you again soon. Bobby Tables: Thank you. Listen to more Observy McObservface episodes. Related Topics Culture By Jonan Scheffler Jonan spends most of his time staring into tiny boxes and pushing buttons. He likes Ruby, Go, machine learning and playing with robots. Follow the author Jonan Scheffler on Twitter Jonan Scheffler on GitHub Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.99046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Culture Observy McObservface Episode 3 - Firefighting and DevOps: The Platypus Incident Aug 5, 2020 • 22 min read By Jonan Scheffler This week we were joined by Bobby <em>Tables</em> of Firehydrant.io, a world"
      },
      "id": "6076287c28ccbc258751c197"
    },
    {
      "sections": [
        "Basic doc template",
        "Section example",
        "Code example",
        "List example",
        "Table example"
      ],
      "title": "Basic doc template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "8949f5c550b7fcab6ec76ca68fa8dd5ec2ed188f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/article-templates/basic-doc-template/",
      "published_at": "2021-04-16T01:34:17Z",
      "updated_at": "2021-04-05T08:04:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the formatting tips in this template to organize the docs you create on the Docs site. Then replace the template information with your own text, lists, and tables as needed. Before you create sections, start your doc with a brief introduction, usually no more than a paragraph, that helps readers understand what your doc will cover. Your introduction (and the structure of your doc) should help readers understand within ten seconds whether they are in the right place. Section example Begin each section with a meaningful H2 title. The Docs site uses these to generate the contents, which appears automatically in the left navigation. If you want to include a screenshot with the section, provide a permalink for the Docs team to create the image for you. Due to security requirements, the Docs team manages all images on the Docs site. Code example def article_url(category, article, options={}) url_for(options.reverse_merge( :controller => 'articles';, :action => 'show', :category => category, :article => article )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add require('newrelic'); as the first line of your app's main module. Use the command npm install newrelic --save for each application you want to monitor. For unordered lists, use bullets (ul in HTML or * in Markdown). For example: Black White For complex lists, consider using collapsers. Table example Tables help organize detailed lists so the information is easier to skim. Tables are easier to manage in HTML. For exammple: <table> <thead> <tr> <th width={200}> **Item** </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Some thing </td> <td> More detailed information about it </td> </tr> <tr> <td> Another thing </td> <td> More detailed information about another thing </td> </tr> </tbody> </table> Copy Tables created in Markdown use three or more hyphens --- to create each column’s header, and pipes | to separate each column. For example: | Item | Requirements ------------ | ------------ | Some thing | More detailed information about it | Another thing | More detailed information about another thing Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.66397,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Table</em> example",
        "body": "This is a template. Feel free to copy the formatting tips in this template to organize the docs you create on the Docs site. Then replace the template information with your own text, lists, and <em>tables</em> as needed. Before you create sections, start your doc with a brief introduction, usually no more"
      },
      "id": "6042212b64441f49134e886d"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "2cac8412532ee9578450ad37065c796fe46df3d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/quick-reference/tables/",
      "published_at": "2021-04-16T06:40:39Z",
      "updated_at": "2021-03-16T13:40:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the Docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 72.228745,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Tables</em>",
        "sections": "<em>Tables</em>",
        "body": "<em>Tables</em> help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the &quot;five to nine&quot; guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it&#x27;s a specific file name"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    }
  ],
  "/build-apps/ab-test/publish": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 296.45645,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", no matter how complex. You can: Use our APIs to get data into <em>New</em> <em>Relic</em> from any source. Visualize that data in <em>your</em> custom applications. <em>one</em>.newrelic.com: Here’s an example of a custom <em>application</em> built on <em>New</em> <em>Relic</em> <em>One</em>. This <em>application</em> gives a highly detailed analysis of a website, using"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-16T22:12:16Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.1329,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.12158,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.11694,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.11694,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/build-apps/ab-test/subscribe": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 294.37476,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", no matter how complex. You can: Use our APIs to get data into <em>New</em> <em>Relic</em> from any source. Visualize that data in <em>your</em> custom applications. <em>one</em>.newrelic.com: Here’s an example of a custom <em>application</em> built on <em>New</em> <em>Relic</em> <em>One</em>. This <em>application</em> gives a highly detailed analysis of a website, using"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-16T22:12:16Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.07355,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use tags <em>to</em> define the workload content",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.06232,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.05768,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.05768,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/build-apps/ab-test/serve-app": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 296.45645,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em> ",
        "sections": "Build a custom <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", no matter how complex. You can: Use our APIs to get data into <em>New</em> <em>Relic</em> from any source. Visualize that data in <em>your</em> custom applications. <em>one</em>.newrelic.com: Here’s an example of a custom <em>application</em> built on <em>New</em> <em>Relic</em> <em>One</em>. This <em>application</em> gives a highly detailed analysis of a website, using"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Use workloads",
        "Create a workload",
        "Use tags to define the workload content",
        "How the dynamic query logic works",
        "Add dashboards to workloads",
        "Use the API"
      ],
      "title": "Use workloads",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "c39090bde9b797940e7f5ba0c9610ba39879677b",
      "image": "https://docs.newrelic.com/static/14c811e218cfc8793bb4d2bd4b2aad0b/c1b63/new-relic-workloads-add-dashboards.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/use-workloads/",
      "published_at": "2021-04-16T22:12:16Z",
      "updated_at": "2021-04-12T03:03:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view workloads, go to one.newrelic.com and find them on the Explorer. There are two main tabs, Health and Activity, plus the header. The Health tab in a workload provides relevant status data that helps you operate the workload: It shows the global status of the workload, as well as the individual status of all the entities that make up the workload at each point in time. It looks like this: It comprises the following: The navigator view shows the entities that make up the workload, and provides controls to group and sort them. If you’ve used queries to dynamically select entities, the workload entities will change over time. The workload status informs about how your workload is performing, based on the individual alerting status of the entities in your workload. With health over time you’ll see whether and how the workload status has changed in the past three hours. If one or more entities are alerting, you’ll get a count of criticals and warnings and a summary of the open conditions, which will make it easier to identify and troubleshoot the most important issues. The Activity tab shows performance data related to the entities in the workload, along with the events that could explain any changes in those time series. It looks like this: Here's the most important sections: Linked dashboards. You can add links to dashboards from your workload, and create pre-filtered, workload-relevant links to dashboards. Golden metrics. These are charts with the most relevant metrics for each entity type, such as number of requests, response time, and error rate for an application. Explore the charts to detect correlations among different entities (for example, two applications) and different stack layers (for example, applications and hosts). The golden metrics that you see for each entity type on a workload can be customized either at the account or the workload level through the NerdGraph API. Events timeline. This includes the start and end time of incidents and anomalies that refer to the workload entities. It also shows other event types that can explain a change in the status or performance of the workload, such as deployments and configuration changes. Finally, the header contains the filter bar and the edition controls: Filter bar. Use the advanced filtering options when you need to focus only on certain entities within the workload. Edit workload. Define the entities that are part of the workload, and the accounts they’ll be fetched from. Setup status. Configure how the global workload status will be determined, based on the workload entities health. Summary page. See all the tags that have been added to the workload, as well as metadata such as the workload's identifier (GUID) and account. Create a workload A workload should contain the entities you and your team want to see. Your choice of entities depends on your organization structure and goals. one.newrelic.com > Explorer > Workloads > Create a workload: When you create a workload, you choose the associated accounts and monitored entities. You can use New Relic One or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to one.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name that will be meaningful for you and your team later. From the Select an account dropdown, select the workload account you'd like to use. Click Choose the scope accounts to check all of the accounts related to this workload. Find and choose the entities that make up the workload. When you have the results you're looking for, you can add specific entities or add the query to dynamically update the entities in the workload. You can search by entity type, tags, or attributes (like entity name, account ID, and AWS region). Click + Add this query to create a list of dynamically updated entities for your workload. We recommend this if you want your workload to update its entities as your system changes. Click + Add next to an entity to add it to your workload. This is a good choice if you know that the entities will stay useful even as your system changes. You can add a combination of queries and specific entities to the workload, which combine according to the query logic. Click Create a workload to save the workload. Once you've created the workload, you can edit it at any time If your workload contains one or more dashboards, you can set filters on those dashboard links. Below are more details about some aspects of how to define workloads: Use tags to define the workload content You can query and select workload entities using both tags and attributes. Therefore, to optimize your use of workloads, it helps to have a good entity-tagging strategy. We recommend reading the tagging documentation. How the dynamic query logic works You can add several individual entities and queries to define a workload. Queries can include multiple search terms. These are combined with an AND operator. Separate queries within a workload are combined with an OR operator. You can wrap strings between percent signs (%) to match exact substrings within a query. If you use substrings in entity names to categorize those entities (for example, <team>-<env>-<appName>), consider using tags complementarily, which are more powerful for filtering and grouping (for example, team:awesome, env:production). We recommend not to use percent signs (%) in dynamic queries that might return over 500 entities. This way, you get a more consistent experience in the user interface. Add dashboards to workloads If you have custom dashboards and you already know which data is relevant to your team for observing and operating their workloads, you can link those dashboards from your workload. You can also set filters on dashboards to scope them to a workload-specific context. When a user selects that dashboard from the workload, it opens with the filter already applied. one.newrelic.com > Apps > Workloads: You can add dashboards to a workload. To add dashboards to a workload: When creating or editing a workload, type Dashboard in the workload search bar to filter to dashboard entities. Add other search terms to filter to specific dashboards. Click Add. one.newrelic.com > Apps > Workloads: You can set filters on the dashboards you've linked to a workload. To filter a workload’s dashboard: From a workload’s Overview page, select a dashboard. Add search terms to filter the dashboard to a view that’s relevant for that workload. Select Save filter for this workload. Use the API You can query, create, and update workloads with our NerdGraph API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.1329,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": " choose the associated accounts and monitored entities. You can use <em>New</em> <em>Relic</em> <em>One</em> or the NerdGraph API to create a workload. Follow these steps to create a workload using the UI: Go to <em>one</em>.newrelic.com and click on the Explorer, and then click + Create a workload. Give the workload a name"
      },
      "id": "603e81e8196a67c972a83db1"
    },
    {
      "sections": [
        "基本的なUIの機能",
        "プラットフォームを観察する",
        "アカウントとエンティティの検索",
        "チャートおよびクエリ機能の使用",
        "チームメートと共有",
        "円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス",
        "アカウントの調整とユーザーの設定",
        "その他のヘルプ"
      ],
      "title": "基本的なUIの機能",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "ea7bdaa1c695b3f388b4dcbef5eeff2cc0d5259f",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-04-16T03:37:31Z",
      "updated_at": "2021-04-12T03:01:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneの基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する New Relic Oneを使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。one.newrelic.comでNew Relicエクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 New Relic UIの先頭で、主な検索にアクセスできます。検索についての詳細： クロスアカウントアクセスを使用して、すべてのNew Relicアカウントを検索できます。 廃止されるエンティティは、8日間は検索にヒットします。 組織に複数のアカウントがある場合、左上のアカウントピッカーを使用してアカウントを選択します。 チャートおよびクエリ機能の使用 大半のチャートは、新規または既存ダッシュボードに追加できます。すべてまたは大半のプラットフォームで利用可能なクエリおよびチャートの機能は次のとおりです： 以下を行う場合... 操作... データのクエリの開始 カーソルをデータのブラウズの上に移動し、メトリクスやイベント、ログ、トレースを選択して、そのタイプのデータに直接アクセスします。 また、UIページの先頭で、データをクエリを選択して、データエクスプローラーとクエリビルダーにアクセスします。 チャートのクエリの表示 一部チャートでは、そのチャートの生成に使用したNRQLクエリを表示できます。この機能を利用することで、チャートの理解が深まるか、新規クエリの根拠に利用できます。 時間範囲を選択 チャートの一部をドラッグし、その時間範囲で拡大します。また、UIの右上隅にあるタイムピッカーを使用して、事前に設定された時間範囲を選択、またはカスタムの設定を行います。 チャートの詳細を表示 マウスをチャートの上に移動すると、詳細がポップアップ表示されます。一部のチャートでは、チャート上のある点を選択すると、そのメトリックについての詳細情報が記載されたUIページに移動します。 チャート要素を非表示にする、または返す 表示されたチャート要素を非表示する、または非表示を解除するには、チャートの下にあるその要素の名前を選択します。チャート表示は、その要素の有無に合わせて調整されます。 チームメートと共有 New Relic UIと可視化の共有のオプションは次のとおりです。 以下を行う場合... 操作... UIページとダッシュボードを共有する New Relic UIページ全体を共有するには、UIの先頭の近くにある共有をクリックしてURLをコピーします。 チャートを共有する New RelicのチャートがNRQLクエリを使用して作成されている場合、画像として取得やチャートリンクを取得などの共有オプションを含むさまざまなオプションを表示する メニューがあります。 共有についての注： 共有相手の人物は、アクセスしてそのアカウントからのデータを表示できません。これを解決するには、New Relicユーザー管理機能を有するチームの他のユーザーが、その人物をアカウントに追加する必要があります。 カスタムダッシュボードにアクセスできない場合、プライベートに設定されている可能性があります。詳細については、ダッシュボードの許可をご覧ください。 一部の共有オプションには、関連する時間範囲があり、これが後で表示に影響を与える場合があります。たとえば、チャートのチャートリンクを取得オプションを使用し、そのチャートが「直近30分」に設定されている場合、表示すると、共有時に表示された時間範囲ではなく、直近30分が表示されます。特定の時間範囲を共有するには、UIでその時間範囲を選択する必要があります。 円滑なナビゲーション：バーをカスタマイズし、ショートカットにアクセス ナビゲーションバーの右側にある編集 アイコンを選択して、表示をカスタマイズします。ホームとエクスプローラー、ブラウズデータ、ダッシュボード、アラートとAIは固定ですが、お気に入りの要素を最大で6個追加し、バーで表示することもできます。残りは詳細グループに移動します。 ナビゲーションのショートカットを使用して、関連するエンティティやアプリを迅速に検索できます。メニュー項目の上にカーソルを移動して、お気に入りのエンティティや直近閲覧したエンティティにアクセスするか、特定のセクションに移動せずに検索を行えます。エンティティをクリックすると、同じブラウザタブで開くか、または新規のタブで開くかを選択できます。 アカウントの調整とユーザーの設定 アカウント設定とユーザー設定を変更し、サポートとドキュメントリンクを取得するには、ユーザー名の隣の、UIの右上にあるアカウントドロップダウンを使用します。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.12158,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>の基本的なUI機能は、プラットフォーム全体で広く利用できます。こうした機能を理解することで、貴社のデータの発見・分析がさらに容易になります。 プラットフォームを観察する <em>New</em> <em>Relic</em> <em>One</em>を使用して、スタック内のすべてのエンティティからデータへのフルアクセスが可能です。<em>one</em>.newrelic.comで<em>New</em> <em>Relic</em>エクスプローラーに移動し、エンティティのフルリストを表示し、動作全体を特定し、フィルタを適用してパフォーマンスの問題の源を検索するか、システムの改善の計画を作成します。 アカウントとエンティティの検索 <em>New</em> <em>Relic</em> UIの先頭で、主な検"
      },
      "id": "60536451196a67366a2d167b"
    },
    {
      "sections": [
        "New Relicの概要",
        "ヒント",
        "一貫性が高く一本化されたプラットフォーム",
        "コンテキストを素早く理解",
        "関係性と依存関係を理解する",
        "データのクエリを容易にする",
        "ダッシュボードの拡充",
        "New Relic Oneで構築",
        "次のステップ",
        "その他のヘルプ"
      ],
      "title": "New Relicの概要",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "d7291efe1d84143b996efe72253be22af57b4949",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Oneは、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 New Relic Oneにアクセスするには： one.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、one.eu.newrelic.comに移動します。 ヒント New Relic One、およびその他のオブザーバビリティプラットフォームを使用するには、New Relicファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成できます。次に、毎月最大で100GBのデータを無料で取り込みます。期間無制限です。 一貫性が高く一本化されたプラットフォーム New Relic Oneのリリース前は、当社のプラットフォームはAPMやBrowser、Mobileなどさまざまな製品に分かれていました。New Relic Oneに移行することで、システム全体からすべてのデータをより簡単に表示しインタラクションを行えます。 詳細については、New Relic One移行ガイド をご覧ください。 コンテキストを素早く理解 New Relic Oneは、複雑な内容を省略して貴社とチームにコネクテッドなビューを提供し、以下を可能にします： New Relic Oneのフロントドアとして、New Relicエクスプローラーを使用する：システムのすべてのエンティティから、パフォーマンスデータを観察、グループ化し、フィルタリングを行います。New Relic Navigatorを使用して、すべてのエンティティの密度の高い概要が得られるので、問題を一目で検知できます。New Relic Lookoutは、直近動作の乖離が起こっているエンティティを表示します。 タグを使用して、環境の整理とデータのより効果的な管理を実現。タグを使用して、監視内容の関係性とコンテキスト情報を図示します。エンティティへのタグ付けを慎重に行うことで、チームは複雑さと相互依存性のますます高まるシステムにおいて、必要なあらゆるデータを結び付けることができます。 組織全体にまたがるエンティティやダッシュボードなど、監視している全ての内容を一カ所に表示します。クロスアカウントアクセスによって、あらゆる種類のデータをまとめながらも、容易に見つけられるようにします。 あらゆるエンティティをワークロードで部門チーム志向またはプロジェクト志向のグループにグループ化。 固有のニーズに合わせてカスタムダッシュボードを調整できます。ビジネス上のニーズを一目で確認できるビジュアルを作成し、貴社の専門知識を最大限に活かしましょう。 クエリの作成および編集過程でデータ定義を表面化させるクエリビルダーを使用して、クエリの際により多くのコンテキストを入手できます。 関係性と依存関係を理解する 依存関係を理解できる、複数の方法を用意しました。これで、全ての組み合わせを簡単に理解し、問題をトラブルシューティングできます。 以下を行う場合... これを使用 システムの全体像を表示し、パフォーマンスの詳細を掘り下げて把握します。 New Relicエクスプローラーを使用して、監視しているすべてのアプリケーションやサービス、ホスト、コンテナからパフォーマンスデータにアクセスします。ソリューション内の各エンティティやアラートステータス、エンティティがどのように接続されているかを、詳細に可視化します。 貴社システムの各部分がどのように結びついているかを確認する。 サービスマップは、アップストリームおよびダウンストリームの依存関係を図示します。 全ての監視内容を整理し、エンティティにコンテキストを提供する。 全てのエンティティにタグを付けます、 API経由で全てがどのように繋がっているかを理解する。 NerdGraph GraphiQL Explorerは貴社のエンティティ、タグ、関係性を全て管理します。 複雑な環境でサービスまたはダッシュボードを見つける。 統合検索で全てのアカウントを名前別に検索するか、エンティティエクスプローラーをタグまたはテキスト別にフィルタします。 サービスに関する全ての依存関係一覧を表示する。 エンティティサマリの依存関係表示タブは、表示しているエンティティに関する全ての依存関係を示します。 分散システム全域を移動するアクティビティを追跡する。 ディストリビューティッド（分散）トレーシングは、現代組織の分析を支援します。 組織全体の具体的なエンティティの責任をどのチームが負っているか理解する。 監視しているチームと全てのサービスにタグを作成します。 データのクエリを容易にする すべてのUIページの先頭で、データのクエリを使用できます。クエリ言語の習熟度によらず、カスタムのクエリとチャートを作成できます： データエクスプローラーで、クエリを行わずにデータのブラウズを行います。 NRQL（当社のクエリ言語）の専門知識を使用して、NRQLモードクエリビルダーでカスタムチャートを作成します。 クエリビルダーで、PromQLスタイルのクエリを実行します。 ダッシュボードの拡充 one.newrelic.com > Dashboards: New Relic Oneのダッシュボードでは、情報の密集したカスタムビューから最も重要なデータを迅速に導きます。 New Relic Oneダッシュボードでは、より簡単に視覚化を改善でき、カスタマイズの選択肢が増加しています。ダッシュボードには、次の機能が含まれます： クエリビルダーを使用することで、NRQLクエリを実行し、プラットフォーム内のあらゆる場所にチャートとダッシュボードを作成します。 クイックアクセスCRUDメニューと編集オプションによって、チャートとダッシュボード管理を容易にします。 高度なツールチップとズームイン機能でデータの追求とコンテキスト化を行い、貴社のシステムのリアルタイムのアクティビティを監視できます。 ダッシュボードで属性とメトリックスを検索します。 エージェントやインテグレーション、APIを使用して、ダッシュボードにデータを送信します。 ダッシュボードまたはチャートを.pdfで共有するか、外部サイトにチャートを埋め込みます。 ヒント 以前にNew Relic Insightsを使用してダッシュボードを作成した場合、New Relic Oneダッシュボードとして使用できます。 New Relic Oneで構築 カスタムチャートとダッシュボードで現在の問題が解決しない場合、次のようなReact JavaScriptアプリケーションを構築するためのフレームワークを提供します。 貴社のその他のNew Relicがモニターするデータとともに、New Relic Oneプラットフォーム上に存在する。 高度にカスタマイズされた可視化機能を備える。 New Relicが監視するエンティティ、またはサービスやAPIからのデータなど、貴社が望むソースからのデータを表示する。 コミュニティが構築したオープンソースアプリを使用し、自身のオープンソースアプリを作成できます。 詳細については、New Relic Oneアプリケーションをご覧ください。 次のステップ New Relic Oneについての理解を深める: データエクスプローラーでどのデータを使用できるかを確認する。 エンティティエクスプローラーでモニターしたエンティティのブラウズを行う。 NerdGraph APIを使用してデータにタグを追加する。 ダッシュボードの詳細を調べます。 その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.11694,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>の概要",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em>で構築",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em>は、当社のテレメトリーデータプラットフォーム、Full-Stack Observability機能、インテリジェンスの応用機能にアクセスできるプラットフォームです。 <em>New</em> <em>Relic</em> <em>One</em>にアクセスするには： <em>one</em>.newrelic.comに移動します。 または、EUデータセンターにデータをレポートする場合は、<em>one</em>.eu.newrelic.comに移動します。 ヒント <em>New</em> <em>Relic</em> <em>One</em>、およびその他のオブザーバビリティプラットフォームを使用するには、<em>New</em> <em>Relic</em>ファミリーに参加してください。サインアップして、わずか数秒で無料アカウントを作成で"
      },
      "id": "6052b11f196a6772252d168c"
    },
    {
      "sections": [
        "New Relicにおけるエンティティとは？",
        "エンティティとは？",
        "エンティティを見つけて詳しく調べる",
        "ヒント",
        "エンティティ関係",
        "重要",
        "エンティティをグループ化して整理する",
        "その他のヘルプ"
      ],
      "title": "New Relicにおけるエンティティとは？",
      "type": "docs-jp",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "cf09fbb66008ae40d63068e8647302b7630263c3",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-04-16T22:11:13Z",
      "updated_at": "2021-04-12T03:00:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relicモニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ New Relic製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きなグループを指すこともあります。例えば、データセンターを監視するには、こうしたホストをNew Relicに集計して、ワークロード（エンティティのカスタムグループ）にすることができます。このワークロード自体もまた、エンティティになります。 「エンティティ」の概念的な定義は、なぜ重要なのでしょうか。それは、New Relicの目標が、役立たない大量のメトリックスとデータを提供するのではなく、貴社のビジネスにとって重要なエンティティステータスに関する実践的情報を提供することにあるためです。エンティティ自体、そしてエンティティ同士の関係性にフォーカスすることで、弊社は現代の複雑なシステムの監視とトラブルシューティングを最適化します。 エンティティを見つけて詳しく調べる エンティティとは、New Relicにデータを報告するあらゆるものを指すため、New Relicでデータが報告されているのを見た場合は必ずエンティティを見つけることができます。 ヒント 新規エンティティタイプを作成し、データソースをモニターできます。エンティティの統合の詳細をご覧ください。 以下は、エンティティデータの発見と理解に役立ついくつかのポイントになります： エンティティの一意のグローバル識別子（GUID）を検索するには：New Relicエクスプローラーでモニターされたエンティティのリストで、特定のエンティティの上にカーソルを移動し、 アイコンをクリックしてGUIDとその他のメタデータを表示します。 エンティティのGUIDは、属性 entityGuidとしてレポートされます。クエリビルダーでこの属性を使用して、エンティティのクエリを行えます。 New Relicエクスプローラーやサービスマップ、ディストリビューティッド（分散）トレーシング、GraphQLの関係APIで関連エンティティ表示を使用し、エンティティ間の接続を表示します。 NerdGraph GraphiQLエクスプローラー（api.newrelic.com/graphiql）を使用して、エンティティデータを調査します。 エンティティ関係 エンティティ間の接続は、テレメトリーから推測可能なものに基づき、New Relicが自動的に作成します。たとえば、HTTPを使用して通信を行う2つのサービスがNew Relicでインストゥルメントされる場合、それらの間で「呼び出し/呼び出され」関係を推定します。 New RelicエクスプローラーまたはNavigator、Lookoutのいずれかで単一のエンティティを表示する場合、エンティティの簡単な概要で関連エンティティを表示できます。関連エンティティは、重点を置いている現在のエンティティに直接接続しているさまざまなエンティティを表示するものです。スタックのすべての接続された部分を通じて、これらの関連エンティティの重要なメトリクスを迅速に表示し、1つのエンティティから別のエンティティに移動できます。 ヒント NerdGraph APIを使用して、エンティティの関係の詳細について知ることができます。 関係が自動的に検知されない場合、関連エンティティにある「関連エンティティを追加/編集」リンクを使用して、手作業で作成できます。 重要 現在、サービスエンティティ間の呼び出し/呼び出され関係のみ、手作業で作成できます。 ヒント 手作業で関係を管理するには、エンティティ関係で変更および削除機能を有している必要があります。この機能は、デフォルトでユーザーロールに許諾されています。 エンティティをグループ化して整理する エンティティをグループ化して、貴社にとってビジネス上重要な関係性を反映させることができます。たとえば、特定のチームまたは部署、あるいは特定のサービスに関連した全てのエンティティをグループ化することができます。あるいは、複数のホストをまとめて、そのグループ化をデータセンターに反映させることもできます。 エンティティをグループ化するには： エンティティにタグを付ける方法 ワークロードを作成（関連エンティティのグループ） その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.11694,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "sections": "<em>New</em> <em>Relic</em>におけるエンティティとは？",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em>モニタリングは、エンティティのコンセプトを中心に構築されています。このドキュメントは、以下について説明します： エンティティとは何か エンティティデータの見つけ方 エンティティの相互の関係 簡単に分析できるよう、グループ化して整理する方法 エンティティとは？ <em>New</em> <em>Relic</em>製品では、エンティティを幅広いコンセプトとして捉えています。エンティティは、モニターできるデータを保持する識別可能な任意の対象です。 「エンティティ」は、アプリケーション、ホスト、そしてデータベースサービスなどの基本的なデータを報告するコンポーネントを指しますが、こうしたコンポーネントのより大きな"
      },
      "id": "60532c4064441f433b5321b9"
    }
  ],
  "/build-apps/ab-test/create-nerdpack": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/New-Relic-One-Catalog.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-5",
      "sections": [
        "Subscribe to applications with the New Relic One Catalog",
        "Observability Maps",
        "Metric Aggregator",
        "Workload Geo Ops",
        "Check out these other resources for using—and building—New Relic One applications ",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "The Most Popular New Relic One Applications (Roundup #5)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "75f80d867fec167c4a6d62082f32cb2ff1ae0802",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #5) Jun 4, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Observability Maps Metric Aggregator Workload Geo Ops Subscribe to applications with the New Relic One Catalog Before we start accessing the applications via the CLI, let’s look at how to access these applications directly within New Relic One. To explore available applications, navigate to New Relic One and click on the New Relic One Catalog launcher. New Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. New Relic One Catalog If you deploy an application from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Observability Maps Observability Maps allows you to create a view beyond a traditional service map. Using Observability Maps, you can connect disparate entities in your environment into ad hoc relationships, creating your own relationships based on data available in New Relic. See your entities and environment in a way that makes the most sense to your team and business. Observability Maps App Fork or deploy the Observability Maps app from GitHub. Specific requirements for this app Requires data in NRDB from any or all of the New Relic products. Metric Aggregator The Metric Aggregator is a New Relic One application that helps you create events-to-metrics (E2M) rules, a real-time streaming service that converts event data into dimensional metrics at ingest. Converting events to metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Metric Aggregator App Fork or deploy the Metric Aggregator app from GitHub. Specific requirements for this app If you use New Relic, you already have New Relic Metrics. You can  create E2M rules immediately. Workload Geo Ops Workload Geo Ops links your workloads (collections of entities) to physical locations so you can quickly identify and resolve incidents. It's a geographic exploration of workload data tied to geographic data, including location metadata. You can define maps and then collect or assign entities to points on those maps. With workloads, a collection of entities can be managed by rules and tags to support the dynamic, ephemeral nature of modern IT infrastructure. Fork or deploy the Workload Geo Ops app from GitHub. Specific requirements for this app To get the most of this app, we recommend that you configure Workloads in New Relic One. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Workload Geo Ops to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One applications  Here are resources to help you build your own New Relic One applications. If you can imagine it, you can build it:  developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. NerdGraph GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity. Application/data access and permissions and security. NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.893036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic One <em>Applications</em> (Roundup #5)",
        "sections": "Subscribe to <em>applications</em> with the New Relic One Catalog",
        "body": " of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to <em>create</em> your own apps"
      },
      "id": "60762e1f64441fbf2e9d856e"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Event-Stream-Screenshot.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-applications-4",
      "sections": [
        "Event Stream",
        "Specific requirements for this app",
        "Neon",
        "Network Telemetry",
        "SLO/R",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:39:54Z",
      "title": "The Most Popular New Relic One Applications (Roundup #4)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "0ac60d545488f3c1904bdd6e0d552af5c307ee5a",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #4) Jan 9, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs different types and combinations of insights into how their apps and systems are performing. That’s why New Relic One is programmable—you can build and deploy custom apps that give you the specific insights and information your company needs. To show you what’s possible—and to inspire you to create apps—we worked with members of the New Relic community to build a handful of open source applications, and the number of newly-developed apps continues to grow. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Event Stream Neon Network Telemetry SLO/R Event Stream During a launch or incident, you need the absolute latest data from your application. Event Stream is like Unix tail for APM data—it pulls in your Transaction and TransactionError data in a live stream, so you can find out exactly what's happening with your app right at that moment. You can also filter and facet the data to show the exact data you need. New Relic One Application Event Stream Fork or deploy the Event Stream app from GitHub. Specific requirements for this app Install the appropriate New Relic APM agent. Neon Need to create a single dashboard to track the health of entire business units or regions? Neon lets you create a status board based on New Relic alerts or the values from New Relic events. Fork or deploy the Neon app from GitHub. Specific requirements for this app To view the status of New Relic alerts, you’ll need to set up a webhook notification channel for the alert policies. See the New Relic documentation to learn more about managing notification channels. Network Telemetry Network Telemetry Screenshot The Network Telemetry app visualizes data collected through the Network Telemetry Infrastructure integration. The integration collects data from network devices that export Sflow or IPFIX network samples, and the app creates visualizations to help you examine the sources and destinations of communication within a network, as well as the volume of traffic between devices. Fork or deploy Network Telemetry from GitHub. Specific requirements for this app Install the New Relic Infrastructure agent, and ensure you have the related access to New Relic One. Install the New Relic Network Telemetry On-host integration.  SLO/R SLO/R Screenshot The SLO/R app calculates service-level objective (SLO) attainment for an application service. It allows you to quickly define SLOs for error, availability, capacity, and latency conditions. By measuring SLO attainment across your service estate, you'll be able to determine what signals are most important for a given service or set of services, developed and supported by a team, organization, or group. Using New Relic as a consistent basis to define and measure your SLOs offers better insight into comparative SLO attainment in your service delivery organization. Note: SLO/R is intended to work with services reporting to New Relic via an APM agent. The service provides an entity upon which to define SLOs. Error budget SLOs are defined directly from APM Transaction events; the other SLO types are defined using New Relic alerts. See \"Creating a webhook to forward Alert incidents to Insights\" for more details. Fork or deploy the SLO/R app from GitHub. Specific requirements for this app Install the appropriate New Relic APM agents. Create a New Relic alerts webhook to forward alert events to a SLOR_ALERTS New Relic database table. See \"Creating a webhook to forward Alert incidents to Insights\" for details. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Event Stream—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-event-stream.git cd nr1-event-stream nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Event Stream to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-event-stream.git cd nr1-event-stream   nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications. If you can imagine it, you can build it: developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.20316,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic One <em>Applications</em> (Roundup #4)",
        "sections": "Specific requirements for this <em>app</em>",
        "body": " and combinations of insights into how their apps and systems are performing. That’s why New Relic One is programmable—you can build and deploy custom apps that give you the specific insights and information your company needs. To show you what’s possible—and to inspire you to <em>create</em> apps—we worked"
      },
      "id": "60762e2028ccbcaf8651c17c"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/attributory-screenshot-main.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-6",
      "sections": [
        "Subscribe to apps in the New Relic One Catalog",
        "Flex Manager",
        "GraphiQL Notebook",
        "Attributory",
        "What are you waiting for? Deploy these apps now.",
        "Check out these other resources for using—and building—New Relic One apps",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:26:51Z",
      "title": "The Most Popular New Relic One Applications (Roundup #6)",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "76394d24aebbff40a68e9bd6a7f867313e814d74",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #6) Jul 2, 2020 • 8 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the visibility and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source, so you can use them out-of-the-box, or submit a pull request for feedback and feature requests. In this edition, we cover three apps that help engineers do their jobs: Flex Manager GraphiQL Notebook Attributory Subscribe to apps in the New Relic One Catalog You can manage and deploy apps directly within New Relic One. To explore available apps, navigate to New Relic One and click on the New Relic One Catalog launcher. From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. If you deploy an app from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Flex Manager New Relic Flex is an application-agnostic, all-in-one tool that makes sending data to New Relic from third party sources easier than ever. Use Flex Manager to simplify the work of creating, managing, and deploying new integrations you’ve built with Flex. Fork or deploy the Flex Manager app from GitHub. Specific requirements for this app Flex Manager requires New Relic Infrastructure and the Flex integration. GraphiQL Notebook GraphiQL Notebook allows you to explore and learn about the NerdGraph—the New Relic GraphQL API—using a Jupyter Notebook style interface. Notebooks intermix GraphQL requests with data exploration links. You can create, update, save, and delete notebooks. You can also export and share notebooks as blocks of Base64-encoded JSON. Fork or deploy the GraphQL Notebook app from GitHub. Attributory Attributory is a dictionary of attributes from your APM, Browser, or Mobile applications stored in New Relic. It displays a list of attributes for each application. When you open a service or application from the entity explorer, you’ll find Attributes Dictionary listed as an application in the left-hand navigation. New Relic stores event data as key-value pairs. Built-in New Relic attributes include the definition of the attribute. For custom attributes, you can choose to add your own definitions. Fork or deploy the Attributory app from GitHub. Specific requirements for this app Applications with New Relic APM, Browser, or Mobile agents reporting into New Relic. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account Once you have these requirements in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Attributory to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One apps Here are resources to help you build your own New Relic One apps. If you can imagine it, you can build it: New Relic Developers: Build applications using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Open Source: New Relic’s open source website makes it easy for you to explore the open source projects we maintain and the open standards projects we participate in. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, review our Contributors Guide. Keep in mind that when you submit your Pull Request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.54741,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic One <em>Applications</em> (Roundup #6)",
        "sections": "Subscribe to <em>apps</em> in the New Relic One Catalog",
        "body": " of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the visibility and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to <em>create</em> your own"
      },
      "id": "60762e1e28ccbcb5fd51c147"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/GitHub-screenshot_02-1024x724.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-2",
      "sections": [
        "Status Page",
        "Specific requirements for this app",
        "GitHub Integration",
        "Agent Groundskeeper",
        "Customer Journey",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:49:01Z",
      "title": "The Most Popular New Relic One Applications (Round up #2)",
      "updated_at": "2021-04-13T23:49:52Z",
      "type": "",
      "external_id": "c03e99006d6ecc7b6219a2bc68dd0428450cdf26",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Round up #2) Nov 7, 2019 • 8 min read By Joel Worrall We hope you've heard the news that the New Relic One observability platform is now programmable. As the central component of an observability platform, we believe programmability gives you the ability to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the art of the possible—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications … and then we (and all of you!) kept going. In fact, new apps are coming in every day. And we hope to see app contributions by New Relic users continue. In this blog series, we’ll highlight the most popular apps available today. The best part: They’re all open source and ready to be deployed right now! In this edition, we cover: Status Pages GitHub Integration Groundskeeper Customer Journey Status Page Status Page aggregates system status and incident summaries, Statuspage.io style, from multiple providers within a single dashboard. Normally, this is information you’d track down one provider at a time, but Status Page makes it easy to check the status of your key dependencies in one place, at a single glance. Status Page brings together system status and incident report data from key dependencies—making it accessible to your team instantly and easily. Fork or deploy the Status Pages app from GitHub. Specific requirements for this app All you need to get up and running are some status pages you’d like to monitor. Popular options include: New Relic BitBucket Google Cloud Platform GitHub Jira Software Also, keep in mind that currently Status Page can pull in data only from status modules backed by Statuspage.io and Google Status pages. GitHub Integration Having the right information at your fingertips makes a big difference when you’re under the gun to understand a service and resolve an incident. The GitHub Integration connects your New Relic One apps and services to the repos containing relevant documentation, readme files, runbooks, and other essential information. Associate any service or application with its GitHub repository as a one-time action, and you can quickly see that application's readme file, as well as a list of active source code contributors. The GitHub Integration gives you quick access to the documentation for an app or service, including relevant readme files. GitHub Integration also displays a list of the most active contributors to a project, giving you easier access to additional problem-solving resources. Using the GitHub Integration involves a simple, one-time association between any service or application, and its repository. You'll also need to create or use a personal access token, as a one-time setup step, to ensure data security and integrity. Fork or deploy the GitHub Integration app from GitHub. Note: Integration with GitHub requires that you create or use a private access token as a one-time setup step. See GitHub's doc on access tokens for full instructions. Specific requirements for this app A GitHub (either public or private enterprise instance) organization and access to New Relic One. The ability to generate a personal access token in GitHub. Agent Groundskeeper Agent Groundskeeper displays real-time version information for the New Relic APM agents running across your software estate. See which services are up to date (with various upgrade SLO time windows), which are out of date, and which have instances deployed with different versions. Quickly and easily zoom in on your estate by filtering on tags, and search by account, language, and app name. Agent Groundskeeper gives you real-time version information for every APM agent running anywhere within an enterprise environment. Fork or deploy the Agent Groundskeeper app from GitHub. Specific requirements for this app New Relic APM Agent(s) installed and the related access to New Relic One. (Recommended) Add customer-defined labels to your APM applications to make use of New Relic One tag filtering. See our documentation here. Customer Journey Think of this app sort of as a NRQL funnel query on steroids. This application is designed to allow devops teams, product managers, and digital marketers to examine a number of pre-defined measures in a side-by-side comparison between cohorts (columns) of users through a set of steps (rows) where ... Rows equal Steps in a workflow Columns categorize a Series or cohort of users Measures define the Stats that you want to observe for each Series and Step The application employs three visualizations to examine, compare, and present its results: Multi-series Funnel: This visualization combines a third-party funnel library with the New Relic One NerdGraph query to execute three New Relic NRQL queries in the same GraphQL request. The results are aligned into one data set that is delivered to the funnel visualization. Data panels: For each row (Step) and column (Series), the app renders a set of measurements (Stat). Those calculations can apply KPI thresholds to color-code the information. Each panel is also clickable, leading to a more detailed overview. Detail Nerdlet: For any Journey, Series, and Step, there's a Nerdlet that will display the more detailed KPIs as well as a timeseries view of the the given Stats for the selected row and column. Customer Journey can apply KPI thresholds to color-code important information. Each panel is also clickable, leading to a more detailed overview.   A Nerdlet will display more detailed KPIs as well as a timeseries view of the given Stats for a selected row and column. Fork or deploy Customer Journey from GitHub. Specific requirements for this app Access to New Relic One. Configuring the journeyConfig.js. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Status Pages—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-status-pages.git cd nr1-status-pages nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Status Pages to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-status-pages cd nr1-status-pages nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app's launcher (unless otherwise noted above). Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications: New Relic Developer Edition: Early access to the Developer Edition of New Relic One gives you a free, personal sandbox account where you can build your own experience with all the available New Relic tools. developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome contributions to any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.28711,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "The Most Popular New Relic One <em>Applications</em> (Round up #2)",
        "sections": "Specific requirements for this <em>app</em>",
        "body": " to a project, giving you easier access to additional problem-solving resources. Using the GitHub Integration involves a simple, one-time association between any service or application, and its repository. You&#x27;ll also need to <em>create</em> or use a personal access token, as a one-time setup step, to ensure"
      },
      "id": "60762e2028ccbcbab751c12e"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/DEPLOYMENT-ANALYZER-SCREENSHOT-1.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-3",
      "sections": [
        "Container Explorer",
        "Specific requirements for this app",
        "Deployment Analyzer",
        "Page View Map",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:25:05Z",
      "title": "Most Popular New Relic One Applications (Round up #3)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "6f0be6c93ebcc052fac27513c1e849c0dfd256e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic Most Popular New Relic One Applications (Round up #3) Nov 26, 2019 • 7 min read By Joel Worrall Hopefully, you’ve heard the news that the New Relic One observability platform is now programmable. As central component of an observability platform, we believe programmability gives you the ability to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the possibilities—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications … and then we kept going. In fact, new apps are coming in every day. And we hope to see app contributions by New Relic users continue. This blog series is our opportunity to spotlight the most popular apps available today from our GitHub repository. The best part: Every app is available under an open source license and can be deployed right now! In this edition, we cover: Container Explorer Deployment Analyzer Page View Map Container Explorer This app includes a launcher that gives you a global view of all containers associated with an account. You can also employ tags to segment and drill down into subsets of your global container inventory. The app also presents container CPU, memory, and disk I/O usage in the form of intuitive and efficient heat map visualizations. Container Explorer presents CPU, memory, and disk I/O usage for all containers associated with an account—displaying this data via intuitive and efficient heat map visualizations. In the New Relic One entity explorer, we provide a nerdlet that will show all of the containers that are running for a selected APM application (service). We can also detect whether infrastructure data is coming from third-party sources and can, if necessary, automatically present this container telemetry in-context. Container Explorer can detect whether infrastructure data is coming from third-party sources—and can, if necessary, automatically ingest and present this container telemetry in-context. Clicking on a node in the heatmap reveals details about that container, and you can also jump to its host in the entity explorer. Clicking on a node in the Container Explorer heatmap reveals details about that container, and users can also jump to its host in the entity explorer. Fork or deploy the Container Explorer app from GitHub. Specific requirements for this app The New Relic Infrastructure agent must be deployed on any host you want to monitor. Note: We generate per-container CPU and other metrics by summarizing all processes in a given containerId. This will, however, report an accurate value only if the agent reports one ProcessSample per process every 30 seconds. Deployment Analyzer Deployments of applications can be risky events, but you can correlate those events to the performance of your applications, using deployment markers in New Relic. This app builds further on this process—enabling teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Deployment Analyzer enables teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Fork or deploy the Deployment Analyzer app from GitHub. Specific requirements for this app You'll need an active New Relic APM Pro subscription in order to access deployment marker functionality. Page View Map This app creates geographic visualizations of New Relic Browser application data using the React Leaflet mapping library. Leaflet is a leading open-source JavaScript library for mobile-friendly interactive maps. In addition to providing a new way to visualize your business data, this app offers a great example of what's possible for developers working with our GraphQL service and a third party library. Page View Map creates geographic visualizations of New Relic Browser application data Fork or deploy the Page Views Map app from GitHub Specific requirements for this app You must have the New Relic Browser Agent(s) installed, as well as related access to New Relic One. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer.git cd nr1-container-explorer nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Container Explorer to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer cd nr1-container-explorer nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app's launcher (unless otherwise noted above). Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications: New Relic Developer Edition: Early access to the Developer Edition of New Relic One gives you a free, personal sandbox account where you can build your own experience with all the available New Relic tools. developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome contributions to any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series.   Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.18447,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Most Popular New Relic One <em>Applications</em> (Round up #3)",
        "sections": "Specific requirements for this <em>app</em>",
        "body": " you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: nr1 <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;nr1-container-explorer.git cd nr1-container-explorer nr1 <em>nerdpack</em>:serve Or you could download, configure"
      },
      "id": "60762e1f196a673d0a64a782"
    }
  ],
  "/build-apps/ab-test/navigation": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Security1.png",
      "url": "https://newrelic.com/blog/how-to-relic/new-relic-one-security-team-dashboards",
      "sections": [
        "Escaping our “black box”",
        "From dashboard to app",
        "Step 1: Store search parameter values in the state",
        "Step 2: Craft NRQL queries on the fly",
        "Step 3: Craft the final NRQL queries and set some temporary values for the text fields",
        "Step 4: Render the filter functionality",
        "Step 5: Render the charts using our finalized queries",
        "What’s next?"
      ],
      "published_at": "2021-04-16T00:17:37Z",
      "title": "How Our Security Team Uses New Relic One for Prevention",
      "updated_at": "2021-04-14T00:03:23Z",
      "type": "",
      "external_id": "5eea1bf9b3c298f54f9468d89e766a82bdc198b9",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic How Our Security Team Uses New Relic One for Prevention Aug 14, 2020 • 8 min read By Scott Cutler Way back in 2016, the New Relic Security team discussed how we used New Relic Insights to monitor for potential threats and security events. Four years later, we introduced some major changes to the New Relic platform, so we've decided to make our security dashboards more user-friendly and flexible by converting them to Nerdlets using the New Relic One SDK. That’s exactly what we’ll explain in this post.  We documented our process and have made the source code available, so you can try it, too. Escaping our “black box” Until recently, we were using an early version of the Network Telemetry Integration. The integration sends sFlow and IPFIX data to New Relic, where we used the data in several dashboards built from long, complex NRQL queries. The dashboards showed metrics like traffic over time, anomalous traffic types, and sources by location. We even successfully used them to identify and troubleshoot at least one security incident. The dashboard and underlying queries survived multiple iterations of team members until it became a “black box”—we knew it worked but weren’t sure how. With an ever-changing infrastructure, our queries became obsolete and our dashboard unusable. We realized if we wanted to continue tracking anomalous data, we needed a revamp. From dashboard to app In our previous iteration, we had a set of static queries we used to create each dashboard. To replace the static queries, we wrote a Nerdlet from scratch that lets us filter and create our own queries. It’s important to note that our Nerdlet relies on New Relic Database data produced from the Network Telemetry Integration. This is what we came up with: In this instance, we’re able to use the text fields at the top row to add filter values—such as removing a specific IP address or protocol number. We can also remove the filters by pressing the X next to each filter value at the top. And each time we press the + or X, the rest of the Nerdlet is re-rendered with the correct results. Once we have a “filter set” that we like, we can copy and paste the NRQL query at the bottom and use it in an alert or dashboard. In this case, our next step is to start creating alerts focused on bandwidth usage for specific protocols we know aren’t used very often, and for network segments that shouldn’t be generating large amounts of traffic. Now, let’s take a look at how we created this Nerdlet. We broke it down into five steps, and if you want to try something similar, you can grab the code from this gist. Step 1: Store search parameter values in the state In our state object, we store several arrays, one for each filter type on the top row: Step 2: Craft NRQL queries on the fly Once we have the values in the arrays, we can start building NRQL queries with simple string concatenation tricks. In the example of IP Protocol numbers, we add WHERE protocolIdentifier = <number> when we want to filter for a specific protocol number. You may also notice that this method will introduce several WHERE clauses. Thankfully NRQL interprets this behavior as multiple AND clauses. Step 3: Craft the final NRQL queries and set some temporary values for the text fields In the beginning of our render function we set up two main things: our tempTextBoxValues object, which will hold the user-inputted values, and the final NRQL queries. Step 4: Render the filter functionality We created a few helper functions to render our filter bar at the top. The key was taking advantage of the fact that JavaScript will pass JSON objects by reference rather than value, allowing the onChange lambda to modify the tempTextBoxValues from step three. In our render portion of the code, we called it with one line: { this.populateTopToolbarStack(tempTextBoxValues) } Step 5: Render the charts using our finalized queries In our render block, we can now create grid items with chart objects that mirror the NR1 workshop examples but reference our finishedNrqlQueries object. When the user clicks a filter button, the autoSetFilters() function is called and will update the state object and trigger React to re-render the page. What’s next? What we really want is for the New Relic One platform to become our own security information and event management (SIEM), but we’re not quite there yet. For now, we plan to add pre-processing logic on logs before sending them to New Relic. This pre-processing could serve as our implementation for correlation and look for logs that occur across different event types. It seems like this may be possible in a New Relic One application, but we are still working on the idea of processing data outside the context of a browser session. If you’re looking for ways to get more out of New Relic One, check out our catalog of available apps and accompanying blog post series. By Scott Cutler Scott Cutler is a Senior Application Security Engineer at New Relic. He has been interested in security since he went to his first DefCon conference in 2004. He graduated with an Information and Computer Science degree from UC Irvine in 2009, took his first security job in 2012, and now works on the New Relic Threat Detection team. While engaging with the larger security community is fun (RainSec, OWASP, Twitter, CTFs), he also enjoys hiking, photography, and video games (DoTA 2 and Satisfactory are currently his go-tos). He has been living in North Portland for about four years and will always appreciate a food or drink recommendation for anywhere around Portland! Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.16292,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "From dashboard <em>to</em> app",
        "body": " in Sign up Main <em>navigation</em> menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog <em>navigation</em> menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog"
      },
      "id": "6076314be7b9d2ad1da5c64b"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programability_browser_analyze_1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-developers-guide-roundup",
      "sections": [
        "Intro to New Relic One SDK",
        "New Relic One CLI",
        "Intro to NerdStorageVault - New Feature!",
        "Create a \"Hello, World\" app",
        "Practice diagnosing common issues using New Relic",
        "Get coding and get inspired",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:23:24Z",
      "title": "New Relic Developers Guide Roundup",
      "updated_at": "2021-04-13T23:23:31Z",
      "type": "",
      "external_id": "9322d4fbb3dbbeb84cc7c3f26c9cc2c275e3a11d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Relic Developers Guide Roundup Jan 5, 2021 • 7 min read By Vi Tran When we first launched our programmable platform, one of our executives envisioned a simple way to visualize customer experience and satisfaction scores. He sent the following sketch to an engineer: Two days later, he had a production-ready application, built on New Relic One, that showed not just what the customer experience scores were, but what they should be. The browser analyzer application This New Relic One application is called the browser analyzer—it’s open source and available for you to use today. But now it’s your turn to go from sketch to app. We’ve given you the same tools our own engineers use, so you can build and deploy applications in New Relic One that connect your observability data, gathered from myriad sources—including third-party open source data—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK The New Relic One SDK provides the necessary components you need to build New Relic One applications. Components of the SDK include: React UI components for controlling text and layout in a New Relic One application Chart components for representing different types of charts Query and storage components for fetching and storing New Relic data Platform APIs that enable your application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build your applications, create visualizations, and fetch New Relic or third-party data. New Relic One CLI In addition to the SDK, you’ll need the New Relic One CLI to build apps on the platform. You’ll use the CLI to build, publish, and manage your app. More specifically, you’ll use the CLI to do the following: Generate Nerdpack/Nerdlet templates—(a Nerdpack is a package containing all the files needed by an application; a Nerdlet is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Intro to NerdStorageVault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store your data. NerdStorageVault lets you store and retrieve sensitive data secrets such as: Personal access tokens License keys API keys Other third-party secrets You can explore NerdStorageVault fields and response types with the NerdGraph API explorer. NerdStorageVault is encrypted with AES-256 encryption. In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes. Check out the guide for more information. Create a \"Hello, World\" app In this guide, you’ll build a \"Hello, World!\" application in New Relic One in nine quick steps. You’ll create a local version of the New Relic One site where you can prototype your application, and when you're ready to share the application with others, you can publish it to New Relic One. [embed]https://www.youtube.com/watch?v=7omo0qHxku8&feature=youtu.be[/embed] To get started, make sure you have accounts in GitHub and New Relic. You’ll also need to install Node.js and familiarize yourself with the New Relic One CLI. Tip: Check out Set up your development environment to make sure you have everything in order before you jump in. Practice diagnosing common issues using New Relic Every time you deploy an application, you hope that it's efficient and free of errors. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled demo environment. Acme Telco Lite is a telecom business that maintains an e-commerce website for its customers. The site's architecture has eight interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. Check out the full guide for more on prerequisites and deployment details. Get coding and get inspired Explore more guides and tutorials on New Relic Developers, because we’re constantly adding content. Best of all? The site is built completely in open source—feel free to submit a pull request while you’re there. Related Topics Extend New Relic By Vi Tran Vi Tran is a Senior Product Marketing Manager for Developer Ecosystem at New Relic. Her focus is on growing and enabling the developer ecosystem to extend New Relic One. Before New Relic, she was on the global strategic alliances team at Splunk and was a management consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.91415,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro <em>to</em> New Relic One SDK",
        "body": " Nerdpack&#x2F;<em>Nerdlet</em> templates—(a Nerdpack is a package containing all the files needed by an application; a <em>Nerdlet</em> is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks <em>Add</em> screenshots and metadata"
      },
      "id": "607627f464441f7e2b9d8537"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/GitHub-screenshot_02-1024x724.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-2",
      "sections": [
        "Status Page",
        "Specific requirements for this app",
        "GitHub Integration",
        "Agent Groundskeeper",
        "Customer Journey",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:49:01Z",
      "title": "The Most Popular New Relic One Applications (Round up #2)",
      "updated_at": "2021-04-13T23:49:52Z",
      "type": "",
      "external_id": "c03e99006d6ecc7b6219a2bc68dd0428450cdf26",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Round up #2) Nov 7, 2019 • 8 min read By Joel Worrall We hope you've heard the news that the New Relic One observability platform is now programmable. As the central component of an observability platform, we believe programmability gives you the ability to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the art of the possible—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications … and then we (and all of you!) kept going. In fact, new apps are coming in every day. And we hope to see app contributions by New Relic users continue. In this blog series, we’ll highlight the most popular apps available today. The best part: They’re all open source and ready to be deployed right now! In this edition, we cover: Status Pages GitHub Integration Groundskeeper Customer Journey Status Page Status Page aggregates system status and incident summaries, Statuspage.io style, from multiple providers within a single dashboard. Normally, this is information you’d track down one provider at a time, but Status Page makes it easy to check the status of your key dependencies in one place, at a single glance. Status Page brings together system status and incident report data from key dependencies—making it accessible to your team instantly and easily. Fork or deploy the Status Pages app from GitHub. Specific requirements for this app All you need to get up and running are some status pages you’d like to monitor. Popular options include: New Relic BitBucket Google Cloud Platform GitHub Jira Software Also, keep in mind that currently Status Page can pull in data only from status modules backed by Statuspage.io and Google Status pages. GitHub Integration Having the right information at your fingertips makes a big difference when you’re under the gun to understand a service and resolve an incident. The GitHub Integration connects your New Relic One apps and services to the repos containing relevant documentation, readme files, runbooks, and other essential information. Associate any service or application with its GitHub repository as a one-time action, and you can quickly see that application's readme file, as well as a list of active source code contributors. The GitHub Integration gives you quick access to the documentation for an app or service, including relevant readme files. GitHub Integration also displays a list of the most active contributors to a project, giving you easier access to additional problem-solving resources. Using the GitHub Integration involves a simple, one-time association between any service or application, and its repository. You'll also need to create or use a personal access token, as a one-time setup step, to ensure data security and integrity. Fork or deploy the GitHub Integration app from GitHub. Note: Integration with GitHub requires that you create or use a private access token as a one-time setup step. See GitHub's doc on access tokens for full instructions. Specific requirements for this app A GitHub (either public or private enterprise instance) organization and access to New Relic One. The ability to generate a personal access token in GitHub. Agent Groundskeeper Agent Groundskeeper displays real-time version information for the New Relic APM agents running across your software estate. See which services are up to date (with various upgrade SLO time windows), which are out of date, and which have instances deployed with different versions. Quickly and easily zoom in on your estate by filtering on tags, and search by account, language, and app name. Agent Groundskeeper gives you real-time version information for every APM agent running anywhere within an enterprise environment. Fork or deploy the Agent Groundskeeper app from GitHub. Specific requirements for this app New Relic APM Agent(s) installed and the related access to New Relic One. (Recommended) Add customer-defined labels to your APM applications to make use of New Relic One tag filtering. See our documentation here. Customer Journey Think of this app sort of as a NRQL funnel query on steroids. This application is designed to allow devops teams, product managers, and digital marketers to examine a number of pre-defined measures in a side-by-side comparison between cohorts (columns) of users through a set of steps (rows) where ... Rows equal Steps in a workflow Columns categorize a Series or cohort of users Measures define the Stats that you want to observe for each Series and Step The application employs three visualizations to examine, compare, and present its results: Multi-series Funnel: This visualization combines a third-party funnel library with the New Relic One NerdGraph query to execute three New Relic NRQL queries in the same GraphQL request. The results are aligned into one data set that is delivered to the funnel visualization. Data panels: For each row (Step) and column (Series), the app renders a set of measurements (Stat). Those calculations can apply KPI thresholds to color-code the information. Each panel is also clickable, leading to a more detailed overview. Detail Nerdlet: For any Journey, Series, and Step, there's a Nerdlet that will display the more detailed KPIs as well as a timeseries view of the the given Stats for the selected row and column. Customer Journey can apply KPI thresholds to color-code important information. Each panel is also clickable, leading to a more detailed overview.   A Nerdlet will display more detailed KPIs as well as a timeseries view of the given Stats for a selected row and column. Fork or deploy Customer Journey from GitHub. Specific requirements for this app Access to New Relic One. Configuring the journeyConfig.js. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Status Pages—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-status-pages.git cd nr1-status-pages nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Status Pages to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-status-pages cd nr1-status-pages nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app's launcher (unless otherwise noted above). Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications: New Relic Developer Edition: Early access to the Developer Edition of New Relic One gives you a free, personal sandbox account where you can build your own experience with all the available New Relic tools. developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome contributions to any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.01898,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Contribute <em>to</em> these open source projects",
        "body": " in Sign up Main <em>navigation</em> menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog <em>navigation</em> menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog"
      },
      "id": "60762e2028ccbcbab751c12e"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/dashboard-notes-action-menu-example.jpg",
      "url": "https://newrelic.com/blog/nerdlog/insights-dashboard-notes",
      "sections": [
        "Text and charts, together!",
        "Multiple use cases for Dashboard Notes"
      ],
      "published_at": "2021-04-16T02:09:56Z",
      "title": "New Dashboard Notes Feature Lets You Add Notes to Any Insights Dashboard",
      "updated_at": "2021-04-14T01:12:29Z",
      "type": "",
      "external_id": "42cf7e5cd7bdfff8d1d452bd26bcc683ba25c201",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Nerdlog New Dashboard Notes Feature Lets You Add Notes to Any Insights Dashboard Aug 7, 2017 • 5 min read By Iris Gau New Relic Insights, our platform for real-time analytics and data visualization, helps customers better understand how their applications and infrastructure are performing, the quality of the end user experience they’re delivering, and how their business is running. In the past year, the Insights team has launched a variety of cool new features such as the Metric Explorer, the Dashboard Timepicker, and company-wide dashboards, all designed to make the dashboarding and data exploration experience more cohesive, customized, and easy to navigate. Today, we’re excited to announce a new feature that allows customers to add notes to their dashboards: Dashboard Notes! A new “Add Dashboard Note” button in the upper right section of the Insights toolbar lets users add a Dashboard Note. Text and charts, together! While users have long been able to add notes to individual charts in Insights, there was previously no way to include text content on a dashboard alongside the data charts. Good news! With Dashboard Notes, users can now create, add, and edit a note on any dashboard. Using Markdown, a simple and widely used formatting syntax, Dashboard Notes makes it easy to add custom content such as text, images, and links that are highly visible and easily accessible. (Note that to avoid potentially private information being shared without authorization, Dashboard Notes cannot be copied to other dashboards within the same account or cross-account.) Clicking the “Add Dashboard Note” button launches an editor that lets users customize their note in Markdown, and see a live preview of how the formatting will look on the dashboard. Multiple use cases for Dashboard Notes Furthermore, this feature is incredibly flexible. Here are some sample use cases: Create a postmortem dashboard following an incident, including notes about the details of the incident, why it occurred, when it occurred, and so on. Attach a runbook URL to a dashboard so engineers and support teams can easily access supplemental information when an incident or outage occurs. Add an image, perhaps of the relevant team or the owner of the dashboard, so that everyone immediately knows whom to contact with questions or updates. Point users to external links, such as a source repo or other relevant dashboards. This screenshot shows the fully formatted Dashboard Note on the right. Ultimately, Dashboard Notes is designed to let users add flexible and editable context that can be easily viewed and accessed by all the users of the dashboard. For more information, check out the documentation for Dashboard Notes here. Consistent with data charts in Insights, the Dashboard Notes action menu lets you expand, edit, and delete your notes.   By Iris Gau Iris Gau is an engineering intern on the Insights team and a rising junior at Rice University, studying computer science and cognitive science. At New Relic, she has enjoyed learning about full-stack development, mob programming, and the fancy coffee machine. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 85.20241,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Dashboard Notes Feature Lets You <em>Add</em> Notes <em>to</em> Any Insights Dashboard",
        "sections": "Text and charts, <em>together</em>!",
        "body": " <em>navigation</em> menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Nerdlog New Dashboard Notes Feature Lets You <em>Add</em> Notes to Any Insights Dashboard Aug 7, 2017 • 5 min read By Iris Gau New Relic Insights, our platform for real-time analytics and data visualization, helps"
      },
      "id": "6076417e64441f14b69d856a"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-04/diego-mari%C3%B1o.jpg?h=a2f616d4&itok=AJ-Tkk0B",
      "url": "https://newrelic.com/blog/nerdlog/role-based-access-control-rbac",
      "sections": [
        "Easily add admin capabilities per New Relic product",
        "Create custom roles based on your needs",
        "RBAC extensions are ready to use"
      ],
      "published_at": "2021-04-16T02:09:56Z",
      "title": "New Relic Extends Role-Based Access Control (RBAC) Capabilities",
      "updated_at": "2021-04-14T01:12:09Z",
      "type": "",
      "external_id": "2684fbf918a3ee8dbb298421efac22166978a40b",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Nerdlog New Relic Extends Role-Based Access Control (RBAC) Capabilities Sep 6, 2017 • 6 min read By Diego Mariño As your development and operations teams grow in size and complexity, it becomes ever more critical to give each team member only the least required permissions they need to do their job. You want to make sure everyone can perform their functions with ease, but to avoid security and governance problems, they should not be able to access anything beyond their role. For instance, a mobile developer should be able to make any needed changes to their mobile app but should not have permission to make changes to other products. This can be achieved in several ways, and New Relic has long provided this kind of role-based access control (RBAC) via built-in base roles (Admin, User, and Restricted User). But today we are very excited to announce that we are extending the RBAC capabilities in our platform with the introduction of easy-to-use, fine-grained access-control permissions via two new types of add-on roles: custom and managed by New Relic. Easily add admin capabilities per New Relic product With managed add-on roles you can add Admin capability per New Relic product to the built-in base roles. So now you can grant a particular user Admin access for only a given product and restricted access for other products. For instance, if you have iOS/Android developers on your team, you can make them Admins only for New Relic Mobile and restricted users for other New Relic products. To make it easy to be aware of the exact permissions granted with your selection of base and add-on roles, we added a capabilities preview to the New Relic user interface. The capabilities preview automatically updates to show you the permissions granted for each product with the managed add-on roles and base role you select. managed add-on roles example Managed add-on roles are maintained by New Relic and contain all of the necessary capabilities to execute any action inside each of the products in the New Relic Digital Intelligence Platform. In addition, these managed add-on roles are designed to be automatically upgraded when we deliver new product functionality. Create custom roles based on your needs These managed add-on roles are built to provide Admin capabilities for individual New Relic products, but we know that some customers want even more fine-grained access-control capabilities. For instance, some customers may want to give their users full autonomy to use New Relic APM, except for the ability to delete deployed applications (that capability should often be limited to the smallest number of people possible). With custom add-on roles, you can tailor access to view, modify, or delete capabilities for specific features in each product. Once you have created a custom role (with specific view, modify, or delete capabilities), you can add that custom role to the base role and provide fine-grain access. Throughout the process, the new RBAC preview capabilities view shows you exactly which capabilities are granted with the given combination of base and add-on roles. custom add-on roles example RBAC extensions are ready to use Starting today, both custom and managed add-on roles are available for all New Relic customers. This is a great opportunity to log into your users and roles settings and start tightening your users’ access privileges to meet your organization’s particular needs. To learn more about the new add-on roles, please refer to our documentation and join the discussion on the New Relic community site. For a longer RBAC tutorial, check out the video below: Going forward, we plan to add even more access control capabilities. You can find out more about our upcoming projects at FutureStack17: New York, September 13-14. Register today before the event sells out!   Note: Event dates, speakers, and schedules are subject to change without notice. By Diego Mariño Diego started his professional career as a software developer, then shifted into the business side of the technology. In 2006 he founded Abiquo, a company that delivered one of the first Infrastructure-as-a-Service platforms, and led it until its international expansion in 2010. In 2011 he founded Ducksboard, a SaaS service to gather and display business metrics, which was acquired by New Relic in 2014. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.36412,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Easily <em>add</em> admin capabilities per New Relic product",
        "body": " <em>navigation</em> menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Nerdlog New Relic Extends Role-Based Access Control (RBAC) Capabilities Sep 6, 2017 • 6 min read By Diego Mariño As <em>your</em> development and operations teams grow in size and complexity, it becomes ever more"
      },
      "id": "6076416a196a674b0b64a76f"
    }
  ],
  "/build-apps/ab-test/add-charts": [
    {
      "image": "https://newrelic.com/sites/default/files/styles/4x5_600w/public/2021-03/Hurrell,%20Liam%20FS21.jpg?h=2662c9ad&itok=BufuePAq",
      "url": "https://newrelic.com/futurestack/speakers/liam-hurrell",
      "sections": [
        "Liam Hurrell",
        "Sessions with Liam Hurrell",
        "New Relic for More Advanced Data Nerds: Advanced: Alerts",
        "New Relic for More Advanced Data Nerds: Advanced: Synthetic Monitoring",
        "Meet Our Speakers",
        "Eugene Kovshilovsky",
        "Justin Eveland",
        "Scot Gorman",
        "Henry Jewkes",
        "Dan Rufener",
        "Mike Neville-O'Neill",
        "Bill Staples",
        "Lew Cirne",
        "Nicole van der Hoeven",
        "Colin MacNaughton",
        "Aaron Judy",
        "Kim Hickey",
        "{Future}Stack is coming. May 25 - 27, 2021"
      ],
      "published_at": "2021-04-15T22:32:43Z",
      "title": "Liam Hurrell | New Relic",
      "updated_at": "2021-04-15T22:32:43Z",
      "type": "",
      "external_id": "ef258c5f5ef0a708897115ac333d8fe5a834240b",
      "popularity": 1,
      "body": "Skip to main content #futurestack Agenda Speakers Dev Zone #FUTURESTACK Connect with us on Twitch Twitter LinkedIn Agenda Speakers Dev Zone Register Main navigation menu, 1 item Liam Hurrell Senior Technical Training Specialist, New Relic Liam is a Senior Technical Training Specialist at New Relic. With roots in software development and training from companies like BSkyB and Dorling Kindersley in London, he has over 20 years experience from London, Sydney and Dublin. As an Adobe Certified Instructor he set up his own Adobe, Apple, and Android Authorised Training centre and went on to run developer bootcamps in Ireland, building apps and web applications for partners. Two years ago he joined New Relic and brings his experience of both in-company and commercial training, curriculum development, and customer service. Liam lives in Ireland with his wife and two kids, and when not on the laptop can mostly be found training for marathons (PB 3:06), cooking vegan food, and trying to escape from his animals (3 dogs, 3 cats, 4 chickens, 3 horses). on LinkedIn Sessions with Liam Hurrell 10:00 am - 12:00 pm PT | Tuesday, May 25 | New Relic University New Relic for More Advanced Data Nerds: Advanced: Alerts Dive deeper into alerts! Through a combination of live presentation & hands-on labs, you’ll be an alerting wizard in no time. • Effective Alerting strategies • SLO’s, SLA’s & Thresholds • NRQL Alerts; Outlier detection, & other use cases • Notifying the right team: Channels, Test Channels and Webhooks • Alerts and Dashboarding • Managing Alerts & Conditions (Join this session for live chat OR watch on-demand the following day) 1:00 pm - 3:00 pm PT | Tuesday, May 25 | New Relic University New Relic for More Advanced Data Nerds: Advanced: Synthetic Monitoring Synthetic monitoring allows you to proactively monitor your sites and APIs to ensure your content is not only available, but functional. By the end of this workshop, you’ll understand how to use Synthetics to help you make sure your content is always up. • Get proactive with your monitoring and performance testing • Add monitors to test: • Availability, Functionality, Performance • Share SLA’s and Reporting on your monitor • Use Secure Credentials and Private Locations to extend your Synthetics monitoring • Set up Dashboards to chart success and performance of your Monitors • Set up Alerting on your monitors, and manage maintenance windows (Join this session for live chat OR watch on-demand the following day) Meet Our Speakers Eugene Kovshilovsky CarParts.com Learn more Justin Eveland New Relic Learn more Scot Gorman Chegg Learn more Henry Jewkes Split.io Learn more Dan Rufener New Relic Learn more Mike Neville-O'Neill New Relic Learn more Bill Staples New Relic Learn more Lew Cirne New Relic Learn more Nicole van der Hoeven k6.io Learn more Colin MacNaughton New Relic Learn more Aaron Judy Maricopa County Clerk of the Superior Court Learn more Kim Hickey New Relic Learn more See All Speakers {Future}Stack is coming. May 25 - 27, 2021 Count down to get your Nerd on with learning, sharing, networking and lots of fun surprises. #futurestack Register Register Connect with us on Twitch Twitter LinkedIn newrelic.com Code of Conduct Terms and Conditions Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.41862,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "New Relic for More <em>Advanced</em> Data Nerds: <em>Advanced</em>: <em>Alerts</em>",
        "body": " • <em>Add</em> monitors to <em>test</em>: • Availability, Functionality, Performance • Share SLA’s and Reporting on <em>your</em> monitor • Use Secure Credentials and Private Locations to extend <em>your</em> Synthetics monitoring • Set up Dashboards to <em>chart</em> success and performance of <em>your</em> Monitors • Set up Alerting on <em>your</em> monitors"
      },
      "id": "6042d15e196a67d2fe960f6d"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programability_browser_analyze_1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-developers-guide-roundup",
      "sections": [
        "Intro to New Relic One SDK",
        "New Relic One CLI",
        "Intro to NerdStorageVault - New Feature!",
        "Create a \"Hello, World\" app",
        "Practice diagnosing common issues using New Relic",
        "Get coding and get inspired",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:23:24Z",
      "title": "New Relic Developers Guide Roundup",
      "updated_at": "2021-04-13T23:23:31Z",
      "type": "",
      "external_id": "9322d4fbb3dbbeb84cc7c3f26c9cc2c275e3a11d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Relic Developers Guide Roundup Jan 5, 2021 • 7 min read By Vi Tran When we first launched our programmable platform, one of our executives envisioned a simple way to visualize customer experience and satisfaction scores. He sent the following sketch to an engineer: Two days later, he had a production-ready application, built on New Relic One, that showed not just what the customer experience scores were, but what they should be. The browser analyzer application This New Relic One application is called the browser analyzer—it’s open source and available for you to use today. But now it’s your turn to go from sketch to app. We’ve given you the same tools our own engineers use, so you can build and deploy applications in New Relic One that connect your observability data, gathered from myriad sources—including third-party open source data—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK The New Relic One SDK provides the necessary components you need to build New Relic One applications. Components of the SDK include: React UI components for controlling text and layout in a New Relic One application Chart components for representing different types of charts Query and storage components for fetching and storing New Relic data Platform APIs that enable your application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build your applications, create visualizations, and fetch New Relic or third-party data. New Relic One CLI In addition to the SDK, you’ll need the New Relic One CLI to build apps on the platform. You’ll use the CLI to build, publish, and manage your app. More specifically, you’ll use the CLI to do the following: Generate Nerdpack/Nerdlet templates—(a Nerdpack is a package containing all the files needed by an application; a Nerdlet is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Intro to NerdStorageVault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store your data. NerdStorageVault lets you store and retrieve sensitive data secrets such as: Personal access tokens License keys API keys Other third-party secrets You can explore NerdStorageVault fields and response types with the NerdGraph API explorer. NerdStorageVault is encrypted with AES-256 encryption. In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes. Check out the guide for more information. Create a \"Hello, World\" app In this guide, you’ll build a \"Hello, World!\" application in New Relic One in nine quick steps. You’ll create a local version of the New Relic One site where you can prototype your application, and when you're ready to share the application with others, you can publish it to New Relic One. [embed]https://www.youtube.com/watch?v=7omo0qHxku8&feature=youtu.be[/embed] To get started, make sure you have accounts in GitHub and New Relic. You’ll also need to install Node.js and familiarize yourself with the New Relic One CLI. Tip: Check out Set up your development environment to make sure you have everything in order before you jump in. Practice diagnosing common issues using New Relic Every time you deploy an application, you hope that it's efficient and free of errors. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled demo environment. Acme Telco Lite is a telecom business that maintains an e-commerce website for its customers. The site's architecture has eight interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. Check out the full guide for more on prerequisites and deployment details. Get coding and get inspired Explore more guides and tutorials on New Relic Developers, because we’re constantly adding content. Best of all? The site is built completely in open source—feel free to submit a pull request while you’re there. Related Topics Extend New Relic By Vi Tran Vi Tran is a Senior Product Marketing Manager for Developer Ecosystem at New Relic. Her focus is on growing and enabling the developer ecosystem to extend New Relic One. Before New Relic, she was on the global strategic alliances team at Splunk and was a management consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.69632,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro <em>to</em> New Relic One SDK",
        "body": " The New Relic One SDK provides the necessary <em>components</em> you need to build New Relic One applications. <em>Components</em> of the SDK include: React UI <em>components</em> for controlling text and layout in a New Relic One <em>application</em> <em>Chart</em> <em>components</em> for representing different types of charts Query and storage"
      },
      "id": "607627f464441f7e2b9d8537"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/mobile_ui_react_folder_structure-546x1024.png",
      "url": "https://newrelic.com/blog/best-practices/mobile-ui-react",
      "sections": [
        "The new and improved New Relic Mobile UI architecture",
        "Managing state",
        "Running async services",
        "Plugged in NRQL models",
        "Bonus content: project folder structure",
        "Building more than just a UI"
      ],
      "published_at": "2021-04-16T04:23:43Z",
      "title": "How We Architected the New Relic Mobile Web UI in React",
      "updated_at": "2021-04-14T06:37:40Z",
      "type": "",
      "external_id": "e3d67df0a38b9980728a89cac2fb64cddc1708b1",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Best Practices How We Architected the New Relic Mobile Web UI in React Jan 3, 2018 • 7 min read By Frank Linehan An ongoing curiosity in JavaScript development communities is the question of how to build complex UI applications in React. This open source JavaScript library, maintained by Facebook, makes it easier than ever to write efficient, component-based projects in JavaScript. React has been around for about four years now, but the JavaScript community is still learning how to take full advantage of its powers. The web UI for New Relic Mobile has several points of integration with components, services, and container objects built by different UI engineers across New Relic. Historically it’s been a challenge to cleanly integrate all the pieces. Additionally, we now have more non-frontend engineers than ever contributing to the UI, so it’s become very important for us to have a clean architecture that everyone can easily navigate and contribute to. To make it easier for engineers who contribute code to the UI, we’ve created a flexible system, written in React. And since we’ve built this layered architecture from modules, we’ve been able to decouple the different domains of the UI application from each other, thus easing the burdens of contributors. We wanted to share some of the design behind this complex React project because it’s led us to some seriously great outcomes. The new and improved New Relic Mobile UI architecture Consider this diagram of the new architecture: The top three layers are made up of our framework-specific UI views, containers, and components (which I’ll give a bit more detail for when I discuss the folder structure of our project). Where possible we favor composition over inheritance since React classes are great for this design pattern. For example, we use this pattern in the Handled exceptions sidebar container that has three child UI components: a search input, an occurrence count, and a bar chart component. The sidebar composes these child UI components by passing needed properties to its children (for example, data to render the bar chart). This allows us to reuse these smaller components throughout the application and to handle layout and configuration through the larger container components. We like to think of these UI components as “Lego pieces:” they can be used in multiple ways to build dozens of combinations. The UI views and containers, on the other hand, are much less modular and are more like jigsaw puzzle pieces in that they fit together only one specific way. The bottom layer is composed of three collections of modules in which a significant portion of the Mobile UI application code base lives. These collections handle state management, asynchronous services, and store NRQL models (the latter of which powers the New Relic Query Language functionality in the UI). Managing state In React, state is an object that can change over time; for example, UI text changing to red in the case of an emergency is controlled by state. State can be managed—or held—in stores. In New Relic Mobile, some UI components manage their own internal state (dropdown components keep track of when they are open or closed), but other components, such as the filter list, filter picker, and time picker, use state containers (or bundles of state) that allow state to be easily shared across components. To store the state React renders, we use the MobX library. In the New Relic Mobile UI, the top-level stores that manage application state use singleton patterns. These singletons use object composition to reference the other store singletons in the project. For example, as shown in diagram below, the App store, which handles the UI’s high-level application state, has references to our Router store, Nav store, Time store, Filters store, and Account store. So, for example, when a user clicks and “brushes” a graph (i.e., selects a data point in a graph that is then highlighted in another graph), we need to update our time window and route for the change. When the “brush” action is called, the App store mutates our router state and timestore state, which then triggers updates to all the components that observe those states. The API interface between our State store and the graph component is lightweight and simple, and this part of the UI is flexible if we ever require changes. Running async services This set of core modules are for a few asynchronous services that retrieve data from different places in the New Relic Mobile application. These store objects use the fetch API to make HTTP requests, and they manage the state of data as it loads. These async store objects inherit from our HTTP request store (which is one of the few places where we use inheritance). The HTTP request store is a finite state machine that has some helper methods for handling loading, errors, and data. We chose inheritance for these objects because they all have the same HTTP request pattern (for example, fetch, is loading, has data, has error). By moving that shared behavior to the HTTP request object and inheriting off of it, we removed hundreds of lines of redundant code from our project. Plugged in NRQL models The New Relic Query Language models are modules of code that generate NRQL queries used by the UI components, containers, and views. These models are pretty specific to the structure of the New Relic UI, so a close examination of them isn’t necessary here. Bonus content: project folder structure Finally, no discussion of a JavaScript project is complete without a look at the project’s folder structure. Obviously, there is no “perfect folder structure,” but this is what has worked well for our team in this project. Application code lives in the src folder and styling lives in our scss folder. Both of these folders are bundled up by webpack and turned into UI assets. Our src folder has the following structure: The component folder holds React components that are given sets of properties and render widgets on the screen. These are our “Lego pieces” that can be composed into different combinations in the UI. The containers folder is for components that compose other components. The containers are our puzzle pieces that fit only one way when used in the UI. Then we have our views folder that holds our views components. The views components compose our containers. This folder combines all of our smaller pieces into one big picture, and since most of the team is experienced with some form of the model, view, controller (MVC) architecture, having a views folder gives us all a familiar entry point into the application. The models folder contains the aforementioned NRQL models used to build queries consumed by our graph components and other containers. The configs folder is where we store static variables that are used to configure views and containers. The libs, services, utils, andtransforms folders are where we keep smaller reusable pieces of code that format data or talk to APIs; these can even be used by our other components. Last but not least we have our stores folder, which holds our state containers. As noted, we’re using MobX to store our state and actions. Our end goal was to have as flat a folder structure as possible, since flat is always better than nested. We also made sure the folder names were easily readable since team members need to be able to identify what lives where and what it does. Building more than just a UI In addition to being a successful experiment in architecting a complex JavaScript project in React, we’ve found that this architecture has led to some critical outcomes: Predictable state management: By breaking state into discrete objects, it’s easier for us to see which actions are mutating state in our components. Easy for non-UI-focused team members to contribute: Building our UI architecture with object-oriented programming allows our less experienced UI devs to quickly contribute to the project. Explicitness: Because we’ve decoupled state, UI components, and the underlying service models, new contributors can quickly figure out exactly what parts of the project to contribute to. Ease of use: Thanks to this decoupled and organized architecture, our agent and service engineers were able to complete a significant chunk of UI work in a single sprint while the UI engineer was on a weeklong vacation.   By Frank Linehan Frank Linehan is a Senior Software Engineer on the Mobile APM team at New Relic. He's passionate about front-end engineering, emergent JavaScript frameworks, and maintainable and flexible JavaScript projects. He's also very passionate about mountaineering. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.35466,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How We <em>Architected</em> the New Relic Mobile Web UI in React",
        "sections": "<em>Building</em> more than just <em>a</em> UI",
        "body": " <em>components</em> by passing needed properties to its children (for example, data to render the bar <em>chart</em>). This allows us to reuse these smaller <em>components</em> throughout the <em>application</em> and to handle layout and configuration through the larger container <em>components</em>. We like to think of these UI <em>components</em>"
      },
      "id": "60768db464441f7ce19d854c"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/800w/public/2021-04/3-Logs-UI.png?itok=p4y3RTMr",
      "url": "https://newrelic.com/blog/nerdlog/logs-ui-and-heroku",
      "sections": [
        "Nerdlog Roundup: An Improved Logs UI, and New Heroku Integration",
        "A better, faster Logs UI",
        "Integration with Heroku for logs",
        "Next Steps",
        "Related Topics",
        "More from this topic",
        "Nerdlog Roundup: Test Website Experiences with New Relic Synthetics Step Builder",
        "Nerdlog Roundup: AIOps and Customizing Your Data",
        "Nerdlog Roundup: Embrace the Purple Bubble, Remove Instrumentation Anxiety, and Fork Our D…"
      ],
      "published_at": "2021-04-15T22:12:51Z",
      "title": "Nerdlog Roundup: An Improved Logs UI, and New Heroku Integration | New Relic",
      "updated_at": "2021-04-15T22:12:51Z",
      "type": "",
      "external_id": "9fe0bd2b312740ff2715d6512c7c26e5581c0d29",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Log Management Nerdlog Roundup: An Improved Logs UI, and New Heroku Integration Apr 15, 2021 • 5 min read By Nočnica Fee Get weekly updates about the latest features and releases from the people who built them. Join the Nerdlog discussion every Thursday at 12 p.m. PT on Twitch or follow along in What's New. If you're not a New Relic customer, sign up for your free account today. Logs are one of the four fundamental components of observability (along with metrics, events, and traces) and  include the most detail about your application’s function. In this week’s episode, Senior Manager, Product Management Michael Neville-O’Neill, and Software Engineer Josep Subirats joined the Nerdlog to discuss how they are working to make it easier to send logs to New Relic One.  A better, faster Logs UI New Relic’s log features are now presented more clearly within the UI, making it easier than ever before to find functions like parsing and drop filters right in the left hand toolbars. We’ve added a new log summary view, which tries to pick the most salient key-value pairs from your logs, making it easier to scan through multiple log lines quickly. We also leveraged a new custom visualization feature to create an easy way for you to combine log messages, regardless of their pattern or length, with the rest of your telemetry data already living in New Relic One via dashboards.  Using this new feature, your long log messages (with lots of attributes) can wrap, and you can resize the columns quickly. Just click on the icon in the top right corner of the log messages panel to use this feature. Check out all the new and improved logs experience for yourself here so that you can start increasing the scope and granularity of insight into your full stack. You can also read our docs to learn more about our Logs UI. Integration with Heroku for logs New Relic logs now integrate with Heroku via a “logs drain” that allows you to view syslog entries within New Relic One. This capability opens up the option for you to see business logic like items sold or most active users, as a custom New Relic dashboard, based solely on logs information. To get started, follow the instructions below:  Download and install the Heroku CLI. Create a syslog drain that will send logs to New Relic and attach it to your app: heroku drains:add syslog+tls://newrelic.syslog.nr-data.net:6515 -a YOUR_APP_NAME Run the following to retrieve the drain token assigned to the drain created in Step 2: $ heroku drains -a YOUR_APP_NAME --json Copy the value from the \"token\" attribute returned by the command above: { \"addon\": null, \"created_at\": \"2018-12-04T00:59:46Z\", \"id\": \"906262a4-e151-45d2-b35a-a2dc0ea9e688\", \"token\": \"[your token goes here]\", \"updated_at\": \"2018-12-04T00:59:47Z\", \"url\": \"syslog://logs.example.com\" } Launch New Relic Logs and click Add more data sources. Click on the Heroku tile, add your drain token, and select an Insights insert API key to map it to. Click Add Heroku drain log, and logs will begin flowing to your New Relic One account within seconds. Next Steps For more information about the Heroku Cloud integration for logs and how to view your logs that are streaming, you can head to What’s New or review our docs.    Related Topics Log Management By Nočnica Fee Nočnica Fee is a Dev Advocate for New Relic specializing in serverless. She's a frequent contributor to The New Stack and Dev.to. In her downtime, she enjoys drum machines and woodworking. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn More from this topic Digital Experience Monitoring Nerdlog Roundup: Test Website Experiences with New Relic Synthetics Step Builder Apr 8, 2021 • 6 min read Read the article AIOps Nerdlog Roundup: AIOps and Customizing Your Data Mar 4, 2021 • 4 min read Read the article Nerdlog Nerdlog Roundup: Embrace the Purple Bubble, Remove Instrumentation Anxiety, and Fork Our D… Mar 25, 2021 • 3 min read Read the article Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.46529,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Nerdlog Roundup: <em>An</em> Improved Logs UI, <em>and</em> New Heroku Integration | New Relic",
        "sections": "<em>A</em> <em>better</em>, faster Logs UI",
        "body": "&quot;: null, &quot;created_at&quot;: &quot;2018-12-04T00:59:46Z&quot;, &quot;id&quot;: &quot;906262a4-e151-45d2-<em>b</em>35a-a2dc0ea9e688&quot;, &quot;token&quot;: &quot;[<em>your</em> token goes here]&quot;, &quot;updated_at&quot;: &quot;2018-12-04T00:59:47Z&quot;, &quot;url&quot;: &quot;syslog:&#x2F;&#x2F;logs.example.com&quot; } Launch New Relic Logs and click <em>Add</em> more data sources. Click on the Heroku tile, <em>add</em> <em>your</em> drain token"
      },
      "id": "6078ba63196a67e33264a7ab"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Delayed-Jobs-New-Relic-1024x837.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/monitoring-delayedjob",
      "sections": [
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "Monitoring DelayedJob",
      "updated_at": "2021-04-14T00:06:04Z",
      "type": "",
      "external_id": "2e9c1f784c773aa1fa509a112bcd338cac37c70e",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit APM Monitoring DelayedJob Sep 12, 2012 • 6 min read By Bill Kayser Like many Ruby shops we use the DelayedJob job runner to run many of our background tasks. The New Relic agent has had some basic DelayedJob instrumentation for a while now but until recently you were limited to a few metrics which could only be viewed using the somewhat limited and unwieldy custom charts. But no longer! In the latest release of the Ruby Agent we are sending much richer, useful metrics for DelayedJob workers, and the recently released Custom Dashboards allows you to to build a truly useful view for monitoring and troubleshooting your jobs. Here's what it looks like: This is a Custom Dashboard we built for our DelayedJobs workers running in production. Below, I'll show you the steps to create this in your own New Relic account. But first let me explain what we are looking at. There are four graphs with data reported by the agent running in the DelayedJob worker. Job Queue Length shows the number of jobs waiting to be executed at any given time, based on one minute samples. We break out these numbers by priority since we manage separate workers in three different priority levels. In the graph above, you can see that our highest priority worker maintains a pretty healthy queue while we get a few spikes in our low priority worker every now and then, since the jobs in the low priority queue tend to run a little longer. In our configuration, we destroy jobs when they've run successfully and leave the failed ones. The agent polls the failed jobs and reports the count which we graph in the Failed Jobs chart. We pay particular attention to this chart during a deploy to look for any jump in failing jobs caused by a regression. Locked Jobs is particularly interesting. Jobs are locked while executing, so the number of jobs locked at any given time should not exceed the number of workers. With idle workers, the count will be low. With workers fully utilized, the number will approach the total number of workers. We find you do have to be careful as some jobs occasionally fail without clearing their lock, so you have to manually clear those out. But you can use the Locked Jobs graph as a gauge of your overall worker utilization. The Average Job Execution time graph is simply a graph of the average response time of the DelayedJob transactions. Creating a Custom Dashboard for DelayedJobs Let's walk through the steps to get this set up in a typical account. The first thing you need is the current version of the Ruby Agent gem. You must be running at least version 3.4.2. Then follow these steps in the New Relic application: 1) Select the application where DelayedJob is running. In our case it's \"Background Jobs\". 2) From the Custom Dashboards menu choose Create custom dashboard. Enter the title and \"Grid\" chart type. 3) Choose Add chart to add the first chart to your dashboard.  Fill in the basic properties, including the titles and chart type, which is \"Stacked Area.\" 4) Select the DelayedJob queue lengths for the graph. Start typing in Workers/. Initially it will say the metric doesn't exist, but when you enter the slash it will display the list of available metrics in the Workers namespace. Keep typing Workers/DelayedJob/queue_length/priority/*.  The metrics will auto-complete as you enter each segment. The asterisk at the end indicates that you want to break down the graph by priority. If you don't use priorities you can chart a single line for the queue length using the metric name Workers/DelayedJob/queue_length/all. 5. That's generally good enough to display the chart, but there are a couple of other properties you can customize. In our case, we removed the limit on the number of different priorities it will show, added \"jobs\" to the y-axis labels, and fixed the application to \"RPM Background\" where the DelayedJob agent reports to. Here's what it looks like: 6. Add the Failed Jobs chart. Repeat steps 3 - 5 but enter the metric for tracking failed jobs: Workers/DelayedJob/failed_jobs. 7. Add the Locked Jobs chart. Repeat steps 3 - 5 but enter the metric for tracking locked jobs: Workers/DelayedJob/locked_jobs. 8. Add the Job Execution Time chart. Repeat steps 3 - 5 but enter the metric for the response time of delayed jobs:  OtherTransaction/DelayedJob/all. We show execution time in milliseconds so we chose To Milliseconds for the Number Format and \"ms\" as the y-axis unit label. We also hide the legend. That's enough to get you started with a good dashboard for monitoring your DelayedJob workers. But you don't have to stop there. You can add a table showing you the summary metrics for each job or a breakdown chart of all the jobs. In addition to showing the response time of jobs, you could chart the throughput. We combine our staging and production servers onto one dashboard by duplicating the charts and picking a different application. Custom Dashboards now makes it easy to configure the charts for the exact data you want to display. If you haven't already, try New Relic today to see how you can improve the performance of your Ruby applications. And as always, we welcome your feedback on this post. Let us know what you think of Custom Dashboards and how you're using them to monitor your applications. Related Topics APM By Bill Kayser Bill has been with New Relic from the beginning as both a developer and a data scientist. Having worked in application performance management for nearly two decades, his role now entails discovering new ways of exploring and interpreting data as well as prototyping innovative new features. Follow the author Bill Kayser on Twitter Bill Kayser on GitHub Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.65018,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Related <em>Topics</em>",
        "body": " in the New Relic <em>application</em>: 1) Select the <em>application</em> where DelayedJob is running. In our case it&#x27;s &quot;Background Jobs&quot;. 2) From the Custom Dashboards menu choose Create custom dashboard. Enter the title and &quot;Grid&quot; <em>chart</em> type. 3) Choose <em>Add</em> <em>chart</em> to <em>add</em> the first <em>chart</em> to <em>your</em> dashboard.  Fill"
      },
      "id": "607631ece7b9d201aea5c63a"
    }
  ],
  "/build-apps/ab-test/first-chart": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Delayed-Jobs-New-Relic-1024x837.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/monitoring-delayedjob",
      "sections": [
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "Monitoring DelayedJob",
      "updated_at": "2021-04-14T00:06:04Z",
      "type": "",
      "external_id": "2e9c1f784c773aa1fa509a112bcd338cac37c70e",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit APM Monitoring DelayedJob Sep 12, 2012 • 6 min read By Bill Kayser Like many Ruby shops we use the DelayedJob job runner to run many of our background tasks. The New Relic agent has had some basic DelayedJob instrumentation for a while now but until recently you were limited to a few metrics which could only be viewed using the somewhat limited and unwieldy custom charts. But no longer! In the latest release of the Ruby Agent we are sending much richer, useful metrics for DelayedJob workers, and the recently released Custom Dashboards allows you to to build a truly useful view for monitoring and troubleshooting your jobs. Here's what it looks like: This is a Custom Dashboard we built for our DelayedJobs workers running in production. Below, I'll show you the steps to create this in your own New Relic account. But first let me explain what we are looking at. There are four graphs with data reported by the agent running in the DelayedJob worker. Job Queue Length shows the number of jobs waiting to be executed at any given time, based on one minute samples. We break out these numbers by priority since we manage separate workers in three different priority levels. In the graph above, you can see that our highest priority worker maintains a pretty healthy queue while we get a few spikes in our low priority worker every now and then, since the jobs in the low priority queue tend to run a little longer. In our configuration, we destroy jobs when they've run successfully and leave the failed ones. The agent polls the failed jobs and reports the count which we graph in the Failed Jobs chart. We pay particular attention to this chart during a deploy to look for any jump in failing jobs caused by a regression. Locked Jobs is particularly interesting. Jobs are locked while executing, so the number of jobs locked at any given time should not exceed the number of workers. With idle workers, the count will be low. With workers fully utilized, the number will approach the total number of workers. We find you do have to be careful as some jobs occasionally fail without clearing their lock, so you have to manually clear those out. But you can use the Locked Jobs graph as a gauge of your overall worker utilization. The Average Job Execution time graph is simply a graph of the average response time of the DelayedJob transactions. Creating a Custom Dashboard for DelayedJobs Let's walk through the steps to get this set up in a typical account. The first thing you need is the current version of the Ruby Agent gem. You must be running at least version 3.4.2. Then follow these steps in the New Relic application: 1) Select the application where DelayedJob is running. In our case it's \"Background Jobs\". 2) From the Custom Dashboards menu choose Create custom dashboard. Enter the title and \"Grid\" chart type. 3) Choose Add chart to add the first chart to your dashboard.  Fill in the basic properties, including the titles and chart type, which is \"Stacked Area.\" 4) Select the DelayedJob queue lengths for the graph. Start typing in Workers/. Initially it will say the metric doesn't exist, but when you enter the slash it will display the list of available metrics in the Workers namespace. Keep typing Workers/DelayedJob/queue_length/priority/*.  The metrics will auto-complete as you enter each segment. The asterisk at the end indicates that you want to break down the graph by priority. If you don't use priorities you can chart a single line for the queue length using the metric name Workers/DelayedJob/queue_length/all. 5. That's generally good enough to display the chart, but there are a couple of other properties you can customize. In our case, we removed the limit on the number of different priorities it will show, added \"jobs\" to the y-axis labels, and fixed the application to \"RPM Background\" where the DelayedJob agent reports to. Here's what it looks like: 6. Add the Failed Jobs chart. Repeat steps 3 - 5 but enter the metric for tracking failed jobs: Workers/DelayedJob/failed_jobs. 7. Add the Locked Jobs chart. Repeat steps 3 - 5 but enter the metric for tracking locked jobs: Workers/DelayedJob/locked_jobs. 8. Add the Job Execution Time chart. Repeat steps 3 - 5 but enter the metric for the response time of delayed jobs:  OtherTransaction/DelayedJob/all. We show execution time in milliseconds so we chose To Milliseconds for the Number Format and \"ms\" as the y-axis unit label. We also hide the legend. That's enough to get you started with a good dashboard for monitoring your DelayedJob workers. But you don't have to stop there. You can add a table showing you the summary metrics for each job or a breakdown chart of all the jobs. In addition to showing the response time of jobs, you could chart the throughput. We combine our staging and production servers onto one dashboard by duplicating the charts and picking a different application. Custom Dashboards now makes it easy to configure the charts for the exact data you want to display. If you haven't already, try New Relic today to see how you can improve the performance of your Ruby applications. And as always, we welcome your feedback on this post. Let us know what you think of Custom Dashboards and how you're using them to monitor your applications. Related Topics APM By Bill Kayser Bill has been with New Relic from the beginning as both a developer and a data scientist. Having worked in application performance management for nearly two decades, his role now entails discovering new ways of exploring and interpreting data as well as prototyping innovative new features. Follow the author Bill Kayser on Twitter Bill Kayser on GitHub Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 277.32703,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " in the New Relic application: 1) Select the application where DelayedJob is running. In our case it&#x27;s &quot;Background Jobs&quot;. 2) From the Custom Dashboards menu choose Create custom dashboard. Enter the title and &quot;Grid&quot; <em>chart</em> type. 3) Choose <em>Add</em> <em>chart</em> to <em>add</em> the <em>first</em> <em>chart</em> to <em>your</em> dashboard.  Fill"
      },
      "id": "607631ece7b9d201aea5c63a"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/server-overview-dashboard.png",
      "url": "https://newrelic.com/blog/how-to-relic/server-overview-dashboard",
      "sections": [
        "Building a Server Overview dashboard",
        "Creating custom dashboards is easy"
      ],
      "published_at": "2021-04-16T04:25:53Z",
      "title": "How to Create a Server Overview Dashboard in New Relic Insights",
      "updated_at": "2021-04-14T02:02:40Z",
      "type": "",
      "external_id": "a682a93ac23e587fc70b52a65c2440851f9214aa",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic How to Create a Server Overview Dashboard in New Relic Insights Aug 10, 2017 • 7 min read By Phil Weber New Relic Infrastructure gives you real-time, searchable, filterable visibility across your entire infrastructure. But what if you want to view key metrics about a server on a single dashboard? Thanks to New Relic Insights, you can! Because Infrastructure stores its data in the New Relic Database (NRDB, the same data store used by Insights), it’s easy to create a Server Overview dashboard. In this post I’d like to walk you through how it’s done. Building a Server Overview dashboard First, log into your New Relic account and navigate to Infrastructure’s Compute page: If you look closely above each chart, you’ll notice a small icon that resembles a chart on an easel: Click this icon to open the chart’s underlying NRQL query in Insights: From here, you can customize the query, give the chart a title, and add it to a dashboard. The NRQL AS clause allows you to customize the label of a query attribute. Let’s add some AS clauses to make the chart legend easier to read. Change the NRQL query to SELECT average(cpuSystemPercent) AS 'CPU System %', average(cpuIOWaitPercent) AS 'CPU I/O Wait %', average(cpuUserPercent)   AS 'CPU User %', average(cpuStealPercent) AS 'CPU Steal %' FROM SystemSample SINCE 60 minutes ago TIMESERIES Click the Run button to execute the query. Give the resulting chart a title, such as “CPU Usage,” and click Add to a Dashboard. In the Add to a Dashboard dialog, select Add to a new dashboard and give your new dashboard a name, such as “Server Overview.” Now go back to Infrastructure and repeat the process for the Load and Memory charts. Infrastructure draws a custom chart to display Used and Available memory as a stacked-area chart. Unfortunately, it is not possible to replicate this chart in Insights. Instead, change the NRQL query to SELECT average(memoryUsedBytes / memoryTotalBytes * 100) AS 'Percent Used', 100 AS 'Max' FROM SystemSample SINCE 60 minutes ago TIMESERIES The SELECT...100 AS 'Max' clause forces the Y-axis to a scale of 0 to 100, allowing us to display the memory used as an easy-to-read percentage. From Infrastructure’s Storage page, change the chart to display Total Utilization %, view the query in Insights, and change it to SELECT average(totalUtilizationPercent) FROM StorageSample FACET entityAndMountPoint SINCE 60 minutes ago TIMESERIES To display network throughput, use the following query: SELECT average(transmitBytesPerSecond / 1024) AS 'Transmitted', average(receiveBytesPerSecond / 1024) AS 'Received' FROM NetworkSample SINCE 60 minutes ago TIMESERIES It can be helpful to see which processes are running on a server, in case one of them is consuming a large amount of CPU or memory, for example. You can use the following query to display a list of running processes, the name of the user who started each process, and how much CPU and memory each process is using: SELECT uniqueCount(processId), latest(userName),   average(cpuPercent) AS 'CPU Percent', average(memoryResidentSizeBytes) / 1024 AS 'Memory (MB)' FROM ProcessSample FACET processDisplayName SINCE 1 hour ago New Relic Infrastructure captures information about system events, such as user logins, package deployments, etc. Let’s add a widget to our dashboard to display recent events: SELECT * FROM InfrastructureEvent SINCE 1 day ago Finally, we need a way to select an individual host, so we can see an overview of a single server. Let’s add a table based on the following query: SELECT average(cpuPercent) AS 'CPU %', average(memoryUsedBytes / memoryTotalBytes) * 100 AS 'Memory Used %' FROM SystemSample FACET hostname SINCE 5 minutes ago LIMIT 10 That query displays the Top 10 host names reporting to your account, in order of CPU usage. After adding the above table to your dashboard, click the ellipsis icon in the upper-right corner of the chart widget and select Edit link: In the resulting Link to dashboard dialog, link the widget to the Current dashboard and save your changes. Now you can select a host name from the table to filter the dashboard to that host: To view the information for a host that’s not included in the Top 10, click in the Search hostname field at the top of the page and select the desired hostname. Creating custom dashboards is easy Pulling key server metrics into a single dashboard takes just a few minutes; now you can easily see the status of an individual server at a glance. Because New Relic Infrastructure stores its data in NRDB, it’s easy to export and customize charts from Infrastructure to Insights, and create custom dashboards that display whatever information you want to see. For more information on using New Relic Insights to share and view Infrastructure data, check out the documentation.   By Phil Weber Phil Weber is a Senior Technical Training Specialist with New Relic University. He worked as a software developer for over 15 years, and has been a technical trainer since 2005. As a consultant, he worked for such clients as Intel and Kaiser Permanente. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.52344,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". In this post I’d like to walk you through how it’s done. Building a Server Overview dashboard <em>First</em>, log into <em>your</em> New Relic account and navigate to Infrastructure’s Compute page: If you look closely above each <em>chart</em>, you’ll notice a small icon that resembles a <em>chart</em> on an easel: Click this icon"
      },
      "id": "60764d40196a67ef7f64a7c0"
    },
    {
      "sections": [
        "Metric explorer: Search and chart metric timeslice data",
        "Important",
        "Features",
        "Add to an Insights dashboard",
        "Explore API",
        "Metric charts",
        "Search metrics",
        "Share charts",
        "Workflow",
        "Examples",
        "Add custom metric charts to a dashboard",
        "Tip",
        "Add metric chart for CPU usage faceted by host",
        "Search metrics to get relevant REST API call",
        "Get exact metric name to alert on it",
        "Query metric timeslice data with NRQL"
      ],
      "title": "Metric explorer: Search and chart metric timeslice data",
      "type": "docs",
      "tags": [
        "Insights",
        "Use Insights UI",
        "Explore data"
      ],
      "external_id": "2ce64c845a208b6de903283304f9c55eebca4fe4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/explore-data/metric-explorer-search-chart-metric-timeslice-data/",
      "published_at": "2021-04-16T03:06:48Z",
      "updated_at": "2021-03-30T08:43:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. In New Relic Insights, the Data explorer UI page lets you explore the data available to you in Insights. There are two tabs available: Events Metrics This document will explain details about using the Metrics tab. For information on the Events tab, see Events data explorer. Features Use the Insights Data explorer for metrics to: Search and chart metric timeslice data reported by New Relic APM, Browser, and Mobile (including custom metrics). Add metric charts to Insights dashboards to monitor the data most interesting to you or another team in a centralized place, alongside any NRQL-based event charts. Important You can also query metric timeslice using NRQL, which gives you more power and flexibility when querying this data. Here are some examples of how to get the most out of the metric explorer: Add to an Insights dashboard As you search for agent metrics and create charts in the metric explorer, add them to Insights dashboards to collect, organize, share, and see them alongside other Insights charts. This option is a standard page function available for most metric charts in the New Relic UI. Explore API If you use the New Relic REST API, use the metric explorer to: Browse through your metric data. Search and find the exact metric and metric values you need. Review or sample the charted data. Load the REST API Explorer preset to the selected metric and time range by selecting View in API Explorer. Metric charts The metric explorer enables you to search and create customizable charts for any of your New Relic metric data. You can only chart one metric namespace per chart. Customize your metric chart in the metric explorer for more precise views of your data. Search metrics Find any metric quickly by selecting the relevant entities first, then search or browse the metric namespaces for the metric. Search results are ordered by relevance. The metric explorer also suggests entities and metrics that are commonly used or that have a lot of data you may want to browse and drill into. For example, the metric explorer displays the root namespaces for metrics (Apdex, Datastore, EndUser, External, etc.) to make it easier for users to traverse and find their metrics. You can use some basic regex tokens in your search string. For example: Use ^ to start matching with the string that follows it. Use *as a wildcard. Some New Relic functions, like creating metric alerts, require the exact metric name. For information on how to get a metric's exact name, see Get exact metric name. Share charts Metric explorer creates a permalink URL that displays the charts and data for the selected time range for the current page. Permalinks can be used to share data and charts with colleagues, New Relic support staff, or anyone who has access to your New Relic account. Workflow To search and chart your New Relic agent metrics: From insights.newrelic.com > Data explorer > Metrics, select the entity or application your metrics report under. Browse the top metrics or search for a specific metric name. View metric charts as you select them. Configure the chart options. Optional: To load the API Explorer (preset to the selected metric and time range), select Explore API. To add individual charts to a dashboard, select Add to dashboard. Give each chart a meaningful title to identify it on the target dashboard. Examples Add custom metric charts to a dashboard Use case: The New Relic agent is not automatically capturing response time metric data for some part of your app's code, but you want to see and monitor its performance regularly. Instrument your code to record and send the custom metric to New Relic. For example, use an agent API call and a custom metric name like Custom/MyMetric/My_label. Once your code is running and sending data to New Relic, go to insights.newrelic.com > Data explorer > Metrics. From the metric explorer page, select the entity that your agent is reporting metrics under. Search for the custom metric name. Tip Use the metric explorer's Suggested Search (automatically filled with Custom) to easily find your custom metrics. Select the metric name to chart the metric data. Configure the chart, using available options for time window, chart values (Y-axis), facet by host (if available), etc. To organize this chart alongside similar charts or other NRQL charts, select Add to an Insights dashboard. Add metric chart for CPU usage faceted by host Use case: You want to see how CPU usage is impacting your different hosts for a given application. From insights.newrelic.com > Data explorer > Metrics, select the app. Search for CPU. From the search results, select CPU/System/Utilization to have the metric explorer automatically create a chart showing the percentage of CPU utilization on the app. Optional: To see a larger scope of metrics, add wildcards to the namespaces in front of CPU. To show the CPU percentage broken out by host on the new chart, select View by host. To organize this chart alongside similar charts or other NRQL charts, select Add to an Insights dashboard. Search metrics to get relevant REST API call Use case: You want to feed metrics into an external system to track trends in performance over time outside of New Relic Insights or other New Relic products. From insights.newrelic.com > Data explorer > Metrics, select the entity (application or host). Search for and select a metric that you'd like to chart. To review the data preset to the selected metric and time range: From the new chart, select View in API Explorer. Get exact metric name to alert on it Use case: You want to find the exact metric name in order to alert on it with New Relic Alerts. To use the metric explorer to get the exact name for a metric: Go to insights.newrelic.com > Data explorer > Metrics. Search for and select a metric. Under the metric chart, select View in API Explorer. On the API Explorer page for that metric, copy the name in the names [ ] field. From the selected policy's conditions page under Define thresholds, select Custom > Enter metric name from the When target application dropdown and paste the metric name in the Metric name field. For more about finding metric names, including using the API to do so, see Locate exact metric names. Query metric timeslice data with NRQL You can also query metric timeslice using NRQL, which is a more powerful, flexible way to query than using Insights' metric explorer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.919495,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Metric explorer: Search and <em>chart</em> metric timeslice data",
        "sections": "<em>Add</em> custom metric <em>charts</em> to a dashboard",
        "body": " to search and create customizable charts for any of <em>your</em> New Relic metric data. You can only <em>chart</em> one metric namespace per <em>chart</em>. Customize <em>your</em> metric <em>chart</em> in the metric explorer for more precise views of <em>your</em> data. Search metrics Find any metric quickly by selecting the relevant entities <em>first</em>"
      },
      "id": "6043ed05196a676e5b960f4a"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/markdown-summary-for-syslog-facilities.png",
      "url": "https://newrelic.com/blog/how-to-relic/how-to-create-syslog-dashboard-using-new-relic-terraform",
      "sections": [
        "Understanding the Syslog format",
        "Step 1: Create your Terraform project",
        "Step 2: Create the Syslog dashboard",
        "Widget 1: Billboard counters by severity",
        "Widget 2: Billboard for log throughput",
        "Widget 3: Line chart to view problem-related trends over time",
        "Widget 4: Bar charts by application and node",
        "Widget 5: Line charts to view log counters by severity and facility over time",
        "Widget 6: Event table to display the top 100 logs",
        "Widget 7: Markdown summary for Syslog facilities",
        "Step 3: Apply your code",
        "Step 4: Add alerts for real-time notification",
        "Ready to create a Syslog dashboard?"
      ],
      "published_at": "2021-04-15T23:12:03Z",
      "title": "Dashboards as Code: How to Create a Syslog Dashboard Using New Relic and Terraform",
      "updated_at": "2021-04-13T23:16:12Z",
      "type": "",
      "external_id": "5372ca6e0d29c3dced938e55d3c17f22b01bbec4",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic Dashboards as Code: How to Create a Syslog Dashboard Using New Relic and Terraform Mar 16, 2021 • 11 min read By Edmo Vamerlatti Dashboards are important tools that help you visualize your entire stack's performance to understand context and resolve issues quickly. They also help you answer questions such as, \"When did the problem start?\" and \"What's the impact of this issue?\" However, manually maintaining dashboards can be error prone and is sub-optimal in terms of efficiency and security. Manual updates to dashboards also do not provide any modification history, rollback mechanisms, peer reviews, or any of the benefits we normally expect in CI/CD pipelines. That’s why engineers are beginning to treat them like any other important resource: by creating dashboards as code. For example, using Terraform and the new, built-in log parser rule for Syslog RFC-5424 within New Relic One, you can implement observability as code with a dashboard that organizes Syslog RFC-5424 unstructured messages into attribute/value pairs and lets you drive alerts based on subsets of log data. With the new agentless option for onboarding syslog data, you have a variety of options for data ingest, so long as you properly parse the data when ingesting or directly from the New Relic UI. This blog post guides you through how to create a Syslog RFC-5424 dashboard as code. Understanding the Syslog format To build the dashboard, you first need to understand how log severities are defined in the Syslog RFC-5424 format. The PRI part of a syslog, which is a calculated priority value, is used to represent both the facility and severity of the log or event message. PRI calculates the value by first multiplying the facility number by 8 and then adding the numerical value of the severity. For example, a security/authorization (facility = 4) with a critical severity (severity = 2) would have a PRI value of 34 ((4 * 8) + 2). Based on this understanding, you can extract the log severity from the PRI log attribute using the following formula: (pri - ((floor(pri)/8) * 8)). Step 1: Create your Terraform project As an infrastructure-as-code tool that you can use to provision all kinds of infrastructure and services, Terraform uses a configuration language known as HCL. Its main purpose is to describe resources that are used to represent infrastructure objects. The resources are processed by specific plugins called providers. New Relic has an official Terraform provider. It allows you to manage different types of resources such as dashboards, alert channels, and alert policies. For more information about the Terraform provider, see the provider documentation and the quick-tip video shown here. Start by creating your project folder. Because Terraform is quite flexible and can be adapted depending on the requirements of your project (including multiple environments, multiple accounts, and so on), there are different ways of organizing a Terraform workspace. For simplicity’s sake, we’ll adopt a flat structure for this example. 1. Create a directory for your project. mkdir newrelic-syslog-monitoring 2. Create a file named versions.tf in your working directory. Terraform uses this file to configure the Terraform client and specify all required providers for the current module, in this case, the newrelic provider. terraform { required_version = \">= 0.13\" required_providers { newrelic = { source  = \"newrelic/newrelic\" version = \">= 2.12.0\" } } } 3. Provide input variables. The New Relic Terraform provider requires an Account ID, Personal Key, and Region (US or EU) to integrate with your account and manage resources. It supports two methods of configuration: using environment variables or a provider block. This simple example uses the provider block, and all required information is received through input variables. Create a file named variables.tf: variable \"NEWRELIC_ACCOUNT_ID\" { type    = number } variable \"NEWRELIC_API_KEY\" { type    = string } variable \"NEWRELIC_REGION\" { type    = string } 4. Create a file named main.tf to be the primary entry point for Terraform. The New Relic Terraform provider is also configured in this file using the input variables previously declared in the variables.tf file: provider \"newrelic\" { account_id = var.NEWRELIC_ACCOUNT_ID api_key    = var.NEWRELIC_API_KEY region     = var.NEWRELIC_REGION } Step 2: Create the Syslog dashboard All the dashboard data is retrieved from the Log data type using the NRQL query language. To simplify the queries and avoid repetition, use Terraform locals to represent the Syslog severity formula and the logType filter value. 1. Create a file named dashboards.tf. This file is used to describe the dashboard resource and its widgets/visualizations: locals { syslog   = \"syslog-rfc5424\" severity = \"(numeric(pri) - (floor(numeric(pri)/8) * 8))\" } resource \"newrelic_dashboard\" \"syslog_dashboard\" { title             = \"Syslog Dashboard\" grid_column_count = 12 } 2. Add widgets and visualizations. The first step in designing your dashboard is to define what you want to achieve and which visualizations will be most important to enable that. For this example, the dashboard gives an overview of application health. Note: All widget code goes inside the \"syslog_dashboard\" {...} block. Widget 1: Billboard counters by severity The log's severity is one of the most important fields available in the Syslog format and is widely used on this dashboard's visualizations. Billboard charts show the log counters by severity, coloring them yellow or red depending on the threshold_yellow and threshold_red values. The charts make it easy to see what's happening with your applications and catch your attention if any problematic log arrives. Because these billboard charts share nearly identical code, you can take advantage of Terrafrom's dynamic blocks and reuse the code to iterate through a severity_billboards map to configure every widget. To accomplish this, add a severity_billboards map inside the locals{...} block with the following content: locals { syslog   = \"syslog-rfc5424\" severity = \"(numeric(pri) - (floor(numeric(pri)/8) * 8))\" severity_billboards = tomap({ \"emergency\"     = { severity =  0, row = 1, column = 1, threshold_red = 1 }, \"alert\"         = { severity =  1, row = 2, column = 1, threshold_red = 1 }, \"critical\"      = { severity =  2, row = 1, column = 2, threshold_red = 1 }, \"error\"         = { severity =  3, row = 2, column = 2, threshold_yellow = 1 }, \"warning\"       = { severity =  4, row = 1, column = 3 }, \"notice\"        = { severity =  5, row = 2, column = 3 }, \"informational\" = { severity =  6, row = 1, column = 4 }, \"debug\"         = { severity =  7, row = 2, column = 4 } }) } Then add generic code for the widget inside the syslog_dashboard\" {...} block: dynamic \"widget\" { for_each = local.severity_billboards content { title            = \"\" nrql             = <<-EOF SELECT count(*) as '${title(widget.key)} (${widget.value.severity})' FROM Log WHERE logType = '${local.syslog}' AND ${local.severity} = ${widget.value.severity} EOF visualization    = \"billboard\" width            = 1 height           = 1 row              = widget.value.row column           = widget.value.column threshold_yellow = try(widget.value.threshold_yellow, null) threshold_red    = try(widget.value.threshold_red, null) } } Your final result should look similar to this:   Widget 2: Billboard for log throughput This chart shows the total number of logs and the rate per minute your applications are sending them. widget { title         = \"Throughput\" nrql          = <<-EOF SELECT rate(count(*), 1 minute) as 'Logs /min', count(*) as 'Total' FROM Log WHERE logType = '${local.syslog}' SINCE 1 hour ago EOF visualization = \"attribute_sheet\" width         = 2 height        = 2 row           = 1 column        = 5 } Your final result should look like this:   Widget 3: Line chart to view problem-related trends over time This chart counts all logs with severity equal to Error(3), Critical(2), Alert(1) or Emergency(0) and displays the result over time. Spikes on this graph show that you might have problems with your applications that require actions to be taken to resolve them. widget { title         = \"Logs (Emergency + Alert + Critical + Error)\" nrql          = <<-EOF SELECT count(*) FROM Log WHERE logType = '${local.syslog}' AND ${local.severity} < 4 TIMESERIES AUTO EOF visualization = \"line_chart\" width         = 6 height        = 3 row           = 3 column        = 1 } Your final result should look something like this:   Widget 4: Bar charts by application and node These charts show the number of logs by application and hostname. They can also be configured to filter the current dashboard just by clicking on the application/hostname bars. widget { title         = \"Top Applications\" nrql          = <<-EOF SELECT count(*) FROM Log WHERE logType = '${local.syslog}' FACET app.name EOF visualization = \"facet_bar_chart\" width         = 2 height        = 5 row           = 1 column        = 7 } widget { title         = \"Top Nodes\" nrql          = <<-EOF SELECT count(*) as 'Logs' FROM Log WHERE logType = '${local.syslog}' FACET hostname EOF visualization = \"facet_bar_chart\" width         = 2 height        = 5 row           = 1 column        = 9 } Your final result should look similar to this:   Widget 5: Line charts to view log counters by severity and facility over time The idea behind these charts is to display the number of logs by severity and facility your applications are sending over time. This way you can easily detect spikes of any severity or facility and identify when they started and stopped. widget { title         = \"Logs by Severity\" nrql          = <<-EOF SELECT count(*) FROM Log WHERE logType = '${local.syslog}' FACET string(${local.severity}) as 'Severity' TIMESERIES AUTO EOF visualization = \"faceted_line_chart\" width         = 3 height        = 3 row           = 6 column        = 1 } widget { title         = \"Logs by Facility\" nrql          = <<-EOF SELECT count(*) FROM Log WHERE logType = '${local.syslog}' FACET floor(numeric(pri)/8) as 'Facility' TIMESERIES AUTO EOF visualization = \"faceted_line_chart\" width         = 3 height        = 3 row           = 6 column        = 4 } Your final result should look similar to this:   Widget 6: Event table to display the top 100 logs This chart displays the 100 most important logs prioritized by severity. widget { title         = \"Top 100 Logs\" nrql          = <<-EOF SELECT ${local.severity} as 'Severity', app.name as 'Application', message FROM Log WHERE logType = '${local.syslog}' LIMIT 100 EOF column        = 7 row           = 6 visualization = \"event_table\" width         = 6 height        = 3 } Your final result should look like this:   Widget 7: Markdown summary for Syslog facilities This chart lists the names of the syslog facilities on your dashboard for easy reference. widget { title         = \"\" width         = 2 height        = 5 row           = 1 column        = 11 source        = <<-EOF ### Facilities 1. kernel messages 2. user-level messages 3. mail system 4. system daemons 5. security/authorization messages (note 1) 6. messages generated internally by syslogd 7. line printer subsystem 8. network news subsystem 9. UUCP subsystem 10. clock daemon (note 2) 11. security/authorization messages (note 1) 12. FTP daemon 13. NTP subsystem 14. log audit (note 1) 15. log alert (note 1) 16. clock daemon (note 2) to 23. local uses 0 to 7 (local n) EOF visualization = \"markdown\" } Your final dashboard should look similar to this: markdown summary for syslog facilities example   Step 3: Apply your code You can install the Terraform client either by downloading the binary from www.terraform.io/downloads.html or using your operating system's package manager. More instructions on how to install Terraform in different environments can be found here. After you install the Terraform client, run the following command in your working directory: terraform plan -var NEWRELIC_ACCOUNT_ID=<YOUR-ACCOUNT-ID> -var NEWRELIC_API_KEY=<YOUR-API-KEY> \\ -var NEWRELIC_REGION=<US or EU> The terraform plan command creates an execution plan and then determines which actions are necessary to achieve the desired state specified in the configuration files. In this case, your dashboard resource is added. Finally, run the following command to apply all pending actions and create the resources in the New Relic One platform: terraform apply -var NEWRELIC_ACCOUNT_ID=<YOUR-ACCOUNT-ID> -var NEWRELIC_API_KEY=<YOUR-API-KEY> \\ -var NEWRELIC_REGION=<US or EU> Terraform uses states to map your local resources to the real world. When you have a declared resource such as resource \"newrelic_dashboard\" in your files, Terraform uses the map to know that the New Relic Dashboard ID 1234 is represented by that resource. That said, if you apply this project in different machines without sharing the state, Terraform will recreate all resources instead of updating them. Setting up a remote state would prevent this situation. HashiCorp offers a Terraform Cloud solution that automates Terraform workflow out of the box. It's also possible to use Atlantis, which is a tool that automates Terraform through pull requests, taking your observability as code to the next level. Step 4: Add alerts for real-time notification Although dashboards are essential tools for detecting and troubleshooting problems, unless you’re watching them 24 hours a day, you can miss important logs. Setting up alerts gives you instant notification whenever an important metric hits a threshold. New Relic alerts help you solve your application issues faster and with less noise before they turn into critical incidents. New Relic’s third-party integrations, such as PagerDuty and Slack, make the notification process very efficient and adaptable to your team’s needs. The New Relic Terraform provider supports all required alerting resources to monitor your syslog applications. You can, for example, create different alert channels per team, responsibility, node, or application, notifying different people in various ways when applications are reporting errors. For the example, you can reuse the dashboard queries and define the following NRQL alert conditions: A static threshold alarm for critical severities Error(3), Critical(2), Alert(1) and Emergency(0). Baseline alarm in upper direction for log counters with severity < 4 to detect abnormal unhealthy spikes. Additional alerts depending on your environment and system characteristics, such as a static alert for logs with severity < 4 and facility equal to security/authorization messages(4), which would appropriately send a notification message to the #security-team Slack channel, for example, and not the whole company. (For more information about New Relic alerts with Terraform, see this blog post.) Ready to create a Syslog dashboard? All the code used in the example can be found in this GitHub repository. If you don't want to use Terraform but would like to try out the dashboard, you can import it by copying this JSON file content, replacing the <YOUR_ACCOUNT_ID> placeholder with your Account ID, and importing it into New Relic using the UI (Dashboard > Import dashboard option). If you’re new to New Relic and want to try out the New Relic Terraform provider, sign up for a new account with 100 GB/month of free ingest. By Edmo Vamerlatti Edmo is a Software Engineer at New Relic, where he works on the Logging team. His professional interests include distributed systems, high scalability, observability, and programming languages. In his spare time, he enjoys reading, eating out in restaurants, and skateboarding. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.73624,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Step 1: Create <em>your</em> Terraform project",
        "body": ". The <em>first</em> step in designing <em>your</em> dashboard is to define what you want to achieve and which visualizations will be most important to enable that. For this example, the dashboard gives an overview of application health. Note: All widget code goes inside the &quot;syslog_dashboard&quot; {...} block. Widget 1"
      },
      "id": "6076263d28ccbcffe951c16a"
    },
    {
      "sections": [
        "Plugin summary metrics and dashboards",
        "Important",
        "Limited access to legacy plugins",
        "Plugin summary metrics",
        "Add summary metrics",
        "Optional: Add alert summary metrics",
        "Time periods for metrics",
        "Plugin dashboards",
        "View the default dashboard",
        "Add dashboards",
        "Avoid metric grouping problems",
        "Change or delete dashboards",
        "Plugin settings",
        "Initial settings",
        "Additional updates"
      ],
      "title": "Plugin summary metrics and dashboards",
      "type": "docs",
      "tags": [
        "Plugins",
        "Plugin developer resources",
        "Develop plugins"
      ],
      "external_id": "a0163b9f1efd59d8c50c60a3b8b5b5419f336824",
      "image": "",
      "url": "https://docs.newrelic.com/docs/plugins/plugin-developer-resources/develop-plugins/plugin-summary-metrics-dashboards/",
      "published_at": "2021-04-16T15:11:44Z",
      "updated_at": "2021-03-16T11:00:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important For an even better experience than plugins, go to: newrelic.com/integrations: Integrate the on-host and cloud systems you already use with New Relic, so you can filter and analyze data, create dashboards, and set alerts within a single platform. developer.newrelic.com: Use developer tools to collect data from any source, automate workflows, build apps, and use our APIs. Limited access to legacy plugins As of December 2, 2020, plugin access has been limited to accounts that have accessed a legacy plugin in the past 30 days. The legacy plugin experience will reach end of life (EoL) as of June 16, 2021. For more information, see our Explorers Hub post. Plugin summary metrics Each component or instance for your plugin in Plugin Central can have summary metrics, such as average, total, minimum, maximum, standard deviation, rate, or count. The summary metrics appear on your plugin's Summary page in the Plugins user interface. The summary metric dashboards are also useful as a debugging tool to review all of the metrics sent by your plugin agent to New Relic. To view dashboard details about any component or instance, select any summary metric value for it. You can also change various plugin settings in the UI. When you first create a summary metric for your plugin, this triggers a change to New Relic's collectors. This may cause your running components (instances) to stop showing summary metrics for a short period of time. For example, if you add a new summary metric to your plugin, any components (instances) you are monitoring that use that plugin may have all summary metrics temporarily cleared. This will also close any outstanding related events and alerts. Depending on the components and other factors, you may need to wait fifteen minutes or more before summary metrics appear again. Add summary metrics To add a summary metric: Go to one.newrelic.com > More > Plugins, and select your plugin. From the plugin's Summary page, select Edit. From the Summary metrics section of the plugin's editing page, select Add. If your plugin contains only one summary metric, you can identify the metric in the chart's title and then hide the legend (colored bars that label the metrics) that normally appears below the chart. Also, if you define negative metric values, the charts on your plugin's dashboards will not show them. However, the summary metrics for your plugin will show negative values. Optional: Add alert summary metrics Plugin publishers and users can define alert conditions from the plugin's Summary page by selecting the component's or instance's settings icon. The alerts will be activated when the summary metric's specified values fall above the thresholds. The Recent events list for the plugin's components (instances) appears on the plugin's Summary page. To view additional details about an alert, select its name. Sometimes there may be a delay between the time that a summary metric event is triggered and the time that New Relic creates the corresponding incident and sends the alert notification. There are several timing mechanisms at work, such as collector caching, summary metric event timing, delayed job queues, email delivery, etc. Depending on the situation, this delay could be up to ten or fifteen minutes before the alert notification is sent. Time periods for metrics Metrics that appear in dashboards are reported with a duration. The end time is implied by the time New Relic receives the metrics. This is why you cannot define metric values that both start and end in the future, or start and end in the past. The Plugin API is designed for live metrics only, not historical metric collection. Metrics may only be reported for a period starting in the past (no more than a few hours) and ending upon reporting. The charts on your plugin's dashboards can show various time periods. You can also deliver data at one-hour intervals. New Relic does not extrapolate data values between the data points delivered. For example, New Relic aggregates when there is too much data, but it does not extrapolate if there is not enough data. In order for data to appear on a 30-minute chart, make sure at least one data point is within the range, or no data will appear. Recommendation: Use a 60-second polling interval. Default dashboards show 30 minutes of data, which gives 30 data points for the chart. Or, if you want to show 3 days of data, use a 1-hour polling interval, which provides 24 * 3=72 data points for your chart. Plugin dashboards You can create dashboards to visualize the data generated by your plugins in New Relic. You must be a plugin author or publisher to add, edit, and delete dashboards. Plugin users cannot customize the plugin dashboards they acquire from Plugin Central. View the default dashboard New plugins automatically include a default dashboard. Once your plugin agent starts sending data to New Relic's Plugin API, you can view the default dashboard in New Relic's UI and change it as needed. To view the default dashboard for your plugin: Go to one.newrelic.com > More > Plugins, and select your plugin. From the plugin's Summary page, select a component (instance). Add dashboards In addition to the default dashboard, you can create as many additional dashboards for your plugin as you want. After you publish your plugin, all of these dashboards and summary metrics are available to plugin users. The customized dashboards that display plugin data are part of the plugin. Plugin users cannot add their own dashboards. This needs to be done by the author or publisher as part of a plugin fork or update. To create additional dashboards: Go to one.newrelic.com > More > Plugins, and select your plugin. From the plugin's summary page, select Edit. From the Dashboards section of the plugin's editing page, select Add. Specify a title for your dashboard, select a page layout, then select Create. From the new dashboard page, type a label for the new chart or table, and then select Add chart or table. Edit the chart, including the case-sensitive metrics (for example, a metric name you see in the agent output, such as Component/SIN[Value]) and value (for example, Total value). To use additional options (for example, number format), select Advanced options. Optional: Use a wildcard (*) to show multiple metrics on a chart. For example, to include the metric component/foo/bar and the metric component/foo/xyz, use the metric name component/foo/*.f Select Save and Preview to preview the chart or table. Or, select Save and finish when you are satisfied with the appearance of the chart or table. Review the new chart that appears on the customized dashboard, and continue adding, editing, or rearranging charts and tables on your dashboard as needed. When finished, select I'm done editing. Avoid metric grouping problems Wildcards provide flexibility for how your metric names appear. When creating a chart, consider whether you want the metric names to appear with identical namespace segments, or include a wildcard to strip the namespace segments. For example: Component/Database/Metric1 Component/Database/Metric2 Component/Database/Metric3 Copy OR Metric1 Metric2 Metric3 Copy To prevent problems with metric grouping issues, avoid defining values that result in excessively large numbers. For example, if a plugin's chart value is 1 widget and New Relic collects 3 million widgets, change the value to 1 million widgets so that the chart can show millions of widgets more efficiently. Also, avoid creating high-precision values containing many digits after a decimal point. Change or delete dashboards To update or remove any plugin dashboard, including the default: Go to one.newrelic.com > More > Plugins, and select your plugin. From the plugin's summary page, select Edit. Keep a stable production version of your plugin that users can acquire from Plugin Central, and create a development version that you are actively improving, testing, browsing the presentation of metrics on your custom dashboard, or otherwise have in a non-production state. Plugin settings You can change several plugin settings before you publish the plugin. You can also make changes at any time to published plugins. Initial settings Before you publish your plugin, you can: Select a generic plugin icon for the Plugins UI. This is not the same as the URL for your customized branding image you may choose as part of the publishing process. Change your plugin's label for the Plugins UI. By default, this is the first 11 characters of the plugin's Title field. Change your plugin's title. The default title is your plugin's GUID. Add, change, or delete your plugin's summary metrics and their alert conditions. Add, change, or delete your plugin's dashboards. Exception: You can edit but you cannnot delete your plugin's default dashboard. To add, change, or delete plugin settings: Go to one.newrelic.com > More > Plugins, and select your plugin. From the plugin's Summary page, select Edit. When finished, be sure to save your changes. Additional updates After you publish your plugin, you can continue making changes. Recommendation: To avoid development and testing impacts on your users, maintain development and production versions. To make additional updates to your plugin: Go to one.newrelic.com > More > Plugins, and select your plugin. From your plugin's Summary page, select Edit, Publish, or your component's (instance's) settings icon as applicable. Update the settings as needed, and then save your changes. When you are ready to release this version: Go to one.newrelic.com > More > Plugins, select your plugin, and then select Publish. Here is a summary of where to view or make changes to your plugin. Type of change Edit Publish Settings Agent: Change the plugin's version (n/a in UI). Alert conditions, customized for components (instances) Alert conditions, defaults for summary metrics Branding image (URL) that appears in Plugin Central Components (instances): Remove from your plugin Dashboards: Add, edit, delete Description Developer Terms of Service Icon that appears in the Plugins UI Name for plugin (label) in the Plugins UI Name for plugin (title) in Plugin Central NPI Compatible designation Publisher's name Summary metrics: Add, edit, delete URL for installation and setup instructions URL for your support site URL for your website (\"About us\")",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.64896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em> summary metrics",
        "body": " various plugin settings in the UI. When you <em>first</em> create a summary metric for <em>your</em> plugin, this triggers a change to New Relic&#x27;s collectors. This may cause <em>your</em> running components (instances) to stop showing summary metrics for a short period of time. For example, if you <em>add</em> a new summary metric"
      },
      "id": "603ea2bc196a6740f7a83de2"
    }
  ],
  "/build-apps/ab-test/add-ui": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Step-4-e1536085654473.png",
      "url": "https://newrelic.com/blog/how-to-relic/using-new-relic-to-identify-and-manage-application-dependencies-video",
      "sections": [
        "Step 1. Identify applications and components",
        "Step 2. Install New Relic agents",
        "Step 3. Map and assess dependencies",
        "Step 4. Spot unknown dependencies",
        "Step 5. Perform an infrastructure inventory",
        "Your next step: success",
        "Related Topics"
      ],
      "published_at": "2021-04-16T00:00:25Z",
      "title": "Using New Relic to Identify and Manage Application Dependencies [Video]",
      "updated_at": "2021-04-14T01:13:03Z",
      "type": "",
      "external_id": "472a071713ff830accf5bed0735c017911b761b2",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit APM Using New Relic to Identify and Manage Application Dependencies [Video] Sep 4, 2018 • 5 min read By Rose Randall Application dependencies and infrastructure configuration play a critical role in the cloud migration process. When you successfully define an application’s architecture, including application dependencies and inventory, you reduce the risk that a missed interdependency might complicate a cloud migration project—or even cause an outage. In this post, and in the associated video at the bottom of the page, we’ll walk you through how New Relic helps you identify application dependencies quickly and efficiently. We’ll focus our attention on five key steps in this process: Identify applications and components Install New Relic agents Map and assess dependencies Spot unknown dependencies Perform an infrastructure inventory Let’s get started! Step 1. Identify applications and components Before you do anything else, you need to answer three basic questions about your current on-premise architecture: What applications are included in the cloud migration? What are the dependencies of each application? What underlying services and inventory support each application? It pays to scope your cloud migration carefully; a missed dependency now could cost you time and trouble later. Step 2. Install New Relic agents New Relic agents connect your applications and infrastructure to the functionality of the New Relic platform. To install the agents, and to get help configuring them, follow the instructions you see within the user interface or refer to our agent documentation. The New Relic APM agent collects data related to app availability and external services, and uploads metrics and events to New Relic. Within a few minutes, New Relic APM will begin to create a visual summary of your application dependencies. Step 3. Map and assess dependencies Next, you’ll want to use the Service Maps feature of New Relic APM. Log into your New Relic account, click Maps at the top right, and then select Service Maps. A list of your instrumented services will populate on the left; there may be one or more of these, depending on your APM deployment. Find the in-scope application for your cloud migration, select it, and watch the corresponding Service Map begin to populate. The Service Map identifies all of the connections between applications and external services, web services, databases, and APIs. These, in turn, define the upstream and downstream dependencies of your application, and provide a starting point to plan your cloud migration. Step 4. Spot unknown dependencies Because applications can undergo significant changes over time, this process often reveals surprising information about an application—especially if other people previously owned and maintained it. The New Relic APM and New Relic Infrastructure agents help you discover these dependencies before you begin a cloud migration—not as an unwelcome surprise during a migration. When you discover an unknown dependency, you can assess its relationship to your application, and decide whether to add the new component to your migration plan. Step 5. Perform an infrastructure inventory The next component to think about is your infrastructure inventory. To view it, click the Infrastructure tab and then the Inventory tab. Filter the results to include only the hosts that are currently running your application, and you’ll see an inventory populate on the right side of the screen. The key function of this process is to identify the software packages installed on these servers. You’ll also find a detailed rundown of system configuration, including: System modules Configuration files Metadata Packages Services User sessions The Inventory page is updated in real time, and it allows you to filter and search a host’s configuration data to suit your needs. There’s another important capability to note here: New Relic highlights variations within the versions of installed packages, as you can see on a few of the items in our demo video (below). You can use this information to upgrade and/or replicate the relevant packages to support your cloud migration. You can also use this feature to track dependencies between software packages and configuration files; and to quickly identify any host with a non-standard configuration. These sorts of package-management insights can play a critical role in your migration plan, helping you to make better decisions about the cloud infrastructure that will support your workloads. Your next step: success The tools and tactics discussed here are designed to give you a full picture of your application and infrastructure ecosystems. New Relic Service Maps and infrastructure inventory can help you understand the application dependencies within the scope of a cloud migration, and provide detailed information about how your infrastructure is configured. Once you’re armed with these insights, you can move more quickly to plan your migration and set priorities with confidence. To learn more, watch the video below, and stay tuned for more episodes in our Plan, Migrate, Win series of video and blog tutorials.   Additional information: Application dependencies and inventory documentation New Relic cloud adoption tutorial The Essential Guide to Cloud Migration Monitoring   Related Topics APM By Rose Randall Rose Randall is a Senior Solutions Consultant for New Relic. She assists her clients with cloud adoption/migration and DevOps initiatives, and enhances their digital customer experience through real-time performance and business level KPI analytics. Previously, Rose held positions at BlueJeans Network, Avaya, and Dolby Laboratories. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.43002,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Using New Relic <em>to</em> Identify and Manage <em>Application</em> Dependencies [Video]",
        "sections": "Step 1. Identify <em>applications</em> and <em>components</em>",
        "body": " a cloud migration—not as an unwelcome surprise during a migration. When you discover an unknown dependency, you can assess its relationship to <em>your</em> <em>application</em>, and decide whether to <em>add</em> the new component to <em>your</em> migration plan. Step 5. Perform an infrastructure inventory The next component to think"
      },
      "id": "6076419f196a676d6264a765"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Figure17-min.jpg",
      "url": "https://newrelic.com/blog/best-practices/best-javascript-libraries-frameworks",
      "sections": [
        "JavaScript Libraries",
        "1. D3.js",
        "2. jQuery",
        "3. jQuery UI",
        "4. Parsley",
        "5. QUnit",
        "6. React",
        "JavaScript Frameworks",
        "1. Angular",
        "2. Ember.js",
        "3. Node.js",
        "4. Vue.js",
        "Other choices",
        "The bottom line"
      ],
      "published_at": "2021-04-16T02:43:31Z",
      "title": "10 Amazing Libraries and Frameworks for Your Web-based JavaScript Applications",
      "updated_at": "2021-04-14T01:58:42Z",
      "type": "",
      "external_id": "269b0c13c7f9e16337d7fa92331a1afb7162019c",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Best Practices 10 Amazing Libraries and Frameworks for Your Web-based JavaScript Applications Jun 21, 2018 • 15 min read By John Paul Mueller Updated June 2018. Of all the languages you can use to create web applications, JavaScript has perhaps the most robust selection of truly useful libraries and frameworks. In fact, there are so many that it can be hard to figure out which ones to use, especially when you’re just getting started. The key difference between JavaScript libraries and frameworks is that libraries consist of functions that an application can call to perform a task, while a framework defines how a developer designs an application. In other words, the framework calls on the application code, rather than the other way around. Of course, developers still need libraries to accomplish basic tasks on the web using JavaScript. The nature of these tools has changed in the last few years. Back in 2015, for example, jQuery was the top JavaScript library. Today, according to JavaScript Scene, traditional JavaScript libraries remain important but face increased competition from JavaScript frameworks such as React, Angular, Node.js, and Ember.js. When considering any JavaScript library or framework, you may want to ask a few key questions: Is the library or framework flexible enough to meet your needs? How often is the library or framework updated to meet new application requirements and to ensure compatibility with new standards? Is the library or framework secure? It can be very difficult to fix security problems later. Does the library or framework enjoy strong community support? You might be surprised how often you’ll need it. Are there simple example applications? You want to be sure that the library or framework is well written and provides usable documentation. With that in mind, we’re updating our list, originally published in 2015, to cover well-known libraries and frameworks employed by just about every site on the web, as well as more specialized options designed to support specific site functionalities. To help you understand the choices, we’ve listed the libraries and frameworks separately (in alphabetical order): JavaScript Libraries 1. D3.js Many modern websites are data driven. News sites, for example, must constantly refresh their content, making it impossible to reconfigure the setup every few seconds to support these changes. The Data Driven Documents, or D3.js, library is unique in that it puts the data first. The screenshot below shows just a few of the many data presentations you’ll find in D3.js’ visual index: Clicking an entry in the visual index takes you to a detail page where you can see a full view of the data presentation (shown below), as well as the underlying code and the data used to create the presentation: The site provides full-fledged examples designed to help you understand the power of the library. The main advantage of this library is its extremely flexible handling of content. The flip side, however, is that D3.js doesn’t deliver a lot of pizzazz. If you’re working on an e-commerce site, for example, rather than merely presenting information, this library may not be the best choice. In addition to extreme flexibility, D3.js’ relatively streamlined presentation helps improve speed by eschewing a lot of the baggage other libraries use to create bedazzling presentations. And if you find that D3.js is still a bit too much for your needs, consider Chart.js, a smaller library dedicated to providing charting. 2. jQuery jQuery has earned its long-running status as the reigning ruler of the webpage. Many sites still use jQuery for basic Document Object Model (DOM) manipulation for three essential reasons: jQuery is incredibly easy to learn. It provides more examples than most libraries, so there is a really good chance you’ll find an example that demonstrates exactly how to accomplish your specific task. jQuery is incredibly fast. Because it focuses on performing specific tasks well, jQuery makes it possible to perform those tasks quickly. jQuery has a huge installed base. It also has significant amount of community support and project contributors. You can expect this library to be around for the long haul. The additional development time also means the documentation is quite polished. As you can see below, the documentation breaks topics down into easily understood pieces and you can then delve into additional detail as needed: Of course, nothing is perfect. For example, there are times when jQuery doesn’t work quite the same across multiple browsers. JQuery is up front about these concerns, and you can find information about browser support on the site. Finally, unlike other libraries, jQuery isn’t a complete solution. You need another product, such as jQuery UI (see the next entry) to build a complete application. It’s important to realize that your site will be more modular and dependent on more libraries when working with jQuery (which isn’t necessarily a bad thing). 3. jQuery UI jQuery UI is just one of many add-ons for jQuery, but it’s the one you see most often, which is why we’ve included it here. You use jQuery UI to add basic graphic elements to your application after you incorporate jQuery. The jQuery UI library comes with all sorts of interesting widgets, such as accordions, sliders, tooltips, and datepickers, that make it possible to configure your application to provide useful services. You can drill down to particular widgets or other controls to see how they work. A page typically contains the control at the top, followed by directions for use and sample code. As with jQuery, you begin with a simple example but drill down as needed to see additions you can make. This library stands out for several reasons. Most important, JQuery UI works with just about any browser, so users are less likely to complain that your application doesn’t work as expected. jQuery UI also offers a vast number of add-ons. For example, while jQuery UI lacks a time picker, you can get add-ons to perform that task from places such as trentrichardson.com/examples/timepicker. The one issue with the jQuery group of libraries is that they have gotten big … really big. Sometimes a library simply gets to be too feature rich. The size of JQuery libraries can make them slow to load on smaller devices. Alternative third-party libraries such as Granim.js and Multiple.js have sprung up to provide a subset of jQuery features, sometimes with a focused set of additional features, with significantly faster load times. 4. Parsley Form validation is an essential task. Because data is now so often analyzed by machines, clean data is more essential than ever. Cleaning the data after the fact is time consuming and never as accurate as getting the user to provide correct information in the first place. Parsley provides more form-validation techniques than just about any other JavaScript library. You choose the level of validation you need, but they can become quite complex: Even the supposedly simple validation shown below contains many different validation types, along with the code required to perform the task. It’s amazing how easy it is to accomplish most common validations. (You won’t need heavy coding unless you’re trying to validate complex data.) 5. QUnit The testing functionality provided by many libraries leaves much to be desired. Even if you use a script, manual testing of complex applications is bound to be cumbersome and time consuming—if it can even find all the errors. QUnit is one of several unit-testing libraries available for JavaScript. Though some might consider it a bit dated, it’s relatively comprehensive and stands out with great community support and a short learning curve. The QUnit site provides a wealth of get-started information, including a complete tutorial on unit testing. You can even use QUnit to test QUnit (assuming you’d ever want to do so)! 6. React Usually considered a library, React is sometimes referred to as a framework. In the context of the Model-View-Controller (MVC) approach to creating large-scale applications, React provides the view portion. It doesn’t assume anything about the underlying technology stack that you’re using to model or control the data. All React is interested in is displaying the data on screen. With this in mind, it doesn’t rely on the browser Document Object Model (DOM), but instead uses a light virtual DOM that displays the information quickly. One of the best things about React is that it’s declarative, which means you tell the framework what you want to do, not how to do it. The price you pay for the speed and ability to use MVC is some degree of added complexity. Even a small component requires quite a bit of code (as demonstrated by the examples on the React site). What you gain is flexibility and speed when working with really large projects. JavaScript Frameworks 1. Angular The Angular framework makes it possible to extend HTML by acting as the controller portion of MVC. Controllers are the behavior behind DOM components. Angular makes it possible to create new behaviors in a manner that is both natural and straightforward. The extensions end up looking like additions to HTML, rather than something bolted in place. The Angular site makes clear the two essential reasons to use this product: “speed & performance” and “incredible tooling.” However, the coding can become complex, and this framework may be more suited to enterprises than small startups. Even the simple examples on the Angular site rely on multiple files that quickly create complexity. It’s important to note that the latest version of Angular also relies on TypeScript instead of pure JavaScript, which increases the learning curve but provides scalability. Fortunately, Angular comes with an extensive tutorial, shown here, that should make it easier for experienced developers to start producing results quickly. One potential issue: the latest version of Angular does not support as wide a range of browsers as did previous releases. Make sure it’s compatible with the browsers your site supports. 2. Ember.js There is something serious about a framework that refers to itself as a “framework for ambitious web developers.” Well-known companies like Microsoft, Netflix, and LinkedIn use Ember.js because it employs the Model-View-View-Model (MVVM) pattern and incorporates best practices as part of the framework. Best of all, it scales really well. Interestingly, while Ember.js focuses on web development, you can also use it to build mobile and desktop applications—it was used to build Apple Music. Unlike many other frameworks, you can use the full suite of Ember-based tools to create a highly compatible development environment. The Ember CLI (command line interface) provides access to a wealth of tools that you can automate using scripts. Ember Data, for example, provides web-oriented data access using Object-Relational Mapping (ORM). Ember Inspector, meanwhile, is a plugin for Firefox and Chrome browsers designed to make debugging easier. Even with all its power, though, Ember.js’ quick-start tutorial takes just five minutes to complete. Of course, the standard tutorial takes significantly longer, but produces more respectable results, as shown here: The documentation for this framework includes all of the topics you need, including discussions of the object model, templates, components, controllers, and models. There is also a blog, and the Ember.js community can provide additional help. 3. Node.js Node.js is an asynchronous, event-driven JavaScript runtime with some unique features. For one thing, if it has no work to do, it simply “goes to sleep.” This may not sound like a big deal, but if you’re hosting your site in the public cloud, “puting it to sleep” could save you money—possibly lots of money. In addition, because Node.js doesn’t require locks to do its work, it doesn’t tend to dead-lock as some other frameworks can. This product is more like jQuery rather than jQueryUI, in that you don’t use it to create a user interface. Instead, you create code that reacts to events—a client generates events, and the server responds to those events. The user interface is a separate element that displays any result. Because Node.js is so simple and fast, with community support second to none, you can find it in the unlikeliest of places. Even if you don’t think you have the full package installed, you likely have at least part of it installed as part of Node.js Package Manager (NPM). According to the Node.js foundation, there are 9 million instances of it running on more than 50,000 thousand packages. In other words, Node.js forms the foundation of a great many of the packages you use. With Node.js, developers can build: Backend applications Blogs Customer management systems Real-time services, such as chat apps and games REST APIs Social network applications Utilities and tools 4. Vue.js A versatile open-source JavaScript framework, Vue is “progressive,” which means that unlike “monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable.” Scaling between a library and full-featured framework, Vue uses a “component-based development model” that lets you mix and match Vue components into your projects. Key Vue features include components, templates, transitions, and two-way data binding, but perhaps its most distinctive feature is its “reactivity” system. Basically, reactivity means that updating a JavaScript object in Vue automatically and unobtrusively updates the Vue templates. Vue was built to be usable by anyone with a working knowledge of HTML, CSS, and JavaScript. To get an idea of how it works, watch the video below: For more information, you can see how Vue compares with other Frameworks here. Other choices Don’t forget that there are many more JavaScript libraries, communities, collections, and frameworks available, often with specific focus areas. For example, CodePen is a free online community for testing and showcasing mixes of HTML, CSS, and JavaScript. Think of it as a social environment for frontend designers and developers, an online development community, and an editor with a uniform interface. Each CodePen entry is called a Pen and you can see them in action as part of a collection. Some collections are quite fancy, such as anime.js, while others, such as Funny JS, have interesting widgets you might not see elsewhere. It also works with directly with React. Similarly, Jest is a “zero-configuration” JavaScript testing solution designed to work out-of-the-box with React. BIDEO.JS, meanwhile, provides a method for displaying full-screen background videos, useful if you’re building a site for a travel agency, for example. The bottom line As it should be clear by now, the problem isn’t finding a JavaScript library or framework that can help you do something interesting—it’s finding the library that will help you do the one task you need to accomplish. In addition, you want to make sure you’re relying on libraries that will still be around tomorrow. No one wants to have to rework their application because the JavaScript library it uses is no longer available. And even though most modern JavaScript libraries and frameworks are now extremely reliable, you still have to ensure they work with all of the devices and browsers your users rely on. By John Paul Mueller John Mueller is a freelance author and technical editor, with 108 books and more than 600 articles to his credit on topics ranging from networking to artificial intelligence and from database management to heads-down programming. His current books cover Python for beginners, Artificial Intelligence (AI), Machine Learning, Data Science, C# 7.0, and Amazon Web Services (AWS). You can read his blog at http://blog.johnmuellerbooks.com/. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.55788,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "10 Amazing Libraries and Frameworks for <em>Your</em> Web-based JavaScript <em>Applications</em>",
        "body": ". jQuery UI jQuery UI is just one of many <em>add</em>-ons for jQuery, but it’s the one you see most often, which is why we’ve included it here. You use jQuery UI to <em>add</em> basic graphic elements to <em>your</em> <em>application</em> after you incorporate jQuery. The jQuery UI library comes with all sorts of interesting widgets"
      },
      "id": "60764c52e7b9d21185a5c67f"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/mobile_ui_react_folder_structure-546x1024.png",
      "url": "https://newrelic.com/blog/best-practices/mobile-ui-react",
      "sections": [
        "The new and improved New Relic Mobile UI architecture",
        "Managing state",
        "Running async services",
        "Plugged in NRQL models",
        "Bonus content: project folder structure",
        "Building more than just a UI"
      ],
      "published_at": "2021-04-16T04:23:43Z",
      "title": "How We Architected the New Relic Mobile Web UI in React",
      "updated_at": "2021-04-14T06:37:40Z",
      "type": "",
      "external_id": "e3d67df0a38b9980728a89cac2fb64cddc1708b1",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Best Practices How We Architected the New Relic Mobile Web UI in React Jan 3, 2018 • 7 min read By Frank Linehan An ongoing curiosity in JavaScript development communities is the question of how to build complex UI applications in React. This open source JavaScript library, maintained by Facebook, makes it easier than ever to write efficient, component-based projects in JavaScript. React has been around for about four years now, but the JavaScript community is still learning how to take full advantage of its powers. The web UI for New Relic Mobile has several points of integration with components, services, and container objects built by different UI engineers across New Relic. Historically it’s been a challenge to cleanly integrate all the pieces. Additionally, we now have more non-frontend engineers than ever contributing to the UI, so it’s become very important for us to have a clean architecture that everyone can easily navigate and contribute to. To make it easier for engineers who contribute code to the UI, we’ve created a flexible system, written in React. And since we’ve built this layered architecture from modules, we’ve been able to decouple the different domains of the UI application from each other, thus easing the burdens of contributors. We wanted to share some of the design behind this complex React project because it’s led us to some seriously great outcomes. The new and improved New Relic Mobile UI architecture Consider this diagram of the new architecture: The top three layers are made up of our framework-specific UI views, containers, and components (which I’ll give a bit more detail for when I discuss the folder structure of our project). Where possible we favor composition over inheritance since React classes are great for this design pattern. For example, we use this pattern in the Handled exceptions sidebar container that has three child UI components: a search input, an occurrence count, and a bar chart component. The sidebar composes these child UI components by passing needed properties to its children (for example, data to render the bar chart). This allows us to reuse these smaller components throughout the application and to handle layout and configuration through the larger container components. We like to think of these UI components as “Lego pieces:” they can be used in multiple ways to build dozens of combinations. The UI views and containers, on the other hand, are much less modular and are more like jigsaw puzzle pieces in that they fit together only one specific way. The bottom layer is composed of three collections of modules in which a significant portion of the Mobile UI application code base lives. These collections handle state management, asynchronous services, and store NRQL models (the latter of which powers the New Relic Query Language functionality in the UI). Managing state In React, state is an object that can change over time; for example, UI text changing to red in the case of an emergency is controlled by state. State can be managed—or held—in stores. In New Relic Mobile, some UI components manage their own internal state (dropdown components keep track of when they are open or closed), but other components, such as the filter list, filter picker, and time picker, use state containers (or bundles of state) that allow state to be easily shared across components. To store the state React renders, we use the MobX library. In the New Relic Mobile UI, the top-level stores that manage application state use singleton patterns. These singletons use object composition to reference the other store singletons in the project. For example, as shown in diagram below, the App store, which handles the UI’s high-level application state, has references to our Router store, Nav store, Time store, Filters store, and Account store. So, for example, when a user clicks and “brushes” a graph (i.e., selects a data point in a graph that is then highlighted in another graph), we need to update our time window and route for the change. When the “brush” action is called, the App store mutates our router state and timestore state, which then triggers updates to all the components that observe those states. The API interface between our State store and the graph component is lightweight and simple, and this part of the UI is flexible if we ever require changes. Running async services This set of core modules are for a few asynchronous services that retrieve data from different places in the New Relic Mobile application. These store objects use the fetch API to make HTTP requests, and they manage the state of data as it loads. These async store objects inherit from our HTTP request store (which is one of the few places where we use inheritance). The HTTP request store is a finite state machine that has some helper methods for handling loading, errors, and data. We chose inheritance for these objects because they all have the same HTTP request pattern (for example, fetch, is loading, has data, has error). By moving that shared behavior to the HTTP request object and inheriting off of it, we removed hundreds of lines of redundant code from our project. Plugged in NRQL models The New Relic Query Language models are modules of code that generate NRQL queries used by the UI components, containers, and views. These models are pretty specific to the structure of the New Relic UI, so a close examination of them isn’t necessary here. Bonus content: project folder structure Finally, no discussion of a JavaScript project is complete without a look at the project’s folder structure. Obviously, there is no “perfect folder structure,” but this is what has worked well for our team in this project. Application code lives in the src folder and styling lives in our scss folder. Both of these folders are bundled up by webpack and turned into UI assets. Our src folder has the following structure: The component folder holds React components that are given sets of properties and render widgets on the screen. These are our “Lego pieces” that can be composed into different combinations in the UI. The containers folder is for components that compose other components. The containers are our puzzle pieces that fit only one way when used in the UI. Then we have our views folder that holds our views components. The views components compose our containers. This folder combines all of our smaller pieces into one big picture, and since most of the team is experienced with some form of the model, view, controller (MVC) architecture, having a views folder gives us all a familiar entry point into the application. The models folder contains the aforementioned NRQL models used to build queries consumed by our graph components and other containers. The configs folder is where we store static variables that are used to configure views and containers. The libs, services, utils, andtransforms folders are where we keep smaller reusable pieces of code that format data or talk to APIs; these can even be used by our other components. Last but not least we have our stores folder, which holds our state containers. As noted, we’re using MobX to store our state and actions. Our end goal was to have as flat a folder structure as possible, since flat is always better than nested. We also made sure the folder names were easily readable since team members need to be able to identify what lives where and what it does. Building more than just a UI In addition to being a successful experiment in architecting a complex JavaScript project in React, we’ve found that this architecture has led to some critical outcomes: Predictable state management: By breaking state into discrete objects, it’s easier for us to see which actions are mutating state in our components. Easy for non-UI-focused team members to contribute: Building our UI architecture with object-oriented programming allows our less experienced UI devs to quickly contribute to the project. Explicitness: Because we’ve decoupled state, UI components, and the underlying service models, new contributors can quickly figure out exactly what parts of the project to contribute to. Ease of use: Thanks to this decoupled and organized architecture, our agent and service engineers were able to complete a significant chunk of UI work in a single sprint while the UI engineer was on a weeklong vacation.   By Frank Linehan Frank Linehan is a Senior Software Engineer on the Mobile APM team at New Relic. He's passionate about front-end engineering, emergent JavaScript frameworks, and maintainable and flexible JavaScript projects. He's also very passionate about mountaineering. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.68565,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " <em>components</em> by passing needed properties to its children (for example, data to render the bar chart). This allows us to reuse these smaller <em>components</em> throughout the <em>application</em> and to handle layout and configuration through the larger container <em>components</em>. We like to think of these UI <em>components</em>"
      },
      "id": "60768db464441f7ce19d854c"
    },
    {
      "sections": [
        "Get started with Incident Intelligence",
        "Tip",
        "How it works",
        "Set up Incident Intelligence",
        "1. Configure your environment (one-time)",
        "2. Configure sources",
        "Alerts",
        "Anomalies",
        "PagerDuty",
        "Splunk",
        "Important",
        "Splunk metadata",
        "Prometheus Alertmanager",
        "Grafana",
        "AWS",
        "REST API",
        "3. Configure destinations",
        "Configure ServiceNow (example)",
        "Send data to ServiceNow",
        "Custom notification message",
        "Other destinations",
        "Send data to PagerDuty",
        "Send data via webhook",
        "4. Configure pathways",
        "Visual timeline",
        "Related activity",
        "Issue summary",
        "Root cause analysis",
        "Use decisions",
        "Use suggested responders",
        "EU and US datacenter and Incident Intelligence data"
      ],
      "title": "Get started with Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "8c4a5a914ca01cb42250908d2fb1a12ccc697e25",
      "image": "https://docs.newrelic.com/static/6e37cc77304398121e1a0080a57e47bb/8c557/screenshot_incident_intelligence_timeline_event_detail.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence/",
      "published_at": "2021-04-16T14:29:07Z",
      "updated_at": "2021-04-16T14:29:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As part of Applied Intelligence, Incident Intelligence helps you correlate your incidents and reduce noise in your environment. It gives you an overview of all your incidents, their sources, and related events. Tip To use Incident Intelligence and Applied Intelligence, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. How it works After you set up Incident Intelligence, our system will begin finding issues from your data sources. In the issue feed, you can find an overview of all your issues, along with helpful information about them. You can also click any individual issue for more detail, including its analysis summary, event log, and details about correlated issues. This screenshot shows an example issue feed, which describes your issues' statuses, correlations, and more. What's the difference between an issue, incident, and event? In short, these terms are like building blocks. Events are raw data from your sources. Incidents are made up of one or more events. Issues are composed of one or more incidents. In more detail: Events indicate a state change or trigger defined by your monitoring systems. An event contains information about the affected entity, and they are almost always triggered automatically by the system. Incidents are groups of events that describe the \"symptoms\" of your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. Issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. Set up Incident Intelligence To enable Incident Intelligence, follow these four steps. Afterwards, issues should start to appear in your issue feed. 1. Configure your environment (one-time). 2. Configure sources. 3. Configure destinations. 4. Configure pathways. 1. Configure your environment (one-time) To set up an environment in Incident Intelligence, you need an administrator to select a New Relic account for it. This account should be the one your team is using. Who sets the environment? Only administrators, and only for accounts where they have admin privileges. Can administrators set more than one environment? They can set one environment per master account and its sub-accounts. More than one can be set if an administrator has privileges for more than one master account. Need to change the environment's associated account? Reach out to your account executive or our support team for help. Tip Incident Intelligence is a cross-account product. This means you can send in data from any New Relic account or external source to correlate events. 2. Configure sources After setting up your environment, determine your incident sources. These are your data inputs. You can get data from any of the following sources: Alerts By integrating Incident Intelligence with your alerts violations, you can get context and correlations from what you're monitoring. To get data from alerts: From one.newrelic.com, click Alerts. On the left under Incident Intelligence, click Sources and then click Alerts. Select the policies you want to connect to Applied Intelligence, and click Connect. You can add additional alerts policies or remove policies you've already connected in Sources > New Relic Alerts. Tip Adding alerts as a source will not affect your current configuration or notifications. Anomalies By integrating Incident Intelligence with your New Relic Proactive Detection anomalies, you can get context and correlations from what you're monitoring. To get data from New Relic Proactive Detection anomalies: From one.newrelic.com, click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Anomalies. Select the configurations you want to connect to Applied Intelligence by toggling to on (green). To add or remove alert policies, from Alerts & AI, click Sources, then Alerts. Tip Adding anomalies as a source won't affect your current Proactive Detection configurations or notifications. PagerDuty You can integrate Incident Intelligence directly with your PagerDuty services to ingest, process, and enhance all of your PagerDuty incidents. To get data from PagerDuty: Make sure your PagerDuty API key has write access. From one.newrelic.com, click Alerts & AI. On the left under Incident Intelligence, click Sources and then click PagerDuty. Enter your PagerDuty API key. The key should be either a personal or general access key with write access. If it's created by a user, the user should be an admin. Select the PagerDuty services you want to connect to Applied Intelligence, and click Connect. You can add additional services or remove services you've already connected in Sources > PagerDuty. Tip Connecting PagerDuty services to Applied Intelligence will not affect your current services or notifications. Splunk By integrating Incident Intelligence with your Splunk log monitoring, you can: Use your environment's log data for searches and key term reports. Correlate alerts and search reports with your other metrics and incidents. Important Applied Intelligence supports Splunk Light, Splunk Cloud, and Splunk Enterprise version 6.3 and higher. To get data from Splunk: In your Splunk console, start a search for the relevant events. Save your search as an alert, configure your alert conditions, and then choose the webhook as the delivery method. Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Splunk. Copy the collector URL, and paste it into the webhook endpoint in the Splunk console. Optional: Use Splunk tokens to enrich alert data with Splunk metadata. Splunk metadata To enrich alerts data with your Splunk metadata, use Splunk tokens. This helps you leverage your search data, which includes metadata and values from the first row of search results. If you want to... Do this... Access search data Use the format $<fieldname>$. For example, use $app$ for the app context for the search. Access field values To access field values from the first result row that a search returns, use the format $result.<fieldname>$. For example, use $result.host$ for the host value and $result.sourcetype$ for the source type. Use variables You can leverage any of the Selected fields in the Splunk search and add any unique fields to the Selected fields to make the data available as a variable. The following fields will automatically provide hints to the correlation engine: app: parsed as APPLICATION_NAME application:parsed as APPLICATION_NAME application_name: parsed as APPLICATION_NAME cluster: parsed as CLUSTER_NAME computer: parsed as HOST_NAME Dc: parsed as DATACENTER_NAME datacenter: parsed as DATACENTER_NAME host: parsed as HOST_NAME host_name: parsed as HOST_NAME hostname: parsed as HOST_NAME transaction: parsed as EVENT_ID Transaction_id: parsed as EVENT_ID user: parsed as USER_NAME Prometheus Alertmanager By integrating Incident Intelligence with Prometheus Alertmanager, you can receive and correlate your Prometheus alerts with events from other sources. To integrate Prometheus Alertmanager: Set up your Alertmanager configuration file by running: ./alertmanager -config.file=simple.yml Copy Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Prometheus Alertmanager. Copy the Prometheus Alertmanager URL, and paste it into the <webhook_config>/url section of your Alertmanager config file. Reload the Prometheus Alertmanager configuration with one of the two methods: Send a SIGHUP to the process. Send an HTTP POST request to the /-/reload endpoint. Grafana You can integrate Incident Intelligence with Grafana's notifications for insight into events across your applications and environment. Grafana's webhook notification is a simple way to send information over HTTP to a custom endpoint. To integrate Grafana as a new webhook: Log into your Grafana portal using Admin permissions, and choose Alerting. On the Grafana Notification Channels page, click New Channel > Webhook. Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources, and then click Grafana. Copy the URL, and paste it into your new Grafana webhook. AWS You can integrate Incident Intelligence with Amazon CloudWatch to provide incident management for all of your AWS services. To integrate Amazon CloudWatch: Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Amazon Web Services. Copy the URL. Create a new Amazon SNS topic. Set CloudWatch to forward all Alarms state changes to that topic: In the Amazon CloudWatch UI, click Events > Event Pattern. Select Service Name > CloudWatch. Select Event Type > CloudWatch Alarm State Change. Select Targets > SNS Topic, and select your new Amazon SNS topic. Create a new subscription: In the Amazon AWS UI, click Create a Subscription. Select your new Amazon SNS topic. Select Protocol > choose HTTPS. In Endpoint, paste the URL you previously copied from the Applied Intelligence Sources. REST API Incident Intelligence supports a dedicated REST API interface that lets you integrate with additional systems. The interface allows instrumentation of your code or other monitoring solutions to report any kind of metric or event. A metric can be a raw data point such as CPU, memory, disk utilization, or business KPI. An event can be a monitoring alert, deployment event, incident, exceptions or any other change in state that you want to describe. You can also send any type of data to Incident Intelligence straight from your own systems or applications. The REST API supports secure token-based authentication and accepts JSON content as input. For more information on authentication and the full API reference, see REST API for New Relic Applied Intelligence. 3. Configure destinations Now that you've set up your sources, you can configure your destinations. These are the data outputs where you view your incidents. Configure ServiceNow (example) Using ServiceNow as a destination enables you to push valuable violation data into new ServiceNow incident tickets. Send data to ServiceNow To configure Incident Intelligence to send data to ServiceNow: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click ServiceNow. Required: Enter a channel name. This is used internally in Applied Intelligence to identify the destination (for example, in Pathways). Required: Enter your ServiceNow credentials: Team domain (This must be unique. No two destinations can have the same domain). Username Password Follow the two-way integration on screen instructions: Open and download this XML file. In the ServiceNow sidebar menu, go to System Definition > Business Rule. Click the menu icon in one of the column headers, select Import XML, and upload the XML file you downloaded. The two way integration will allow the ServiceNow incident to be updated with changes to the Applied Intelligence issue. Closing a ServiceNow incident will close its corresponding New Relic issue. When a New Relic issue is resolved, the corresponding ServiceNow incident will be closed. Custom notification message Applied Intelligence uses a templating framework called Jinja2 in the customization section interface. The Value field must be in valid Jinja syntax. By default, the interface populates a set of default fields in ServiceNow. When you add a custom field, enter the ServiceNow field name you want to use. When you want to skip a selected field in an issue update, add the | skip_on_update string at the end of the value you've selected. Tip By default, ServiceNow adds u_ to the beginning of its custom values. When mapping to ServiceNow attributes, use the Column name value. Please note that the name needs to be lowercase separated by underscores. Go here to see the custom notification message attribute descriptions. Go here to see Jinja2 Useful Syntax. Other destinations You can also set PagerDuty as a destination, as well as any other destination compatible with webhook: Send data to PagerDuty Recommended: Create a new PagerDuty service to use as a destination. Because PagerDuty services can also be used as sources, this can help you distinguish your data input from your output. To create a PagerDuty destination: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click PagerDuty. Enter your PagerDuty API key. The key should be either a personal or general access key with write access. If it's created by a user, the user should be an admin. If you've configured a PagerDuty source with an API key, you can use the same key. Select the PagerDuty services you want to connect to Applied Intelligence, and click Connect. When you're ready, you can add policies for one or more PagerDuty destinations. You can also transfer the policies over from your existing services or leave them as sources if needed. From the Destinations > PagerDuty page, you can also: Review the permissions for your services. Click Authorize when you're done. Add or delete existing services from the PagerDuty destination. Edit permissions for any service. To configure your PagerDuty destinations, use the following settings: Configuration setting Description Trigger new incidents Required. Trigger correlated parent incidents so you can identify issues faster. Edit incident titles Required. Alter your incident titles to help you orient and understand issues. Add new integrations Required. Add integrations to enable incident creation for selected services. Add webhook extensions Add webhook extensions to sync user actions in PagerDuty to New Relic. This lets you update the correlated issue state. Auto-resolve correlated incidents When enabled, this will resolve and automatically close correlated parent/child incidents. Select a user to take actions in PagerDuty You need to select a user before you can enable deep integration with PagerDuty. Once you do, the user can: Add notes to incidents (required): Incident notes are used to enrich incidents with context. Acknowledge triggered incidents: When enabled, Applied Intelligence will acknowledge and correlate newly triggered incidents in PagerDuty before you're notified. Use the original escalation policy: When enabled, the escalation policy of the source service will be applied to each incident. Send data via webhook Incident Intelligence will send the event body in JSON format by HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). To configure Incident Intelligence to send data via webhook: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click Webhook. Required: Configure the unique webhook key, used in Applied Intelligence to refer to this webhook configuration and its specific settings. Required: Configure the destination endpoint where the webhook payload will be sent. Optional steps: Configure custom headers, which are key:value pairs of headers to be sent with the request. Example: \"Authentication\" \"Bearer\" <bearer token> Configure a custom payload template that can be used to map New Relic fields to match the destination tool's expected name and format. Configure priority mapping (critical, high, medium, or low), used to map New Relic's priorities to the priorities expected at the destination. Tip There’s a retry mechanism that is triggered a few times with exponential backoff for a couple of minutes once an error occurs. If we reach the retry limit, the Webhook will get auto-disabled. For examples of destination templates, webhook formats, and JSON schema, see the Incident Intelligence destination examples. 4. Configure pathways To control when and where you want to receive notifications from your incidents, you can configure pathways. To add a pathway: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Pathways, then click Add a pathway. In the query builder box, select an attribute, such as application/name. This can be from the list of all attributes available in PagerDuty incidents and New Relic alerts violations, or you can add your own attributes. Select a logical operator. For example, contains. Enter a specific value to complete the logical expression. To include all issues created by your sources, select Send everything. (Use this if you only use one PagerDuty service to manage all incidents.) To build more complex logic, use the AND/OR operators. Select one or more of your destinations. To edit or remove existing pathways, mouse over the pathway's name on the Pathways page. Visual timeline The visual timeline, as presented below, shows you a breakdown of: Incidents The trends taking place What incidents are active What incidents are resolved What is correlated to each other Various milestones at different issue levels In addition, you’ll see a grey line at the top of the timeline. In comparison to the visual timeline that shows the changes to each incident, the grey line represents changes to the issue. Mouse over the grey line to see details of the event. Finally, mouse over the incident to see information on the location, timing, and level of importance of a specific incident. This figure shows a particular incident populated on January 11th with a level of Critical. To view the issues in a text format, in the right hand corner, click Switch to issue log view. Related activity The related activity section aggregates a set of incidents into a single issue, according to a rule-based system. This section will show you the Last Update, the Source location, its State, the number of Related Events, and where it Originated. You can also copy the Payload or click on Analyze for more information. Issue summary The issue page is built to first provide the user with bottom line insights to understand the problem and minimize the time needed to resolve it. The following outlines each of the four sections on the issue page: The Analysis Summary: the analysis summary has two machine learning modules, the golden signals and the related components. The Suggested Responder: the suggested responder will tell you who to potentially reach out to on your team to solve a specific problem. The Impacted Entities: an entity is anything that has data you can monitor. Specifically, these are focused on incidents from New Relic sources, extracting the entities and providing a summary. Each entity is unique. The Label Sets: label sets are focused on incidents that come from 3rd party sources, such as PagerDuty, AWS Cloudwatch, REST APIs, etc., as well as for NRQL queries. They come in the form of key:value pairs. All four of these sections can show up together for each issue or separately. It will vary based on the data in the issue. In addition to these four sections, you can also take a look at anomaly overview and entity overview directly from the issue feed. If you hover over an impacted entity application, you’ll notice both call to actions: anomaly overview and entity overview. Anomaly overview will open the application's anomalies page. This is only available for applications that are set up for Proactive Detection. Finally, the issue page contains deployment events. APM’s Deployment page lists recent deployments and their impact on your end user and app server's Apdex scores, response times, throughput, and errors. This section will only show up if New Relic has identified applications under the Impacted Entities that have deployments. There are two types of deployment events: deployments and related deployments. Click “Show all deployments”, to see all your deployment events when they arrive. Click a specific deployment to see its APM deployments page. Root cause analysis Root cause analysis automatically finds potential causes for an issue and its impacted entities. It shows you why open issues occurred, which deployments contributed, and relevant error logs and attributes. With this, you can investigate the problem and reduce your mean time to resolution (MTTR). Tip Note that root cause analysis is dependent on other New Relic data sources and features. This is why root cause analysis information may not always be present for every issue. When you select an issue, you may see Root cause analysis information. Root cause analysis includes three main UI sections: Deployment events: When you set up deployments, we provide the deployment nearest to the issue creation. Changes, such as deployments, account for a high percentage of the root causes of incidents and having that information at hand can help diagnose and resolve issues. Error logs: You can explore millions of log messages with a single click and use manual querying to help you find anomalous patterns and hard-to-find problems. Attributes to investigate: We scan the distribution of attributes and surface possible causes by finding significant changes in the distribution. For example, for every single transaction event, we can scan to see if an individual user starts to take up an anomalous share of the requests sent to your app. You can also query interesting attributes. Use decisions To further reduce noise or get improved incident correlation, you can change or customize your decisions. Decisions determine how Incident Intelligence groups incidents together. To get started, see Decisions. Use suggested responders If you’re using PagerDuty or New Relic alerts violations as your incident notification tools, Incident Intelligence suggests relevant team members that can help resolve your issues. Incident Intelligence learns from your PagerDuty and alerts violations data to provide suggestions for each new incident. Once you receive a suggestion, you can contact the responder or search for relevant documentation that person may have written. To get started, enable PagerDuty or alerts violations as a source for Incident Intelligence. Afterwards, you can view the suggestions in two places: The issue feed, where you can also provide feedback on the suggestions. Directly within PagerDuty (both UI and API.) If you’re also using PagerDuty as a destination, the suggestions will appear in your issue notifications payload. Important This feature doesn't account for on-call availability at the time of incident. Tip In order to train the model, we use the information PagerDuty provides about individuals. We ingest incident information only, not users’ contact details. EU and US datacenter and Incident Intelligence data New Relic's Incident Intelligence service is performed solely in the United States. By using New Relic Incident Intelligence, you agree that New Relic may move your data to, and process your data in, the US region. This applies whether you store your data in New Relic's US region data center or in our EU region data center. If you elect to use the Suggested Responder feature and manage EU-based individuals, you may need to confirm that an appropriate data processing agreement is in place.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.62591,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "1. Configure <em>your</em> environment (one-time)",
        "body": " Alerts &amp; AI, in the left nav under Incident Intelligence click Pathways, then click <em>Add</em> a pathway. In the query builder box, select an attribute, such as <em>application</em>&#x2F;name. This can be from the list of all attributes available in PagerDuty incidents and New Relic alerts violations, or you can <em>add</em> <em>your</em>"
      },
      "id": "603ea62e64441f119f4e883f"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programability_browser_analyze_1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-developers-guide-roundup",
      "sections": [
        "Intro to New Relic One SDK",
        "New Relic One CLI",
        "Intro to NerdStorageVault - New Feature!",
        "Create a \"Hello, World\" app",
        "Practice diagnosing common issues using New Relic",
        "Get coding and get inspired",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:23:24Z",
      "title": "New Relic Developers Guide Roundup",
      "updated_at": "2021-04-13T23:23:31Z",
      "type": "",
      "external_id": "9322d4fbb3dbbeb84cc7c3f26c9cc2c275e3a11d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Relic Developers Guide Roundup Jan 5, 2021 • 7 min read By Vi Tran When we first launched our programmable platform, one of our executives envisioned a simple way to visualize customer experience and satisfaction scores. He sent the following sketch to an engineer: Two days later, he had a production-ready application, built on New Relic One, that showed not just what the customer experience scores were, but what they should be. The browser analyzer application This New Relic One application is called the browser analyzer—it’s open source and available for you to use today. But now it’s your turn to go from sketch to app. We’ve given you the same tools our own engineers use, so you can build and deploy applications in New Relic One that connect your observability data, gathered from myriad sources—including third-party open source data—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK The New Relic One SDK provides the necessary components you need to build New Relic One applications. Components of the SDK include: React UI components for controlling text and layout in a New Relic One application Chart components for representing different types of charts Query and storage components for fetching and storing New Relic data Platform APIs that enable your application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build your applications, create visualizations, and fetch New Relic or third-party data. New Relic One CLI In addition to the SDK, you’ll need the New Relic One CLI to build apps on the platform. You’ll use the CLI to build, publish, and manage your app. More specifically, you’ll use the CLI to do the following: Generate Nerdpack/Nerdlet templates—(a Nerdpack is a package containing all the files needed by an application; a Nerdlet is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Intro to NerdStorageVault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store your data. NerdStorageVault lets you store and retrieve sensitive data secrets such as: Personal access tokens License keys API keys Other third-party secrets You can explore NerdStorageVault fields and response types with the NerdGraph API explorer. NerdStorageVault is encrypted with AES-256 encryption. In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes. Check out the guide for more information. Create a \"Hello, World\" app In this guide, you’ll build a \"Hello, World!\" application in New Relic One in nine quick steps. You’ll create a local version of the New Relic One site where you can prototype your application, and when you're ready to share the application with others, you can publish it to New Relic One. [embed]https://www.youtube.com/watch?v=7omo0qHxku8&feature=youtu.be[/embed] To get started, make sure you have accounts in GitHub and New Relic. You’ll also need to install Node.js and familiarize yourself with the New Relic One CLI. Tip: Check out Set up your development environment to make sure you have everything in order before you jump in. Practice diagnosing common issues using New Relic Every time you deploy an application, you hope that it's efficient and free of errors. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled demo environment. Acme Telco Lite is a telecom business that maintains an e-commerce website for its customers. The site's architecture has eight interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. Check out the full guide for more on prerequisites and deployment details. Get coding and get inspired Explore more guides and tutorials on New Relic Developers, because we’re constantly adding content. Best of all? The site is built completely in open source—feel free to submit a pull request while you’re there. Related Topics Extend New Relic By Vi Tran Vi Tran is a Senior Product Marketing Manager for Developer Ecosystem at New Relic. Her focus is on growing and enabling the developer ecosystem to extend New Relic One. Before New Relic, she was on the global strategic alliances team at Splunk and was a management consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.98315,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Intro <em>to</em> New Relic One SDK",
        "body": " <em>components</em> for fetching and storing New Relic data Platform APIs that enable <em>your</em> <em>application</em> to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build <em>your</em> applications"
      },
      "id": "607627f464441f7e2b9d8537"
    }
  ],
  "/build-apps/ab-test/nrql": [
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important",
        "For more help"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "09e95d602d8acf7a94c6bfe9109f2ac8420b6430",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/alert-custom-violation-descriptions/",
      "published_at": "2021-04-16T02:33:09Z",
      "updated_at": "2021-03-30T08:56:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tag.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. For a condition, you can create a custom violation description using this field. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tag.fullHostname}} Owning Team: {{tag.label.owning_team}} Product: {{tag.label.product}} ec2VpcId: {{tag.aws.ec2VpcId}} Service name : {{tag.label.Name}} AWS Region : {{tag.aws.awsRegion}} AWS Availability Zone: {{tag.aws.awsAvailabilityZone}} Department : {{tag.label.department}} Environment: {{tag.label.environment}} Cluster: {{tag.clusterName}} Cluster Role: {{tag.clusterRole}} EC2 Instance Type: {{tag.instanceType}} EC2 InstanceID: {{tag.aws.ec2InstanceId}} EC2 AmiId: {{tag.aws.ec2AmiId}} EC2 Root Device Type: {{tag.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tag.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tag.aws.awsRegion}} Responsible team : {{tag.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tag formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tag.hostName}} The cluster is : {{tag.cluster}} Copy Please note that tag names cannot include a whitespace. The expanded values can include a whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tag.commandLine}} \\n entityGuid : {{tag.entityGuid}} \\n entityName : {{tag.entityName}} \\n fullHostname : {{tag.fullHostname}} \\n instanceType : {{tag.instanceType}} \\n processDisplayName : {{tag.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (e.g. @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @ e.g. !here or !channel For more help Recommendations for learning more: To learn more about NerdGraph, see Introduction to NerdGraph. See the Docs site's Alerts landing page. Browse New Relic's Explorers Hub for community discussions about Alerts. Find additional help or file a support ticket. Review the Alerts licenses attributions, data usage limits, and other notices.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.81595,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a custom violation description with <em>NRQL</em>",
        "body": " : {{tag.label.owning_team}} Copy Facet clause tags: For <em>NRQL</em> conditions only. If a <em>NRQL</em> condition uses a FACET clause, you can use tag formatting to use those values in <em>your</em> custom violation description. For example, if the <em>NRQL</em> <em>query</em> included FACET hostName, cluster, you could then use this: The host"
      },
      "id": "60440b3628ccbcb6232c6073"
    },
    {
      "sections": [
        "NRQL: Group results across time",
        "Facet your NRQL query time range",
        "Group results by month",
        "Other grouping examples with FACET clause"
      ],
      "title": "NRQL: Group results across time",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "90fa8030ed670866a9d8154e8b8f16fc04ba0abf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nrql-group-results-across-time/",
      "published_at": "2021-04-17T02:08:27Z",
      "updated_at": "2021-04-17T02:08:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NRQL, you can create queries that group results across time. For example, you can group results together based on timestamps by separating them into buckets that cover a specified range of dates and times. When using time functions in NRQL queries, the results are returned in UTC. To adjust the results to your time zone, include the WITH TIMEZONE clause in your query. Facet your NRQL query time range To create your NRQL query, use a FACET clause with a bucket function that works with a timestamp attribute. Run a standard FACET query, but instead of faceting by an attribute, facet by time. For example: SELECT count(*) FROM PageView SINCE 1 day ago FACET monthOf(account_created) Copy To perform multiple functions within the same query, use NRQL's multi-facet capability: SELECT count(*) FROM PageView SINCE 1 day ago FACET dateOf(account_created), monthOf(account_created) Copy Time-based functions Description yearOf(attr) Returns the year of a timestamp. quarterOf(attr) Returns the quarter of the year. The returned value includes both the quarter and the year. Example: Q1 2014 monthOf(attr) Returns the month and year of the timestamp. Example: July 2014 weekOf(attr) Returns the week the timestamp occurred by naming the month and day of that week's Monday. Example: Week of January 15. weekdayOf(attr) Returns the day of the week of the timestamp. The returned value loops back at the end of the week, allowing you to look at trends by weekday over time. dateOf(attr) Returns the date of the timestamp. The returned value includes month, day and year. Example: July 15, 2014 dayOfMonthOf(attr) Returns the numeric date within a single month of the timestamp, a value from 1 to 31. The returned value does not include the month. hourOf(attr) Returns the hour of the timestamp. The returned value does not include a prepended 0 for hours between 1am and 9am. This differs from functions and clauses such as SINCE, which accept these hours with a 0 at the start. Examples: 6:00, 12:00, 18:00 Group results by month To group all results based on the month, use the monthOf function. In this example, the NRQL query includes a function (count(*)), a data type (PageView), a time frame (SINCE 1 day ago), and a time facet (monthOf(attribute)). SELECT count(*) FROM PageView SINCE 1 day ago FACET monthOf(account_created) Copy Running the query returns a table of results by month. Other grouping examples with FACET clause You can run NRQL queries to group your data in other ways, not just time. For additional examples, see the NRQL FACET documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.37782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em>: Group results across time",
        "sections": "Facet <em>your</em> <em>NRQL</em> <em>query</em> time range",
        "tags": "<em>Query</em> <em>your</em> data",
        "body": " the results to <em>your</em> time zone, include the WITH TIMEZONE clause in <em>your</em> <em>query</em>. Facet <em>your</em> <em>NRQL</em> <em>query</em> time range To create <em>your</em> <em>NRQL</em> <em>query</em>, use a FACET clause with a bucket function that works with a timestamp attribute. Run a standard FACET <em>query</em>, but instead of faceting by an attribute, facet by time"
      },
      "id": "60445a61196a671ddf960f19"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/1qf2g217c4q7m/promo-image.1608575584.png",
      "url": "https://learn.newrelic.com/getting-started-with-dashboards-nrql",
      "sections": [
        "Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations.",
        "About this workshop",
        "Getting started with Dashboards & NRQL"
      ],
      "published_at": "2021-04-20T01:39:15Z",
      "title": "[Webinar] Getting started with Dashboards & NRQL",
      "updated_at": "2021-04-20T01:39:15Z",
      "type": "",
      "external_id": "20be8b6c5a3882e951f9dfd70354ea7ceaa38c7c",
      "popularity": 1,
      "body": "Sign In [Webinar] Getting started with Dashboards & NRQL Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations. Register | FREE Already registered? Sign In About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.  These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.  Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.   In this hands-on session, you’ll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.  Using a sandbox account you’ll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.  Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL April 20, 2021, 1 p.m. - April 20, 2021, 3 p.m. BST 104 Getting started with Dashboards & NRQL May 6, 2021, noon - May 6, 2021, 2 p.m. PDT 148 Getting started with Dashboards & NRQL May 11, 2021, 1 p.m. - May 11, 2021, 3 p.m. BST 148 Getting started with Dashboards & NRQL June 8, 2021, 1 p.m. - June 8, 2021, 3 p.m. BST 150 Getting started with Dashboards & NRQL June 8, 2021, noon - June 8, 2021, 2 p.m. PDT 150 About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.  These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.  Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.   In this hands-on session, you’ll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.  Using a sandbox account you’ll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.  Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Live events Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL April 20, 2021, 1 p.m. - April 20, 2021, 3 p.m. BST 104 Getting started with Dashboards & NRQL May 6, 2021, noon - May 6, 2021, 2 p.m. PDT 148 Getting started with Dashboards & NRQL May 11, 2021, 1 p.m. - May 11, 2021, 3 p.m. BST 148 Getting started with Dashboards & NRQL June 8, 2021, 1 p.m. - June 8, 2021, 3 p.m. BST 150 Getting started with Dashboards & NRQL June 8, 2021, noon - June 8, 2021, 2 p.m. PDT 150 © 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.52463,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "[Webinar] Getting started with Dashboards &amp; <em>NRQL</em>",
        "sections": "Learn <em>to</em> use the Data Explorer and <em>Query</em> Builder Basic Mode <em>to</em> create charts and dashboards without any knowledge of <em>NRQL</em>. Progress <em>to</em> working directly with <em>NRQL</em> <em>to</em> create a wider range of charts and visualizations.",
        "body": " and data correlation.  Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and <em>NRQL</em> Data Explorer: Create charts without writing <em>NRQL</em> Lab: Explore <em>your</em> data: Event, Plot, Dimensions Lab: Create performance charts <em>Query</em> Builder: <em>NRQL</em> and <em>query</em> <em>components</em> Group and Filter"
      },
      "id": "5fe29f8528ccbcf532f15668"
    },
    {
      "sections": [
        "NerdGraph API: NRQL condition alerts",
        "Tip",
        "Steps to create a NRQL condition",
        "NRQL static condition",
        "NRQL baseline condition",
        "NRQL outlier condition",
        "Update a condition",
        "Update mutations",
        "List and filter NRQL conditions",
        "Use cursor pagination",
        "Request type-specific fields",
        "Filter NRQL conditions",
        "Singular NRQL condition queries",
        "Update the description",
        "Delete conditions"
      ],
      "title": "NerdGraph API: NRQL condition alerts ",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "85399f92d659094c72d6565f258061a0161e751d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-nrql-condition-alerts/",
      "published_at": "2021-04-16T14:44:06Z",
      "updated_at": "2021-03-13T01:23:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage alerts conditions using our GraphQL NerdGraph API. Here are some conditions queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. This document covers the following: Steps to create a NRQL condition NRQL static condition NRQL baseline condition NRQL outlier condition Update a condition Update mutations List and filter NRQL conditions Singular NRQL condition queries Create a description Delete conditions Steps to create a NRQL condition Follow these steps: Decide which condition type you want to create (see NRQL Condition threshold types). Find your relevant policyID by doing one of the following: Use the NerdGraph policies API. Go to one.newrelic.com, in the top nav click Alerts & AI, then click Policies. Choose a policy. Find the ID under the policy name. Provide the appropriate mutation for your NRQL condition type and the relevant values. Tip The NerdGraph GraphiQL explorer is the best place to find up-to-date documentation about the per-field specifics of the NerdGraph NRQL Conditions API. For example, questions like \"What does the valueFunction field accept?\" are best answered with the inline NerdGraph documentation. NRQL static condition Here's an example of creating a static condition: mutation { alertsNrqlConditionStaticCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Low Host Count - Catastrophic\" enabled: true nrql: { query: \"SELECT uniqueCount(host) from Transaction where appName='my-app-name'\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 2 thresholdOccurrences: AT_LEAST_ONCE thresholdDuration: 600 operator: BELOW priority: CRITICAL } valueFunction: SINGLE_VALUE violationTimeLimitSeconds: 86400 }) { id name } } Copy NRQL baseline condition Here's an example of creating a baseline condition: mutation { alertsNrqlConditionBaselineCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Baseline Condition\" enabled: true baselineDirection: UPPER_ONLY nrql: { query: \"SELECT average(duration) FROM Transaction\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 13 thresholdDuration: 180 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 86400 }) { id name baselineDirection } } Copy NRQL outlier condition Here's an example of creating an outlier condition: mutation { alertsNrqlConditionOutlierCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Outlier Condition\" enabled: true expectedGroups: 4 openViolationOnGroupOverlap: false nrql: { query: \"SELECT average(duration) FROM Transaction FACET httpResponseCode\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 1 thresholdDuration: 300 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 86400 }) { id name expectedGroups openViolationOnGroupOverlap } } Copy Update a condition Complete the following: Determine the type of your existing condition by requesting the type field in a nrqlConditionsSearch query like this: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nrqlConditions { id type } } } } } } Copy Tip The type returned is what you use for your update mutation. For example, if the type returned is STATIC, use alertsNrqlConditionStaticUpdate. If the type returned is BASELINE, use alertsNrqlConditionBaselineUpdate. If the type returned is OUTLIER, use alertsNrqlConditionOutlierUpdate. Provide the id of your condition to your relevant condition type mutation. Note that you can only update conditions of the relevant type. Only provide update mutations for the fields you want to update. Fields you don't provide in the update are not touched. Update mutations Only fields that you provide in the update are changed. In the following example, baselineDirection returns unchanged, but name is updated. mutation { alertsNrqlConditionBaselineUpdate(id: YOUR_CONDITION_ID, accountId: YOUR_ACCOUNT_ID, condition: { name: \"Your updated name\" }) { id name baselineDirection } } Copy List and filter NRQL conditions To list or filter your NRQL conditions, use the nrqlConditionsSearch query in NerdGraph. Use cursor pagination The basic of list functionality for NRQL conditions allows you to paginate through your NRQL conditions as well as request the total count of conditions per account. The nrqlConditionsSearch query utilizes cursor pagination to paginate through resources. The idea behind cursor pagination is that the client will request a cursor in a programmatic loop until the cursor comes back empty. An initial list response will look something like this: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nextCursor nrqlConditions { id name type } totalCount } } } } } Copy This example returns a JSON response like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlConditionsSearch\": { \"nextCursor\": \"WOwfJ4+TWm9QTFeKMGyg+w==:QqkI8S4+Wwnpno6z+uk8kQ==\", \"nrqlConditions\": [ { \"id\": \"4432\", \"name\": \"Baseline Condition\", \"type\": \"BASELINE\" }, { \"id\": \"443\", \"name\": \"A static condition\", \"type\": \"STATIC\" }, // more conditions here in reality ], \"totalCount\": 435 } } } } }, } Copy In order to paginate through conditions in the response, have the client request the cursor to be returned until the nextCursor returns from the response as null: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch(cursor: \"WOwfJ4+TWm9QTFeKMGyg+w==:QqkI8S4+Wwnpno6z+uk8kQ==\", ) { nextCursor nrqlConditions { id name type } totalCount } } } } } Copy Request type-specific fields Certain fields are only available on specific NRQL condition types. The main reason that mutations are split between the different condition types is because they have minor differences between the fields they accept. For example, valueFunction is only relevant for static NRQL conditions and baselineDirection is only relevant on baseline NRQL conditions. But if these fields are only available on these certain condition types, how do we return them in a list of all of our condition types? The answer is a GraphQL convention known as inline fragments. Inline fragments allow you to access the data on a specific type of NRQL condition: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nrqlConditions { id name type ...on AlertsNrqlStaticCondition { valueFunction } ...on AlertsNrqlBaselineCondition { baselineDirection } ...on AlertsNrqlOutlierCondition { expectedGroups } } } } } } } Copy In the previous example query, we are asking GraphQL to do the hard work for us to determine which NRQL conditions are the correct type. So, when the returned type is a static condition, it will return the valueFunction in the object. When the returned type is a baseline condition, it will return baselineDirection instead, and when the type is an outlier condition, it will return expectedGroups. Here is an example response: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlConditionsSearch\": { \"nrqlConditions\": [ { \"baselineDirection\": \"UPPER_ONLY\", \"id\": \"342\", \"name\": \"My baseline condition\", \"type\": \"BASELINE\" }, { \"id\": \"553\", \"name\": \"My static condition\", \"type\": \"STATIC\", \"valueFunction\": \"SINGLE_VALUE\" }, { \"expectedGroups\": 4, \"id\": \"802\", \"name\": \"My outlier condition\", \"type\": \"OUTLIER\" } ] } } } } } } Copy Filter NRQL conditions You can filter NRQL conditions with the searchCriteria argument of the nrqlConditionsSearch query: Here's an example of filtering NRQL conditions with matching by name. This query returns NRQL conditions that match the provided name. Note that this match is case insensitive. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch(searchCriteria: { name: \"Baseline Condition\" }) { nrqlConditions { id name type } } } } } } Copy Singular NRQL condition queries You can use the NRQL condition API to query for a singular condition. Run the nrqlCondition query in the alerts namespace. Similar to type specific fields on the nrqlConditionSearch query, you can also use these inline fragments to request fields that are restricted to a NRQL condition type. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: YOUR_CONDITION_ID) { id name ...on AlertsNrqlStaticCondition { valueFunction } } } } } } Copy Update the description This will walk you through the procedure to create a description for a NRQL alert condition. Get all the conditions for a policy: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditions(policyId: YOUR_POLICY_ID) { nextCursor results { id name description enabled nrql { query } signal { aggregationWindow evaluationOffset } policyId runbookUrl terms { duration operator priority timeFunction threshold } type violationTimeLimitSeconds } } } } } } Copy Get the details for a single condition: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: \"YOUR_CONDITION_ID\") { description id enabled name nrql { query } signal { aggregationWindow evaluationOffset } policyId runbookUrl terms { operator priority threshold thresholdDuration thresholdOccurrences } type violationTimeLimitSeconds } } } } } Copy Create a mutation with the description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { description } } Copy Here's an example mutation with an included example description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tag.commandLine}} \\n entityGuid : {{tag.entityGuid}} \\n entityName : {{tag.entityName}} \\n fullHostname : {{tag.fullHostname}} \\n instanceType : {{tag.instanceType}} \\n processDisplayName : {{tag.processDisplayName}}\"}) { description } } Copy Delete conditions You can use the alertsConditionDelete mutation to delete any type of condition. You can only request the id field on a delete mutation; for example: mutation { alertsConditionDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CONDITION_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.49933,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NerdGraph API: <em>NRQL</em> condition alerts ",
        "sections": "Steps <em>to</em> create a <em>NRQL</em> condition",
        "body": " outlier condition Here&#x27;s an example of creating an outlier condition: mutation { alerts<em>Nrql</em>ConditionOutlierCreate(accountId: <em>YOUR</em>_ACCOUNT_ID, policyId: <em>YOUR</em>_POLICY_ID, condition: { name: &quot;Outlier Condition&quot; enabled: true expectedGroups: 4 openViolationOnGroupOverlap: false <em>nrql</em>: { <em>query</em>: &quot;SELECT"
      },
      "id": "60440540196a678165960f6a"
    },
    {
      "sections": [
        "NRQL syntax, clauses, and functions",
        "Syntax",
        "Query components",
        "Required clauses",
        "Required: SELECT statement",
        "Avg response time since last week",
        "Required: FROM clause",
        "Query one data type",
        "Query multiple data types",
        "Optional clauses",
        "AS clause",
        "Query using math function and AS",
        "Query using funnel and AS",
        "COMPARE WITH clause",
        "EXTRAPOLATE clause",
        "Important",
        "Example of extrapolating throughput",
        "Example of extrapolating throughput as a time series",
        "FACET clause",
        "Faceted query using count()",
        "Faceted query using uniqueCount()",
        "Grouping results across time",
        "FACET ... AS clause",
        "FACET CASES clause",
        "Basic usage with WHERE",
        "Group based on multiple attributes",
        "Label groups with AS",
        "FACET ... ORDER BY clause",
        "Tip",
        "LIMIT clause",
        "Query using LIMIT",
        "OFFSET clause",
        "ORDER BY clause",
        "SHOW EVENT TYPES clause",
        "Data types in the last day",
        "SINCE clause",
        "SLIDE BY clause",
        "Use SLIDE BY with MAX or AUTO interval",
        "TIMESERIES clause",
        "Use a set interval",
        "Use an automatically set interval",
        "Use MAX interval",
        "UNTIL clause",
        "WHERE clause",
        "Example query with three conditions",
        "WITH METRIC_FORMAT clause",
        "WITH TIMEZONE clause",
        "Query metric data",
        "Aggregator functions",
        "aggregationendtime()",
        "apdex(attribute, t: )",
        "Get Apdex for specific customers",
        "Get Apdex for specific transaction",
        "Get overall Apdex for your app",
        "average(attribute)",
        "buckets(attribute, ceiling [,number of buckets])",
        "bucketPercentile(attribute)",
        "cardinality(attribute)",
        "count(*)",
        "derivative(attribute [,time interval])",
        "dimensions(include: {attributes}, exclude: {attributes})",
        "earliest(attribute)",
        "Get earliest country per user agent from PageView",
        "eventType()",
        "Use eventType() in filter() function",
        "Use eventType() with FACET",
        "filter(function(attribute), WHERE condition)",
        "Analyze purchases that used offer codes",
        "funnel(attribute, steps)",
        "getField(attribute, field)",
        "histogram(attribute, ceiling [,number of buckets])",
        "Histogram of response times from PageView events",
        "Prometheus histogram buckets",
        "New Relic distribution metric",
        "Histogram with a FACET clause",
        "keyset()",
        "See all attributes for a data type",
        "latest(attribute)",
        "Get most recent country per user agent from PageView",
        "latestrate(attribute, time interval)",
        "Get the most recent rate of change of PageView Duration",
        "max(attribute)",
        "median(attribute)",
        "Median query",
        "min(attribute)",
        "minuteOf(attribute)",
        "mod(attribute, divisor)",
        "mod() within a WHERE clause condition",
        "mod() within a FACET clause",
        "percentage(function(attribute), WHERE condition)",
        "percentile(attribute [, percentile [, ...]])",
        "Basic percentile query",
        "predictLinear(attribute, [,time interval])",
        "rate(function(attribute) [,time interval])",
        "Basic rate query",
        "round(attribute)",
        "stddev(attribute)",
        "stdvar(attribute)",
        "sum(attribute)",
        "uniqueCount(attribute)",
        "uniques(attribute [,limit])",
        "Using tuple",
        "Type conversion"
      ],
      "title": "NRQL syntax, clauses, and functions",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "97c38ce7950d354d9f1d9efa5f432326f9bb4b00",
      "image": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/images/screen-apdex-function.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/",
      "published_at": "2021-04-16T19:26:15Z",
      "updated_at": "2021-04-12T09:29:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NRQL is a query language you can use to query the New Relic database. This document explains NRQL syntax, clauses, components, and functions. Syntax This document is a reference for the functions and clauses used in a NRQL query. Other resources for understanding NRQL: Intro to NRQL: explains what NRQL is used for, what data you can query with it, and basic NRQL syntax Examine NRQL queries used to build New Relic charts Learn how to query the Metric data type Simulate SQL JOIN functions Use funnels to evaluate a series of related data Format NRQL for querying with the Event API Query components Every NRQL query will begin with a SELECT statement or a FROM clause. All other clauses are optional. The clause definitions below also contain example NRQL queries. Required clauses Required: SELECT statement SELECT attribute ... Copy SELECT function(attribute) ... Copy The SELECT specifies what portion of a data type you want to query by specifying an attribute or a function. It's followed by one or more arguments separated by commas. In each argument you can: Get the values of all available attributes by using * as a wildcard. For example: SELECT * from Transaction. Get values associated with a specified attribute or multiple attributes specified in a comma separated list. Get aggregated values from specified attributes by selecting an aggregator function. Label the results returned in each argument with the AS clause. You can also use SELECT with basic math functions. Avg response time since last week This query returns the average response time since last week. SELECT average(duration) FROM PageView SINCE 1 week ago Copy Required: FROM clause SELECT ... FROM data type ... Copy Use the FROM clause to specify the data type you wish to query. You can start your query with FROM or with SELECT. You can merge values for the same attributes across multiple data types in a comma separated list. Query one data type This query returns the count of all APM transactions over the last three days: SELECT count(*) FROM Transaction SINCE 3 days ago Copy Query multiple data types This query returns the count of all APM transactions and Browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Optional clauses AS clause SELECT ... AS 'label' ... Copy Use the AS clause to label an attribute, aggregator, step in a funnel, or the result of a math function with a string delimited by single quotes. The label is used in the resulting chart. Query using math function and AS This query returns the number of page views per session: SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session' FROM PageView Copy Query using funnel and AS This query returns a count of people who have visited both the main page and the careers page of a site over the past week: SELECT funnel(SESSION, WHERE name='Controller/about/main' AS 'Step 1', WHERE name = 'Controller/about/careers' AS 'Step 2') FROM PageView SINCE 1 week ago Copy COMPARE WITH clause SELECT ... (SINCE or UNTIL) (integer units) AGO COMPARE WITH (integer units) AGO ... Copy Use the COMPARE WITH clause to compare the values for two different time ranges. COMPARE WITH requires a SINCE or UNTIL statement. The time specified by COMPARE WITH is relative to the time specified by SINCE or UNTIL. For example, SINCE 1 day ago COMPARE WITH 1 day ago compares yesterday with the day before. The time range for theCOMPARE WITH value is always the same as that specified by SINCE or UNTIL. For example, SINCE 2 hours ago COMPARE WITH 4 hours ago might compare 3:00pm through 5:00pm against 11:00am through 1:00pm. COMPARE WITH can be formatted as either a line chart or a billboard: With TIMESERIES, COMPARE WITH creates a line chart with the comparison mapped over time. Without TIMESERIES, COMPARE WITH generates a billboard with the current value and the percent change from the COMPARE WITH value. Example: This query returns data as a line chart showing the 95th percentile for the past hour compared to the same range one week ago. First as a single value, then as a line chart. SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO Copy EXTRAPOLATE clause You can use this clause with these data types: Transaction TransactionError Custom events reported via APM agent APIs The purpose of EXTRAPOLATE is to mathematically compensate for the effects of APM agent sampling of event data so that query results more closely represent the total activity in your system. This clause will be useful when a New Relic APM agent reports so many events that it often passes its harvest cycle reporting limits. When that occurs, the agent begins to sample events. When EXTRAPOLATE is used in a NRQL query that supports its use, the ratio between the reported events and the total events is used to extrapolate a close approximation of the total unsampled data. When it is used in a NRQL query that doesn’t support its use or that hasn’t used sampled data, it has no effect. Important Note that EXTRAPOLATE is most useful for homogenous data (like throughput or error rate). It's not effective when attempting to extrapolate a count of distinct things (like uniqueCount() or uniques()). This clause works only with NRQL queries that use one of the following aggregator functions: apdex average count histogram sum percentage (if function it takes as an argument supports EXTRAPOLATE) rate (if function it takes as an argument supports EXTRAPOLATE) stddev Example of extrapolating throughput A query that will show the extrapolated throughput of a service named interestingApplication. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE Copy Example of extrapolating throughput as a time series A query that will show the extrapolated throughput of a service named interestingApplication by transaction name, displayed as a time series. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE Copy FACET clause SELECT ... FACET attribute ... Copy Use FACET to separate and group your results by attribute values. For example, you could FACET your PageView data by deviceType to figure out what percentage of your traffic comes from mobile, tablet, and desktop devices. Use the LIMIT clause to specify how many facets appear (default is 10). For more complex grouping, use FACET CASES. FACET clauses support up to five attributes, separated by commas. The facets are sorted in descending order by the first field you provide in the SELECT clause. If you are faceting on attributes with more than 2,000 unique values, a subset of facet values is selected and sorted according to the query type. When selecting min(), max(), or count(), FACET uses those functions to determine how facets are picked and sorted. When selecting any other function, FACET uses the frequency of the attribute you are faceting on to determine how facets are picked and sorted. For more on faceting on multiple attributes, with some real-world examples, see this New Relic blog post. Faceted query using count() This query shows cities with the highest pageview counts. This query uses the total number of pageviews per city to determine how facets are picked and ordered. SELECT count(*) FROM PageView FACET city Copy Faceted query using uniqueCount() This query shows the cities that access the highest number of unique URLs. This query uses the total number of times a particular city appears in the results to determine how facets are picked and ordered. SELECT uniqueCount(pageUrl) FROM PageView FACET city Copy Grouping results across time Advanced segmentation and cohort analysis allow you to facet on bucket functions to more effectively break out your data. Cohort analysis is a way to group results together based on timestamps. You can separate them into buckets that cover a specified range of dates and times. FACET ... AS clause Use FACET ... AS to name facets using the AS keyword in queries. This clause is helpful for adding clearer or simplified names for facets in your results. It can also be used to rename facets in nested aggregation queries. FACET ... AS queries will change the facet names in results (when they appear as headers in tables, for example), but not the actual facet names themselves. FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type' Copy FACET CASES clause SELECT ... FACET CASES ( WHERE attribute operator value, WHERE attribute operator value, ... ) ... Copy Use FACET CASES to break out your data by more complex conditions than possible with FACET. Separate multiple conditions with a comma ,. For example, you could query your PageView data and FACET CASES into categories like less than 1 second, from 1 to 10 seconds, and greater than 10 seconds. You can combine multiple attributes within your cases, and label the cases with the AS selector. Data points will be added to at most one facet case, the first facet case that they match. You may also use a time function with your attribute. Basic usage with WHERE SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10) Copy Group based on multiple attributes This example groups results into one bucket where the transaction name contains login, and another where the URL contains login and a custom attribute indicates that the user was a paid user: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') Copy Label groups with AS This example uses the AS selector to give your results a human-readable name: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users') Copy FACET ... ORDER BY clause In NRQL, the default is for the first aggregation in the SELECT clause to guide the selection of facets in a query. FACET ... ORDER BY allows you to override this default behavior by adding an aggregate function with the ORDER BY modifier to specify how facets are selected. Specifically, the clause will override the priority by which facets are chosen to be in the final result before being limited by the LIMIT clause. This clause can be used in querying but not for alerts or streaming. This example shows how to use FACET ... ORDER BY to find the average durations of app transactions, showing the top 10 (default limit) highest durations by apps which have the highest response size. In this case, if FACET ... ORDER BY is not used, the query results will instead show the top 10 by highest durations, with response size being irrelevant to the app selection. FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize) Copy Tip Because the operations are performed before the LIMIT clause is applied, FACET ... ORDER BY does not impact the sort of the final query results, which will be particularly noticeable in the results for non-timeseries queries. Important The ORDER BY modifier in this case works differently than the ORDER BY clause. When parsing queries that follow the format FACET attribute1 ORDER BY attribute2, New Relic will read these as FACET ... ORDER BY queries, but only if ORDER BY appears immediately after FACET. Otherwise ORDER BY will be interpreted by New Relic as a clause. LIMIT clause SELECT ... LIMIT count ... Copy Use the LIMIT clause to control the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. This clause takes a single integer value as an argument. If the LIMIT clause is not specified, or no value is provided, the limit defaults to 10 for FACET queries and 100 in the case of SELECT * queries. The maximum allowed value for the LIMIT clause is 2,000. Query using LIMIT This query shows the top 20 countries by session count and provides 95th percentile of response time for each country for Windows users only. SELECT uniqueCount(session), percentile(duration, 95) FROM PageView WHERE userAgentOS = 'Windows' FACET countryCode LIMIT 20 SINCE YESTERDAY Copy OFFSET clause SELECT ... LIMIT count OFFSET count ... Copy Use the OFFSET clause with LIMIT to control the portion of rows returned by SELECT * or SELECT column queries. Like the LIMIT clause, OFFSET takes a single integer value as an argument. OFFSET sets the number of rows to be skipped before the selected rows of your query are returned. This is constrained by LIMIT. OFFSET rows are skipped starting from the most recent record. For example, the query SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1 returns the last 5 values from Minute_Report except for the most recent one. ORDER BY clause The ORDER BY clause allows you to specify how you want to sort your query results in queries that select event attributes by row. This query orders transactions by duration. FROM Transaction SELECT appName, duration ORDER BY duration Copy The default sort order is ascending, but this can be changed by adding the ASC or DESC modifiers. SHOW EVENT TYPES clause SHOW EVENT TYPES... Copy SHOW EVENT TYPES will return a list of all the data types present in your account for a specific time range. It is used as the first clause in a query instead of SELECT. Important In this context, \"event types\" refers to the data types you can access with a NRQL query. Data types in the last day This query will return all the data types present over the past day: SHOW EVENT TYPES SINCE 1 day ago Copy SINCE clause SELECT ... SINCE [numerical units AGO | phrase] ... Copy The default value is 1 hour ago. Use the SINCE clause to define the beginning of a time range for the returned data. When using NRQL, you can set a UTC timestamp or relative time range. You can specify a timezone for the query but not for the results. NRQL results are based on your system time. See Set time range on dashboards and charts for detailed information and examples. SLIDE BY clause The SLIDE BY clause supports a feature known as sliding windows. With sliding windows,SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. To use SLIDE BY, place it in a query after the TIMESERIES clause. For example, this query pulls data in 5-minute windows with a 1-minute SLIDE BY interval, meaning that each window lasts 5 minutes, but window 1 starts at 0 minutes, window 2 starts at 1 minute, window 3 starts at 2 minutes, and so on. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy To learn more about how and when you can use SLIDE BY, see Create smoother charts with sliding windows. Use SLIDE BY with MAX or AUTO interval You can use sliding windows in combination with MAX or AUTO. However, MAX or AUTO may not be placed between TIMESERIES and SLIDE BY. This query will automatically decide a SLIDE BY window interval. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy This query will set the SLIDE BY window to the maximum interval granularity. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy Important The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which can cause gaps and unexpected results. TIMESERIES clause SELECT ... TIMESERIES integer units ... Copy Use the TIMESERIES clause to return data as a time series broken out by a specified period of time. Since TIMESERIES is used to trigger certain charts, there is no default value. To indicate the time range, use integer units. For example: TIMESERIES 1 minute TIMESERIES 30 minutes TIMESERIES 1 hour TIMESERIES 30 seconds TIMESERIES can be combined with arguments such as MAX, AUTO, and SLIDE BY to further tailor query results, as shown in the examples below. Important For functions such as average( ) or percentile( ), a large aggregation window can have a significant smoothing effect on outliers. This is true whether or not the query makes use of sliding windows. Use a set interval The value provided indicates the units used to break out the graph. For example, to present a one-day graph showing 30 minute increments: SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes Copy Use an automatically set interval TIMESERIES can also be set to AUTO, which will divide your graph into a reasonable number of divisions. For example, a daily chart will be divided into 30 minute intervals and a weekly chart will be divided into 6 hour intervals. This query returns data as a line chart showing the 50th and 90th percentile of client-side transaction time for one week with a data point every 6 hours. SELECT average(duration), percentile(duration, 50, 90) FROM PageView SINCE 1 week AGO TIMESERIES AUTO Copy Use MAX interval You can set TIMESERIES to MAX, which will automatically adjust your time window to the maximum number of intervals allowed for a given time period. This allows you to update your time windows without having to manually update your TIMESERIES buckets and ensures your time window is being split into the peak number of intervals allowed. The maximum number of TIMESERIES buckets that will be returned is 366. For example, the following query creates 4-minute intervals, which is the ceiling for a daily chart. SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX Copy UNTIL clause SELECT ... UNTIL integer units AGO ... Copy The default value is NOW. Only use UNTIL to specify an end point other than the default. Use the UNTIL clause to define the end of a time range across which to return data. Once a time range has been specified, the data will be preserved and can be reviewed after the time range has ended. You can specify a UTC timestamp or relative time range. You can specify a time zone for the query but not for the results. The returned results are based on your system time. See Set time range on dashboards and charts for detailed information and examples. WHERE clause Use the WHERE clause to filter results. NRQL returns the results that fulfill the condition(s) you specify in the clause. SELECT function(attribute) ... WHERE attribute [operator 'value' | IN ('value' [, 'value]) | IS [NOT] NULL ] [AND|OR ...] ... Copy If you specify more than one condition, separate the conditions by the operators AND or OR. If you want to simulate a SQL join, use custom attributes in a WHERE or FACET clause. Operators that the WHERE clause accepts Description =, !=, <, <=, >, >= NRQL accepts standard comparison operators. Example: state = 'WA' AND Used to define an intersection of two conditions. OR Used to define a union of two conditions. IS NULL Determines if an attribute has a null value. IS NOT NULL Determines if an attribute does not have a null value. IN Determines if the string value of an attribute is in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Example: animalType IN ('cat', 'dog', 'fish') NOT IN Determines if the string value of an attribute is not in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Values must be in parentheses, separated by commas. For example: SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA') Copy LIKE Determines if an attribute contains a specified sub-string. The string argument for the LIKE operator accepts the percent sign (%) as a wildcard anywhere in the string. If the substring does not begin or end the string you are matching against, the wildcard must begin or end the string. Examples: userAgentName LIKE 'IE%' IE IE Mobile userAgentName LIKE 'o%a%' Opera Opera Mini userAgentName LIKE 'o%a' Opera userAgentName LIKE '%o%a%' Opera Opera Mini Mozilla Gecko NOT LIKE Determines if an attribute does not contain a specified sub-string. RLIKE Determines if an attribute contains a specified Regex sub-string. Uses RE2 syntax. Examples: appName RLIKE 'z.*|q.*'' z-app q-app hostname RLIKE 'ip-10-351-[0-2]?[0-9]-.*' ip-10-351-19-237 ip-10-351-2-41 ip-10-351-24-238 ip-10-351-14-15 Important Note: Slashes must be escaped in the Regex pattern. For example, \\d must be \\\\d. Regex defaults to full-string matching, therefore ^ and $ are implicit and you do not need to add them. If the Regex pattern contains a capture group, the group will be ignored. That is, the group will not be captured for use later in the query. NOT RLIKE Determines if an attribute does not contain a specified Regex sub-string. Uses RE2 syntax. Example query with three conditions This query returns the browser response time for pages with checkout in the URL for Safari users in the United States and Canada over the past 24 hours. SELECT histogram(duration, 50, 20) FROM PageView WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%' SINCE 1 day ago Copy WITH METRIC_FORMAT clause For information on querying metric data, see Query metrics. WITH TIMEZONE clause SELECT ... WITH TIMEZONE (selected zone) ... Copy By default, query results are displayed in the timezone of the browser you're using. Use the WITH TIMEZONE clause to select a time zone for a date or time in the query that hasn't already had a time zone specified for it. For example, the query clause SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York' will return data recorded from Monday at midnight, Eastern Standard Time, until midnight Tuesday, Eastern Standard Time. Available Time Zone Selections Africa/Abidjan Africa/Addis_Ababa Africa/Algiers Africa/Blantyre Africa/Cairo Africa/Windhoek America/Adak America/Anchorage America/Araguaina America/Argentina/Buenos_Aires America/Belize America/Bogota America/Campo_Grande America/Cancun America/Caracas America/Chicago America/Chihuahua America/Dawson_Creek America/Denver America/Ensenada America/Glace_Bay America/Godthab America/Goose_Bay America/Havana America/La_Paz America/Los_Angeles America/Miquelon America/Montevideo America/New_York America/Noronha America/Santiago America/Sao_Paulo America/St_Johns Asia/Anadyr Asia/Bangkok Asia/Beirut Asia/Damascus Asia/Dhaka Asia/Dubai Asia/Gaza Asia/Hong_Kong Asia/Irkutsk Asia/Jerusalem Asia/Kabul Asia/Katmandu Asia/Kolkata Asia/Krasnoyarsk Asia/Magadan Asia/Novosibirsk Asia/Rangoon Asia/Seoul Asia/Tashkent Asia/Tehran Asia/Tokyo Asia/Vladivostok Asia/Yakutsk Asia/Yekaterinburg Asia/Yerevan Atlantic/Azores Atlantic/Cape_Verde Atlantic/Stanley Australia/Adelaide Australia/Brisbane Australia/Darwin Australia/Eucla Australia/Hobart Australia/Lord_Howe Australia/Perth Chile/EasterIsland Etc/GMT+10 Etc/GMT+8 Etc/GMT-11 Etc/GMT-12 Europe/Amsterdam Europe/Belfast Europe/Belgrade Europe/Brussels Europe/Dublin Europe/Lisbon Europe/London Europe/Minsk Europe/Moscow Pacific/Auckland Pacific/Chatham Pacific/Gambier Pacific/Kiritimati Pacific/Marquesas Pacific/Midway Pacific/Norfolk Pacific/Tongatapu UTC See Set time range on dashboards and charts for detailed information and examples. Query metric data Metric data is more complex than other types of data. There are specific tips for querying it well. We have two types of metric data, each with their own query guidelines: Query dimensional metrics, which are reported by our Metric API and by some of our tools that use that API, like our Telemetry SDKs and our open-source telemetry integrations (OpenTelemetry, Kamon, Micrometer, more). Query metric timeslice data, which is our original metric data type reported by our APM, mobile monitoring, and browser monitoring. For more on understanding these data types, see Metric data types. Aggregator functions Use aggregator functions to filter and aggregate data in a NRQL query. Some helpful information about using aggregator functions: See the New Relic University tutorials for Filter queries, Apdex queries, and Percentile queries. Or, go to the full online course Writing NRQL queries. Data type \"coercion\" is not supported. Read about available type conversion functions. Cohort analysis functions appear on the New Relic Insights Cohort analysis page. The cohort functions aggregate transactions into time segments. Here are the available aggregator functions. The definitions below contain example NRQL queries. Examples: SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy aggregationendtime() Use the aggregationendtime() function to return the time of the relevant aggregation. More specifically, for a given aggregate, the aggregationendtime() function provides the timestamp of the end of the time period of that aggregation. For example, in a timeseries query, for a data point that encompasses an hour’s worth of data, the function would return the timestamp of the end of that hour period. apdex(attribute, t: ) Use the apdex function to return an Apdex score for a single transaction or for all your transactions. The attribute can be any attribute based on response time, such as duration or backendDuration. The t: argument defines an Apdex T threshold in seconds. The Apdex score returned by the apdex( ) function is based only on execution time. It does not account for APM errors. If a transaction includes an error but completes in Apdex T or less, that transaction will be rated satisfying by the apdex ( ) function. Get Apdex for specific customers If you have defined custom attributes, you can filter based on those attributes. For example, you could monitor the Apdex for a particularly important customer: SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago Copy Get Apdex for specific transaction Use the name attribute to return a score for a specific transaction, or return an overall Apdex by omitting name. This query returns an Apdex score for the Controller/notes/index transaction over the last hour: SELECT apdex(duration, t: 0.5) from Transaction WHERE name='Controller/notes/index' SINCE 1 hour ago Copy The apdex function returns an Apdex score that measures user satisfaction with your site. Arguments are a response time attribute and an Apdex T threshold in seconds. Get overall Apdex for your app This example query returns an overall Apdex for the application over the last three weeks: SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago Copy average(attribute) Use the average( ) function to return the average value for an attribute. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. buckets(attribute, ceiling [,number of buckets]) Use the buckets() function to aggregate data split up by a FACET clause into buckets based on ranges. You can bucket by any attribute that is stored as a numerical value in the New Relic database. It takes three arguments: Attribute name Maximum value of the sample range. Any outliers will appear in the final bucket. Total number of buckets For more information and examples, see Split your data into buckets. bucketPercentile(attribute) The bucketPercentile( ) function is the NRQL equivalent of the histogram_quantile function in Prometheus. It is intended to be used with dimensional metric data. Instead of the quantile, New Relic returns the percentile, which is the quantile * 100. Use the bucketPercentile( ) function to calculate the quantile from the histogram data in a Prometheus format. It takes the bucket name as an argument and reports percentiles along the bucket's boundaries: SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago Copy Optionally, you can add percentile specifications as an argument: SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago Copy Because multiple metrics are used to make up Prometheus histogram data, you must query for specific Prometheus metrics in terms of the associated <basename>. For example, to compute percentiles from a Prometheus histogram, with the <basename> prometheus_http_request_duration_seconds using NRQL, use bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50). Note how _ bucket is added to the end of the <basename> as a suffix. See the Prometheus.io documentation for more information. cardinality(attribute) Use the cardinality( ) function to obtain the number of combinations of all the dimensions (attributes) on a metric. It takes three arguments, all optional: Metric name: if present, cardinality( ) only computes the metric specified. Include: if present, the include list restricts the cardinality computation to those attributes. Exclude: if present, the exclude list causes those attributes to be ignored in the cardinality computation. SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list}) Copy count(*) Use the count( ) function to return a count of available records. It takes a single argument; either *, an attribute, or a constant value. Currently, it follows typical SQL behavior and counts all records that have values for its argument. Since count(*) does not name a specific attribute, the results will be formatted in the default \"humanize\" format. derivative(attribute [,time interval]) derivative() finds the rate of change for a given dataset. The rate of change is calculated using a linear least-squares regression to approximate the derivative. Since this calculation requires comparing more than one datapoint, if only one datapoint is included in the evaluation range, the calculation is indeterminate and won't work, resulting in a null value. The time interval is the period for which the rate of change is calculated. For example, derivative(attributeName, 1 minute) will return the rate of change per minute. dimensions(include: {attributes}, exclude: {attributes}) Use the dimensions( ) function to return all the dimensional values on a data type. You can explicitly include or exclude specific attributes using the optional arguments: Include: if present, the include list limits dimensions( ) to those attributes. Exclude: if present, the dimensions( ) calculation ignores those attributes. FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions() Copy When used with a FACET clause, dimensions( ) produces a unique timeseries for all facets available on the event type, similar to how Prometheus behaves with non-aggregated queries. earliest(attribute) Use the earliest( ) function to return the earliest value for an attribute over the specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get earliest country per user agent from PageView This query returns the earliest country code per each user agent from the PageView event. SELECT earliest(countryCode) FROM PageView FACET userAgentName Copy eventType() ...WHERE eventType() = 'EventNameHere'... ...FACET eventType()... Copy Use the eventType() function in a FACET clause to break out results by the selected data type or in a WHERE clause to filter results to a specific data type. This is particularly useful for targeting specific data types with the filter() and percentage() functions. Important In this context, \"event type\" refers to the types of data you can access with a NRQL query. Use eventType() in filter() function This query returns the percentage of total TransactionError results out of the total Transaction results. You can use the eventType() function to target specific types of data with the filter() function. SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago Copy Use eventType() with FACET This query displays a count of how many records each data type (Transaction and TransactionError) returns. SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES Copy filter(function(attribute), WHERE condition) Use the filter() function to limit the results for one of the aggregator functions in your SELECT statement. You can use filter() in conjunction with FACET or TIMESERIES. Filter is only useful when selecting multiple different aggregations such as SELECT filter(sum(x), WHERE attribute='a') AS 'A', filter(sum(x), WHERE attribute='b') AS 'B' .... Otherwise, it's better to just use the standard WHERE clause. Analyze purchases that used offer codes You could use filter() to compare the items bought in a set of transactions for those using an offer code versus those who aren't: Use the filter( ) function to limit the results for one of the aggregator functions in your SELECT statement. funnel(attribute, steps) Use the funnel() function to generate a funnel chart. It takes an attribute as its first argument. You then specify steps as WHERE clauses (with optional AS clauses for labels) separated by commas. For details and examples, see the funnels documentation. getField(attribute, field) Use the getField() function to extract a field from complex metrics. It takes the following arguments: Metric type Supported fields summary count, total, max, min gauge count, total, max, min, latest distribution count, total, max, min counter count Examples: SELECT max(getField(mySummary, count)) from Metric Copy SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10 Copy histogram(attribute, ceiling [,number of buckets]) Use the histogram( ) function to generate histograms. It takes three arguments: Attribute name Maximum value of the sample range Total number of buckets (between 1 and 500, inclusive) Histogram of response times from PageView events This query results in a histogram of response times ranging up to 10 seconds over 20 buckets. SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy Prometheus histogram buckets histogram( ) accepts Prometheus histogram buckets: SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago Copy New Relic distribution metric histogram( ) accepts Distribution metric as an input: SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago Copy Histogram with a FACET clause Use histogram( ) with a FACET clause to generate a heatmap chart: SELECT histogram(duration) FROM PageView FACET appName SINCE 1 week ago Copy keyset() Using keyset() will allow you to see all of the attributes for a given data type over a given time range. It takes no arguments. It returns a JSON structure containing groups of string-typed keys, numeric-typed keys, boolean-typed keys, and all keys. See all attributes for a data type This query returns the attributes found for PageView events from the last day: SELECT keyset() FROM PageView SINCE 1 day ago Copy latest(attribute) Use the latest( ) function to return the most recent value for an attribute over a specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get most recent country per user agent from PageView This query returns the most recent country code per each user agent from the PageView event. SELECT latest(countryCode) FROM PageView FACET userAgentName Copy latestrate(attribute, time interval) Use the latestrate( ) function to return the rate of change of a value based on the last 2 data points. It takes the attribute in question as the first argument and the unit of time for the resulting rate as the second argument. The function returns a result in units of change in attribute/time interval. This function can be useful to provide the most recent rate of change for an attribute in order to see leading-edge trends. Get the most recent rate of change of PageView Duration This query returns the rate of change of duration based on the last 2 data points. It will be returned in units of duration/second because of the 1 SECOND argument. SELECT latestrate(duration, 1 SECOND) FROM PageView Copy max(attribute) Use the max( ) function to return the maximum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. median(attribute) Use the median( ) function to return an attribute's median, or 50th percentile. For more information about percentile queries, see percentile(). Tip The median( ) query is only available when using the query builder. Median query This query will generate a line chart for the median value. SELECT median(duration) FROM PageView TIMESERIES AUTO Copy min(attribute) Use the min( ) function to return the minimum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. minuteOf(attribute) Use the minuteOf() function to extract only the minute portion (i.e. 0-59) of an attribute holding a valid timestamp value. mod(attribute, divisor) Use the mod( ) function to return the floor modulus after dividing the value of the provided numeric attribute (the first argument, or dividend) by a numeric value (the second argument, or divisor). This modulo operation can be used within a WHERE clause condition to filter to an arbitrary subset of results or within a FACET clause as a way to subdivide the result set. mod() within a WHERE clause condition FROM Transaction SELECT * WHERE mod(port, 2) = 1 Copy mod() within a FACET clause FROM NrDailyUsage SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10) Copy percentage(function(attribute), WHERE condition) Use the percentage( ) function to return the percentage of a target data set that matches some condition. The first argument requires an aggregator function against the desired attribute. Use exactly two arguments (arguments after the first two will be ignored). If the attribute is not numeric, this function returns a value of 100%. percentile(attribute [, percentile [, ...]]) Use the percentile( ) function to return an attribute's approximate value at a given percentile. It requires an attribute and can take any number of arguments representing percentile points. The percentile() function enables percentiles to displays with up to three digits after the decimal point, providing greater precision. Percentile thresholds may be specified as decimal values, but be aware that for most data sets, percentiles closer than 0.1 from each other will not be resolved. Percentile display examples Use TIMESERIES to generate a line chart with percentiles mapped over time. Omit TIMESERIES to generate a billboard and attribute sheet showing aggregate values for the percentiles. If no percentiles are listed, the default is the 95th percentile. To return only the 50th percentile value, the median, you can also use median(). Basic percentile query This query will generate a line chart with lines for the 5th, 50th, and 95th percentile. SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO Copy predictLinear(attribute, [,time interval]) predictLinear() is an extension of the derivative() function. It uses a similar method of least-squares linear regression to predict the future values for a dataset. The time interval is how far the query will look into the future. For example, predictLinear(attributeName, 1 hour) is a linear prediction 1 hour into the future of the query time window. Generally, predictLinear() is helpful for continuously growing values like disk space, or predictions on large trends. Since predictLinear() is a linear regression, familiarity with the dataset being queried helps to ensure accurate long-term predictions. Any dataset which grows exponentially, logarithmically, or by other nonlinear means will likely only be successful in very short-term predictions. New Relic recommends against using predictLinear in TIMESERIES queries. This is because each bucket will be making an individual prediction based on its relative timeframe within the query, meaning that such queries will not show predictions from the end of the timeseries forward. rate(function(attribute) [,time interval]) Use the rate( ) function to visualize the frequency or rate of a given query per time interval. For example, you might want to know the number of pageviews per minute over an hour-long period or the count of unique sessions on your site per hour over a day-long period. Use TIMESERIES to generate a line chart with rates mapped over time. Omit TIMESERIES to generate a billboard showing a single rate value averaged over time. Basic rate query This query will generate a line chart showing the rate of throughput for APM transactions per 10 minutes over the past 6 hours. SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago TIMESERIES Copy round(attribute) Use the round( ) function to return the rounded value of an attribute. Optionally round( ) can take a second argument, to_nearest, to round the first argument to the closest multiple of the second one. to_nearest can be fractional. SELECT round(n [, to_nearest]) Copy stddev(attribute) Use the stddev( ) function to return one standard deviation for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. stdvar(attribute) Use the stdvar( ) function to return the standard variance for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. sum(attribute) Use the sum( ) function to return the sum recorded values of a numeric attribute over the time range specified. It takes a single argument. Arguments after the first will be ignored. If the attribute is not numeric, it will return a value of zero. uniqueCount(attribute) Use the uniqueCount( ) function to return the number of unique values recorded for an attribute over the time range specified. Tip To optimize query performance, this function returns approximate results for queries that inspect more than 256 unique values. uniques(attribute [,limit]) Use the uniques( ) function to return a list of unique values recorded for an attribute over the time range specified. When used along with the facet clause, a list of unique attribute values will be returned per each facet value. The limit parameter is optional. When it is not provided, the default limit of 1,000 unique attribute values per facet is applied. You may specify a different limit value, up to a maximum of 10,000. The uniques( ) function will return the first set of unique attribute values discovered, until the limit is reached. Therefore, if you have 5,000 unique attribute values in your data set, and the limit is set to 1,000, the operator will return the first 1,000 unique values that it discovers, regardless of their frequency. The maximum number of values that can be returned in a query result is the product of the uniques( ) limit times the facet limit. In the following query, the theoretical maximum number of values that can be returned is 5 million (5,000 x 1,000). Depending on the data set being queried, and the complexity of the query, memory protection limits may prevent a very large query from being executed. From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000 Copy Using tuple If you'd like to know the unique combinations of a handful of attributes, you can structure a query in the format SELECT unique(tuple(x, y, ... z)) ...` to get all the unique tuples of values, to maintain their relationship. In the following query, tuple is used on index and cellName together to find uniques where those two values occur in combination. FROM NodeStatus SELECT uniques(tuple(index, cellName), 5) Copy Type conversion NRQL does not support \"coercion.\" This means that a float stored as a string is treated as a string and cannot be operated on by functions expecting float values. You can convert a string with a numeric value or a boolean with a string value to their numeric and boolean types with these functions: Use the numeric() function to convert a number with a string format to a numeric function. The function can be built into a query that uses math functions on query results or NRQL aggregator functions, such as average(). Use the boolean() function to convert a string value of \"true\" or \"false\" to the corresponding boolean value.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.29578,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> syntax, clauses, and functions",
        "sections": "<em>Query</em> <em>components</em>",
        "tags": "<em>Query</em> <em>your</em> data",
        "body": "<em>NRQL</em> is a <em>query</em> language you can use to <em>query</em> the New Relic database. This document explains <em>NRQL</em> syntax, clauses, <em>components</em>, and functions. Syntax This document is a reference for the functions and clauses used in a <em>NRQL</em> <em>query</em>. Other resources for understanding <em>NRQL</em>: Intro to <em>NRQL</em>: explains what"
      },
      "id": "604456c1196a678db8960f41"
    }
  ],
  "/build-apps/add-visualizations-to-dashboard": [
    {
      "sections": [
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "Tip",
        "2. Take advantage of CLI tools",
        "3. Leverage the power of APIs"
      ],
      "title": "Automate instrumentation",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "65d82617672b47497b59dcf7c55eaba535714676",
      "image": "https://docs.newrelic.com/static/82b9b43751f8e8c8dbf4be1242cc6cb3/c1b63/new-relic-terraform-snippet.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation/",
      "published_at": "2021-04-16T10:15:36Z",
      "updated_at": "2021-03-16T10:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Tip Read this Best Practices post for more information about automating instrumentation in your pipeline Configuration management tools such as Terraform enable automation as well. Using the New Relic Terraform Provider, you can automatically add agents and alerts, or create a dashboard when you start up a new service. 2. Take advantage of CLI tools Most tools provide a command line interface that allows a back-door to quickly get work done. For example, the New Relic CLI lets you search and tag entities across accounts. The New Relic Lambda CLI installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the NR-1 CLI to build and share your own New Relic applications. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.77087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>1</em>. Make instrumentation part of every build",
        "body": ". For example, the New Relic <em>CLI</em> lets you search and tag entities across accounts. The New Relic Lambda <em>CLI</em> installs and configures a New Relic AWS Lambda layer onto your AWS Lambda functions. You can also use the <em>NR</em>-<em>1</em> <em>CLI</em> to build and share your own New Relic applications. 3. Leverage the power of APIs Now"
      },
      "id": "603ea2f7196a672323a83def"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/1qf2g217c4q7m/promo-image.1608575584.png",
      "url": "https://learn.newrelic.com/getting-started-with-dashboards-nrql",
      "sections": [
        "Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations.",
        "About this workshop",
        "Getting started with Dashboards & NRQL"
      ],
      "published_at": "2021-04-20T01:39:15Z",
      "title": "[Webinar] Getting started with Dashboards & NRQL",
      "updated_at": "2021-04-20T01:39:15Z",
      "type": "",
      "external_id": "20be8b6c5a3882e951f9dfd70354ea7ceaa38c7c",
      "popularity": 1,
      "body": "Sign In [Webinar] Getting started with Dashboards & NRQL Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of NRQL. Progress to working directly with NRQL to create a wider range of charts and visualizations. Register | FREE Already registered? Sign In About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.  These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.  Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.   In this hands-on session, you’ll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.  Using a sandbox account you’ll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.  Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL April 20, 2021, 1 p.m. - April 20, 2021, 3 p.m. BST 104 Getting started with Dashboards & NRQL May 6, 2021, noon - May 6, 2021, 2 p.m. PDT 148 Getting started with Dashboards & NRQL May 11, 2021, 1 p.m. - May 11, 2021, 3 p.m. BST 148 Getting started with Dashboards & NRQL June 8, 2021, 1 p.m. - June 8, 2021, 3 p.m. BST 150 Getting started with Dashboards & NRQL June 8, 2021, noon - June 8, 2021, 2 p.m. PDT 150 About this workshop New Relic One offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and visualizations.  These charts can be combined to create powerful dashboards to help you correlate and understand your systems, troubleshoot more efficiently, or correlate performance metrics with business KPIs. Using tools like the Data Explorer or Query Builder Basic Mode, you can quickly and easily create charts and dashboards without any knowledge of NRQL.  Working directly with NRQL you can go further and create a wider range of charts and visualizations to suit your requirements.   In this hands-on session, you’ll get to explore the data being collected, start building custom charts with the Data Explorer, and learn about the structure and capabilities of NRQL.  Using a sandbox account you’ll get familiar with NRQL syntax, work with the Query Builder to build your own queries and charts, and create data rich dashboards.  You’ll also learn about some of the powerful features of dashboards which enable you to link, filter, and share them for more powerful troubleshooting and data correlation.  Course agenda: Introduction to Charts and Dashboards Introduction to Event Data and NRQL Data Explorer: Create charts without writing NRQL Lab: Explore your data: Event, Plot, Dimensions Lab: Create performance charts Query Builder: NRQL and query components Group and Filter your data Lab: Starting queries Lab: Create user-based charts Aggregate your data: Answering specific questions Lab: Create specific performance charts Time spans, Timeseries, and Comparing data Query multiple columns; Multi Facet Interactive Dashboards More Event types Lab: Build a dashboard Knowledge Check and Takeaways Live events Getting started with Dashboards & NRQL Event Date Spaces left Getting started with Dashboards & NRQL April 20, 2021, 1 p.m. - April 20, 2021, 3 p.m. BST 104 Getting started with Dashboards & NRQL May 6, 2021, noon - May 6, 2021, 2 p.m. PDT 148 Getting started with Dashboards & NRQL May 11, 2021, 1 p.m. - May 11, 2021, 3 p.m. BST 148 Getting started with Dashboards & NRQL June 8, 2021, 1 p.m. - June 8, 2021, 3 p.m. BST 150 Getting started with Dashboards & NRQL June 8, 2021, noon - June 8, 2021, 2 p.m. PDT 150 © 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.67432,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "[Webinar] Getting started with Dashboards &amp; <em>NRQL</em>",
        "sections": "Learn to use the Data Explorer and Query Builder Basic Mode to create charts and dashboards without any knowledge of <em>NRQL</em>. Progress to working directly with <em>NRQL</em> to create a wider range of charts and <em>visualizations</em>.",
        "body": " registered? Sign In About this workshop New Relic <em>One</em> offers a consistent, powerful, and flexible query language NRQL which enables you to query and analyze all of your collected data, and build custom charts and <em>visualizations</em>.  These charts can be combined to create powerful dashboards to help you"
      },
      "id": "5fe29f8528ccbcf532f15668"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.64117,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a custom New Relic <em>One</em> application ",
        "sections": "Build a custom New Relic <em>One</em> application",
        "tags": "New Relic <em>One</em>",
        "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic <em>One</em> platform, alongside your other dashboards and data. Feature <em>visualizations</em> that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/cloud-migration-quickstart-2.png",
      "url": "https://newrelic.com/blog/how-to-relic/dashboards-and-custom-visualizations",
      "sections": [
        "Visualize your data from scratch or a quickstart",
        "Extend capabilities with the dashboards API and customizations UI",
        "Let’s build together"
      ],
      "published_at": "2021-04-16T04:27:09Z",
      "title": "New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil",
      "updated_at": "2021-04-13T23:29:41Z",
      "type": "",
      "external_id": "5d1ed7d2f89c24024b85aac381ce3940605bd0e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil Feb 25, 2021 • 4 min read By Sebastian Galiano Molina If you’re like most engineers, you may find yourself parsing through data from more sources than ever before. Chances are that you need a way to visualize and customize all the data to fit your organization’s needs, and report and efficiently communicate your analysis to different stakeholders. Starting from scratch isn’t the most efficient way. The good news is that you don’t have to start from scratch. As a New Relic One user, you can begin accessing new dashboards and custom visualization capabilities today that give you access to a library of dashboards, third-party custom visualization capabilities, and quickstart visualizations, based on common use cases in the New Relic One Catalog and the New Relic One Dashboard API. Visualize your data from scratch or a quickstart If you would like a custom visualization, you can create smaller-scale custom widgets and pin them to a dashboard. Is there a visualization you like in a popular JavaScript charting library like D3 or Recharts? You can now use it in your custom visualization connected to the data already in the Telemetry Data Platform. Are you looking for maps, heat maps, and traffic lights to visualize your system movements? We have you covered. Sample charts you can generate using the D3 or Recharts charting library.   To make it even easier to find the template you want, you can access a Quickstarts Library, a community repository of New Relic dashboards, alerts, and installation instructions. Deploy the app in your account to quickly find the template you want and start using it in your account. Best of all? We built this all in open source, which means you can provide feedback and suggestions on use cases you’re looking to solve. Create an issue or send a pull request—we’re building this library for you and your needs. Sample cloud migration quickstart. Extend capabilities with the dashboards API and customizations UI New Relic One dashboards provide custom visualizations that can be automated through templates and a full dashboard CRUD API, with custom chart widgets built with React.js, the ability to pull in third-party library widgets, and a library of templates to get started fast—and all of it in open source. With the recent customization updates, you can now quickly add widgets directly to dashboards simply by clicking “add to dashboards” in the Query Builder. You can also customize existing widgets to display data as you need it: Number and time formatter: Define decimals (e.g., number of 9s in your SLO) and formatting your dates and timestamps (e.g., US format or EU format) Customize y-axis: You can now define how you want your y-axis to behave by setting it to a specific value and ignore outliers Customize y-axis min/max   Format date and time to fit your needs.   Format numbers to appropriate decimal places for more precision.   As a busy engineer, reducing toil is a must. You can use the API to deploy a standard set of dashboards for every new service you create. And if you need inspiration, a large inventory of pre-built custom dashboards reflect observability best practices. You’ll find a range of subject areas, including infrastructure monitoring, cloud, browser, and mobile monitoring. Let’s build together We designed these new capabilities to help you innovate. We’re continuously listening to your feedback and adding more templates, resources, and visualizations to our libraries. Because we’re invested in working in the “open source way” and providing you transparency, our visualization builder pulls from the open source ecosystem, so you can visualize data in any way that you prefer. If you have feedback or suggestions, please feel free to submit it through New Relic One. We’re building an extensive library and we encourage you to join us. Check out developer.newrelic.com to learn more. By Sebastian Galiano Molina Sebastian Galiano Molina is a Senior Product Manager Data Visualization, Data Exploration and Dashboards at New Relic, based in Barcelona. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.58737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic Dashboards and Custom <em>Visualizations</em>: Flexibility with Less Toil",
        "sections": "<em>Visualize</em> your data from scratch or a quickstart",
        "body": " is that you don’t have to start from scratch. As a New Relic <em>One</em> user, you can begin accessing new dashboards and custom visualization capabilities today that give you access to a library of dashboards, third-party custom visualization capabilities, and quickstart <em>visualizations</em>, based on common use"
      },
      "id": "60762965196a677f8464a77b"
    },
    {
      "sections": [
        "Introduction to New Relic One",
        "Tip",
        "A more consistent and unified platform",
        "Quickly understand context",
        "Know your relationships and dependencies",
        "Query your data more easily",
        "Enhanced dashboards",
        "Build on New Relic One",
        "What’s next?"
      ],
      "title": "Introduction to New Relic One",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Get started"
      ],
      "external_id": "c9ba93c83a579625a4ba3364c6046f3c475cba3a",
      "image": "https://docs.newrelic.com/static/260eb3b62364143206af57cd5a84e77d/c1b63/NR1-dashboards-image.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/get-started/introduction-new-relic-one/",
      "published_at": "2021-04-16T22:11:14Z",
      "updated_at": "2021-03-30T13:06:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One is the platform that gives you access to our Telemetry Data Platform, our Full-Stack Observability features, and our Applied Intelligence functionality. To access New Relic One: Go to one.newrelic.com. Or, if you report data to the EU data center go to one.eu.newrelic.com. Tip To use New Relic One and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. A more consistent and unified platform Before our release of New Relic One, our platform was separated into various products, like APM, Browser, and Mobile. With our move to New Relic One, you can view and interact with all the data from across your entire system more easily. For more information, see our New Relic One transition guide. Quickly understand context New Relic One gives you and your teams a connected view that cuts through complexity and allows you to: Use the New Relic Explorer as the front door to New Relic One: observe, group, and filter the performance data from all the entities in your system. The New Relic Navigator gives you a high density overview of all your entities so you can detect any issues at a glance. And the New Relic Lookout shows entities recently experiencing behavior deviations. Organize your environments and manage data more effectively with tags. Use tags to illustrate relationships and contextual information for what you monitor. By thoughtfully tagging your entities, you can connect all the data your teams need to understand their increasingly complex and interdependent systems. View everything you’re monitoring in one place, like entities or dashboards across your organization. Cross-account access brings all types of data together while still making everything easy to find. Group any entities together into functional team-focused or project-focused groupings with workloads. Tailor custom dashboards for your unique needs. Create visuals that showcase your business needs at a glance, and make the most of your expertise. Get more context while you query with the query builder which surfaces data definitions as you craft and edit queries. Know your relationships and dependencies We provide multiple ways to understand dependencies, so you can easily see how everything fits together and troubleshoot problems. If you want to... Use this Have an overall view of your system, and drill down to get performance details. The New Relic Explorer gives you context to the performance data from all your monitored applications, services, hosts, or containers. Gain extensive visibility into each entity in your solution, its alert status, and how the entities are connected. See how each part of your system is connected. Service maps illustrate your upstream and downstream dependencies. Organize everything you monitor and provide context for your entities. Add tags to all your entities. Understand how everything is connected via API. The NerdGraph GraphiQL explorer manages all your entities, tags, and relationships. Find a service or dashboard in a complex environment. Search by name across all accounts in the unified search, or filter the explorer by tags or text View a list of all the dependencies for a service. The dependencies view tab in an entity summary shows all the dependencies of the entity you’re viewing. Track activity as it moves across your distributed system. Distributed tracing helps you analyze your modern environment. Know which teams are responsible for specific entities across your organization. Create tags for teams and all the services they monitor. Query your data more easily At the top of all UI pages, Query your data is available. No matter your level of proficiency with our query language, you can create custom queries and charts: Browse your data in a query-less experience with our data explorer. Use your NRQL (our query language) expertise to build custom charts in the NRQL mode query builder. Run PromQL-style queries in the query builder. Enhanced dashboards one.newrelic.com > Dashboards: Quickly create information dense custom views into the data that matters most to you with dashboards in New Relic One. New Relic One dashboards let you build better visualizations more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our agents, integrations, and APIs. Share dashboards or charts as a .pdf, or embed a chart in an external site. Tip If you previously used New Relic Insights to create dashboards, these are available as New Relic One dashboards. Build on New Relic One If custom charts and dashboards don't solve your current challenge, we give you a framework for building React JavaScript applications that: Live on New Relic One, alongside your other New Relic-monitored data. Feature highly tailored visualizations. Display data from any source you want, whether from a New Relic-monitored entity or data from any service or API. And you can use open source apps built by the community, and contribute your own open source apps. To learn more, see New Relic One applications. What’s next? To get started understanding how to get around in New Relic One: See what data you have available with the data explorer. Browse your monitored entities with the New Relic Explorer. Use our NerdGraph API to add tags to your data. Learn about dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.30034,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>One</em>",
        "sections": "Introduction to New Relic <em>One</em>",
        "tags": "New Relic <em>One</em>",
        "body": " with dashboards in New Relic <em>One</em>. New Relic <em>One</em> dashboards let you build better <em>visualizations</em> more easily, with more options to customize. Dashboard features include: Perform NRQL queries and create charts and dashboards everywhere in the platform using the query builder. Manage your charts and dashboards"
      },
      "id": "603ec19164441f9e704e8896"
    }
  ],
  "/explore-docs/custom-viz": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/New-Relic-One-Catalog.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-5",
      "sections": [
        "Subscribe to applications with the New Relic One Catalog",
        "Observability Maps",
        "Metric Aggregator",
        "Workload Geo Ops",
        "Check out these other resources for using—and building—New Relic One applications ",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "The Most Popular New Relic One Applications (Roundup #5)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "75f80d867fec167c4a6d62082f32cb2ff1ae0802",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #5) Jun 4, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Observability Maps Metric Aggregator Workload Geo Ops Subscribe to applications with the New Relic One Catalog Before we start accessing the applications via the CLI, let’s look at how to access these applications directly within New Relic One. To explore available applications, navigate to New Relic One and click on the New Relic One Catalog launcher. New Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. New Relic One Catalog If you deploy an application from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Observability Maps Observability Maps allows you to create a view beyond a traditional service map. Using Observability Maps, you can connect disparate entities in your environment into ad hoc relationships, creating your own relationships based on data available in New Relic. See your entities and environment in a way that makes the most sense to your team and business. Observability Maps App Fork or deploy the Observability Maps app from GitHub. Specific requirements for this app Requires data in NRDB from any or all of the New Relic products. Metric Aggregator The Metric Aggregator is a New Relic One application that helps you create events-to-metrics (E2M) rules, a real-time streaming service that converts event data into dimensional metrics at ingest. Converting events to metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Metric Aggregator App Fork or deploy the Metric Aggregator app from GitHub. Specific requirements for this app If you use New Relic, you already have New Relic Metrics. You can  create E2M rules immediately. Workload Geo Ops Workload Geo Ops links your workloads (collections of entities) to physical locations so you can quickly identify and resolve incidents. It's a geographic exploration of workload data tied to geographic data, including location metadata. You can define maps and then collect or assign entities to points on those maps. With workloads, a collection of entities can be managed by rules and tags to support the dynamic, ephemeral nature of modern IT infrastructure. Fork or deploy the Workload Geo Ops app from GitHub. Specific requirements for this app To get the most of this app, we recommend that you configure Workloads in New Relic One. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Workload Geo Ops to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One applications  Here are resources to help you build your own New Relic One applications. If you can imagine it, you can build it:  developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. NerdGraph GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity. Application/data access and permissions and security. NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.4867,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: <em>nr1</em> <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>nr1</em>-workload-geoops.git cd <em>nr1</em>-workload-geoops <em>nr1</em> <em>nerdpack</em>:serve Or you could download, configure, and deploy an account"
      },
      "id": "60762e1f64441fbf2e9d856e"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/attributory-screenshot-main.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-6",
      "sections": [
        "Subscribe to apps in the New Relic One Catalog",
        "Flex Manager",
        "GraphiQL Notebook",
        "Attributory",
        "What are you waiting for? Deploy these apps now.",
        "Check out these other resources for using—and building—New Relic One apps",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:26:51Z",
      "title": "The Most Popular New Relic One Applications (Roundup #6)",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "76394d24aebbff40a68e9bd6a7f867313e814d74",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #6) Jul 2, 2020 • 8 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the visibility and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source, so you can use them out-of-the-box, or submit a pull request for feedback and feature requests. In this edition, we cover three apps that help engineers do their jobs: Flex Manager GraphiQL Notebook Attributory Subscribe to apps in the New Relic One Catalog You can manage and deploy apps directly within New Relic One. To explore available apps, navigate to New Relic One and click on the New Relic One Catalog launcher. From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. If you deploy an app from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Flex Manager New Relic Flex is an application-agnostic, all-in-one tool that makes sending data to New Relic from third party sources easier than ever. Use Flex Manager to simplify the work of creating, managing, and deploying new integrations you’ve built with Flex. Fork or deploy the Flex Manager app from GitHub. Specific requirements for this app Flex Manager requires New Relic Infrastructure and the Flex integration. GraphiQL Notebook GraphiQL Notebook allows you to explore and learn about the NerdGraph—the New Relic GraphQL API—using a Jupyter Notebook style interface. Notebooks intermix GraphQL requests with data exploration links. You can create, update, save, and delete notebooks. You can also export and share notebooks as blocks of Base64-encoded JSON. Fork or deploy the GraphQL Notebook app from GitHub. Attributory Attributory is a dictionary of attributes from your APM, Browser, or Mobile applications stored in New Relic. It displays a list of attributes for each application. When you open a service or application from the entity explorer, you’ll find Attributes Dictionary listed as an application in the left-hand navigation. New Relic stores event data as key-value pairs. Built-in New Relic attributes include the definition of the attribute. For custom attributes, you can choose to add your own definitions. Fork or deploy the Attributory app from GitHub. Specific requirements for this app Applications with New Relic APM, Browser, or Mobile agents reporting into New Relic. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account Once you have these requirements in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Attributory to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One apps Here are resources to help you build your own New Relic One apps. If you can imagine it, you can build it: New Relic Developers: Build applications using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Open Source: New Relic’s open source website makes it easy for you to explore the open source projects we maintain and the open standards projects we participate in. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, review our Contributors Guide. Keep in mind that when you submit your Pull Request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 256.48654,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: <em>nr1</em> <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>nr1</em>-attributory.git cd <em>nr1</em>-attributory <em>nr1</em> <em>nerdpack</em>:serve Or you could download, configure, and deploy an account-specific instance of Attributory"
      },
      "id": "60762e1e28ccbcb5fd51c147"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/DEPLOYMENT-ANALYZER-SCREENSHOT-1.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-3",
      "sections": [
        "Container Explorer",
        "Specific requirements for this app",
        "Deployment Analyzer",
        "Page View Map",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:25:05Z",
      "title": "Most Popular New Relic One Applications (Round up #3)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "6f0be6c93ebcc052fac27513c1e849c0dfd256e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic Most Popular New Relic One Applications (Round up #3) Nov 26, 2019 • 7 min read By Joel Worrall Hopefully, you’ve heard the news that the New Relic One observability platform is now programmable. As central component of an observability platform, we believe programmability gives you the ability to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the possibilities—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications … and then we kept going. In fact, new apps are coming in every day. And we hope to see app contributions by New Relic users continue. This blog series is our opportunity to spotlight the most popular apps available today from our GitHub repository. The best part: Every app is available under an open source license and can be deployed right now! In this edition, we cover: Container Explorer Deployment Analyzer Page View Map Container Explorer This app includes a launcher that gives you a global view of all containers associated with an account. You can also employ tags to segment and drill down into subsets of your global container inventory. The app also presents container CPU, memory, and disk I/O usage in the form of intuitive and efficient heat map visualizations. Container Explorer presents CPU, memory, and disk I/O usage for all containers associated with an account—displaying this data via intuitive and efficient heat map visualizations. In the New Relic One entity explorer, we provide a nerdlet that will show all of the containers that are running for a selected APM application (service). We can also detect whether infrastructure data is coming from third-party sources and can, if necessary, automatically present this container telemetry in-context. Container Explorer can detect whether infrastructure data is coming from third-party sources—and can, if necessary, automatically ingest and present this container telemetry in-context. Clicking on a node in the heatmap reveals details about that container, and you can also jump to its host in the entity explorer. Clicking on a node in the Container Explorer heatmap reveals details about that container, and users can also jump to its host in the entity explorer. Fork or deploy the Container Explorer app from GitHub. Specific requirements for this app The New Relic Infrastructure agent must be deployed on any host you want to monitor. Note: We generate per-container CPU and other metrics by summarizing all processes in a given containerId. This will, however, report an accurate value only if the agent reports one ProcessSample per process every 30 seconds. Deployment Analyzer Deployments of applications can be risky events, but you can correlate those events to the performance of your applications, using deployment markers in New Relic. This app builds further on this process—enabling teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Deployment Analyzer enables teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Fork or deploy the Deployment Analyzer app from GitHub. Specific requirements for this app You'll need an active New Relic APM Pro subscription in order to access deployment marker functionality. Page View Map This app creates geographic visualizations of New Relic Browser application data using the React Leaflet mapping library. Leaflet is a leading open-source JavaScript library for mobile-friendly interactive maps. In addition to providing a new way to visualize your business data, this app offers a great example of what's possible for developers working with our GraphQL service and a third party library. Page View Map creates geographic visualizations of New Relic Browser application data Fork or deploy the Page Views Map app from GitHub Specific requirements for this app You must have the New Relic Browser Agent(s) installed, as well as related access to New Relic One. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer.git cd nr1-container-explorer nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Container Explorer to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer cd nr1-container-explorer nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app's launcher (unless otherwise noted above). Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications: New Relic Developer Edition: Early access to the Developer Edition of New Relic One gives you a free, personal sandbox account where you can build your own experience with all the available New Relic tools. developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome contributions to any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series.   Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 253.79684,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: <em>nr1</em> <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>nr1</em>-container-explorer.git cd <em>nr1</em>-container-explorer <em>nr1</em> <em>nerdpack</em>:serve Or you could download, configure"
      },
      "id": "60762e1f196a673d0a64a782"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Event-Stream-Screenshot.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-applications-4",
      "sections": [
        "Event Stream",
        "Specific requirements for this app",
        "Neon",
        "Network Telemetry",
        "SLO/R",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:39:54Z",
      "title": "The Most Popular New Relic One Applications (Roundup #4)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "0ac60d545488f3c1904bdd6e0d552af5c307ee5a",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #4) Jan 9, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs different types and combinations of insights into how their apps and systems are performing. That’s why New Relic One is programmable—you can build and deploy custom apps that give you the specific insights and information your company needs. To show you what’s possible—and to inspire you to create apps—we worked with members of the New Relic community to build a handful of open source applications, and the number of newly-developed apps continues to grow. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Event Stream Neon Network Telemetry SLO/R Event Stream During a launch or incident, you need the absolute latest data from your application. Event Stream is like Unix tail for APM data—it pulls in your Transaction and TransactionError data in a live stream, so you can find out exactly what's happening with your app right at that moment. You can also filter and facet the data to show the exact data you need. New Relic One Application Event Stream Fork or deploy the Event Stream app from GitHub. Specific requirements for this app Install the appropriate New Relic APM agent. Neon Need to create a single dashboard to track the health of entire business units or regions? Neon lets you create a status board based on New Relic alerts or the values from New Relic events. Fork or deploy the Neon app from GitHub. Specific requirements for this app To view the status of New Relic alerts, you’ll need to set up a webhook notification channel for the alert policies. See the New Relic documentation to learn more about managing notification channels. Network Telemetry Network Telemetry Screenshot The Network Telemetry app visualizes data collected through the Network Telemetry Infrastructure integration. The integration collects data from network devices that export Sflow or IPFIX network samples, and the app creates visualizations to help you examine the sources and destinations of communication within a network, as well as the volume of traffic between devices. Fork or deploy Network Telemetry from GitHub. Specific requirements for this app Install the New Relic Infrastructure agent, and ensure you have the related access to New Relic One. Install the New Relic Network Telemetry On-host integration.  SLO/R SLO/R Screenshot The SLO/R app calculates service-level objective (SLO) attainment for an application service. It allows you to quickly define SLOs for error, availability, capacity, and latency conditions. By measuring SLO attainment across your service estate, you'll be able to determine what signals are most important for a given service or set of services, developed and supported by a team, organization, or group. Using New Relic as a consistent basis to define and measure your SLOs offers better insight into comparative SLO attainment in your service delivery organization. Note: SLO/R is intended to work with services reporting to New Relic via an APM agent. The service provides an entity upon which to define SLOs. Error budget SLOs are defined directly from APM Transaction events; the other SLO types are defined using New Relic alerts. See \"Creating a webhook to forward Alert incidents to Insights\" for more details. Fork or deploy the SLO/R app from GitHub. Specific requirements for this app Install the appropriate New Relic APM agents. Create a New Relic alerts webhook to forward alert events to a SLOR_ALERTS New Relic database table. See \"Creating a webhook to forward Alert incidents to Insights\" for details. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Event Stream—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-event-stream.git cd nr1-event-stream nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Event Stream to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-event-stream.git cd nr1-event-stream   nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications. If you can imagine it, you can build it: developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 253.79684,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "—in this example, Event Stream—is as easy as running a few commands: <em>nr1</em> <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>nr1</em>-event-stream.git cd <em>nr1</em>-event-stream <em>nr1</em> <em>nerdpack</em>:serve Or you could download, configure, and deploy an account-specific instance of Event Stream to your New Relic account using"
      },
      "id": "60762e2028ccbcaf8651c17c"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/GitHub-screenshot_02-1024x724.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-2",
      "sections": [
        "Status Page",
        "Specific requirements for this app",
        "GitHub Integration",
        "Agent Groundskeeper",
        "Customer Journey",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:49:01Z",
      "title": "The Most Popular New Relic One Applications (Round up #2)",
      "updated_at": "2021-04-13T23:49:52Z",
      "type": "",
      "external_id": "c03e99006d6ecc7b6219a2bc68dd0428450cdf26",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Round up #2) Nov 7, 2019 • 8 min read By Joel Worrall We hope you've heard the news that the New Relic One observability platform is now programmable. As the central component of an observability platform, we believe programmability gives you the ability to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the art of the possible—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications … and then we (and all of you!) kept going. In fact, new apps are coming in every day. And we hope to see app contributions by New Relic users continue. In this blog series, we’ll highlight the most popular apps available today. The best part: They’re all open source and ready to be deployed right now! In this edition, we cover: Status Pages GitHub Integration Groundskeeper Customer Journey Status Page Status Page aggregates system status and incident summaries, Statuspage.io style, from multiple providers within a single dashboard. Normally, this is information you’d track down one provider at a time, but Status Page makes it easy to check the status of your key dependencies in one place, at a single glance. Status Page brings together system status and incident report data from key dependencies—making it accessible to your team instantly and easily. Fork or deploy the Status Pages app from GitHub. Specific requirements for this app All you need to get up and running are some status pages you’d like to monitor. Popular options include: New Relic BitBucket Google Cloud Platform GitHub Jira Software Also, keep in mind that currently Status Page can pull in data only from status modules backed by Statuspage.io and Google Status pages. GitHub Integration Having the right information at your fingertips makes a big difference when you’re under the gun to understand a service and resolve an incident. The GitHub Integration connects your New Relic One apps and services to the repos containing relevant documentation, readme files, runbooks, and other essential information. Associate any service or application with its GitHub repository as a one-time action, and you can quickly see that application's readme file, as well as a list of active source code contributors. The GitHub Integration gives you quick access to the documentation for an app or service, including relevant readme files. GitHub Integration also displays a list of the most active contributors to a project, giving you easier access to additional problem-solving resources. Using the GitHub Integration involves a simple, one-time association between any service or application, and its repository. You'll also need to create or use a personal access token, as a one-time setup step, to ensure data security and integrity. Fork or deploy the GitHub Integration app from GitHub. Note: Integration with GitHub requires that you create or use a private access token as a one-time setup step. See GitHub's doc on access tokens for full instructions. Specific requirements for this app A GitHub (either public or private enterprise instance) organization and access to New Relic One. The ability to generate a personal access token in GitHub. Agent Groundskeeper Agent Groundskeeper displays real-time version information for the New Relic APM agents running across your software estate. See which services are up to date (with various upgrade SLO time windows), which are out of date, and which have instances deployed with different versions. Quickly and easily zoom in on your estate by filtering on tags, and search by account, language, and app name. Agent Groundskeeper gives you real-time version information for every APM agent running anywhere within an enterprise environment. Fork or deploy the Agent Groundskeeper app from GitHub. Specific requirements for this app New Relic APM Agent(s) installed and the related access to New Relic One. (Recommended) Add customer-defined labels to your APM applications to make use of New Relic One tag filtering. See our documentation here. Customer Journey Think of this app sort of as a NRQL funnel query on steroids. This application is designed to allow devops teams, product managers, and digital marketers to examine a number of pre-defined measures in a side-by-side comparison between cohorts (columns) of users through a set of steps (rows) where ... Rows equal Steps in a workflow Columns categorize a Series or cohort of users Measures define the Stats that you want to observe for each Series and Step The application employs three visualizations to examine, compare, and present its results: Multi-series Funnel: This visualization combines a third-party funnel library with the New Relic One NerdGraph query to execute three New Relic NRQL queries in the same GraphQL request. The results are aligned into one data set that is delivered to the funnel visualization. Data panels: For each row (Step) and column (Series), the app renders a set of measurements (Stat). Those calculations can apply KPI thresholds to color-code the information. Each panel is also clickable, leading to a more detailed overview. Detail Nerdlet: For any Journey, Series, and Step, there's a Nerdlet that will display the more detailed KPIs as well as a timeseries view of the the given Stats for the selected row and column. Customer Journey can apply KPI thresholds to color-code important information. Each panel is also clickable, leading to a more detailed overview.   A Nerdlet will display more detailed KPIs as well as a timeseries view of the given Stats for a selected row and column. Fork or deploy Customer Journey from GitHub. Specific requirements for this app Access to New Relic One. Configuring the journeyConfig.js. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Status Pages—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-status-pages.git cd nr1-status-pages nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Status Pages to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-status-pages cd nr1-status-pages nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app's launcher (unless otherwise noted above). Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications: New Relic Developer Edition: Early access to the Developer Edition of New Relic One gives you a free, personal sandbox account where you can build your own experience with all the available New Relic tools. developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome contributions to any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 240.86668,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Customer</em> Journey",
        "body": " an application locally—in this example, Status Pages—is as easy as running a few commands: <em>nr1</em> <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>nr1</em>-status-pages.git cd <em>nr1</em>-status-pages <em>nr1</em> <em>nerdpack</em>:serve Or you could download, configure, and deploy an account-specific instance of Status Pages to your New"
      },
      "id": "60762e2028ccbcbab751c12e"
    }
  ],
  "/explore-docs/custom-viz/configuration-options": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/cloud-migration-quickstart-2.png",
      "url": "https://newrelic.com/blog/how-to-relic/dashboards-and-custom-visualizations",
      "sections": [
        "Visualize your data from scratch or a quickstart",
        "Extend capabilities with the dashboards API and customizations UI",
        "Let’s build together"
      ],
      "published_at": "2021-04-16T04:27:09Z",
      "title": "New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil",
      "updated_at": "2021-04-13T23:29:41Z",
      "type": "",
      "external_id": "5d1ed7d2f89c24024b85aac381ce3940605bd0e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit How to Relic New Relic Dashboards and Custom Visualizations: Flexibility with Less Toil Feb 25, 2021 • 4 min read By Sebastian Galiano Molina If you’re like most engineers, you may find yourself parsing through data from more sources than ever before. Chances are that you need a way to visualize and customize all the data to fit your organization’s needs, and report and efficiently communicate your analysis to different stakeholders. Starting from scratch isn’t the most efficient way. The good news is that you don’t have to start from scratch. As a New Relic One user, you can begin accessing new dashboards and custom visualization capabilities today that give you access to a library of dashboards, third-party custom visualization capabilities, and quickstart visualizations, based on common use cases in the New Relic One Catalog and the New Relic One Dashboard API. Visualize your data from scratch or a quickstart If you would like a custom visualization, you can create smaller-scale custom widgets and pin them to a dashboard. Is there a visualization you like in a popular JavaScript charting library like D3 or Recharts? You can now use it in your custom visualization connected to the data already in the Telemetry Data Platform. Are you looking for maps, heat maps, and traffic lights to visualize your system movements? We have you covered. Sample charts you can generate using the D3 or Recharts charting library.   To make it even easier to find the template you want, you can access a Quickstarts Library, a community repository of New Relic dashboards, alerts, and installation instructions. Deploy the app in your account to quickly find the template you want and start using it in your account. Best of all? We built this all in open source, which means you can provide feedback and suggestions on use cases you’re looking to solve. Create an issue or send a pull request—we’re building this library for you and your needs. Sample cloud migration quickstart. Extend capabilities with the dashboards API and customizations UI New Relic One dashboards provide custom visualizations that can be automated through templates and a full dashboard CRUD API, with custom chart widgets built with React.js, the ability to pull in third-party library widgets, and a library of templates to get started fast—and all of it in open source. With the recent customization updates, you can now quickly add widgets directly to dashboards simply by clicking “add to dashboards” in the Query Builder. You can also customize existing widgets to display data as you need it: Number and time formatter: Define decimals (e.g., number of 9s in your SLO) and formatting your dates and timestamps (e.g., US format or EU format) Customize y-axis: You can now define how you want your y-axis to behave by setting it to a specific value and ignore outliers Customize y-axis min/max   Format date and time to fit your needs.   Format numbers to appropriate decimal places for more precision.   As a busy engineer, reducing toil is a must. You can use the API to deploy a standard set of dashboards for every new service you create. And if you need inspiration, a large inventory of pre-built custom dashboards reflect observability best practices. You’ll find a range of subject areas, including infrastructure monitoring, cloud, browser, and mobile monitoring. Let’s build together We designed these new capabilities to help you innovate. We’re continuously listening to your feedback and adding more templates, resources, and visualizations to our libraries. Because we’re invested in working in the “open source way” and providing you transparency, our visualization builder pulls from the open source ecosystem, so you can visualize data in any way that you prefer. If you have feedback or suggestions, please feel free to submit it through New Relic One. We’re building an extensive library and we encourage you to join us. Check out developer.newrelic.com to learn more. By Sebastian Galiano Molina Sebastian Galiano Molina is a Senior Product Manager Data Visualization, Data Exploration and Dashboards at New Relic, based in Barcelona. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.36897,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic Dashboards and <em>Custom</em> <em>Visualizations</em>: Flexibility with Less Toil",
        "sections": "<em>Visualize</em> <em>your</em> data from scratch or a quickstart",
        "body": " cases in the New Relic One Catalog and the New Relic One Dashboard API. Visualize <em>your</em> data from scratch or a quickstart If you would like a <em>custom</em> <em>visualization</em>, you can create smaller-scale <em>custom</em> widgets and pin them to a dashboard. Is there a <em>visualization</em> you like in a popular JavaScript charting"
      },
      "id": "60762965196a677f8464a77b"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.06912,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a <em>custom</em> New Relic One application ",
        "sections": "Build a <em>custom</em> New Relic One application",
        "body": " the PageView events reported from New Relic Browser. Tip If <em>your</em> <em>visualization</em> needs are relatively simple, consider using <em>custom</em> charts and <em>custom</em> dashboards. Now, visit our developer site and start building!"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "image": "https://newrelic.com/sites/default/files/styles/1x1_100w/public/2021-03/Fee_No%C4%8Dnica-01.png?h=3b518393&itok=UlU_gNqe",
      "url": "https://newrelic.com/blog/nerdlog/nerdlog-aiops-and-custom-dashboards",
      "sections": [
        "Finding anomalies with New Relic AIOps",
        "Using AI to find correlated failures",
        "Smart alert muting on New Relic",
        "Custom data visualizations",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:18:16Z",
      "title": "Nerdlog Roundup: AIOps and Customizing Your Data",
      "updated_at": "2021-04-13T23:23:32Z",
      "type": "",
      "external_id": "f02fd7a53ed1069f0c126104e26c67a25f1d3371",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit AIOps Nerdlog Roundup: AIOps and Customizing Your Data Mar 4, 2021 • 4 min read By Nočnica Fee Technology changes fast, and that’s doubly true when your business is adding observability to technology. That’s why we make the Nerdlog. Follow us on Twitch and tune in every Thursday at noon PT (8 p.m. UTC) to learn about the latest New Relic observability features from the product managers and engineers who built them. You can get step-by-step tutorials, give feedback, and ask questions live. If you missed last week’s Nerdlog episode 3, check out the recap below. Finding anomalies with New Relic AIOps Throughout the day, lots of New Relic users put up anomaly detection to keep a general eye on the state of their system overall. In a quick demo, Devin shows how our anomalies feed can help give you a great overview of what’s happening within your system. You can slice and dice your anomalies by category, app name, time, configuration (groups of apps that you’ve configured to be monitored by Proactive Detection), and state. These capabilities are super powerful. By default, the detected anomalies are available within the New Relic interface. You can also send notifications to many integrations. For example, users like to send notifications to a private Slack channel to preview how anomaly detection would notify their teams as they configure the tool. Using AI to find correlated failures Managing alerts remains a challenge for teams as they grow. Nate Heinrich has been working for the last few months to improve the Incident Intelligence system within Applied Intelligence, an AIOps-assisted tool for showing how your alerts connect. Correlation is a fancy term for “things happening around the same time.” With these tools, you can use automation to find correlations, and configure correlations based on  your services’ attributes. This capability makes it easy to see things like “show me patterns from our services that are part of the infrastructure team” or “show me data that covers enterprise customers.” The correlation preview shows how multiple events would be correlated in future incidents. Toward the end of the segment, Nate ponders the future of AIOps: no system will get to full automation and diagnose every problem. But in the future, tools like Applied Intelligence will use their broad scope of data to give better and better clues, test hypotheses automatically, and make things easier for humans. Smart alert muting on New Relic It’s funny to get excited about muting, but Brian Goleno, a product manager in our Applied Intelligence group, makes a clear case for it: “Very often, teams have planned maintenance, or regular long-running jobs, that they know will trigger alerts that shouldn’t wake anyone up,” says Brian. Muting lets you set criteria, including a time window, for muting alerts and notifications. You can filter by tags or other attributes, finding only those violations that shouldn’t trigger alerts. Alerting doesn’t mean disabling monitoring: while this tool will stamp incidents with muted = true, they’ll still be visible in Applied Intelligence. This is helpful if an engineer is wondering why the service is down during maintenance: she can still see the Applied Intelligence notification, without getting paged for downtime during maintenance. Watch to see Brian go deep on giving your on-call engineers peace and quiet. Custom data visualizations Jewels Nocera, senior software engineer and fashion icon, shares how you can build custom New Relic One visualizations with our programmability tools. Starting with customizing dashboard charts, she shows how to add and remove attributes, scale charts, and otherwise tweak pre-made visualizations to make dashboards more readable. I’ve written before that your time to resolution is directly related to how easy it is to read your dashboard. The ability to carefully scale, scope, and control custom dashboards can improve by those critical minutes. In the second half of the segment, Jewels shows how our new feature for custom visualizations lets you fully customize the way your data is displayed. With a local development environment, you can build complete visualizations using your real New Relic data. Even better, you can create a configuration for your custom visualization. Other users within your team don’t have to update your code, but can use visual configuration toggles just like they do with custom dashboards. Related Topics AIOps By Nočnica Fee Nočnica Fee is a Dev Advocate for New Relic specializing in serverless. She's a frequent contributor to The New Stack and Dev.to. In her downtime, she enjoys drum machines and woodworking. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.40054,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Nerdlog Roundup: AIOps and <em>Customizing</em> <em>Your</em> Data",
        "sections": "<em>Custom</em> data <em>visualizations</em>",
        "body": " is displayed. With a local development environment, you can build complete visualizations using <em>your</em> real New Relic data. Even better, you can create a configuration for <em>your</em> <em>custom</em> <em>visualization</em>. Other users within <em>your</em> team don’t have to update <em>your</em> code, but can use <em>visual</em> configuration toggles just like"
      },
      "id": "607627f464441f73919d8566"
    },
    {
      "sections": [
        "Add custom visualizations to your dashboards",
        "Add a visualization to a dashboard",
        "Manage your dashboard visualizations"
      ],
      "title": "Add custom visualizations to your dashboards",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "d6c9973ef2c2547a99539d1da027b54db23af42c",
      "image": "https://docs.newrelic.com/static/5f7bd9c6a2a163d1f19c5c8b0d844d2f/c1b63/dashboard_viz.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/add-custom-visualizations-your-dashboards/",
      "published_at": "2021-04-17T03:06:30Z",
      "updated_at": "2021-03-16T11:03:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can build your own visualizations and add them to a dashboard. This gives you great flexibility around what you display on dashboards, from a company logo to custom queries from any data source. This visualization shows the number of people in each city who are viewing New Relic within an organization. The visualization was created using the New Relic One CLI and Treemap from the Recharts library. If you have full user permissions, which include the Nerdpack manager role, you can add a visualization to a dashboard as described in the following section. The process for creating a visualization is covered in the guide, Build a custom visualization for dashboards. Add a visualization to a dashboard You can add a visualization to a new or existing dashboard. From New Relic, in the top right, click the Apps button, and then on the Apps page, click Custom Visualizations. Hint: if you don't see the Custom Visualizations tile, use the search to locate it. In Custom Visualizations, select the visualization you want to add to a dashboard and then enable it. If there are configuration options, fill those in. The visualization will update with your changes. Click Add to dashboard and then select a dashboard from the list of available dashboards, or select New dashboard. If you decide to create a new dashboard, select the account where you want to run the dashboard, and give the dashboard a name. Click Add to dashboard, then click the link to your dashboard to see the custom visualization. Manage your dashboard visualizations Deleting: To remove a visualization from a dashboard, click the ellipses button in the right-hand corner of the visualization and click delete. Editing: If your visualization needs some tweaking, delete the visualization, then follow the steps above to re-add the visualization, making any updates in Custom Visualizations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.65801,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add <em>custom</em> <em>visualizations</em> to <em>your</em> dashboards",
        "sections": "Add <em>custom</em> <em>visualizations</em> to <em>your</em> dashboards",
        "tags": "Query <em>your</em> data",
        "body": "You can build <em>your</em> own visualizations and add them to a dashboard. This gives you great flexibility around what you display on dashboards, from a company logo to <em>custom</em> queries from any data source. This <em>visualization</em> shows the number of people in each city who are viewing New Relic within"
      },
      "id": "603ec4e628ccbc9409eba7ab"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/NR-Blog-Post-1-of-6.png",
      "url": "https://newrelic.com/blog/nerdlog/sumo-logic-webhook-machine-data-analytics",
      "sections": [
        "Unlocking Insights from Sumo Logic",
        "Step 1: Configure the New Relic webhook connection",
        "Step 2: Schedule a search to send custom events",
        "Step 3: Visualize events in New Relic Insights",
        "Learn more"
      ],
      "published_at": "2021-04-16T00:38:02Z",
      "title": "Integrating Machine Data Analytics in New Relic Insights via Sumo Logic Webhooks",
      "updated_at": "2021-04-13T23:50:37Z",
      "type": "",
      "external_id": "009df309f7ea2ce5a5585e4d97b3dd06dc2a1b28",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Nerdlog Integrating Machine Data Analytics in New Relic Insights via Sumo Logic Webhooks Jun 8, 2017 • 7 min read By Brian Bozzello Guest author Brian Bozzello is a product manager at Sumo Logic When Sumo Logic and New Relic announced a partnership at AWS re:Invent 2016, we immediately started hearing the excitement from our joint customers. The ability to combine the strengths of two leading SaaS services that offer fast time-to-value for monitoring and troubleshooting modern applications would offer a powerful and complete view of digital businesses, from the client down to the infrastructure. Today, we’re pleased to announce another advancement in our partnership: integrated machine data analytics with application and infrastructure performance data in New Relic Insights via a custom New Relic webhook built directly into Sumo Logic. Custom New Relic webhook in Sumo Logic Unlocking Insights from Sumo Logic Scheduled searches in Sumo Logic allow you to monitor and alert on key events occurring in your application and infrastructure. The flexibility of the query language allows you to pull just the information you need while fine-tuning the thresholds to trigger only when necessary. Combined with your New Relic APM and New Relic Infrastructure data in New Relic Insights, you’ll now be able to visualize information such as: Events: Service upgrades, exceptions, server restarts, for example Alerts: More than 10 errors seen in 5 minutes, for example, or failed login attempts exceeding 5 in 15 minutes KPIs: Count of errors by host, for example, or top 10 IPs by number of requests Integrating these insights into New Relic provides an integrated context for faster root cause analysis and reduced Mean Time to Resolution (MTTR), all within a single pane of glass. In just three simple steps, you’ll be able to leverage Sumo Logic webhooks to send data to New Relic. Step 1: Configure the New Relic webhook connection In New Relic Insights, you will first need to register an API key that will be used by the Sumo Logic webhook. These keys allow you to securely send custom events into New Relic from different data sources. Type in a short description to keep a record of how this API key will be used, then copy the Endpoint and Key for setup in Sumo Logic. API key In Sumo Logic, create a New Relic webhook connection and insert the Endpoint and Key into the URL and Insert Key fields. The payload field gives you the flexibility to customize the event for viewing in New Relic. In addition to the actual results, you can optionally specify metadata to provide additional context. For example, the name of the Sumo Logic search, a URL to that particular search, a description, and more. This payload can also be customized later when you schedule the search. Variables from your Sumo Logic search can be included in your payload for additional context in New Relic. Step 2: Schedule a search to send custom events After saving your New Relic webhook, you have the option to specify this as the destination for any scheduled search in Sumo Logic. The example below shows a query to look for “Invalid user” in our Linux logs every 15 minutes. To store and visualize this information in New Relic, we simply schedule a search, select the New Relic webhook that we configured in Step 1, and customize the payload with any additional information we want to include. This payload will send each result row from Sumo Logic as an individual event in New Relic. sumo logic query language Step 3: Visualize events in New Relic Insights Once the scheduled search has been saved and triggered, we can see the data populating in New Relic Insights and use the New Relic Query Language (NRQL) to create the visualizations we need. NRQL’s flexibility lets you tailor the data to your use case, and the visualization options make it seamless to place alongside your own New Relic data. In fact, you might not even notice the difference between the data sources—can you tell which data below is coming from New Relic, and which is coming from Sumo Logic? new relic sumo logic dashboard The ability to visualize application and infrastructure performance issues alongside insights from your logs reduces the need to pivot between tools, which can speed root cause analysis. If you’ve spotted an issue that requires a deeper analysis of your logs, you can jump right into a linked Sumo Logic dashboard or search to leverage machine learning and advanced analytics capabilities. Learn more Head over to Sumo Logic DocHub for more details on how to configure the New Relic webhook, then schedule some searches to send custom events to New Relic Insights. We’re excited to continue advancing this partnership, and we look forward to sharing more with you in the future. Stay tuned!   By Brian Bozzello Guest author Brian Bozzello is a product manager at Sumo Logic, the leading cloud-native, machine data analytics service. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.239975,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Step 1: <em>Configure</em> the New Relic webhook connection",
        "body": " webhook built directly into Sumo Logic. <em>Custom</em> New Relic webhook in Sumo Logic Unlocking Insights from Sumo Logic Scheduled searches in Sumo Logic allow you to monitor and alert on key events occurring in <em>your</em> application and infrastructure. The flexibility of the query language allows you to pull"
      },
      "id": "60762e4e196a67531f64a779"
    }
  ],
  "/build-apps/advanced-config": [
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/32r7lf1gmda1w/promo-image.1608575562.png",
      "url": "https://learn.newrelic.com/go-deeper-advanced-alerting-nrql-alerts",
      "sections": [
        "Delve deeper into Alerts and move beyond the basics to implement an effective alerting strategy in this FREE 2 hour workshop. With scenario based labs, you’ll create specific policies and conditions for typical use cases, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance s",
        "About this workshop",
        "Go Deeper: Advanced Alerting & NRQL Alerts"
      ],
      "published_at": "2021-04-20T01:39:15Z",
      "title": "[Webinar] Go Deeper: Advanced Alerting & NRQL Alerts",
      "updated_at": "2021-04-20T01:39:15Z",
      "type": "",
      "external_id": "a44bc2bed49a8b258b97a438df3e7a0bbcf7095a",
      "popularity": 1,
      "body": "Sign In [Webinar] Go Deeper: Advanced Alerting & NRQL Alerts Delve deeper into Alerts and move beyond the basics to implement an effective alerting strategy in this FREE 2 hour workshop. With scenario based labs, you’ll create specific policies and conditions for typical use cases, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios. Register | FREE Already registered? Sign In About this workshop You’ve mastered Alerting Fundamentals and want to know more about alerting? Join this highly practical and engaging session where we delve deeper into how to move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you, and get routed effectively to relevant teams or tools.   With scenario based labs, you’ll create specific policies and conditions for typical use cases across the full stack, use tags to dynamically target entities, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.  The format of this session will include best practices, challenge based labs and activities, and takeaways you can immediately apply to your accounts, or your requirements.  Agenda and Labs Effective Alerting strategies  SLO’s, SLA’s and Thresholds Use Cases and labs:  Alerting on SLA’s Alerting on variable performance -Dynamic Baseline Alerting Using tags to dynamically target Entities NRQL Alerts; Outlier detection, and other use cases Lab: Alert on Multiple issues (Static),  Lab: Alert on Synthetic performance (Dynamic),  Lab: Alert on Outlier behaviour (Outlier - Facets) Notifying the right team: Channels, Test Channels and Webhooks  Lab: Webhook Challenge Alerts and Dashboarding  Lab: Charting alerts Managing Alerts and Conditions REST API and Muting Rules Go Deeper: Advanced Alerting & NRQL Alerts Event Date Spaces left Go Deeper: Advanced Alerting & NRQL Alerts April 22, 2021, 10 a.m. - April 22, 2021, noon BST 125 Go Deeper: Advanced Alerting & NRQL Alerts April 27, 2021, 10 a.m. - April 27, 2021, noon PDT 125 Go Deeper: Advanced Alerting & NRQL Alerts May 27, 2021, 10 a.m. - May 27, 2021, noon BST 150 Go Deeper: Advanced Alerting & NRQL Alerts May 27, 2021, 10 a.m. - May 27, 2021, noon PDT 149 Go Deeper: Advanced Alerting & NRQL Alerts June 24, 2021, 10 a.m. - June 24, 2021, noon BST 149 Go Deeper: Advanced Alerting & NRQL Alerts June 29, 2021, 10 a.m. - June 29, 2021, noon PDT 150 About this workshop You’ve mastered Alerting Fundamentals and want to know more about alerting? Join this highly practical and engaging session where we delve deeper into how to move beyond basic alerts to implementing an effective alerting strategy, and create alerts which surface issues that are important to you, and get routed effectively to relevant teams or tools.   With scenario based labs, you’ll create specific policies and conditions for typical use cases across the full stack, use tags to dynamically target entities, leverage powerful NRQL alerts, and manage alerts for downtime or maintenance scenarios.  The format of this session will include best practices, challenge based labs and activities, and takeaways you can immediately apply to your accounts, or your requirements.  Agenda and Labs Effective Alerting strategies  SLO’s, SLA’s and Thresholds Use Cases and labs:  Alerting on SLA’s Alerting on variable performance -Dynamic Baseline Alerting Using tags to dynamically target Entities NRQL Alerts; Outlier detection, and other use cases Lab: Alert on Multiple issues (Static),  Lab: Alert on Synthetic performance (Dynamic),  Lab: Alert on Outlier behaviour (Outlier - Facets) Notifying the right team: Channels, Test Channels and Webhooks  Lab: Webhook Challenge Alerts and Dashboarding  Lab: Charting alerts Managing Alerts and Conditions REST API and Muting Rules Live events Go Deeper: Advanced Alerting & NRQL Alerts Event Date Spaces left Go Deeper: Advanced Alerting & NRQL Alerts April 22, 2021, 10 a.m. - April 22, 2021, noon BST 125 Go Deeper: Advanced Alerting & NRQL Alerts April 27, 2021, 10 a.m. - April 27, 2021, noon PDT 125 Go Deeper: Advanced Alerting & NRQL Alerts May 27, 2021, 10 a.m. - May 27, 2021, noon BST 150 Go Deeper: Advanced Alerting & NRQL Alerts May 27, 2021, 10 a.m. - May 27, 2021, noon PDT 149 Go Deeper: Advanced Alerting & NRQL Alerts June 24, 2021, 10 a.m. - June 24, 2021, noon BST 149 Go Deeper: Advanced Alerting & NRQL Alerts June 29, 2021, 10 a.m. - June 29, 2021, noon PDT 150 © 2021 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.220955,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "[Webinar] Go Deeper: <em>Advanced</em> Alerting &amp; NRQL Alerts",
        "sections": "Go Deeper: <em>Advanced</em> Alerting &amp; NRQL Alerts",
        "body": "Sign In [Webinar] Go Deeper: <em>Advanced</em> Alerting &amp; NRQL Alerts Delve deeper into Alerts and move beyond the basics to implement an effective alerting strategy in this FREE 2 hour workshop. With scenario based labs, you’ll create specific policies and conditions for typical use cases, leverage"
      },
      "id": "600789b728ccbc0c0a3f6fa8"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/programability_browser_analyze_1.jpg",
      "url": "https://newrelic.com/blog/nerdlog/new-relic-developers-guide-roundup",
      "sections": [
        "Intro to New Relic One SDK",
        "New Relic One CLI",
        "Intro to NerdStorageVault - New Feature!",
        "Create a \"Hello, World\" app",
        "Practice diagnosing common issues using New Relic",
        "Get coding and get inspired",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:23:24Z",
      "title": "New Relic Developers Guide Roundup",
      "updated_at": "2021-04-13T23:23:31Z",
      "type": "",
      "external_id": "9322d4fbb3dbbeb84cc7c3f26c9cc2c275e3a11d",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic New Relic Developers Guide Roundup Jan 5, 2021 • 7 min read By Vi Tran When we first launched our programmable platform, one of our executives envisioned a simple way to visualize customer experience and satisfaction scores. He sent the following sketch to an engineer: Two days later, he had a production-ready application, built on New Relic One, that showed not just what the customer experience scores were, but what they should be. The browser analyzer application This New Relic One application is called the browser analyzer—it’s open source and available for you to use today. But now it’s your turn to go from sketch to app. We’ve given you the same tools our own engineers use, so you can build and deploy applications in New Relic One that connect your observability data, gathered from myriad sources—including third-party open source data—all in one place. At New Relic Developers, we’ve created dozens of guides and tutorials to inspire New Relic customers with these tools. In fact, here’s a roundup of five guides you definitely don’t want to miss. Intro to New Relic One SDK The New Relic One SDK provides the necessary components you need to build New Relic One applications. Components of the SDK include: React UI components for controlling text and layout in a New Relic One application Chart components for representing different types of charts Query and storage components for fetching and storing New Relic data Platform APIs that enable your application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set configurations, and more. In all, the SDK provides everything you need to build your applications, create visualizations, and fetch New Relic or third-party data. New Relic One CLI In addition to the SDK, you’ll need the New Relic One CLI to build apps on the platform. You’ll use the CLI to build, publish, and manage your app. More specifically, you’ll use the CLI to do the following: Generate Nerdpack/Nerdlet templates—(a Nerdpack is a package containing all the files needed by an application; a Nerdlet is a specific UI view in an app, represented by a React JavaScript package) Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Intro to NerdStorageVault - New Feature! When you build applications using the New Relic One SDK, you’ll need a secure place to store your data. NerdStorageVault lets you store and retrieve sensitive data secrets such as: Personal access tokens License keys API keys Other third-party secrets You can explore NerdStorageVault fields and response types with the NerdGraph API explorer. NerdStorageVault is encrypted with AES-256 encryption. In order to persist changes to NerdStorageVault, such as writing, deleting, and fetching data, you must have a user role with permission to persist changes. Check out the guide for more information. Create a \"Hello, World\" app In this guide, you’ll build a \"Hello, World!\" application in New Relic One in nine quick steps. You’ll create a local version of the New Relic One site where you can prototype your application, and when you're ready to share the application with others, you can publish it to New Relic One. [embed]https://www.youtube.com/watch?v=7omo0qHxku8&feature=youtu.be[/embed] To get started, make sure you have accounts in GitHub and New Relic. You’ll also need to install Node.js and familiarize yourself with the New Relic One CLI. Tip: Check out Set up your development environment to make sure you have everything in order before you jump in. Practice diagnosing common issues using New Relic Every time you deploy an application, you hope that it's efficient and free of errors. The reality, however, is usually quite different. You might introduce a bug in a release, overlook an edge case, or find a broken dependency. All of which can lead to a poor user experience. In this guide, you’ll use our open source demo-deployer to spin up the infrastructure for Acme Telco Lite, a fictional company, and simulate real-world issues in a controlled demo environment. Acme Telco Lite is a telecom business that maintains an e-commerce website for its customers. The site's architecture has eight interconnected microservices, plus a simulator: The simulator isn't part of the Telco Lite infrastructure, but it is part of the demo deployment. It runs scenarios against the application to create web traffic and generate interesting data in New Relic. For this guide, you can choose between Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform (GCP) to host your deployment. Check out the full guide for more on prerequisites and deployment details. Get coding and get inspired Explore more guides and tutorials on New Relic Developers, because we’re constantly adding content. Best of all? The site is built completely in open source—feel free to submit a pull request while you’re there. Related Topics Extend New Relic By Vi Tran Vi Tran is a Senior Product Marketing Manager for Developer Ecosystem at New Relic. Her focus is on growing and enabling the developer ecosystem to extend New Relic One. Before New Relic, she was on the global strategic alliances team at Splunk and was a management consultant at Accenture. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.19056,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " components for fetching and storing New Relic data Platform APIs that <em>enable</em> <em>your</em> application to interact with different parts of the New Relic One platform to read and write state from and to a URL, set <em>configurations</em>, and more. In all, the SDK provides everything you need to build <em>your</em> applications"
      },
      "id": "607627f464441f7e2b9d8537"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/New-Relic-One-Catalog.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-5",
      "sections": [
        "Subscribe to applications with the New Relic One Catalog",
        "Observability Maps",
        "Metric Aggregator",
        "Workload Geo Ops",
        "Check out these other resources for using—and building—New Relic One applications ",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "The Most Popular New Relic One Applications (Roundup #5)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "75f80d867fec167c4a6d62082f32cb2ff1ae0802",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #5) Jun 4, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Observability Maps Metric Aggregator Workload Geo Ops Subscribe to applications with the New Relic One Catalog Before we start accessing the applications via the CLI, let’s look at how to access these applications directly within New Relic One. To explore available applications, navigate to New Relic One and click on the New Relic One Catalog launcher. New Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. New Relic One Catalog If you deploy an application from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Observability Maps Observability Maps allows you to create a view beyond a traditional service map. Using Observability Maps, you can connect disparate entities in your environment into ad hoc relationships, creating your own relationships based on data available in New Relic. See your entities and environment in a way that makes the most sense to your team and business. Observability Maps App Fork or deploy the Observability Maps app from GitHub. Specific requirements for this app Requires data in NRDB from any or all of the New Relic products. Metric Aggregator The Metric Aggregator is a New Relic One application that helps you create events-to-metrics (E2M) rules, a real-time streaming service that converts event data into dimensional metrics at ingest. Converting events to metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Metric Aggregator App Fork or deploy the Metric Aggregator app from GitHub. Specific requirements for this app If you use New Relic, you already have New Relic Metrics. You can  create E2M rules immediately. Workload Geo Ops Workload Geo Ops links your workloads (collections of entities) to physical locations so you can quickly identify and resolve incidents. It's a geographic exploration of workload data tied to geographic data, including location metadata. You can define maps and then collect or assign entities to points on those maps. With workloads, a collection of entities can be managed by rules and tags to support the dynamic, ephemeral nature of modern IT infrastructure. Fork or deploy the Workload Geo Ops app from GitHub. Specific requirements for this app To get the most of this app, we recommend that you configure Workloads in New Relic One. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Workload Geo Ops to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One applications  Here are resources to help you build your own New Relic One applications. If you can imagine it, you can build it:  developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. NerdGraph GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity. Application/data access and permissions and security. NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.68704,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Check out these other resources <em>for</em> using—and building—New Relic One applications ",
        "body": " Relic One Catalog launcher From there, you can access all our global applications. If you’re a <em>Nerdpack</em> Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If <em>your</em> team changes, and you need"
      },
      "id": "60762e1f64441fbf2e9d856e"
    },
    {
      "sections": [
        "AWS Lambda for sending CloudWatch logs",
        "Requirements",
        "Install and configure the Cloudwatch logs Lambda function",
        "Tip",
        "Create a Lambda trigger",
        "Configure retries (optional)",
        "Resources created by the SAM template",
        "View log data",
        "What's next?"
      ],
      "title": "AWS Lambda for sending CloudWatch logs",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "7e097c6c48cd7e02d55ed7ce2c63982ba003b1d5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/enable-log-management-new-relic/enable-log-monitoring-new-relic/aws-lambda-sending-cloudwatch-logs/",
      "published_at": "2021-04-16T03:34:20Z",
      "updated_at": "2021-04-16T03:34:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can send your CloudWatch logs to New Relic using our AWS Lambda function, newrelic-log-ingestion, which can be easily deployed from the AWS Serverless application repository. Requirements To use our CloudWatch logs Lambda function, you only need a New Relic license key. Install and configure the Cloudwatch logs Lambda function Tip The following setup shows one approach to configuring environment variables. You can also configure them from the Functions page. Complete the following: Open the AWS Serverless Application Repository in your browser. Search for newrelic and check Show apps that create custom IAM roles or resource policies to find newrelic-log-ingestion. Open the newrelic-log-ingestion details and click Deploy. Scroll to the Application settings and configure log forwarding using the following environment variables: Key Description Value DEBUG_LOGGING_ENABLED A boolean to determine if you want to output debug messages in the CloudWatch console. Optional. To turn on debug logs, set this to true. By default, it is false. LICENSE_KEY New Relic License key is used for sending data to New Relic Infrastructure and Logs. Required. Your New Relic license key. LOGGING_ENABLED Determines if logs are forwarded to New Relic. Required. To turn on logging, set this to true. NR_LOGGING_ENDPOINT New Relic ingestion endpoint for Logs. Required. Two endpoints are available: US: https://log-api.newrelic.com/log/v1 EU: https://log-api.eu.newrelic.com/log/v1 NR_TAGS Specify tags to be added to all log events. Optional. Each tag is composed of a colon delimited key and value. Multiple key-value pairs are semi-colon delimited, for example, env:prod;team:myTeam Acknowledge that the app creates custom IAM roles and then click Deploy. Once the process completes, follow the steps below in Create a Lambda trigger to link your Lambda function to CloudWatch Logs. Create a Lambda trigger To get your logs streaming to New Relic you will need to attach a trigger to the Lambda: From the left side menu, select Functions. Find and select the previously created newrelic-log-ingestion function. Under Designer, click Add Triggers, and select Cloudwatch Logs from the dropdown. Select the the appropriate Log group for your application. Enter a name for your filter. Optional: Enter a filter pattern. Check the Enable trigger checkbox, then click Add to create the trigger. Configure retries (optional) You can configure the number of retries you want to perform in case the function fails to send the data in case of communication issues. Recommended number is 3 retries, but you can change the retry behavior by changing the below parameters: Tip Be aware that more number of retries can make the function run for longer time and therefore increases the probability of having higher costs for Lambda. On the contrary, decreasing the number of retries could increase the probability of data loss. MAX_RETRIES = 3 # Defines the number of retries after lambda failure to deliver data INITIAL_BACKOFF = 1 # Defines the initial wait seconds until next retry is executed BACKOFF_MULTIPLIER = 2 # Time multiplier between the retries As an example, in default above configuration, first retry will happen after 1 second, second retry after 2 seconds and third retry will happen after 4 seconds. Copy Resources created by the SAM template There are few resources that will be created when you create the application from the repository: The Lambda function itself A Role used to give execution permissions to the Lambda function based in CloudWatch Logs. All other lambda configurations not listed in the steps above can be left as the defaults. View log data If everything is configured correctly and your data is being collected, you should see data logs in both of these places: New Relic Logs UI New Relic tools for running NRQL queries. For example, you can execute a query like this: SELECT * FROM Log Copy What's next? Now that you've enabled Logs, here are some potential next steps: Explore your data using the Logs UI. Configure your agent to see contextual log data, such as distributed tracing, stack traces, application logs, and more. Query your data and create custom dashboards or alerts. If no data appears after you enable log management, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.36867,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "AWS Lambda <em>for</em> sending CloudWatch logs",
        "sections": "Install and <em>configure</em> the Cloudwatch logs Lambda function",
        "tags": "<em>Enable</em> log management in New Relic",
        "body": " function. Under Designer, click Add Triggers, and select Cloudwatch Logs from the dropdown. Select the the appropriate Log group for <em>your</em> application. Enter a name for <em>your</em> filter. Optional: Enter a filter pattern. Check the <em>Enable</em> trigger checkbox, then click Add to create the trigger. Configure"
      },
      "id": "603ea6bb28ccbc228deba74c"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/attributory-screenshot-main.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-6",
      "sections": [
        "Subscribe to apps in the New Relic One Catalog",
        "Flex Manager",
        "GraphiQL Notebook",
        "Attributory",
        "What are you waiting for? Deploy these apps now.",
        "Check out these other resources for using—and building—New Relic One apps",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:26:51Z",
      "title": "The Most Popular New Relic One Applications (Roundup #6)",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "76394d24aebbff40a68e9bd6a7f867313e814d74",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #6) Jul 2, 2020 • 8 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the visibility and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source, so you can use them out-of-the-box, or submit a pull request for feedback and feature requests. In this edition, we cover three apps that help engineers do their jobs: Flex Manager GraphiQL Notebook Attributory Subscribe to apps in the New Relic One Catalog You can manage and deploy apps directly within New Relic One. To explore available apps, navigate to New Relic One and click on the New Relic One Catalog launcher. From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. If you deploy an app from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Flex Manager New Relic Flex is an application-agnostic, all-in-one tool that makes sending data to New Relic from third party sources easier than ever. Use Flex Manager to simplify the work of creating, managing, and deploying new integrations you’ve built with Flex. Fork or deploy the Flex Manager app from GitHub. Specific requirements for this app Flex Manager requires New Relic Infrastructure and the Flex integration. GraphiQL Notebook GraphiQL Notebook allows you to explore and learn about the NerdGraph—the New Relic GraphQL API—using a Jupyter Notebook style interface. Notebooks intermix GraphQL requests with data exploration links. You can create, update, save, and delete notebooks. You can also export and share notebooks as blocks of Base64-encoded JSON. Fork or deploy the GraphQL Notebook app from GitHub. Attributory Attributory is a dictionary of attributes from your APM, Browser, or Mobile applications stored in New Relic. It displays a list of attributes for each application. When you open a service or application from the entity explorer, you’ll find Attributes Dictionary listed as an application in the left-hand navigation. New Relic stores event data as key-value pairs. Built-in New Relic attributes include the definition of the attribute. For custom attributes, you can choose to add your own definitions. Fork or deploy the Attributory app from GitHub. Specific requirements for this app Applications with New Relic APM, Browser, or Mobile agents reporting into New Relic. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account Once you have these requirements in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Attributory to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One apps Here are resources to help you build your own New Relic One apps. If you can imagine it, you can build it: New Relic Developers: Build applications using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Open Source: New Relic’s open source website makes it easy for you to explore the open source projects we maintain and the open standards projects we participate in. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, review our Contributors Guide. Keep in mind that when you submit your Pull Request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.213295,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "What are you waiting <em>for</em>? Deploy these apps now.",
        "body": " Catalog launcher. From there, you can access all our global applications. If you’re a <em>Nerdpack</em> Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If <em>your</em> team changes, and you need to remove"
      },
      "id": "60762e1e28ccbcb5fd51c147"
    }
  ],
  "/build-apps/publish-deploy/serve": [
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/New-Relic-One-Catalog.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-5",
      "sections": [
        "Subscribe to applications with the New Relic One Catalog",
        "Observability Maps",
        "Metric Aggregator",
        "Workload Geo Ops",
        "Check out these other resources for using—and building—New Relic One applications ",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:27:10Z",
      "title": "The Most Popular New Relic One Applications (Roundup #5)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "75f80d867fec167c4a6d62082f32cb2ff1ae0802",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #5) Jun 4, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the insights and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Observability Maps Metric Aggregator Workload Geo Ops Subscribe to applications with the New Relic One Catalog Before we start accessing the applications via the CLI, let’s look at how to access these applications directly within New Relic One. To explore available applications, navigate to New Relic One and click on the New Relic One Catalog launcher. New Relic One Catalog launcher From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. New Relic One Catalog If you deploy an application from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Observability Maps Observability Maps allows you to create a view beyond a traditional service map. Using Observability Maps, you can connect disparate entities in your environment into ad hoc relationships, creating your own relationships based on data available in New Relic. See your entities and environment in a way that makes the most sense to your team and business. Observability Maps App Fork or deploy the Observability Maps app from GitHub. Specific requirements for this app Requires data in NRDB from any or all of the New Relic products. Metric Aggregator The Metric Aggregator is a New Relic One application that helps you create events-to-metrics (E2M) rules, a real-time streaming service that converts event data into dimensional metrics at ingest. Converting events to metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Metric Aggregator App Fork or deploy the Metric Aggregator app from GitHub. Specific requirements for this app If you use New Relic, you already have New Relic Metrics. You can  create E2M rules immediately. Workload Geo Ops Workload Geo Ops links your workloads (collections of entities) to physical locations so you can quickly identify and resolve incidents. It's a geographic exploration of workload data tied to geographic data, including location metadata. You can define maps and then collect or assign entities to points on those maps. With workloads, a collection of entities can be managed by rules and tags to support the dynamic, ephemeral nature of modern IT infrastructure. Fork or deploy the Workload Geo Ops app from GitHub. Specific requirements for this app To get the most of this app, we recommend that you configure Workloads in New Relic One. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Workload Geo Ops to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-workload-geoops.git cd nr1-workload-geoops nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One applications  Here are resources to help you build your own New Relic One applications. If you can imagine it, you can build it:  developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. NerdGraph GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity. Application/data access and permissions and security. NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.04823,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " these requirements in place, deploying an application locally—in this example, Workload Geo Ops—is as easy as running a few commands: nr1 <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;nr1-workload-geoops.git cd nr1-workload-geoops nr1 <em>nerdpack:serve</em> Or you could download, configure, and deploy an account"
      },
      "id": "60762e1f64441fbf2e9d856e"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/attributory-screenshot-main.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-6",
      "sections": [
        "Subscribe to apps in the New Relic One Catalog",
        "Flex Manager",
        "GraphiQL Notebook",
        "Attributory",
        "What are you waiting for? Deploy these apps now.",
        "Check out these other resources for using—and building—New Relic One apps",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:26:51Z",
      "title": "The Most Popular New Relic One Applications (Roundup #6)",
      "updated_at": "2021-04-13T23:49:49Z",
      "type": "",
      "external_id": "76394d24aebbff40a68e9bd6a7f867313e814d74",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #6) Jul 2, 2020 • 8 min read By Joel Worrall Every company’s technology stack is different, and every company needs unique views of the data generated by their apps and systems. You can build and deploy custom apps on New Relic One that give you the visibility and information your company needs to connect data from any source with your specific business requirements. To show you what’s possible—and to inspire you to create your own apps—we’re sharing some of the open source apps developers have built on our platform. In this blog series, we highlight the most popular apps available. The best part: They’re all open source, so you can use them out-of-the-box, or submit a pull request for feedback and feature requests. In this edition, we cover three apps that help engineers do their jobs: Flex Manager GraphiQL Notebook Attributory Subscribe to apps in the New Relic One Catalog You can manage and deploy apps directly within New Relic One. To explore available apps, navigate to New Relic One and click on the New Relic One Catalog launcher. From there, you can access all our global applications. If you’re a Nerdpack Manager, you’ll be able to subscribe applications to accounts and subaccounts. Click Add the app to add the application to the account you wish to grant access. If your team changes, and you need to remove access, you can unsubscribe applications from accounts directly within New Relic One. If you deploy an app from the catalog, you can use it with only its out-of-the-box capabilities. If you want to customize an app, you’ll need to deploy it through the CLI. We’ll explain that process below. Flex Manager New Relic Flex is an application-agnostic, all-in-one tool that makes sending data to New Relic from third party sources easier than ever. Use Flex Manager to simplify the work of creating, managing, and deploying new integrations you’ve built with Flex. Fork or deploy the Flex Manager app from GitHub. Specific requirements for this app Flex Manager requires New Relic Infrastructure and the Flex integration. GraphiQL Notebook GraphiQL Notebook allows you to explore and learn about the NerdGraph—the New Relic GraphQL API—using a Jupyter Notebook style interface. Notebooks intermix GraphQL requests with data exploration links. You can create, update, save, and delete notebooks. You can also export and share notebooks as blocks of Base64-encoded JSON. Fork or deploy the GraphQL Notebook app from GitHub. Attributory Attributory is a dictionary of attributes from your APM, Browser, or Mobile applications stored in New Relic. It displays a list of attributes for each application. When you open a service or application from the entity explorer, you’ll find Attributes Dictionary listed as an application in the left-hand navigation. New Relic stores event data as key-value pairs. Built-in New Relic attributes include the definition of the attribute. For custom attributes, you can choose to add your own definitions. Fork or deploy the Attributory app from GitHub. Specific requirements for this app Applications with New Relic APM, Browser, or Mobile agents reporting into New Relic. What are you waiting for? Deploy these apps now. To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key Node v10 or higher A GitHub account Once you have these requirements in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Attributory to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-attributory.git cd nr1-attributory nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building—New Relic One apps Here are resources to help you build your own New Relic One apps. If you can imagine it, you can build it: New Relic Developers: Build applications using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. New Relic Open Source: New Relic’s open source website makes it easy for you to explore the open source projects we maintain and the open standards projects we participate in. New Relic Developer Toolkit: a suite of tools expressly built to ease the configuration, management, and usage of New Relic through automation. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications. Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, review our Contributors Guide. Keep in mind that when you submit your Pull Request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.04817,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " in place, deploying an app locally—in this example, Attributory—is as easy as running a few commands: nr1 <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;nr1-attributory.git cd nr1-attributory nr1 <em>nerdpack:serve</em> Or you could download, configure, and deploy an account-specific instance of Attributory"
      },
      "id": "60762e1e28ccbcb5fd51c147"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/DEPLOYMENT-ANALYZER-SCREENSHOT-1.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-3",
      "sections": [
        "Container Explorer",
        "Specific requirements for this app",
        "Deployment Analyzer",
        "Page View Map",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-16T04:25:05Z",
      "title": "Most Popular New Relic One Applications (Round up #3)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "6f0be6c93ebcc052fac27513c1e849c0dfd256e8",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic Most Popular New Relic One Applications (Round up #3) Nov 26, 2019 • 7 min read By Joel Worrall Hopefully, you’ve heard the news that the New Relic One observability platform is now programmable. As central component of an observability platform, we believe programmability gives you the ability to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the possibilities—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications … and then we kept going. In fact, new apps are coming in every day. And we hope to see app contributions by New Relic users continue. This blog series is our opportunity to spotlight the most popular apps available today from our GitHub repository. The best part: Every app is available under an open source license and can be deployed right now! In this edition, we cover: Container Explorer Deployment Analyzer Page View Map Container Explorer This app includes a launcher that gives you a global view of all containers associated with an account. You can also employ tags to segment and drill down into subsets of your global container inventory. The app also presents container CPU, memory, and disk I/O usage in the form of intuitive and efficient heat map visualizations. Container Explorer presents CPU, memory, and disk I/O usage for all containers associated with an account—displaying this data via intuitive and efficient heat map visualizations. In the New Relic One entity explorer, we provide a nerdlet that will show all of the containers that are running for a selected APM application (service). We can also detect whether infrastructure data is coming from third-party sources and can, if necessary, automatically present this container telemetry in-context. Container Explorer can detect whether infrastructure data is coming from third-party sources—and can, if necessary, automatically ingest and present this container telemetry in-context. Clicking on a node in the heatmap reveals details about that container, and you can also jump to its host in the entity explorer. Clicking on a node in the Container Explorer heatmap reveals details about that container, and users can also jump to its host in the entity explorer. Fork or deploy the Container Explorer app from GitHub. Specific requirements for this app The New Relic Infrastructure agent must be deployed on any host you want to monitor. Note: We generate per-container CPU and other metrics by summarizing all processes in a given containerId. This will, however, report an accurate value only if the agent reports one ProcessSample per process every 30 seconds. Deployment Analyzer Deployments of applications can be risky events, but you can correlate those events to the performance of your applications, using deployment markers in New Relic. This app builds further on this process—enabling teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Deployment Analyzer enables teams to visualize application deployments across an enterprise environment, based on APM deployment marker data. Fork or deploy the Deployment Analyzer app from GitHub. Specific requirements for this app You'll need an active New Relic APM Pro subscription in order to access deployment marker functionality. Page View Map This app creates geographic visualizations of New Relic Browser application data using the React Leaflet mapping library. Leaflet is a leading open-source JavaScript library for mobile-friendly interactive maps. In addition to providing a new way to visualize your business data, this app offers a great example of what's possible for developers working with our GraphQL service and a third party library. Page View Map creates geographic visualizations of New Relic Browser application data Fork or deploy the Page Views Map app from GitHub Specific requirements for this app You must have the New Relic Browser Agent(s) installed, as well as related access to New Relic One. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer.git cd nr1-container-explorer nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Container Explorer to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-container-explorer cd nr1-container-explorer nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app's launcher (unless otherwise noted above). Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications: New Relic Developer Edition: Early access to the Developer Edition of New Relic One gives you a free, personal sandbox account where you can build your own experience with all the available New Relic tools. developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome contributions to any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series.   Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.35837,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " you have these requirements in place, deploying an application locally—in this example, Container Explorer—is as easy as running a few commands: nr1 <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;nr1-container-explorer.git cd nr1-container-explorer nr1 <em>nerdpack:serve</em> Or you could download, configure"
      },
      "id": "60762e1f196a673d0a64a782"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/Event-Stream-Screenshot.jpg",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-applications-4",
      "sections": [
        "Event Stream",
        "Specific requirements for this app",
        "Neon",
        "Network Telemetry",
        "SLO/R",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:39:54Z",
      "title": "The Most Popular New Relic One Applications (Roundup #4)",
      "updated_at": "2021-04-13T23:49:51Z",
      "type": "",
      "external_id": "0ac60d545488f3c1904bdd6e0d552af5c307ee5a",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Roundup #4) Jan 9, 2020 • 6 min read By Joel Worrall Every company’s technology stack is different, and every company needs different types and combinations of insights into how their apps and systems are performing. That’s why New Relic One is programmable—you can build and deploy custom apps that give you the specific insights and information your company needs. To show you what’s possible—and to inspire you to create apps—we worked with members of the New Relic community to build a handful of open source applications, and the number of newly-developed apps continues to grow. In this blog series, we highlight the most popular apps available. The best part: They’re all open source and ready to be deployed. In this edition, we cover: Event Stream Neon Network Telemetry SLO/R Event Stream During a launch or incident, you need the absolute latest data from your application. Event Stream is like Unix tail for APM data—it pulls in your Transaction and TransactionError data in a live stream, so you can find out exactly what's happening with your app right at that moment. You can also filter and facet the data to show the exact data you need. New Relic One Application Event Stream Fork or deploy the Event Stream app from GitHub. Specific requirements for this app Install the appropriate New Relic APM agent. Neon Need to create a single dashboard to track the health of entire business units or regions? Neon lets you create a status board based on New Relic alerts or the values from New Relic events. Fork or deploy the Neon app from GitHub. Specific requirements for this app To view the status of New Relic alerts, you’ll need to set up a webhook notification channel for the alert policies. See the New Relic documentation to learn more about managing notification channels. Network Telemetry Network Telemetry Screenshot The Network Telemetry app visualizes data collected through the Network Telemetry Infrastructure integration. The integration collects data from network devices that export Sflow or IPFIX network samples, and the app creates visualizations to help you examine the sources and destinations of communication within a network, as well as the volume of traffic between devices. Fork or deploy Network Telemetry from GitHub. Specific requirements for this app Install the New Relic Infrastructure agent, and ensure you have the related access to New Relic One. Install the New Relic Network Telemetry On-host integration.  SLO/R SLO/R Screenshot The SLO/R app calculates service-level objective (SLO) attainment for an application service. It allows you to quickly define SLOs for error, availability, capacity, and latency conditions. By measuring SLO attainment across your service estate, you'll be able to determine what signals are most important for a given service or set of services, developed and supported by a team, organization, or group. Using New Relic as a consistent basis to define and measure your SLOs offers better insight into comparative SLO attainment in your service delivery organization. Note: SLO/R is intended to work with services reporting to New Relic via an APM agent. The service provides an entity upon which to define SLOs. Error budget SLOs are defined directly from APM Transaction events; the other SLO types are defined using New Relic alerts. See \"Creating a webhook to forward Alert incidents to Insights\" for more details. Fork or deploy the SLO/R app from GitHub. Specific requirements for this app Install the appropriate New Relic APM agents. Create a New Relic alerts webhook to forward alert events to a SLOR_ALERTS New Relic database table. See \"Creating a webhook to forward Alert incidents to Insights\" for details. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Event Stream—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-event-stream.git cd nr1-event-stream nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Event Stream to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-event-stream.git cd nr1-event-stream   nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app’s launcher. Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications. If you can imagine it, you can build it: developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome open source application contributions. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you’ll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.35837,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "—in this example, Event Stream—is as easy as running a few commands: nr1 <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;nr1-event-stream.git cd nr1-event-stream nr1 <em>nerdpack:serve</em> Or you could download, configure, and deploy an account-specific instance of Event Stream to your New Relic account using"
      },
      "id": "60762e2028ccbcaf8651c17c"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/GitHub-screenshot_02-1024x724.png",
      "url": "https://newrelic.com/blog/how-to-relic/most-popular-new-relic-one-apps-2",
      "sections": [
        "Status Page",
        "Specific requirements for this app",
        "GitHub Integration",
        "Agent Groundskeeper",
        "Customer Journey",
        "What are you waiting for? Deploy these apps now!",
        "Check out these other resources for using—and building!—New Relic One applications",
        "Contribute to these open source projects",
        "Related Topics"
      ],
      "published_at": "2021-04-15T23:49:01Z",
      "title": "The Most Popular New Relic One Applications (Round up #2)",
      "updated_at": "2021-04-13T23:49:52Z",
      "type": "",
      "external_id": "c03e99006d6ecc7b6219a2bc68dd0428450cdf26",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit Extend New Relic The Most Popular New Relic One Applications (Round up #2) Nov 7, 2019 • 8 min read By Joel Worrall We hope you've heard the news that the New Relic One observability platform is now programmable. As the central component of an observability platform, we believe programmability gives you the ability to connect your observability data to your business, so you can make data-driven decisions—on your terms. To that end, New Relic One gives you the same tools our own engineers use to build the curated experiences you know and love. With these tools, you can build and deploy custom applications on New Relic One that connect your observability data, gathered from myriad sources—including third-party open-source data—all in one place. To show you the art of the possible—and to inspire your own app creations—we worked with members of the New Relic community to build a handful of open source applications … and then we (and all of you!) kept going. In fact, new apps are coming in every day. And we hope to see app contributions by New Relic users continue. In this blog series, we’ll highlight the most popular apps available today. The best part: They’re all open source and ready to be deployed right now! In this edition, we cover: Status Pages GitHub Integration Groundskeeper Customer Journey Status Page Status Page aggregates system status and incident summaries, Statuspage.io style, from multiple providers within a single dashboard. Normally, this is information you’d track down one provider at a time, but Status Page makes it easy to check the status of your key dependencies in one place, at a single glance. Status Page brings together system status and incident report data from key dependencies—making it accessible to your team instantly and easily. Fork or deploy the Status Pages app from GitHub. Specific requirements for this app All you need to get up and running are some status pages you’d like to monitor. Popular options include: New Relic BitBucket Google Cloud Platform GitHub Jira Software Also, keep in mind that currently Status Page can pull in data only from status modules backed by Statuspage.io and Google Status pages. GitHub Integration Having the right information at your fingertips makes a big difference when you’re under the gun to understand a service and resolve an incident. The GitHub Integration connects your New Relic One apps and services to the repos containing relevant documentation, readme files, runbooks, and other essential information. Associate any service or application with its GitHub repository as a one-time action, and you can quickly see that application's readme file, as well as a list of active source code contributors. The GitHub Integration gives you quick access to the documentation for an app or service, including relevant readme files. GitHub Integration also displays a list of the most active contributors to a project, giving you easier access to additional problem-solving resources. Using the GitHub Integration involves a simple, one-time association between any service or application, and its repository. You'll also need to create or use a personal access token, as a one-time setup step, to ensure data security and integrity. Fork or deploy the GitHub Integration app from GitHub. Note: Integration with GitHub requires that you create or use a private access token as a one-time setup step. See GitHub's doc on access tokens for full instructions. Specific requirements for this app A GitHub (either public or private enterprise instance) organization and access to New Relic One. The ability to generate a personal access token in GitHub. Agent Groundskeeper Agent Groundskeeper displays real-time version information for the New Relic APM agents running across your software estate. See which services are up to date (with various upgrade SLO time windows), which are out of date, and which have instances deployed with different versions. Quickly and easily zoom in on your estate by filtering on tags, and search by account, language, and app name. Agent Groundskeeper gives you real-time version information for every APM agent running anywhere within an enterprise environment. Fork or deploy the Agent Groundskeeper app from GitHub. Specific requirements for this app New Relic APM Agent(s) installed and the related access to New Relic One. (Recommended) Add customer-defined labels to your APM applications to make use of New Relic One tag filtering. See our documentation here. Customer Journey Think of this app sort of as a NRQL funnel query on steroids. This application is designed to allow devops teams, product managers, and digital marketers to examine a number of pre-defined measures in a side-by-side comparison between cohorts (columns) of users through a set of steps (rows) where ... Rows equal Steps in a workflow Columns categorize a Series or cohort of users Measures define the Stats that you want to observe for each Series and Step The application employs three visualizations to examine, compare, and present its results: Multi-series Funnel: This visualization combines a third-party funnel library with the New Relic One NerdGraph query to execute three New Relic NRQL queries in the same GraphQL request. The results are aligned into one data set that is delivered to the funnel visualization. Data panels: For each row (Step) and column (Series), the app renders a set of measurements (Stat). Those calculations can apply KPI thresholds to color-code the information. Each panel is also clickable, leading to a more detailed overview. Detail Nerdlet: For any Journey, Series, and Step, there's a Nerdlet that will display the more detailed KPIs as well as a timeseries view of the the given Stats for the selected row and column. Customer Journey can apply KPI thresholds to color-code important information. Each panel is also clickable, leading to a more detailed overview.   A Nerdlet will display more detailed KPIs as well as a timeseries view of the given Stats for a selected row and column. Fork or deploy Customer Journey from GitHub. Specific requirements for this app Access to New Relic One. Configuring the journeyConfig.js. What are you waiting for? Deploy these apps now! To deploy any of these apps you need: Access to New Relic One (Requires a paid New Relic account and use of a supported browser) The New Relic One CLI A personal New Relic API key  Node v10 or higher A GitHub account  Once you have these requirements in place, deploying an application locally—in this example, Status Pages—is as easy as running a few commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-status-pages.git cd nr1-status-pages nr1 nerdpack:serve Or you could download, configure, and deploy an account-specific instance of Status Pages to your New Relic account using the following commands: nr1 nerdpack:clone -r https://github.com/newrelic/nr1-status-pages cd nr1-status-pages nr1 nerdpack:publish nr1 nerdpack:deploy -c STABLE nr1 nerdpack:subscribe -c STABLE Then go to the homepage of one.newrelic.com and select the app's launcher (unless otherwise noted above). Check out these other resources for using—and building!—New Relic One applications While we’d love you to use any of the applications we’ve built, we also created plenty of resources to help you build your own New Relic One applications: New Relic Developer Edition: Early access to the Developer Edition of New Relic One gives you a free, personal sandbox account where you can build your own experience with all the available New Relic tools. developer.newrelic.com: Build applications in minutes using our CLI and SDK. Review our library of React components for designing interfaces, charting data, and fetching data from our GraphQL API. GraphQL Explorer: Explore your data using our GraphQL API. New Relic documentation: Learn more about: The Nerdpack file structure, including how to link your application with an entity Application/data access and permissions and security NR1 Workshop: a step-by-step, self-paced, open source training experience, designed to introduce you to the New Relic One CLI and SDK. New Relic Explorers Hub: Community posts and questions about using and building New Relic One applications [embed]https://www.youtube.com/watch?v=FhEwaZuY81o[/embed] Contribute to these open source projects We welcome contributions to any of our open source applications. If you’d like to contribute, please review our Contributors Guide. Keep in mind that when you submit your pull request, you'll need to sign our Contributor License Agreement (CLA). If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com. Be sure to check in regularly! We’ll preview more of our very best apps in future editions of this series. Related Topics Extend New Relic By Joel Worrall Joel Worrall is the Director of Open Source and Developer Advocacy at New Relic. After 20 years as a software developer, product manager, and accidental marketer, he still writes code every week. Joel is passionate about how New Relic's programmable platform can make a positive difference in the world through open source and partnering with a vibrant and inclusive developer community. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.827896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " an application locally—in this example, Status Pages—is as easy as running a few commands: nr1 <em>nerdpack</em>:clone -r https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;nr1-status-pages.git cd nr1-status-pages nr1 <em>nerdpack:serve</em> Or you could download, configure, and deploy an account-specific instance of Status Pages to your New"
      },
      "id": "60762e2028ccbcbab751c12e"
    }
  ],
  "/ab-test": [
    {
      "sections": [
        "Analyze PHPUnit test data in New Relic",
        "Enable PHPUnit test events",
        "Tip",
        "View available attributes",
        "Example queries",
        "Percent success",
        "Test outcome",
        "Test failures",
        "Test suite failures",
        "Duration",
        "Linked facets",
        "PHPUnit event attributes",
        "TestSuite event attributes",
        "Test event attributes",
        "For more help"
      ],
      "title": "Analyze PHPUnit test data in New Relic",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Frameworks and libraries"
      ],
      "external_id": "212a60ebd1bad9ac705002f17ba4f5d9720b248d",
      "image": "https://docs.newrelic.com/docs/agents/php-agent/frameworks-libraries/analyze-phpunit-test-data-new-relic/images/PHPUnit_test_outcomes.png",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/frameworks-libraries/analyze-phpunit-test-data-new-relic/",
      "published_at": "2021-04-16T05:40:32Z",
      "updated_at": "2021-04-16T05:40:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use PHPUnit to manage and run your unit tests, the New Relic PHP agent can automatically capture the test summary results and send them to New Relic as an event where you can query and visualize test data at a glance. This feature was released in version 6.7.0 of the PHP Agent and supports PHPUnit versions 3.7 to 8.x Enable PHPUnit test events To enable PHPUnit test events: Find or add the newrelic.phpunit_events.enabled setting in your newrelic.ini file and set it to true. Restart your web server (apache, PHP-FPM, Nginx, etc) for the setting change to take effect. Tip Exception messages are collected and sent with events. Also, if you use PHPUnit's --disallow-test-output option, which flags tests that print output as \"risky,\" the test event will include the offending output. View available attributes When enabled, the PHP Agent detects PHPUnit commands and populates New Relic with two event types that contain data for the test suite (named TestSuite) and individual tests (named Test). You can query the data with NRQL queries and build a dashboard of information important to you. To query your test events, use FROM TestSuite and FROM Test when specifying your SELECT statements: SELECT uniqueCount(name) FROM TestSuite Copy Example of a PHPUnit test dashboard created by querying TestSuite and Test events. Example queries A dashboard of test summary data allows you to quickly see a snapshot of overall test success as well as dig into failing suites to determine their cause. These examples illustrate the kinds of widgets you can create with both TestSuite and Test event types. Percent success What percent of suites or tests are passing? SELECT percentage(count(*), WHERE successful IS true) FROM TestSuite Copy SELECT percentage(count(*), WHERE outcome = 'passed') FROM Test Copy What percent of suites and tests are passing? Test outcome What is the breakdown of test outcomes? SELECT count(*) FROM Test FACET outcome Copy What is the breakdown of test outcomes? Test failures What percent of the time does each test pass? SELECT percentage(count(*), WHERE outcome = 'failed') FROM Test FACET name Copy What percent of the time does each test pass? Test suite failures What percent of the time does each suite pass, and is that consistent over time? SELECT histogram((passedCount / testCount)*100, 100, 10) FROM TestSuite FACET name Copy What percent of the time does each suite pass, and is that consistent over time? Duration How long does each test suite take to run, and is that consistent over time? SELECT histogram(duration*1000, 10, 20) FROM TestSuite FACET name Copy How long does each test suite take to run, and is that consistent over time? Linked facets Because a PHPUnit test suite is linked to individual tests via its run ID, you can use FACET widgets to filter results for a specific test run. For example, if you created a widget with the most recent failing test suites and linked it to the current dashboard, you could click on a test and the surrounding widgets would update with information for only that test suite run. FACET widget (top-left) linked to the current dashboard allows you to drill into failing test suites. In the above example, you can see that by clicking on run 5bb37ccee2a1dbc7, we learn that one of two tests, testFoo, failed. Here are the NRQL queries that made up this example: Recent unsuccessful suites: SELECT latest(timestamp), latest(name) FROM TestSuite WHERE successful IS false FACET runId Copy Last unsuccessful suite: SELECT host, name, duration * 1000 AS 'duration (ms)', assertionCount, testCount, passedCount, failedCount, incompleteCount, skippedCount, errorCount, riskyCount, warningCount FROM TestSuite WHERE successful IS false LIMIT 1 Copy Last unsuccessful test: SELECT host, name, testSuiteName, duration * 1000 AS 'duration (ms)', outcome, assertionCount, message FROM Test WHERE outcome != 'passed' LIMIT 1 Copy PHPUnit event attributes TestSuite and Test events contain the following attributes you can query against: TestSuite event attributes TestSuite events include the following attributes: Attribute Description duration The number of seconds it took for the test suite to run. assertionCount The total number of assertions the test suite made. errorCount The number of errors reported. warningCount The number of tests with warnings. Note that PHPUnit includes these in the passedCount as well. failedCount The number of failed tests. incompleteCount The number of incomplete tests. passedCount The number of passed tests. riskyCount The number of tests marked by PHPUnit as risky. skippedCount The number of tests that were skipped. testCount The number of tests that ran. runId A unique identifier that ties the test suite to the individual tests. For example, 861d12cea0d5b923. successful A boolean that is true if there were no failures or errors during the test suite run. name The name of the test suite. Test event attributes Test events include the following attributes: Attribute Description duration The number of seconds it took for the test to run. message Any message associated with the test outcome. For example: Failed asserting that false is true or This test depends on 'StackTest::testFailure' to pass.. assertionCount The number of assertions the test made. outcome The outcome of the test. Options include passed, failed, skipped, risky, warning, and incomplete. runId A unique identifier that ties the test to its test suite. For example: 861d12cea0d5b923. name The name of the test. testSuiteName The name of the parent test suite. For more help Suggest a change and learn how to contribute to our PHP agent open source repository. Additional documentation resources include: Building dashboards (how to build and view customized dashboards) Using NRQL (how to use NRQL to explore your data)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 85.916336,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Analyze</em> PHPUnit <em>test</em> data in New Relic",
        "sections": "<em>Analyze</em> PHPUnit <em>test</em> data in New Relic",
        "tags": "Frameworks <em>and</em> libraries",
        "body": " A unique identifier that ties the <em>test</em> to its <em>test</em> suite. For example: 861d12cea0d5<em>b</em>923. name The name of the <em>test</em>. <em>test</em>SuiteName The name of the parent <em>test</em> suite. For more help Suggest a change and learn how to contribute to our PHP agent open source repository. Additional documentation resources include: Building dashboards (how to <em>build</em> and view customized dashboards) Using NRQL (how to use NRQL to explore your data)"
      },
      "id": "6043cdca196a670e89960f57"
    },
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "Tip",
        "New Relic One: a programmable platform"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-04-16T03:50:48Z",
      "updated_at": "2021-04-12T02:56:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. Tip To use our developer site and New Relic One, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic Browser. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.8621,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Build</em> <em>a</em> custom New Relic One <em>application</em> ",
        "sections": "<em>Build</em> <em>a</em> custom New Relic One <em>application</em>",
        "tags": "<em>Build</em> on New Relic One",
        "body": "New Relic gives you a framework to <em>build</em> your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you&#x27;ve tailored specifically for your organization. Display data from any source you want, whether from"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "クロスアプリケーショントレースの概要",
        "クロスアプリケーショントレーシングとは？",
        "重要",
        "セキュリティに関する懸念事項",
        "その他のヘルプ"
      ],
      "title": "クロスアプリケーショントレースの概要",
      "type": "docs-jp",
      "tags": [
        "APM",
        "Transactions",
        "Cross application traces"
      ],
      "external_id": "fb681eb140ac4f149b327bff86d6f428000dff42",
      "image": "",
      "url": "https://docs.newrelic.com/jp/docs/apm/transactions/cross-application-traces/introduction-cross-application-traces/",
      "published_at": "2021-04-16T11:48:07Z",
      "updated_at": "2021-03-17T21:19:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic APMのクロスアプリケーショントレーシングを使用すると、APMが監視するアプリケーション間でトランザクションをリンクできます。 クロスアプリケーショントレーシングとは？ 重要 クロスアプリケーショントレーシングを使用する代わりに、ディストリビューティッド（分散）トレーシング機能を使用することをお勧めします。ディストリビューティッド（分散）トレーシングはクロスアプリケーショントレーシングの機能を向上させたものであり、大規模な分散システムに適しています。 New Relic APMのクロスアプリケーショントレースでは、サービス指向アーキテクチャ（SOA）内にあるAPMアプリケーション間のトランザクションをリンクします。これはたとえば、自分のアプリケーション（「呼び出し元」アプリケーション）と内部あるいは外部サービス（「呼び出し先」アプリケーション）で発生するパフォーマンスの問題（例：内部サービスへのトラフィック）を特定する場合に有効です。 これは以下に役立ちます。 クロスアプリケーションのコールフロー内のボトルネックを発見します。 特定のトランザクションが他のアプリケーションやサービスによってどのように使用されているかを、エンドツーエンドで把握します。 問題をより迅速に診断し、チーム間のコラボレーションを強化します。 セキュリティに関する懸念事項 クロスアプリケーショントレーシングでは3つのHTTPヘッダーを使って、呼び出し元アプリケーションと呼び出し先アプリケーションの間で情報をやり取りします。 最初の2つ（X-NewRelic-IDとX-NewRelic-Transaction）は、インストゥルメントされたアプリケーションによって送られた送信リクエスト内のHTTPリクエストヘッダーとして表示されます。 残りのヘッダ（X-NewRelic-App-Data）は、呼び出されたアプリケーションが呼び出し元アプリケーションと同一のNew Relicアカウントに属している場合、HTTPレスポンスに挿入されます。 New Relicでは、New Relic Browserのページロードタイミング（実際のユーザーの監視またはRUMとも呼ばれます）設定に使われるものと同一の難読化スキームをキーを変えて使用し、ヘッダーのすべてを難読化します。 HTTPヘッダー 説明 X-NewRelic-ID （リクエストヘッダ内） アカウントIDと、呼び出しを行うアプリケーションのアプリケーションIDを含む X-NewRelic-Transaction （リクエストヘッダ内） 呼び出しによって作成される個々のトランザクションに関する情報（呼び出し元トランザクションにとってユニークなGUIDと、トランザクションを発生させたアップストリームの呼び出しに関する情報）を含む X-NewRelic-App-Data （該当する場合、レスポンス内） 呼び出し先アプリケーションに関する次の情報を含みます。 アカウントID アプリケーションID 呼び出されたトランザクションの名前 呼び出されたトランザクションのタイミング情報 呼び出されたトランザクションのGUID その他のヘルプ さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください： Explorers Hubを参照して、コミュニティから支援を受け、ディスカッションに参加してください。 当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます。 Linux、Windows、およびmacOSのトラブルシューティングツールであるNew Relic Diagnosticsを実行します。 New Relicのデータセキュリティとライセンスドキュメントを見直してください。",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 70.57036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Cross <em>application</em> traces"
      },
      "id": "60527274e7b9d2809aa30777"
    },
    {
      "image": "https://newrelic.com/sites/default/files/wp_blog_inline_files/devops-ebook-cover-1-202x300_0.jpg",
      "url": "https://newrelic.com/blog/best-practices/measuring-devops-quality",
      "sections": [
        "Related Topics"
      ],
      "published_at": "2021-04-16T01:40:19Z",
      "title": "Measuring DevOps: Metrics That Define Software Quality",
      "updated_at": "2021-04-14T01:57:51Z",
      "type": "",
      "external_id": "9ab6c6bd5d6c254d760792ce64c2b4a214cf16e0",
      "popularity": 1,
      "body": "Skip to main content We're leveling up FutureStack registration with swag, only until 4/30. Terms & conditions apply. Register Now Dismiss alert New Relic logo Search Submit Products Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Pricing Solutions Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience Tool Consolidation Open Source By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Help Center Learn Docs Build on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources Social Impact Investor Relations Newsroom Partner Program Contact Us New Relic for iOS or Android New Relic Insights App for iOS Search toggle Log in Sign up Main navigation menu, 5 items Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Blog navigation menu, 4 items Toggle blog search How to Relic Best Practices Nerd Life Nerdlog Observatory blog homepage How to Relic Best Practices Nerd Life Nerdlog Toggle blog search Blog navigation menu, 4 items How to Relic Best Practices Nerd Life Nerdlog Search the blog Submit DevOps Measuring DevOps: Metrics That Define Software Quality Jan 14, 2016 • 5 min read By Asami Novak Faster development and deployment of software is great, but if you think about it, the underlying premise of DevOps is kind of an oxymoron: faster and better software delivery. Haven’t these usually been mutually exclusive goals? But shorter development cycles and closer collaboration under a DevOps approach means you catch problems before they go to production, and so spend less time fixing them under duress. The timeless battle of supporting software in production is often about balancing time spent on reactive firefighting versus proactive efforts such as building and testing. Software quality is directly correlated to customer-impacting incidents, so it pays to invest the time and energy into addressing quality issues earlier in the cycles. As reported in Puppet Labs’ 2015 State of DevOps report, high-performing companies are recognizing that quality is a shared responsibility of everyone involved in the software delivery lifecycle, and that quality should be built into the software earlier in the development process. Approaches like TDD (Test Driven Development), CI (Continuous Integration), and CD (Continuous Deployment) can all help to proriotize work that is focused on quality improvements. But how do you know when those approaches are working? As with the other critical drivers of DevOps success (application performance, customer experience, business metrics, and speed), it helps to measure the effectiveness of each by tracking core KPIs. To quantify the quality of your software’s overall continuous improvement efforts, consider tracking the following metrics: Deployment success rate App error rates Incident severity Outstanding bugs Since many quality issues don’t appear until the software hits production, the ability to compare all metrics pre- and post-deploy is extremely helpful in understanding the impact of a specific release. With a before-and-after view, DevOps teams can respond quickly and roll back a release or rapidly fix any issues. Want to know whether your DevOps efforts are making a positive impact on the business? Read our ebook, “DevOps Without Measurement Is a Fail,” for other key metrics to track to measure your DevOps success. Related Topics DevOps By Asami Novak Asami Novak is director of content strategy and development at New Relic. Prior to joining the New Relic team, she wrote marketing and ad copy for a variety of B2B and B2C companies. Her editorial writing has appeared in WIRED and Dwell, among other publications. Was this post helpful? Vote for this content. Remove your vote for this content. 0 votes Share this article Share on Twitter Share on Reddit Share on Facebook Share on LinkedIn Company Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal Connect Contact Us Request Demo Events International 日本語 Français Deutsch 한국어 Facebook Twitter LinkedIn YouTube Instagram Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-21 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 70.35996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Help Center Learn Docs <em>Build</em> on New Relic Explore open source projects Training The Relicans Get help Community forum Global technical support Expert services About About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog"
      },
      "id": "60764c1f28ccbcd2e651c17b"
    },
    {
      "sections": [
        "Troubleshoot cross application tracing",
        "Agent versions and protocols",
        "Config file requirements",
        "High throughput apps",
        "Proxies",
        "Multi-threaded processing (Java)",
        "Sub-accounts"
      ],
      "title": "Troubleshoot cross application tracing",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Cross application traces"
      ],
      "external_id": "fa4ecccd4906018947e6e36fbe96b78d6c005893",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/cross-application-traces/troubleshoot-cross-application-tracing/",
      "published_at": "2021-04-16T11:47:09Z",
      "updated_at": "2021-03-16T08:22:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are troubleshooting tips when using cross application traces. This is not the same as using New Relic's distributed tracing feature. Agent versions and protocols Make sure you meet these requirements for your agent's version, protocols, interfaces, or message queue libraries. If you are using a protocol that is not listed here, you will not see a connection between your applications. Agent version Notes C SDK Use distributed tracing. Go 1.11 or higher HTTP, HTTPS Java 3.9.0 or higher HTTP, HTTPs, JMS 1.1, RabbitMQ The Java agent also supports several message queue libraries, including those that use the JMS 1.1 interface. .NET 4.2 or higher HTTP, and supported .NET messaging systems Node.js 2.0.0 or higher HTTP, HTTPS, RabbitMQ PHP 4.19.0 or higher HTTP, HTTPS, and supported PHP message queuing systems Python 2.38.0.31 or higher HTTP, HTTPS, and supported Python message queuing systems Ruby 4.3.0 or higher HTTP, HTTPS, RabbitMQ Config file requirements In general, New Relic's cross application tracing feature is enabled by default. Requirements to change your configuration file vary, depending on your New Relic agent: C SDK (not supported) Go (not supported) Java .NET Node.js (no specific config file settings needed for Node.js) PHP Python Ruby High throughput apps Cross application traces rely on transaction events to associate related transactions. If you have a high throughput application, your agent may reach the maximum number of events that it can record in a minute and will fall back to sampling events. If a transaction’s events are sampled, you may see an incomplete cross application trace, including sometimes only the transactions that you are focused on. If your application has high throughput, some cross application traces will appear incomplete, sometimes with no links. Try viewing a different transaction trace. To reduce or eliminate sampling, you can also adjust the number of transaction events stored in your agent configuration. High throughput apps Troubleshooting tips Java From the transaction_events stanza, adjust the setting for max_samples_stored. Ruby Adjust the setting for analytics_events.max_samples_stored. Proxies If you expect to see a cross application trace link but it consistently does not appear, there may be a proxy or broker between your application’s communication. Cross application tracing relies on HTTP headers and JMS properties being passed from one application to other. HTTP proxies and message brokers sometimes strip those headers. Multi-threaded processing (Java) If one or more of your Java applications uses an async or \"reactive\" programming model, a transaction's activity may span across multiple threads. New Relic supports the Play framework and Servlet Async but not all async frameworks. For unsupported frameworks, activity on other threads is not reported as part of the transaction. Calls to other applications will not be traced. Sub-accounts Currently cross application traces do not cross New Relic accounts. If you have multiple New Relic accounts (including sub-accounts), you will only see traces for applications within one account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 70.04079,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot cross <em>application</em> tracing",
        "sections": "Troubleshoot cross <em>application</em> tracing",
        "tags": "Cross <em>application</em> traces",
        "body": "Here are troubleshooting tips when using cross <em>application</em> traces. This is not the same as using New Relic&#x27;s distributed tracing feature. Agent versions and protocols Make sure you meet these requirements for your agent&#x27;s version, protocols, interfaces, or message queue libraries. If you are using"
      },
      "id": "603ec3cfe7b9d22f912a07af"
    }
  ]
}